//#region rolldown:runtime
var __create$1 = Object.create;
var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$8 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __esmMin = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export$8 = (all, symbols) => {
	let target = {};
	for (var name in all) {
		__defProp$8(target, name, {
			get: all[name],
			enumerable: true
		});
	}
	if (symbols) {
		__defProp$8(target, Symbol.toStringTag, { value: "Module" });
	}
	return target;
};
var __copyProps$8 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames$8(from), i$2 = 0, n = keys.length, key; i$2 < n; i$2++) {
			key = keys[i$2];
			if (!__hasOwnProp$8.call(to, key) && key !== except) {
				__defProp$8(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc$8(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$8(isNodeMode || !mod || !mod.__esModule ? __defProp$8(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let fs = require("fs");
fs = __toESM$1(fs);
let path = require("path");
path = __toESM$1(path);
let node_stream = require("node:stream");
node_stream = __toESM$1(node_stream);
let node_util = require("node:util");
let node_http = require("node:http");
node_http = __toESM$1(node_http);
let node_https = require("node:https");
node_https = __toESM$1(node_https);
let node_zlib = require("node:zlib");
node_zlib = __toESM$1(node_zlib);
let node_buffer = require("node:buffer");
let node_fs = require("node:fs");
let node_path = require("node:path");
let node_url = require("node:url");
let node_net = require("node:net");
let fs_promises = require("fs/promises");
fs_promises = __toESM$1(fs_promises);
let node_stream_promises = require("node:stream/promises");

//#region node_modules/@actions/core/lib/utils.js
var require_utils$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toCommandProperties = exports.toCommandValue = void 0;
	/**
	* Sanitizes an input into a string so it can be passed into issueCommand safely
	* @param input input to sanitize into a string
	*/
	function toCommandValue(input) {
		if (input === null || input === void 0) return "";
		else if (typeof input === "string" || input instanceof String) return input;
		return JSON.stringify(input);
	}
	exports.toCommandValue = toCommandValue;
	/**
	*
	* @param annotationProperties
	* @returns The command properties to send with the actual annotation command
	* See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
	*/
	function toCommandProperties(annotationProperties) {
		if (!Object.keys(annotationProperties).length) return {};
		return {
			title: annotationProperties.title,
			file: annotationProperties.file,
			line: annotationProperties.startLine,
			endLine: annotationProperties.endLine,
			col: annotationProperties.startColumn,
			endColumn: annotationProperties.endColumn
		};
	}
	exports.toCommandProperties = toCommandProperties;
}));

//#endregion
//#region node_modules/@actions/core/lib/command.js
var require_command = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$20 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$17 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$17 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$20(result, mod, k);
		}
		__setModuleDefault$17(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.issue = exports.issueCommand = void 0;
	const os$5 = __importStar$17(require("os"));
	const utils_1$4 = require_utils$3();
	/**
	* Commands
	*
	* Command Format:
	*   ::name key=value,key=value::message
	*
	* Examples:
	*   ::warning::This is the message
	*   ::set-env name=MY_VAR::some value
	*/
	function issueCommand(command, properties, message) {
		const cmd = new Command(command, properties, message);
		process.stdout.write(cmd.toString() + os$5.EOL);
	}
	exports.issueCommand = issueCommand;
	function issue(name, message = "") {
		issueCommand(name, {}, message);
	}
	exports.issue = issue;
	const CMD_STRING = "::";
	var Command = class {
		constructor(command, properties, message) {
			if (!command) command = "missing.command";
			this.command = command;
			this.properties = properties;
			this.message = message;
		}
		toString() {
			let cmdStr = CMD_STRING + this.command;
			if (this.properties && Object.keys(this.properties).length > 0) {
				cmdStr += " ";
				let first = true;
				for (const key in this.properties) if (this.properties.hasOwnProperty(key)) {
					const val = this.properties[key];
					if (val) {
						if (first) first = false;
						else cmdStr += ",";
						cmdStr += `${key}=${escapeProperty(val)}`;
					}
				}
			}
			cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
			return cmdStr;
		}
	};
	function escapeData(s$2) {
		return (0, utils_1$4.toCommandValue)(s$2).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
	}
	function escapeProperty(s$2) {
		return (0, utils_1$4.toCommandValue)(s$2).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
	}
}));

//#endregion
//#region node_modules/@actions/core/lib/file-command.js
var require_file_command = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$19 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$16 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$16 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$19(result, mod, k);
		}
		__setModuleDefault$16(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
	const crypto$6 = __importStar$16(require("crypto"));
	const fs$9 = __importStar$16(require("fs"));
	const os$4 = __importStar$16(require("os"));
	const utils_1$3 = require_utils$3();
	function issueFileCommand(command, message) {
		const filePath = process.env[`GITHUB_${command}`];
		if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);
		if (!fs$9.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);
		fs$9.appendFileSync(filePath, `${(0, utils_1$3.toCommandValue)(message)}${os$4.EOL}`, { encoding: "utf8" });
	}
	exports.issueFileCommand = issueFileCommand;
	function prepareKeyValueMessage(key, value) {
		const delimiter = `ghadelimiter_${crypto$6.randomUUID()}`;
		const convertedValue = (0, utils_1$3.toCommandValue)(value);
		if (key.includes(delimiter)) throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
		if (convertedValue.includes(delimiter)) throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
		return `${key}<<${delimiter}${os$4.EOL}${convertedValue}${os$4.EOL}${delimiter}`;
	}
	exports.prepareKeyValueMessage = prepareKeyValueMessage;
}));

//#endregion
//#region node_modules/@actions/http-client/lib/proxy.js
var require_proxy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkBypass = exports.getProxyUrl = void 0;
	function getProxyUrl$1(reqUrl) {
		const usingSsl = reqUrl.protocol === "https:";
		if (checkBypass(reqUrl)) return;
		const proxyVar = (() => {
			if (usingSsl) return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
			else return process.env["http_proxy"] || process.env["HTTP_PROXY"];
		})();
		if (proxyVar) try {
			return new DecodedURL(proxyVar);
		} catch (_a$2) {
			if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://")) return new DecodedURL(`http://${proxyVar}`);
		}
		else return;
	}
	exports.getProxyUrl = getProxyUrl$1;
	function checkBypass(reqUrl) {
		if (!reqUrl.hostname) return false;
		const reqHost = reqUrl.hostname;
		if (isLoopbackAddress(reqHost)) return true;
		const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
		if (!noProxy) return false;
		let reqPort;
		if (reqUrl.port) reqPort = Number(reqUrl.port);
		else if (reqUrl.protocol === "http:") reqPort = 80;
		else if (reqUrl.protocol === "https:") reqPort = 443;
		const upperReqHosts = [reqUrl.hostname.toUpperCase()];
		if (typeof reqPort === "number") upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
		for (const upperNoProxyItem of noProxy.split(",").map((x$1) => x$1.trim().toUpperCase()).filter((x$1) => x$1)) if (upperNoProxyItem === "*" || upperReqHosts.some((x$1) => x$1 === upperNoProxyItem || x$1.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x$1.endsWith(`${upperNoProxyItem}`))) return true;
		return false;
	}
	exports.checkBypass = checkBypass;
	function isLoopbackAddress(host) {
		const hostLower = host.toLowerCase();
		return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
	}
	var DecodedURL = class extends URL {
		constructor(url, base) {
			super(url, base);
			this._decodedUsername = decodeURIComponent(super.username);
			this._decodedPassword = decodeURIComponent(super.password);
		}
		get username() {
			return this._decodedUsername;
		}
		get password() {
			return this._decodedPassword;
		}
	};
}));

//#endregion
//#region node_modules/tunnel/lib/tunnel.js
var require_tunnel$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	require("net");
	var tls$3 = require("tls");
	var http$8 = require("http");
	var https$5 = require("https");
	var events$1 = require("events");
	require("assert");
	var util$23 = require("util");
	exports.httpOverHttp = httpOverHttp;
	exports.httpsOverHttp = httpsOverHttp;
	exports.httpOverHttps = httpOverHttps;
	exports.httpsOverHttps = httpsOverHttps;
	function httpOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$8.request;
		return agent;
	}
	function httpsOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$8.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function httpOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$5.request;
		return agent;
	}
	function httpsOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$5.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function TunnelingAgent(options) {
		var self$1 = this;
		self$1.options = options || {};
		self$1.proxyOptions = self$1.options.proxy || {};
		self$1.maxSockets = self$1.options.maxSockets || http$8.Agent.defaultMaxSockets;
		self$1.requests = [];
		self$1.sockets = [];
		self$1.on("free", function onFree(socket, host, port, localAddress) {
			var options$1 = toOptions(host, port, localAddress);
			for (var i$2 = 0, len$1 = self$1.requests.length; i$2 < len$1; ++i$2) {
				var pending = self$1.requests[i$2];
				if (pending.host === options$1.host && pending.port === options$1.port) {
					self$1.requests.splice(i$2, 1);
					pending.request.onSocket(socket);
					return;
				}
			}
			socket.destroy();
			self$1.removeSocket(socket);
		});
	}
	util$23.inherits(TunnelingAgent, events$1.EventEmitter);
	TunnelingAgent.prototype.addRequest = function addRequest(req$1, host, port, localAddress) {
		var self$1 = this;
		var options = mergeOptions({ request: req$1 }, self$1.options, toOptions(host, port, localAddress));
		if (self$1.sockets.length >= this.maxSockets) {
			self$1.requests.push(options);
			return;
		}
		self$1.createSocket(options, function(socket) {
			socket.on("free", onFree);
			socket.on("close", onCloseOrRemove);
			socket.on("agentRemove", onCloseOrRemove);
			req$1.onSocket(socket);
			function onFree() {
				self$1.emit("free", socket, options);
			}
			function onCloseOrRemove(err) {
				self$1.removeSocket(socket);
				socket.removeListener("free", onFree);
				socket.removeListener("close", onCloseOrRemove);
				socket.removeListener("agentRemove", onCloseOrRemove);
			}
		});
	};
	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
		var self$1 = this;
		var placeholder = {};
		self$1.sockets.push(placeholder);
		var connectOptions = mergeOptions({}, self$1.proxyOptions, {
			method: "CONNECT",
			path: options.host + ":" + options.port,
			agent: false,
			headers: { host: options.host + ":" + options.port }
		});
		if (options.localAddress) connectOptions.localAddress = options.localAddress;
		if (connectOptions.proxyAuth) {
			connectOptions.headers = connectOptions.headers || {};
			connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
		}
		debug$3("making CONNECT request");
		var connectReq = self$1.request(connectOptions);
		connectReq.useChunkedEncodingByDefault = false;
		connectReq.once("response", onResponse);
		connectReq.once("upgrade", onUpgrade);
		connectReq.once("connect", onConnect);
		connectReq.once("error", onError$2);
		connectReq.end();
		function onResponse(res) {
			res.upgrade = true;
		}
		function onUpgrade(res, socket, head) {
			process.nextTick(function() {
				onConnect(res, socket, head);
			});
		}
		function onConnect(res, socket, head) {
			connectReq.removeAllListeners();
			socket.removeAllListeners();
			if (res.statusCode !== 200) {
				debug$3("tunneling socket could not be established, statusCode=%d", res.statusCode);
				socket.destroy();
				var error$1 = /* @__PURE__ */ new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
				error$1.code = "ECONNRESET";
				options.request.emit("error", error$1);
				self$1.removeSocket(placeholder);
				return;
			}
			if (head.length > 0) {
				debug$3("got illegal response body from proxy");
				socket.destroy();
				var error$1 = /* @__PURE__ */ new Error("got illegal response body from proxy");
				error$1.code = "ECONNRESET";
				options.request.emit("error", error$1);
				self$1.removeSocket(placeholder);
				return;
			}
			debug$3("tunneling connection has established");
			self$1.sockets[self$1.sockets.indexOf(placeholder)] = socket;
			return cb(socket);
		}
		function onError$2(cause) {
			connectReq.removeAllListeners();
			debug$3("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
			var error$1 = /* @__PURE__ */ new Error("tunneling socket could not be established, cause=" + cause.message);
			error$1.code = "ECONNRESET";
			options.request.emit("error", error$1);
			self$1.removeSocket(placeholder);
		}
	};
	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
		var pos = this.sockets.indexOf(socket);
		if (pos === -1) return;
		this.sockets.splice(pos, 1);
		var pending = this.requests.shift();
		if (pending) this.createSocket(pending, function(socket$1) {
			pending.request.onSocket(socket$1);
		});
	};
	function createSecureSocket(options, cb) {
		var self$1 = this;
		TunnelingAgent.prototype.createSocket.call(self$1, options, function(socket) {
			var hostHeader = options.request.getHeader("host");
			var tlsOptions = mergeOptions({}, self$1.options, {
				socket,
				servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
			});
			var secureSocket = tls$3.connect(0, tlsOptions);
			self$1.sockets[self$1.sockets.indexOf(socket)] = secureSocket;
			cb(secureSocket);
		});
	}
	function toOptions(host, port, localAddress) {
		if (typeof host === "string") return {
			host,
			port,
			localAddress
		};
		return host;
	}
	function mergeOptions(target) {
		for (var i$2 = 1, len$1 = arguments.length; i$2 < len$1; ++i$2) {
			var overrides = arguments[i$2];
			if (typeof overrides === "object") {
				var keys = Object.keys(overrides);
				for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
					var k = keys[j];
					if (overrides[k] !== void 0) target[k] = overrides[k];
				}
			}
		}
		return target;
	}
	var debug$3;
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) debug$3 = function() {
		var args = Array.prototype.slice.call(arguments);
		if (typeof args[0] === "string") args[0] = "TUNNEL: " + args[0];
		else args.unshift("TUNNEL:");
		console.error.apply(console, args);
	};
	else debug$3 = function() {};
	exports.debug = debug$3;
}));

//#endregion
//#region node_modules/tunnel/index.js
var require_tunnel = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_tunnel$1();
}));

//#endregion
//#region node_modules/undici/lib/core/symbols.js
var require_symbols$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kClose: Symbol("close"),
		kDestroy: Symbol("destroy"),
		kDispatch: Symbol("dispatch"),
		kUrl: Symbol("url"),
		kWriting: Symbol("writing"),
		kResuming: Symbol("resuming"),
		kQueue: Symbol("queue"),
		kConnect: Symbol("connect"),
		kConnecting: Symbol("connecting"),
		kHeadersList: Symbol("headers list"),
		kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
		kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
		kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
		kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
		kKeepAlive: Symbol("keep alive"),
		kHeadersTimeout: Symbol("headers timeout"),
		kBodyTimeout: Symbol("body timeout"),
		kServerName: Symbol("server name"),
		kLocalAddress: Symbol("local address"),
		kHost: Symbol("host"),
		kNoRef: Symbol("no ref"),
		kBodyUsed: Symbol("used"),
		kRunning: Symbol("running"),
		kBlocking: Symbol("blocking"),
		kPending: Symbol("pending"),
		kSize: Symbol("size"),
		kBusy: Symbol("busy"),
		kQueued: Symbol("queued"),
		kFree: Symbol("free"),
		kConnected: Symbol("connected"),
		kClosed: Symbol("closed"),
		kNeedDrain: Symbol("need drain"),
		kReset: Symbol("reset"),
		kDestroyed: Symbol.for("nodejs.stream.destroyed"),
		kMaxHeadersSize: Symbol("max headers size"),
		kRunningIdx: Symbol("running index"),
		kPendingIdx: Symbol("pending index"),
		kError: Symbol("error"),
		kClients: Symbol("clients"),
		kClient: Symbol("client"),
		kParser: Symbol("parser"),
		kOnDestroyed: Symbol("destroy callbacks"),
		kPipelining: Symbol("pipelining"),
		kSocket: Symbol("socket"),
		kHostHeader: Symbol("host header"),
		kConnector: Symbol("connector"),
		kStrictContentLength: Symbol("strict content length"),
		kMaxRedirections: Symbol("maxRedirections"),
		kMaxRequests: Symbol("maxRequestsPerClient"),
		kProxy: Symbol("proxy agent options"),
		kCounter: Symbol("socket request counter"),
		kInterceptors: Symbol("dispatch interceptors"),
		kMaxResponseSize: Symbol("max response size"),
		kHTTP2Session: Symbol("http2Session"),
		kHTTP2SessionState: Symbol("http2Session state"),
		kHTTP2BuildRequest: Symbol("http2 build request"),
		kHTTP1BuildRequest: Symbol("http1 build request"),
		kHTTP2CopyHeaders: Symbol("http2 copy headers"),
		kHTTPConnVersion: Symbol("http connection version"),
		kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
		kConstruct: Symbol("constructable")
	};
}));

//#endregion
//#region node_modules/undici/lib/core/errors.js
var require_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var UndiciError$2 = class extends Error {
		constructor(message) {
			super(message);
			this.name = "UndiciError";
			this.code = "UND_ERR";
		}
	};
	var ConnectTimeoutError$1 = class ConnectTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ConnectTimeoutError$1);
			this.name = "ConnectTimeoutError";
			this.message = message || "Connect Timeout Error";
			this.code = "UND_ERR_CONNECT_TIMEOUT";
		}
	};
	var HeadersTimeoutError$1 = class HeadersTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersTimeoutError$1);
			this.name = "HeadersTimeoutError";
			this.message = message || "Headers Timeout Error";
			this.code = "UND_ERR_HEADERS_TIMEOUT";
		}
	};
	var HeadersOverflowError$1 = class HeadersOverflowError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersOverflowError$1);
			this.name = "HeadersOverflowError";
			this.message = message || "Headers Overflow Error";
			this.code = "UND_ERR_HEADERS_OVERFLOW";
		}
	};
	var BodyTimeoutError$1 = class BodyTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, BodyTimeoutError$1);
			this.name = "BodyTimeoutError";
			this.message = message || "Body Timeout Error";
			this.code = "UND_ERR_BODY_TIMEOUT";
		}
	};
	var ResponseStatusCodeError$1 = class ResponseStatusCodeError$1 extends UndiciError$2 {
		constructor(message, statusCode, headers, body) {
			super(message);
			Error.captureStackTrace(this, ResponseStatusCodeError$1);
			this.name = "ResponseStatusCodeError";
			this.message = message || "Response Status Code Error";
			this.code = "UND_ERR_RESPONSE_STATUS_CODE";
			this.body = body;
			this.status = statusCode;
			this.statusCode = statusCode;
			this.headers = headers;
		}
	};
	var InvalidArgumentError$22 = class InvalidArgumentError$22 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidArgumentError$22);
			this.name = "InvalidArgumentError";
			this.message = message || "Invalid Argument Error";
			this.code = "UND_ERR_INVALID_ARG";
		}
	};
	var InvalidReturnValueError$2 = class InvalidReturnValueError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidReturnValueError$2);
			this.name = "InvalidReturnValueError";
			this.message = message || "Invalid Return Value Error";
			this.code = "UND_ERR_INVALID_RETURN_VALUE";
		}
	};
	var RequestAbortedError$9 = class RequestAbortedError$9 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestAbortedError$9);
			this.name = "AbortError";
			this.message = message || "Request aborted";
			this.code = "UND_ERR_ABORTED";
		}
	};
	var InformationalError$1 = class InformationalError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InformationalError$1);
			this.name = "InformationalError";
			this.message = message || "Request information";
			this.code = "UND_ERR_INFO";
		}
	};
	var RequestContentLengthMismatchError$1 = class RequestContentLengthMismatchError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestContentLengthMismatchError$1);
			this.name = "RequestContentLengthMismatchError";
			this.message = message || "Request body length does not match content-length header";
			this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ResponseContentLengthMismatchError$1 = class ResponseContentLengthMismatchError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ResponseContentLengthMismatchError$1);
			this.name = "ResponseContentLengthMismatchError";
			this.message = message || "Response body length does not match content-length header";
			this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ClientDestroyedError$2 = class ClientDestroyedError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientDestroyedError$2);
			this.name = "ClientDestroyedError";
			this.message = message || "The client is destroyed";
			this.code = "UND_ERR_DESTROYED";
		}
	};
	var ClientClosedError$1 = class ClientClosedError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientClosedError$1);
			this.name = "ClientClosedError";
			this.message = message || "The client is closed";
			this.code = "UND_ERR_CLOSED";
		}
	};
	var SocketError$3 = class SocketError$3 extends UndiciError$2 {
		constructor(message, socket) {
			super(message);
			Error.captureStackTrace(this, SocketError$3);
			this.name = "SocketError";
			this.message = message || "Socket error";
			this.code = "UND_ERR_SOCKET";
			this.socket = socket;
		}
	};
	var NotSupportedError$2 = class NotSupportedError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError$2);
			this.name = "NotSupportedError";
			this.message = message || "Not supported error";
			this.code = "UND_ERR_NOT_SUPPORTED";
		}
	};
	var BalancedPoolMissingUpstreamError$1 = class extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError$2);
			this.name = "MissingUpstreamError";
			this.message = message || "No upstream has been added to the BalancedPool";
			this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
		}
	};
	var HTTPParserError$1 = class HTTPParserError$1 extends Error {
		constructor(message, code$1, data) {
			super(message);
			Error.captureStackTrace(this, HTTPParserError$1);
			this.name = "HTTPParserError";
			this.code = code$1 ? `HPE_${code$1}` : void 0;
			this.data = data ? data.toString() : void 0;
		}
	};
	var ResponseExceededMaxSizeError$1 = class ResponseExceededMaxSizeError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ResponseExceededMaxSizeError$1);
			this.name = "ResponseExceededMaxSizeError";
			this.message = message || "Response content exceeded max size";
			this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
		}
	};
	var RequestRetryError$1 = class RequestRetryError$1 extends UndiciError$2 {
		constructor(message, code$1, { headers, data }) {
			super(message);
			Error.captureStackTrace(this, RequestRetryError$1);
			this.name = "RequestRetryError";
			this.message = message || "Request retry error";
			this.code = "UND_ERR_REQ_RETRY";
			this.statusCode = code$1;
			this.data = data;
			this.headers = headers;
		}
	};
	module.exports = {
		HTTPParserError: HTTPParserError$1,
		UndiciError: UndiciError$2,
		HeadersTimeoutError: HeadersTimeoutError$1,
		HeadersOverflowError: HeadersOverflowError$1,
		BodyTimeoutError: BodyTimeoutError$1,
		RequestContentLengthMismatchError: RequestContentLengthMismatchError$1,
		ConnectTimeoutError: ConnectTimeoutError$1,
		ResponseStatusCodeError: ResponseStatusCodeError$1,
		InvalidArgumentError: InvalidArgumentError$22,
		InvalidReturnValueError: InvalidReturnValueError$2,
		RequestAbortedError: RequestAbortedError$9,
		ClientDestroyedError: ClientDestroyedError$2,
		ClientClosedError: ClientClosedError$1,
		InformationalError: InformationalError$1,
		SocketError: SocketError$3,
		NotSupportedError: NotSupportedError$2,
		ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1,
		BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError$1,
		ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$1,
		RequestRetryError: RequestRetryError$1
	};
}));

//#endregion
//#region node_modules/undici/lib/core/constants.js
var require_constants$5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {Record<string, string | undefined>} */
	const headerNameLowerCasedRecord$1 = {};
	const wellknownHeaderNames = [
		"Accept",
		"Accept-Encoding",
		"Accept-Language",
		"Accept-Ranges",
		"Access-Control-Allow-Credentials",
		"Access-Control-Allow-Headers",
		"Access-Control-Allow-Methods",
		"Access-Control-Allow-Origin",
		"Access-Control-Expose-Headers",
		"Access-Control-Max-Age",
		"Access-Control-Request-Headers",
		"Access-Control-Request-Method",
		"Age",
		"Allow",
		"Alt-Svc",
		"Alt-Used",
		"Authorization",
		"Cache-Control",
		"Clear-Site-Data",
		"Connection",
		"Content-Disposition",
		"Content-Encoding",
		"Content-Language",
		"Content-Length",
		"Content-Location",
		"Content-Range",
		"Content-Security-Policy",
		"Content-Security-Policy-Report-Only",
		"Content-Type",
		"Cookie",
		"Cross-Origin-Embedder-Policy",
		"Cross-Origin-Opener-Policy",
		"Cross-Origin-Resource-Policy",
		"Date",
		"Device-Memory",
		"Downlink",
		"ECT",
		"ETag",
		"Expect",
		"Expect-CT",
		"Expires",
		"Forwarded",
		"From",
		"Host",
		"If-Match",
		"If-Modified-Since",
		"If-None-Match",
		"If-Range",
		"If-Unmodified-Since",
		"Keep-Alive",
		"Last-Modified",
		"Link",
		"Location",
		"Max-Forwards",
		"Origin",
		"Permissions-Policy",
		"Pragma",
		"Proxy-Authenticate",
		"Proxy-Authorization",
		"RTT",
		"Range",
		"Referer",
		"Referrer-Policy",
		"Refresh",
		"Retry-After",
		"Sec-WebSocket-Accept",
		"Sec-WebSocket-Extensions",
		"Sec-WebSocket-Key",
		"Sec-WebSocket-Protocol",
		"Sec-WebSocket-Version",
		"Server",
		"Server-Timing",
		"Service-Worker-Allowed",
		"Service-Worker-Navigation-Preload",
		"Set-Cookie",
		"SourceMap",
		"Strict-Transport-Security",
		"Supports-Loading-Mode",
		"TE",
		"Timing-Allow-Origin",
		"Trailer",
		"Transfer-Encoding",
		"Upgrade",
		"Upgrade-Insecure-Requests",
		"User-Agent",
		"Vary",
		"Via",
		"WWW-Authenticate",
		"X-Content-Type-Options",
		"X-DNS-Prefetch-Control",
		"X-Frame-Options",
		"X-Permitted-Cross-Domain-Policies",
		"X-Powered-By",
		"X-Requested-With",
		"X-XSS-Protection"
	];
	for (let i$2 = 0; i$2 < wellknownHeaderNames.length; ++i$2) {
		const key = wellknownHeaderNames[i$2];
		const lowerCasedKey = key.toLowerCase();
		headerNameLowerCasedRecord$1[key] = headerNameLowerCasedRecord$1[lowerCasedKey] = lowerCasedKey;
	}
	Object.setPrototypeOf(headerNameLowerCasedRecord$1, null);
	module.exports = {
		wellknownHeaderNames,
		headerNameLowerCasedRecord: headerNameLowerCasedRecord$1
	};
}));

//#endregion
//#region node_modules/undici/lib/core/util.js
var require_util$8 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$19 = require("assert");
	const { kDestroyed: kDestroyed$1, kBodyUsed: kBodyUsed$2 } = require_symbols$4();
	const { IncomingMessage } = require("http");
	const stream$5 = require("stream");
	const net$5 = require("net");
	const { InvalidArgumentError: InvalidArgumentError$21 } = require_errors();
	const { Blob: Blob$6 } = require("buffer");
	const nodeUtil = require("util");
	const { stringify: stringify$2 } = require("querystring");
	const { headerNameLowerCasedRecord } = require_constants$5();
	const [nodeMajor$1, nodeMinor$1] = process.versions.node.split(".").map((v) => Number(v));
	function nop$1() {}
	function isStream(obj) {
		return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
	}
	function isBlobLike$7(object) {
		return Blob$6 && object instanceof Blob$6 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
	}
	function buildURL$2(url, queryParams) {
		if (url.includes("?") || url.includes("#")) throw new Error("Query params cannot be passed when url already contains \"?\" or \"#\".");
		const stringified = stringify$2(queryParams);
		if (stringified) url += "?" + stringified;
		return url;
	}
	function parseURL(url) {
		if (typeof url === "string") {
			url = new URL(url);
			if (!/^https?:/.test(url.origin || url.protocol)) throw new InvalidArgumentError$21("Invalid URL protocol: the URL must start with `http:` or `https:`.");
			return url;
		}
		if (!url || typeof url !== "object") throw new InvalidArgumentError$21("Invalid URL: The URL argument must be a non-null object.");
		if (!/^https?:/.test(url.origin || url.protocol)) throw new InvalidArgumentError$21("Invalid URL protocol: the URL must start with `http:` or `https:`.");
		if (!(url instanceof URL)) {
			if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) throw new InvalidArgumentError$21("Invalid URL: port must be a valid integer or a string representation of an integer.");
			if (url.path != null && typeof url.path !== "string") throw new InvalidArgumentError$21("Invalid URL path: the path must be a string or null/undefined.");
			if (url.pathname != null && typeof url.pathname !== "string") throw new InvalidArgumentError$21("Invalid URL pathname: the pathname must be a string or null/undefined.");
			if (url.hostname != null && typeof url.hostname !== "string") throw new InvalidArgumentError$21("Invalid URL hostname: the hostname must be a string or null/undefined.");
			if (url.origin != null && typeof url.origin !== "string") throw new InvalidArgumentError$21("Invalid URL origin: the origin must be a string or null/undefined.");
			const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
			let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
			let path$9 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
			if (origin.endsWith("/")) origin = origin.substring(0, origin.length - 1);
			if (path$9 && !path$9.startsWith("/")) path$9 = `/${path$9}`;
			url = new URL(origin + path$9);
		}
		return url;
	}
	function parseOrigin$1(url) {
		url = parseURL(url);
		if (url.pathname !== "/" || url.search || url.hash) throw new InvalidArgumentError$21("invalid url");
		return url;
	}
	function getHostname(host) {
		if (host[0] === "[") {
			const idx$1 = host.indexOf("]");
			assert$19(idx$1 !== -1);
			return host.substring(1, idx$1);
		}
		const idx = host.indexOf(":");
		if (idx === -1) return host;
		return host.substring(0, idx);
	}
	function getServerName(host) {
		if (!host) return null;
		assert$19.strictEqual(typeof host, "string");
		const servername = getHostname(host);
		if (net$5.isIP(servername)) return "";
		return servername;
	}
	function deepClone(obj) {
		return JSON.parse(JSON.stringify(obj));
	}
	function isAsyncIterable(obj) {
		return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
	}
	function isIterable(obj) {
		return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
	}
	function bodyLength(body) {
		if (body == null) return 0;
		else if (isStream(body)) {
			const state = body._readableState;
			return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
		} else if (isBlobLike$7(body)) return body.size != null ? body.size : null;
		else if (isBuffer(body)) return body.byteLength;
		return null;
	}
	function isDestroyed(stream$6) {
		return !stream$6 || !!(stream$6.destroyed || stream$6[kDestroyed$1]);
	}
	function isReadableAborted(stream$6) {
		const state = stream$6 && stream$6._readableState;
		return isDestroyed(stream$6) && state && !state.endEmitted;
	}
	function destroy(stream$6, err) {
		if (stream$6 == null || !isStream(stream$6) || isDestroyed(stream$6)) return;
		if (typeof stream$6.destroy === "function") {
			if (Object.getPrototypeOf(stream$6).constructor === IncomingMessage) stream$6.socket = null;
			stream$6.destroy(err);
		} else if (err) process.nextTick((stream$7, err$1) => {
			stream$7.emit("error", err$1);
		}, stream$6, err);
		if (stream$6.destroyed !== true) stream$6[kDestroyed$1] = true;
	}
	const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
	function parseKeepAliveTimeout(val) {
		const m$2 = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
		return m$2 ? parseInt(m$2[1], 10) * 1e3 : null;
	}
	/**
	* Retrieves a header name and returns its lowercase value.
	* @param {string | Buffer} value Header name
	* @returns {string}
	*/
	function headerNameToString(value) {
		return headerNameLowerCasedRecord[value] || value.toLowerCase();
	}
	function parseHeaders$1(headers, obj = {}) {
		if (!Array.isArray(headers)) return headers;
		for (let i$2 = 0; i$2 < headers.length; i$2 += 2) {
			const key = headers[i$2].toString().toLowerCase();
			let val = obj[key];
			if (!val) if (Array.isArray(headers[i$2 + 1])) obj[key] = headers[i$2 + 1].map((x$1) => x$1.toString("utf8"));
			else obj[key] = headers[i$2 + 1].toString("utf8");
			else {
				if (!Array.isArray(val)) {
					val = [val];
					obj[key] = val;
				}
				val.push(headers[i$2 + 1].toString("utf8"));
			}
		}
		if ("content-length" in obj && "content-disposition" in obj) obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
		return obj;
	}
	function parseRawHeaders(headers) {
		const ret = [];
		let hasContentLength = false;
		let contentDispositionIdx = -1;
		for (let n = 0; n < headers.length; n += 2) {
			const key = headers[n + 0].toString();
			const val = headers[n + 1].toString("utf8");
			if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
				ret.push(key, val);
				hasContentLength = true;
			} else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) contentDispositionIdx = ret.push(key, val) - 1;
			else ret.push(key, val);
		}
		if (hasContentLength && contentDispositionIdx !== -1) ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
		return ret;
	}
	function isBuffer(buffer$1) {
		return buffer$1 instanceof Uint8Array || Buffer.isBuffer(buffer$1);
	}
	function validateHandler(handler$1, method, upgrade$1) {
		if (!handler$1 || typeof handler$1 !== "object") throw new InvalidArgumentError$21("handler must be an object");
		if (typeof handler$1.onConnect !== "function") throw new InvalidArgumentError$21("invalid onConnect method");
		if (typeof handler$1.onError !== "function") throw new InvalidArgumentError$21("invalid onError method");
		if (typeof handler$1.onBodySent !== "function" && handler$1.onBodySent !== void 0) throw new InvalidArgumentError$21("invalid onBodySent method");
		if (upgrade$1 || method === "CONNECT") {
			if (typeof handler$1.onUpgrade !== "function") throw new InvalidArgumentError$21("invalid onUpgrade method");
		} else {
			if (typeof handler$1.onHeaders !== "function") throw new InvalidArgumentError$21("invalid onHeaders method");
			if (typeof handler$1.onData !== "function") throw new InvalidArgumentError$21("invalid onData method");
			if (typeof handler$1.onComplete !== "function") throw new InvalidArgumentError$21("invalid onComplete method");
		}
	}
	function isDisturbed$2(body) {
		return !!(body && (stream$5.isDisturbed ? stream$5.isDisturbed(body) || body[kBodyUsed$2] : body[kBodyUsed$2] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
	}
	function isErrored$2(body) {
		return !!(body && (stream$5.isErrored ? stream$5.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
	}
	function isReadable$1(body) {
		return !!(body && (stream$5.isReadable ? stream$5.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
	}
	function getSocketInfo(socket) {
		return {
			localAddress: socket.localAddress,
			localPort: socket.localPort,
			remoteAddress: socket.remoteAddress,
			remotePort: socket.remotePort,
			remoteFamily: socket.remoteFamily,
			timeout: socket.timeout,
			bytesWritten: socket.bytesWritten,
			bytesRead: socket.bytesRead
		};
	}
	async function* convertIterableToBuffer(iterable) {
		for await (const chunk of iterable) yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
	}
	let ReadableStream$6;
	function ReadableStreamFrom$3(iterable) {
		if (!ReadableStream$6) ReadableStream$6 = require("stream/web").ReadableStream;
		if (ReadableStream$6.from) return ReadableStream$6.from(convertIterableToBuffer(iterable));
		let iterator$1;
		return new ReadableStream$6({
			async start() {
				iterator$1 = iterable[Symbol.asyncIterator]();
			},
			async pull(controller) {
				const { done, value } = await iterator$1.next();
				if (done) queueMicrotask(() => {
					controller.close();
				});
				else {
					const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
					controller.enqueue(new Uint8Array(buf));
				}
				return controller.desiredSize > 0;
			},
			async cancel(reason) {
				await iterator$1.return();
			}
		}, 0);
	}
	function isFormDataLike(object) {
		return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
	}
	function throwIfAborted$1(signal) {
		if (!signal) return;
		if (typeof signal.throwIfAborted === "function") signal.throwIfAborted();
		else if (signal.aborted) {
			const err = /* @__PURE__ */ new Error("The operation was aborted");
			err.name = "AbortError";
			throw err;
		}
	}
	function addAbortListener$2(signal, listener) {
		if ("addEventListener" in signal) {
			signal.addEventListener("abort", listener, { once: true });
			return () => signal.removeEventListener("abort", listener);
		}
		signal.addListener("abort", listener);
		return () => signal.removeListener("abort", listener);
	}
	const hasToWellFormed = !!String.prototype.toWellFormed;
	/**
	* @param {string} val
	*/
	function toUSVString$5(val) {
		if (hasToWellFormed) return `${val}`.toWellFormed();
		else if (nodeUtil.toUSVString) return nodeUtil.toUSVString(val);
		return `${val}`;
	}
	function parseRangeHeader$1(range) {
		if (range == null || range === "") return {
			start: 0,
			end: null,
			size: null
		};
		const m$2 = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
		return m$2 ? {
			start: parseInt(m$2[1]),
			end: m$2[2] ? parseInt(m$2[2]) : null,
			size: m$2[3] ? parseInt(m$2[3]) : null
		} : null;
	}
	const kEnumerableProperty$9 = Object.create(null);
	kEnumerableProperty$9.enumerable = true;
	module.exports = {
		kEnumerableProperty: kEnumerableProperty$9,
		nop: nop$1,
		isDisturbed: isDisturbed$2,
		isErrored: isErrored$2,
		isReadable: isReadable$1,
		toUSVString: toUSVString$5,
		isReadableAborted,
		isBlobLike: isBlobLike$7,
		parseOrigin: parseOrigin$1,
		parseURL,
		getServerName,
		isStream,
		isIterable,
		isAsyncIterable,
		isDestroyed,
		headerNameToString,
		parseRawHeaders,
		parseHeaders: parseHeaders$1,
		parseKeepAliveTimeout,
		destroy,
		bodyLength,
		deepClone,
		ReadableStreamFrom: ReadableStreamFrom$3,
		isBuffer,
		validateHandler,
		getSocketInfo,
		isFormDataLike,
		buildURL: buildURL$2,
		throwIfAborted: throwIfAborted$1,
		addAbortListener: addAbortListener$2,
		parseRangeHeader: parseRangeHeader$1,
		nodeMajor: nodeMajor$1,
		nodeMinor: nodeMinor$1,
		nodeHasAutoSelectFamily: nodeMajor$1 > 18 || nodeMajor$1 === 18 && nodeMinor$1 >= 13,
		safeHTTPMethods: [
			"GET",
			"HEAD",
			"OPTIONS",
			"TRACE"
		]
	};
}));

//#endregion
//#region node_modules/undici/lib/timers.js
var require_timers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let fastNow = Date.now();
	let fastNowTimeout;
	const fastTimers = [];
	function onTimeout() {
		fastNow = Date.now();
		let len$1 = fastTimers.length;
		let idx = 0;
		while (idx < len$1) {
			const timer = fastTimers[idx];
			if (timer.state === 0) timer.state = fastNow + timer.delay;
			else if (timer.state > 0 && fastNow >= timer.state) {
				timer.state = -1;
				timer.callback(timer.opaque);
			}
			if (timer.state === -1) {
				timer.state = -2;
				if (idx !== len$1 - 1) fastTimers[idx] = fastTimers.pop();
				else fastTimers.pop();
				len$1 -= 1;
			} else idx += 1;
		}
		if (fastTimers.length > 0) refreshTimeout();
	}
	function refreshTimeout() {
		if (fastNowTimeout && fastNowTimeout.refresh) fastNowTimeout.refresh();
		else {
			clearTimeout(fastNowTimeout);
			fastNowTimeout = setTimeout(onTimeout, 1e3);
			if (fastNowTimeout.unref) fastNowTimeout.unref();
		}
	}
	var Timeout = class {
		constructor(callback, delay, opaque) {
			this.callback = callback;
			this.delay = delay;
			this.opaque = opaque;
			this.state = -2;
			this.refresh();
		}
		refresh() {
			if (this.state === -2) {
				fastTimers.push(this);
				if (!fastNowTimeout || fastTimers.length === 1) refreshTimeout();
			}
			this.state = 0;
		}
		clear() {
			this.state = -1;
		}
	};
	module.exports = {
		setTimeout(callback, delay, opaque) {
			return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
		},
		clearTimeout(timeout) {
			if (timeout instanceof Timeout) timeout.clear();
			else clearTimeout(timeout);
		}
	};
}));

//#endregion
//#region node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Copyright Brian White. All rights reserved.
	*
	* @see https://github.com/mscdex/streamsearch
	*
	* Permission is hereby granted, free of charge, to any person obtaining a copy
	* of this software and associated documentation files (the "Software"), to
	* deal in the Software without restriction, including without limitation the
	* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	* sell copies of the Software, and to permit persons to whom the Software is
	* furnished to do so, subject to the following conditions:
	*
	* The above copyright notice and this permission notice shall be included in
	* all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	* IN THE SOFTWARE.
	*
	* Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
	* by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
	*/
	const EventEmitter$4 = require("node:events").EventEmitter;
	const inherits$5 = require("node:util").inherits;
	function SBMH(needle) {
		if (typeof needle === "string") needle = Buffer.from(needle);
		if (!Buffer.isBuffer(needle)) throw new TypeError("The needle has to be a String or a Buffer.");
		const needleLength = needle.length;
		if (needleLength === 0) throw new Error("The needle cannot be an empty String/Buffer.");
		if (needleLength > 256) throw new Error("The needle cannot have a length bigger than 256.");
		this.maxMatches = Infinity;
		this.matches = 0;
		this._occ = new Array(256).fill(needleLength);
		this._lookbehind_size = 0;
		this._needle = needle;
		this._bufpos = 0;
		this._lookbehind = Buffer.alloc(needleLength);
		for (var i$2 = 0; i$2 < needleLength - 1; ++i$2) this._occ[needle[i$2]] = needleLength - 1 - i$2;
	}
	inherits$5(SBMH, EventEmitter$4);
	SBMH.prototype.reset = function() {
		this._lookbehind_size = 0;
		this.matches = 0;
		this._bufpos = 0;
	};
	SBMH.prototype.push = function(chunk, pos) {
		if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, "binary");
		const chlen = chunk.length;
		this._bufpos = pos || 0;
		let r$1;
		while (r$1 !== chlen && this.matches < this.maxMatches) r$1 = this._sbmh_feed(chunk);
		return r$1;
	};
	SBMH.prototype._sbmh_feed = function(data) {
		const len$1 = data.length;
		const needle = this._needle;
		const needleLength = needle.length;
		const lastNeedleChar = needle[needleLength - 1];
		let pos = -this._lookbehind_size;
		let ch;
		if (pos < 0) {
			while (pos < 0 && pos <= len$1 - needleLength) {
				ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
				if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
					this._lookbehind_size = 0;
					++this.matches;
					this.emit("info", true);
					return this._bufpos = pos + needleLength;
				}
				pos += this._occ[ch];
			}
			if (pos < 0) while (pos < 0 && !this._sbmh_memcmp(data, pos, len$1 - pos)) ++pos;
			if (pos >= 0) {
				this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
				this._lookbehind_size = 0;
			} else {
				const bytesToCutOff = this._lookbehind_size + pos;
				if (bytesToCutOff > 0) this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
				this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
				this._lookbehind_size -= bytesToCutOff;
				data.copy(this._lookbehind, this._lookbehind_size);
				this._lookbehind_size += len$1;
				this._bufpos = len$1;
				return len$1;
			}
		}
		pos += (pos >= 0) * this._bufpos;
		if (data.indexOf(needle, pos) !== -1) {
			pos = data.indexOf(needle, pos);
			++this.matches;
			if (pos > 0) this.emit("info", true, data, this._bufpos, pos);
			else this.emit("info", true);
			return this._bufpos = pos + needleLength;
		} else pos = len$1 - needleLength;
		while (pos < len$1 && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len$1 - pos), needle.subarray(0, len$1 - pos)) !== 0)) ++pos;
		if (pos < len$1) {
			data.copy(this._lookbehind, 0, pos, pos + (len$1 - pos));
			this._lookbehind_size = len$1 - pos;
		}
		if (pos > 0) this.emit("info", false, data, this._bufpos, pos < len$1 ? pos : len$1);
		this._bufpos = len$1;
		return len$1;
	};
	SBMH.prototype._sbmh_lookup_char = function(data, pos) {
		return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
	};
	SBMH.prototype._sbmh_memcmp = function(data, pos, len$1) {
		for (var i$2 = 0; i$2 < len$1; ++i$2) if (this._sbmh_lookup_char(data, pos + i$2) !== this._needle[i$2]) return false;
		return true;
	};
	module.exports = SBMH;
}));

//#endregion
//#region node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const inherits$4 = require("node:util").inherits;
	const ReadableStream$5 = require("node:stream").Readable;
	function PartStream$1(opts) {
		ReadableStream$5.call(this, opts);
	}
	inherits$4(PartStream$1, ReadableStream$5);
	PartStream$1.prototype._read = function(n) {};
	module.exports = PartStream$1;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function getLimit$3(limits, name, defaultLimit) {
		if (!limits || limits[name] === void 0 || limits[name] === null) return defaultLimit;
		if (typeof limits[name] !== "number" || isNaN(limits[name])) throw new TypeError("Limit " + name + " is not a valid number");
		return limits[name];
	};
}));

//#endregion
//#region node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter$3 = require("node:events").EventEmitter;
	const inherits$3 = require("node:util").inherits;
	const getLimit$2 = require_getLimit();
	const StreamSearch$1 = require_sbmh();
	const B_DCRLF = Buffer.from("\r\n\r\n");
	const RE_CRLF = /\r\n/g;
	const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
	function HeaderParser$1(cfg) {
		EventEmitter$3.call(this);
		cfg = cfg || {};
		const self$1 = this;
		this.nread = 0;
		this.maxed = false;
		this.npairs = 0;
		this.maxHeaderPairs = getLimit$2(cfg, "maxHeaderPairs", 2e3);
		this.maxHeaderSize = getLimit$2(cfg, "maxHeaderSize", 80 * 1024);
		this.buffer = "";
		this.header = {};
		this.finished = false;
		this.ss = new StreamSearch$1(B_DCRLF);
		this.ss.on("info", function(isMatch, data, start, end) {
			if (data && !self$1.maxed) {
				if (self$1.nread + end - start >= self$1.maxHeaderSize) {
					end = self$1.maxHeaderSize - self$1.nread + start;
					self$1.nread = self$1.maxHeaderSize;
					self$1.maxed = true;
				} else self$1.nread += end - start;
				self$1.buffer += data.toString("binary", start, end);
			}
			if (isMatch) self$1._finish();
		});
	}
	inherits$3(HeaderParser$1, EventEmitter$3);
	HeaderParser$1.prototype.push = function(data) {
		const r$1 = this.ss.push(data);
		if (this.finished) return r$1;
	};
	HeaderParser$1.prototype.reset = function() {
		this.finished = false;
		this.buffer = "";
		this.header = {};
		this.ss.reset();
	};
	HeaderParser$1.prototype._finish = function() {
		if (this.buffer) this._parseHeader();
		this.ss.matches = this.ss.maxMatches;
		const header = this.header;
		this.header = {};
		this.buffer = "";
		this.finished = true;
		this.nread = this.npairs = 0;
		this.maxed = false;
		this.emit("header", header);
	};
	HeaderParser$1.prototype._parseHeader = function() {
		if (this.npairs === this.maxHeaderPairs) return;
		const lines = this.buffer.split(RE_CRLF);
		const len$1 = lines.length;
		let m$2, h$2;
		for (var i$2 = 0; i$2 < len$1; ++i$2) {
			if (lines[i$2].length === 0) continue;
			if (lines[i$2][0] === "	" || lines[i$2][0] === " ") {
				if (h$2) {
					this.header[h$2][this.header[h$2].length - 1] += lines[i$2];
					continue;
				}
			}
			const posColon = lines[i$2].indexOf(":");
			if (posColon === -1 || posColon === 0) return;
			m$2 = RE_HDR.exec(lines[i$2]);
			h$2 = m$2[1].toLowerCase();
			this.header[h$2] = this.header[h$2] || [];
			this.header[h$2].push(m$2[2] || "");
			if (++this.npairs === this.maxHeaderPairs) break;
		}
	};
	module.exports = HeaderParser$1;
}));

//#endregion
//#region node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const WritableStream$1 = require("node:stream").Writable;
	const inherits$2 = require("node:util").inherits;
	const StreamSearch = require_sbmh();
	const PartStream = require_PartStream();
	const HeaderParser = require_HeaderParser();
	const DASH = 45;
	const B_ONEDASH = Buffer.from("-");
	const B_CRLF = Buffer.from("\r\n");
	const EMPTY_FN = function() {};
	function Dicer$2(cfg) {
		if (!(this instanceof Dicer$2)) return new Dicer$2(cfg);
		WritableStream$1.call(this, cfg);
		if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") throw new TypeError("Boundary required");
		if (typeof cfg.boundary === "string") this.setBoundary(cfg.boundary);
		else this._bparser = void 0;
		this._headerFirst = cfg.headerFirst;
		this._dashes = 0;
		this._parts = 0;
		this._finished = false;
		this._realFinish = false;
		this._isPreamble = true;
		this._justMatched = false;
		this._firstWrite = true;
		this._inHeader = true;
		this._part = void 0;
		this._cb = void 0;
		this._ignoreData = false;
		this._partOpts = { highWaterMark: cfg.partHwm };
		this._pause = false;
		const self$1 = this;
		this._hparser = new HeaderParser(cfg);
		this._hparser.on("header", function(header) {
			self$1._inHeader = false;
			self$1._part.emit("header", header);
		});
	}
	inherits$2(Dicer$2, WritableStream$1);
	Dicer$2.prototype.emit = function(ev) {
		if (ev === "finish" && !this._realFinish) {
			if (!this._finished) {
				const self$1 = this;
				process.nextTick(function() {
					self$1.emit("error", /* @__PURE__ */ new Error("Unexpected end of multipart data"));
					if (self$1._part && !self$1._ignoreData) {
						const type = self$1._isPreamble ? "Preamble" : "Part";
						self$1._part.emit("error", /* @__PURE__ */ new Error(type + " terminated early due to unexpected end of multipart data"));
						self$1._part.push(null);
						process.nextTick(function() {
							self$1._realFinish = true;
							self$1.emit("finish");
							self$1._realFinish = false;
						});
						return;
					}
					self$1._realFinish = true;
					self$1.emit("finish");
					self$1._realFinish = false;
				});
			}
		} else WritableStream$1.prototype.emit.apply(this, arguments);
	};
	Dicer$2.prototype._write = function(data, encoding, cb) {
		if (!this._hparser && !this._bparser) return cb();
		if (this._headerFirst && this._isPreamble) {
			if (!this._part) {
				this._part = new PartStream(this._partOpts);
				if (this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
				else this._ignore();
			}
			const r$1 = this._hparser.push(data);
			if (!this._inHeader && r$1 !== void 0 && r$1 < data.length) data = data.slice(r$1);
			else return cb();
		}
		if (this._firstWrite) {
			this._bparser.push(B_CRLF);
			this._firstWrite = false;
		}
		this._bparser.push(data);
		if (this._pause) this._cb = cb;
		else cb();
	};
	Dicer$2.prototype.reset = function() {
		this._part = void 0;
		this._bparser = void 0;
		this._hparser = void 0;
	};
	Dicer$2.prototype.setBoundary = function(boundary) {
		const self$1 = this;
		this._bparser = new StreamSearch("\r\n--" + boundary);
		this._bparser.on("info", function(isMatch, data, start, end) {
			self$1._oninfo(isMatch, data, start, end);
		});
	};
	Dicer$2.prototype._ignore = function() {
		if (this._part && !this._ignoreData) {
			this._ignoreData = true;
			this._part.on("error", EMPTY_FN);
			this._part.resume();
		}
	};
	Dicer$2.prototype._oninfo = function(isMatch, data, start, end) {
		let buf;
		const self$1 = this;
		let i$2 = 0;
		let r$1;
		let shouldWriteMore = true;
		if (!this._part && this._justMatched && data) {
			while (this._dashes < 2 && start + i$2 < end) if (data[start + i$2] === DASH) {
				++i$2;
				++this._dashes;
			} else {
				if (this._dashes) buf = B_ONEDASH;
				this._dashes = 0;
				break;
			}
			if (this._dashes === 2) {
				if (start + i$2 < end && this.listenerCount("trailer") !== 0) this.emit("trailer", data.slice(start + i$2, end));
				this.reset();
				this._finished = true;
				if (self$1._parts === 0) {
					self$1._realFinish = true;
					self$1.emit("finish");
					self$1._realFinish = false;
				}
			}
			if (this._dashes) return;
		}
		if (this._justMatched) this._justMatched = false;
		if (!this._part) {
			this._part = new PartStream(this._partOpts);
			this._part._read = function(n) {
				self$1._unpause();
			};
			if (this._isPreamble && this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
			else if (this._isPreamble !== true && this.listenerCount("part") !== 0) this.emit("part", this._part);
			else this._ignore();
			if (!this._isPreamble) this._inHeader = true;
		}
		if (data && start < end && !this._ignoreData) {
			if (this._isPreamble || !this._inHeader) {
				if (buf) shouldWriteMore = this._part.push(buf);
				shouldWriteMore = this._part.push(data.slice(start, end));
				if (!shouldWriteMore) this._pause = true;
			} else if (!this._isPreamble && this._inHeader) {
				if (buf) this._hparser.push(buf);
				r$1 = this._hparser.push(data.slice(start, end));
				if (!this._inHeader && r$1 !== void 0 && r$1 < end) this._oninfo(false, data, start + r$1, end);
			}
		}
		if (isMatch) {
			this._hparser.reset();
			if (this._isPreamble) this._isPreamble = false;
			else if (start !== end) {
				++this._parts;
				this._part.on("end", function() {
					if (--self$1._parts === 0) if (self$1._finished) {
						self$1._realFinish = true;
						self$1.emit("finish");
						self$1._realFinish = false;
					} else self$1._unpause();
				});
			}
			this._part.push(null);
			this._part = void 0;
			this._ignoreData = false;
			this._justMatched = true;
			this._dashes = 0;
		}
	};
	Dicer$2.prototype._unpause = function() {
		if (!this._pause) return;
		this._pause = false;
		if (this._cb) {
			const cb = this._cb;
			this._cb = void 0;
			cb();
		}
	};
	module.exports = Dicer$2;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const utf8Decoder = new TextDecoder("utf-8");
	const textDecoders = new Map([["utf-8", utf8Decoder], ["utf8", utf8Decoder]]);
	function getDecoder(charset) {
		let lc;
		while (true) switch (charset) {
			case "utf-8":
			case "utf8": return decoders.utf8;
			case "latin1":
			case "ascii":
			case "us-ascii":
			case "iso-8859-1":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "windows-1252":
			case "iso_8859-1:1987":
			case "cp1252":
			case "x-cp1252": return decoders.latin1;
			case "utf16le":
			case "utf-16le":
			case "ucs2":
			case "ucs-2": return decoders.utf16le;
			case "base64": return decoders.base64;
			default:
				if (lc === void 0) {
					lc = true;
					charset = charset.toLowerCase();
					continue;
				}
				return decoders.other.bind(charset);
		}
	}
	const decoders = {
		utf8: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.utf8Slice(0, data.length);
		},
		latin1: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") return data;
			return data.latin1Slice(0, data.length);
		},
		utf16le: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.ucs2Slice(0, data.length);
		},
		base64: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.base64Slice(0, data.length);
		},
		other: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			if (textDecoders.has(exports.toString())) try {
				return textDecoders.get(exports).decode(data);
			} catch {}
			return typeof data === "string" ? data : data.toString();
		}
	};
	function decodeText$3(text, sourceEncoding, destEncoding) {
		if (text) return getDecoder(destEncoding)(text, sourceEncoding);
		return text;
	}
	module.exports = decodeText$3;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const decodeText$2 = require_decodeText();
	const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
	const EncodedLookup = {
		"%00": "\0",
		"%01": "",
		"%02": "",
		"%03": "",
		"%04": "",
		"%05": "",
		"%06": "",
		"%07": "\x07",
		"%08": "\b",
		"%09": "	",
		"%0a": "\n",
		"%0A": "\n",
		"%0b": "\v",
		"%0B": "\v",
		"%0c": "\f",
		"%0C": "\f",
		"%0d": "\r",
		"%0D": "\r",
		"%0e": "",
		"%0E": "",
		"%0f": "",
		"%0F": "",
		"%10": "",
		"%11": "",
		"%12": "",
		"%13": "",
		"%14": "",
		"%15": "",
		"%16": "",
		"%17": "",
		"%18": "",
		"%19": "",
		"%1a": "",
		"%1A": "",
		"%1b": "\x1B",
		"%1B": "\x1B",
		"%1c": "",
		"%1C": "",
		"%1d": "",
		"%1D": "",
		"%1e": "",
		"%1E": "",
		"%1f": "",
		"%1F": "",
		"%20": " ",
		"%21": "!",
		"%22": "\"",
		"%23": "#",
		"%24": "$",
		"%25": "%",
		"%26": "&",
		"%27": "'",
		"%28": "(",
		"%29": ")",
		"%2a": "*",
		"%2A": "*",
		"%2b": "+",
		"%2B": "+",
		"%2c": ",",
		"%2C": ",",
		"%2d": "-",
		"%2D": "-",
		"%2e": ".",
		"%2E": ".",
		"%2f": "/",
		"%2F": "/",
		"%30": "0",
		"%31": "1",
		"%32": "2",
		"%33": "3",
		"%34": "4",
		"%35": "5",
		"%36": "6",
		"%37": "7",
		"%38": "8",
		"%39": "9",
		"%3a": ":",
		"%3A": ":",
		"%3b": ";",
		"%3B": ";",
		"%3c": "<",
		"%3C": "<",
		"%3d": "=",
		"%3D": "=",
		"%3e": ">",
		"%3E": ">",
		"%3f": "?",
		"%3F": "?",
		"%40": "@",
		"%41": "A",
		"%42": "B",
		"%43": "C",
		"%44": "D",
		"%45": "E",
		"%46": "F",
		"%47": "G",
		"%48": "H",
		"%49": "I",
		"%4a": "J",
		"%4A": "J",
		"%4b": "K",
		"%4B": "K",
		"%4c": "L",
		"%4C": "L",
		"%4d": "M",
		"%4D": "M",
		"%4e": "N",
		"%4E": "N",
		"%4f": "O",
		"%4F": "O",
		"%50": "P",
		"%51": "Q",
		"%52": "R",
		"%53": "S",
		"%54": "T",
		"%55": "U",
		"%56": "V",
		"%57": "W",
		"%58": "X",
		"%59": "Y",
		"%5a": "Z",
		"%5A": "Z",
		"%5b": "[",
		"%5B": "[",
		"%5c": "\\",
		"%5C": "\\",
		"%5d": "]",
		"%5D": "]",
		"%5e": "^",
		"%5E": "^",
		"%5f": "_",
		"%5F": "_",
		"%60": "`",
		"%61": "a",
		"%62": "b",
		"%63": "c",
		"%64": "d",
		"%65": "e",
		"%66": "f",
		"%67": "g",
		"%68": "h",
		"%69": "i",
		"%6a": "j",
		"%6A": "j",
		"%6b": "k",
		"%6B": "k",
		"%6c": "l",
		"%6C": "l",
		"%6d": "m",
		"%6D": "m",
		"%6e": "n",
		"%6E": "n",
		"%6f": "o",
		"%6F": "o",
		"%70": "p",
		"%71": "q",
		"%72": "r",
		"%73": "s",
		"%74": "t",
		"%75": "u",
		"%76": "v",
		"%77": "w",
		"%78": "x",
		"%79": "y",
		"%7a": "z",
		"%7A": "z",
		"%7b": "{",
		"%7B": "{",
		"%7c": "|",
		"%7C": "|",
		"%7d": "}",
		"%7D": "}",
		"%7e": "~",
		"%7E": "~",
		"%7f": "",
		"%7F": "",
		"%80": "",
		"%81": "",
		"%82": "",
		"%83": "",
		"%84": "",
		"%85": "",
		"%86": "",
		"%87": "",
		"%88": "",
		"%89": "",
		"%8a": "",
		"%8A": "",
		"%8b": "",
		"%8B": "",
		"%8c": "",
		"%8C": "",
		"%8d": "",
		"%8D": "",
		"%8e": "",
		"%8E": "",
		"%8f": "",
		"%8F": "",
		"%90": "",
		"%91": "",
		"%92": "",
		"%93": "",
		"%94": "",
		"%95": "",
		"%96": "",
		"%97": "",
		"%98": "",
		"%99": "",
		"%9a": "",
		"%9A": "",
		"%9b": "",
		"%9B": "",
		"%9c": "",
		"%9C": "",
		"%9d": "",
		"%9D": "",
		"%9e": "",
		"%9E": "",
		"%9f": "",
		"%9F": "",
		"%a0": "\xA0",
		"%A0": "\xA0",
		"%a1": "",
		"%A1": "",
		"%a2": "",
		"%A2": "",
		"%a3": "",
		"%A3": "",
		"%a4": "",
		"%A4": "",
		"%a5": "",
		"%A5": "",
		"%a6": "",
		"%A6": "",
		"%a7": "",
		"%A7": "",
		"%a8": "",
		"%A8": "",
		"%a9": "",
		"%A9": "",
		"%aa": "",
		"%Aa": "",
		"%aA": "",
		"%AA": "",
		"%ab": "",
		"%Ab": "",
		"%aB": "",
		"%AB": "",
		"%ac": "",
		"%Ac": "",
		"%aC": "",
		"%AC": "",
		"%ad": "",
		"%Ad": "",
		"%aD": "",
		"%AD": "",
		"%ae": "",
		"%Ae": "",
		"%aE": "",
		"%AE": "",
		"%af": "",
		"%Af": "",
		"%aF": "",
		"%AF": "",
		"%b0": "",
		"%B0": "",
		"%b1": "",
		"%B1": "",
		"%b2": "",
		"%B2": "",
		"%b3": "",
		"%B3": "",
		"%b4": "",
		"%B4": "",
		"%b5": "",
		"%B5": "",
		"%b6": "",
		"%B6": "",
		"%b7": "",
		"%B7": "",
		"%b8": "",
		"%B8": "",
		"%b9": "",
		"%B9": "",
		"%ba": "",
		"%Ba": "",
		"%bA": "",
		"%BA": "",
		"%bb": "",
		"%Bb": "",
		"%bB": "",
		"%BB": "",
		"%bc": "",
		"%Bc": "",
		"%bC": "",
		"%BC": "",
		"%bd": "",
		"%Bd": "",
		"%bD": "",
		"%BD": "",
		"%be": "",
		"%Be": "",
		"%bE": "",
		"%BE": "",
		"%bf": "",
		"%Bf": "",
		"%bF": "",
		"%BF": "",
		"%c0": "",
		"%C0": "",
		"%c1": "",
		"%C1": "",
		"%c2": "",
		"%C2": "",
		"%c3": "",
		"%C3": "",
		"%c4": "",
		"%C4": "",
		"%c5": "",
		"%C5": "",
		"%c6": "",
		"%C6": "",
		"%c7": "",
		"%C7": "",
		"%c8": "",
		"%C8": "",
		"%c9": "",
		"%C9": "",
		"%ca": "",
		"%Ca": "",
		"%cA": "",
		"%CA": "",
		"%cb": "",
		"%Cb": "",
		"%cB": "",
		"%CB": "",
		"%cc": "",
		"%Cc": "",
		"%cC": "",
		"%CC": "",
		"%cd": "",
		"%Cd": "",
		"%cD": "",
		"%CD": "",
		"%ce": "",
		"%Ce": "",
		"%cE": "",
		"%CE": "",
		"%cf": "",
		"%Cf": "",
		"%cF": "",
		"%CF": "",
		"%d0": "",
		"%D0": "",
		"%d1": "",
		"%D1": "",
		"%d2": "",
		"%D2": "",
		"%d3": "",
		"%D3": "",
		"%d4": "",
		"%D4": "",
		"%d5": "",
		"%D5": "",
		"%d6": "",
		"%D6": "",
		"%d7": "",
		"%D7": "",
		"%d8": "",
		"%D8": "",
		"%d9": "",
		"%D9": "",
		"%da": "",
		"%Da": "",
		"%dA": "",
		"%DA": "",
		"%db": "",
		"%Db": "",
		"%dB": "",
		"%DB": "",
		"%dc": "",
		"%Dc": "",
		"%dC": "",
		"%DC": "",
		"%dd": "",
		"%Dd": "",
		"%dD": "",
		"%DD": "",
		"%de": "",
		"%De": "",
		"%dE": "",
		"%DE": "",
		"%df": "",
		"%Df": "",
		"%dF": "",
		"%DF": "",
		"%e0": "",
		"%E0": "",
		"%e1": "",
		"%E1": "",
		"%e2": "",
		"%E2": "",
		"%e3": "",
		"%E3": "",
		"%e4": "",
		"%E4": "",
		"%e5": "",
		"%E5": "",
		"%e6": "",
		"%E6": "",
		"%e7": "",
		"%E7": "",
		"%e8": "",
		"%E8": "",
		"%e9": "",
		"%E9": "",
		"%ea": "",
		"%Ea": "",
		"%eA": "",
		"%EA": "",
		"%eb": "",
		"%Eb": "",
		"%eB": "",
		"%EB": "",
		"%ec": "",
		"%Ec": "",
		"%eC": "",
		"%EC": "",
		"%ed": "",
		"%Ed": "",
		"%eD": "",
		"%ED": "",
		"%ee": "",
		"%Ee": "",
		"%eE": "",
		"%EE": "",
		"%ef": "",
		"%Ef": "",
		"%eF": "",
		"%EF": "",
		"%f0": "",
		"%F0": "",
		"%f1": "",
		"%F1": "",
		"%f2": "",
		"%F2": "",
		"%f3": "",
		"%F3": "",
		"%f4": "",
		"%F4": "",
		"%f5": "",
		"%F5": "",
		"%f6": "",
		"%F6": "",
		"%f7": "",
		"%F7": "",
		"%f8": "",
		"%F8": "",
		"%f9": "",
		"%F9": "",
		"%fa": "",
		"%Fa": "",
		"%fA": "",
		"%FA": "",
		"%fb": "",
		"%Fb": "",
		"%fB": "",
		"%FB": "",
		"%fc": "",
		"%Fc": "",
		"%fC": "",
		"%FC": "",
		"%fd": "",
		"%Fd": "",
		"%fD": "",
		"%FD": "",
		"%fe": "",
		"%Fe": "",
		"%fE": "",
		"%FE": "",
		"%ff": "",
		"%Ff": "",
		"%fF": "",
		"%FF": ""
	};
	function encodedReplacer(match) {
		return EncodedLookup[match];
	}
	const STATE_KEY = 0;
	const STATE_VALUE = 1;
	const STATE_CHARSET = 2;
	const STATE_LANG = 3;
	function parseParams$2(str) {
		const res = [];
		let state = STATE_KEY;
		let charset = "";
		let inquote = false;
		let escaping = false;
		let p = 0;
		let tmp = "";
		const len$1 = str.length;
		for (var i$2 = 0; i$2 < len$1; ++i$2) {
			const char = str[i$2];
			if (char === "\\" && inquote) if (escaping) escaping = false;
			else {
				escaping = true;
				continue;
			}
			else if (char === "\"") if (!escaping) {
				if (inquote) {
					inquote = false;
					state = STATE_KEY;
				} else inquote = true;
				continue;
			} else escaping = false;
			else {
				if (escaping && inquote) tmp += "\\";
				escaping = false;
				if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
					if (state === STATE_CHARSET) {
						state = STATE_LANG;
						charset = tmp.substring(1);
					} else state = STATE_VALUE;
					tmp = "";
					continue;
				} else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
					state = char === "*" ? STATE_CHARSET : STATE_VALUE;
					res[p] = [tmp, void 0];
					tmp = "";
					continue;
				} else if (!inquote && char === ";") {
					state = STATE_KEY;
					if (charset) {
						if (tmp.length) tmp = decodeText$2(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
						charset = "";
					} else if (tmp.length) tmp = decodeText$2(tmp, "binary", "utf8");
					if (res[p] === void 0) res[p] = tmp;
					else res[p][1] = tmp;
					tmp = "";
					++p;
					continue;
				} else if (!inquote && (char === " " || char === "	")) continue;
			}
			tmp += char;
		}
		if (charset && tmp.length) tmp = decodeText$2(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
		else if (tmp) tmp = decodeText$2(tmp, "binary", "utf8");
		if (res[p] === void 0) {
			if (tmp) res[p] = tmp;
		} else res[p][1] = tmp;
		return res;
	}
	module.exports = parseParams$2;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function basename$2(path$9) {
		if (typeof path$9 !== "string") return "";
		for (var i$2 = path$9.length - 1; i$2 >= 0; --i$2) switch (path$9.charCodeAt(i$2)) {
			case 47:
			case 92:
				path$9 = path$9.slice(i$2 + 1);
				return path$9 === ".." || path$9 === "." ? "" : path$9;
		}
		return path$9 === ".." || path$9 === "." ? "" : path$9;
	};
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Readable: Readable$6 } = require("node:stream");
	const { inherits: inherits$1 } = require("node:util");
	const Dicer$1 = require_Dicer();
	const parseParams$1 = require_parseParams();
	const decodeText$1 = require_decodeText();
	const basename$1 = require_basename();
	const getLimit$1 = require_getLimit();
	const RE_BOUNDARY = /^boundary$/i;
	const RE_FIELD = /^form-data$/i;
	const RE_CHARSET$1 = /^charset$/i;
	const RE_FILENAME = /^filename$/i;
	const RE_NAME = /^name$/i;
	Multipart.detect = /^multipart\/form-data/i;
	function Multipart(boy, cfg) {
		let i$2;
		let len$1;
		const self$1 = this;
		let boundary;
		const limits = cfg.limits;
		const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
		const parsedConType = cfg.parsedConType || [];
		const defCharset = cfg.defCharset || "utf8";
		const preservePath = cfg.preservePath;
		const fileOpts = { highWaterMark: cfg.fileHwm };
		for (i$2 = 0, len$1 = parsedConType.length; i$2 < len$1; ++i$2) if (Array.isArray(parsedConType[i$2]) && RE_BOUNDARY.test(parsedConType[i$2][0])) {
			boundary = parsedConType[i$2][1];
			break;
		}
		function checkFinished() {
			if (nends === 0 && finished$2 && !boy._done) {
				finished$2 = false;
				self$1.end();
			}
		}
		if (typeof boundary !== "string") throw new Error("Multipart: Boundary not found");
		const fieldSizeLimit = getLimit$1(limits, "fieldSize", 1 * 1024 * 1024);
		const fileSizeLimit = getLimit$1(limits, "fileSize", Infinity);
		const filesLimit = getLimit$1(limits, "files", Infinity);
		const fieldsLimit = getLimit$1(limits, "fields", Infinity);
		const partsLimit = getLimit$1(limits, "parts", Infinity);
		const headerPairsLimit = getLimit$1(limits, "headerPairs", 2e3);
		const headerSizeLimit = getLimit$1(limits, "headerSize", 80 * 1024);
		let nfiles = 0;
		let nfields = 0;
		let nends = 0;
		let curFile;
		let curField;
		let finished$2 = false;
		this._needDrain = false;
		this._pause = false;
		this._cb = void 0;
		this._nparts = 0;
		this._boy = boy;
		this.parser = new Dicer$1({
			boundary,
			maxHeaderPairs: headerPairsLimit,
			maxHeaderSize: headerSizeLimit,
			partHwm: fileOpts.highWaterMark,
			highWaterMark: cfg.highWaterMark
		});
		this.parser.on("drain", function() {
			self$1._needDrain = false;
			if (self$1._cb && !self$1._pause) {
				const cb = self$1._cb;
				self$1._cb = void 0;
				cb();
			}
		}).on("part", function onPart(part) {
			if (++self$1._nparts > partsLimit) {
				self$1.parser.removeListener("part", onPart);
				self$1.parser.on("part", skipPart);
				boy.hitPartsLimit = true;
				boy.emit("partsLimit");
				return skipPart(part);
			}
			if (curField) {
				const field = curField;
				field.emit("end");
				field.removeAllListeners("end");
			}
			part.on("header", function(header) {
				let contype;
				let fieldname;
				let parsed;
				let charset;
				let encoding;
				let filename;
				let nsize = 0;
				if (header["content-type"]) {
					parsed = parseParams$1(header["content-type"][0]);
					if (parsed[0]) {
						contype = parsed[0].toLowerCase();
						for (i$2 = 0, len$1 = parsed.length; i$2 < len$1; ++i$2) if (RE_CHARSET$1.test(parsed[i$2][0])) {
							charset = parsed[i$2][1].toLowerCase();
							break;
						}
					}
				}
				if (contype === void 0) contype = "text/plain";
				if (charset === void 0) charset = defCharset;
				if (header["content-disposition"]) {
					parsed = parseParams$1(header["content-disposition"][0]);
					if (!RE_FIELD.test(parsed[0])) return skipPart(part);
					for (i$2 = 0, len$1 = parsed.length; i$2 < len$1; ++i$2) if (RE_NAME.test(parsed[i$2][0])) fieldname = parsed[i$2][1];
					else if (RE_FILENAME.test(parsed[i$2][0])) {
						filename = parsed[i$2][1];
						if (!preservePath) filename = basename$1(filename);
					}
				} else return skipPart(part);
				if (header["content-transfer-encoding"]) encoding = header["content-transfer-encoding"][0].toLowerCase();
				else encoding = "7bit";
				let onData, onEnd;
				if (isPartAFile(fieldname, contype, filename)) {
					if (nfiles === filesLimit) {
						if (!boy.hitFilesLimit) {
							boy.hitFilesLimit = true;
							boy.emit("filesLimit");
						}
						return skipPart(part);
					}
					++nfiles;
					if (boy.listenerCount("file") === 0) {
						self$1.parser._ignore();
						return;
					}
					++nends;
					const file = new FileStream(fileOpts);
					curFile = file;
					file.on("end", function() {
						--nends;
						self$1._pause = false;
						checkFinished();
						if (self$1._cb && !self$1._needDrain) {
							const cb = self$1._cb;
							self$1._cb = void 0;
							cb();
						}
					});
					file._read = function(n) {
						if (!self$1._pause) return;
						self$1._pause = false;
						if (self$1._cb && !self$1._needDrain) {
							const cb = self$1._cb;
							self$1._cb = void 0;
							cb();
						}
					};
					boy.emit("file", fieldname, file, filename, encoding, contype);
					onData = function(data) {
						if ((nsize += data.length) > fileSizeLimit) {
							const extralen = fileSizeLimit - nsize + data.length;
							if (extralen > 0) file.push(data.slice(0, extralen));
							file.truncated = true;
							file.bytesRead = fileSizeLimit;
							part.removeAllListeners("data");
							file.emit("limit");
							return;
						} else if (!file.push(data)) self$1._pause = true;
						file.bytesRead = nsize;
					};
					onEnd = function() {
						curFile = void 0;
						file.push(null);
					};
				} else {
					if (nfields === fieldsLimit) {
						if (!boy.hitFieldsLimit) {
							boy.hitFieldsLimit = true;
							boy.emit("fieldsLimit");
						}
						return skipPart(part);
					}
					++nfields;
					++nends;
					let buffer$1 = "";
					let truncated = false;
					curField = part;
					onData = function(data) {
						if ((nsize += data.length) > fieldSizeLimit) {
							const extralen = fieldSizeLimit - (nsize - data.length);
							buffer$1 += data.toString("binary", 0, extralen);
							truncated = true;
							part.removeAllListeners("data");
						} else buffer$1 += data.toString("binary");
					};
					onEnd = function() {
						curField = void 0;
						if (buffer$1.length) buffer$1 = decodeText$1(buffer$1, "binary", charset);
						boy.emit("field", fieldname, buffer$1, false, truncated, encoding, contype);
						--nends;
						checkFinished();
					};
				}
				part._readableState.sync = false;
				part.on("data", onData);
				part.on("end", onEnd);
			}).on("error", function(err) {
				if (curFile) curFile.emit("error", err);
			});
		}).on("error", function(err) {
			boy.emit("error", err);
		}).on("finish", function() {
			finished$2 = true;
			checkFinished();
		});
	}
	Multipart.prototype.write = function(chunk, cb) {
		const r$1 = this.parser.write(chunk);
		if (r$1 && !this._pause) cb();
		else {
			this._needDrain = !r$1;
			this._cb = cb;
		}
	};
	Multipart.prototype.end = function() {
		const self$1 = this;
		if (self$1.parser.writable) self$1.parser.end();
		else if (!self$1._boy._done) process.nextTick(function() {
			self$1._boy._done = true;
			self$1._boy.emit("finish");
		});
	};
	function skipPart(part) {
		part.resume();
	}
	function FileStream(opts) {
		Readable$6.call(this, opts);
		this.bytesRead = 0;
		this.truncated = false;
	}
	inherits$1(FileStream, Readable$6);
	FileStream.prototype._read = function(n) {};
	module.exports = Multipart;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const RE_PLUS = /\+/g;
	const HEX = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	];
	function Decoder$1() {
		this.buffer = void 0;
	}
	Decoder$1.prototype.write = function(str) {
		str = str.replace(RE_PLUS, " ");
		let res = "";
		let i$2 = 0;
		let p = 0;
		const len$1 = str.length;
		for (; i$2 < len$1; ++i$2) if (this.buffer !== void 0) if (!HEX[str.charCodeAt(i$2)]) {
			res += "%" + this.buffer;
			this.buffer = void 0;
			--i$2;
		} else {
			this.buffer += str[i$2];
			++p;
			if (this.buffer.length === 2) {
				res += String.fromCharCode(parseInt(this.buffer, 16));
				this.buffer = void 0;
			}
		}
		else if (str[i$2] === "%") {
			if (i$2 > p) {
				res += str.substring(p, i$2);
				p = i$2;
			}
			this.buffer = "";
			++p;
		}
		if (p < len$1 && this.buffer === void 0) res += str.substring(p);
		return res;
	};
	Decoder$1.prototype.reset = function() {
		this.buffer = void 0;
	};
	module.exports = Decoder$1;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Decoder = require_Decoder();
	const decodeText = require_decodeText();
	const getLimit = require_getLimit();
	const RE_CHARSET = /^charset$/i;
	UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
	function UrlEncoded(boy, cfg) {
		const limits = cfg.limits;
		const parsedConType = cfg.parsedConType;
		this.boy = boy;
		this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
		this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
		this.fieldsLimit = getLimit(limits, "fields", Infinity);
		let charset;
		for (var i$2 = 0, len$1 = parsedConType.length; i$2 < len$1; ++i$2) if (Array.isArray(parsedConType[i$2]) && RE_CHARSET.test(parsedConType[i$2][0])) {
			charset = parsedConType[i$2][1].toLowerCase();
			break;
		}
		if (charset === void 0) charset = cfg.defCharset || "utf8";
		this.decoder = new Decoder();
		this.charset = charset;
		this._fields = 0;
		this._state = "key";
		this._checkingBytes = true;
		this._bytesKey = 0;
		this._bytesVal = 0;
		this._key = "";
		this._val = "";
		this._keyTrunc = false;
		this._valTrunc = false;
		this._hitLimit = false;
	}
	UrlEncoded.prototype.write = function(data, cb) {
		if (this._fields === this.fieldsLimit) {
			if (!this.boy.hitFieldsLimit) {
				this.boy.hitFieldsLimit = true;
				this.boy.emit("fieldsLimit");
			}
			return cb();
		}
		let idxeq;
		let idxamp;
		let i$2;
		let p = 0;
		const len$1 = data.length;
		while (p < len$1) if (this._state === "key") {
			idxeq = idxamp = void 0;
			for (i$2 = p; i$2 < len$1; ++i$2) {
				if (!this._checkingBytes) ++p;
				if (data[i$2] === 61) {
					idxeq = i$2;
					break;
				} else if (data[i$2] === 38) {
					idxamp = i$2;
					break;
				}
				if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesKey;
			}
			if (idxeq !== void 0) {
				if (idxeq > p) this._key += this.decoder.write(data.toString("binary", p, idxeq));
				this._state = "val";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._val = "";
				this._bytesVal = 0;
				this._valTrunc = false;
				this.decoder.reset();
				p = idxeq + 1;
			} else if (idxamp !== void 0) {
				++this._fields;
				let key;
				const keyTrunc = this._keyTrunc;
				if (idxamp > p) key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
				else key = this._key;
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				if (key.length) this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);
				p = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i$2 > p) this._key += this.decoder.write(data.toString("binary", p, i$2));
				p = i$2;
				if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
					this._checkingBytes = false;
					this._keyTrunc = true;
				}
			} else {
				if (p < len$1) this._key += this.decoder.write(data.toString("binary", p));
				p = len$1;
			}
		} else {
			idxamp = void 0;
			for (i$2 = p; i$2 < len$1; ++i$2) {
				if (!this._checkingBytes) ++p;
				if (data[i$2] === 38) {
					idxamp = i$2;
					break;
				}
				if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesVal;
			}
			if (idxamp !== void 0) {
				++this._fields;
				if (idxamp > p) this._val += this.decoder.write(data.toString("binary", p, idxamp));
				this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
				this._state = "key";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				p = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i$2 > p) this._val += this.decoder.write(data.toString("binary", p, i$2));
				p = i$2;
				if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
					this._checkingBytes = false;
					this._valTrunc = true;
				}
			} else {
				if (p < len$1) this._val += this.decoder.write(data.toString("binary", p));
				p = len$1;
			}
		}
		cb();
	};
	UrlEncoded.prototype.end = function() {
		if (this.boy._done) return;
		if (this._state === "key" && this._key.length > 0) this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);
		else if (this._state === "val") this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
		this.boy._done = true;
		this.boy.emit("finish");
	};
	module.exports = UrlEncoded;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/main.js
var require_main = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const WritableStream = require("node:stream").Writable;
	const { inherits } = require("node:util");
	const Dicer = require_Dicer();
	const MultipartParser$1 = require_multipart();
	const UrlencodedParser = require_urlencoded();
	const parseParams = require_parseParams();
	function Busboy$1(opts) {
		if (!(this instanceof Busboy$1)) return new Busboy$1(opts);
		if (typeof opts !== "object") throw new TypeError("Busboy expected an options-Object.");
		if (typeof opts.headers !== "object") throw new TypeError("Busboy expected an options-Object with headers-attribute.");
		if (typeof opts.headers["content-type"] !== "string") throw new TypeError("Missing Content-Type-header.");
		const { headers, ...streamOptions } = opts;
		this.opts = {
			autoDestroy: false,
			...streamOptions
		};
		WritableStream.call(this, this.opts);
		this._done = false;
		this._parser = this.getParserByHeaders(headers);
		this._finished = false;
	}
	inherits(Busboy$1, WritableStream);
	Busboy$1.prototype.emit = function(ev) {
		if (ev === "finish") {
			if (!this._done) {
				this._parser?.end();
				return;
			} else if (this._finished) return;
			this._finished = true;
		}
		WritableStream.prototype.emit.apply(this, arguments);
	};
	Busboy$1.prototype.getParserByHeaders = function(headers) {
		const parsed = parseParams(headers["content-type"]);
		const cfg = {
			defCharset: this.opts.defCharset,
			fileHwm: this.opts.fileHwm,
			headers,
			highWaterMark: this.opts.highWaterMark,
			isPartAFile: this.opts.isPartAFile,
			limits: this.opts.limits,
			parsedConType: parsed,
			preservePath: this.opts.preservePath
		};
		if (MultipartParser$1.detect.test(parsed[0])) return new MultipartParser$1(this, cfg);
		if (UrlencodedParser.detect.test(parsed[0])) return new UrlencodedParser(this, cfg);
		throw new Error("Unsupported Content-Type.");
	};
	Busboy$1.prototype._write = function(chunk, encoding, cb) {
		this._parser.write(chunk, cb);
	};
	module.exports = Busboy$1;
	module.exports.default = Busboy$1;
	module.exports.Busboy = Busboy$1;
	module.exports.Dicer = Dicer;
}));

//#endregion
//#region node_modules/undici/lib/fetch/constants.js
var require_constants$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { MessageChannel, receiveMessageOnPort } = require("worker_threads");
	const corsSafeListedMethods = [
		"GET",
		"HEAD",
		"POST"
	];
	const corsSafeListedMethodsSet$1 = new Set(corsSafeListedMethods);
	const nullBodyStatus$2 = [
		101,
		204,
		205,
		304
	];
	const redirectStatus$1 = [
		301,
		302,
		303,
		307,
		308
	];
	const redirectStatusSet$3 = new Set(redirectStatus$1);
	const badPorts = [
		"1",
		"7",
		"9",
		"11",
		"13",
		"15",
		"17",
		"19",
		"20",
		"21",
		"22",
		"23",
		"25",
		"37",
		"42",
		"43",
		"53",
		"69",
		"77",
		"79",
		"87",
		"95",
		"101",
		"102",
		"103",
		"104",
		"109",
		"110",
		"111",
		"113",
		"115",
		"117",
		"119",
		"123",
		"135",
		"137",
		"139",
		"143",
		"161",
		"179",
		"389",
		"427",
		"465",
		"512",
		"513",
		"514",
		"515",
		"526",
		"530",
		"531",
		"532",
		"540",
		"548",
		"554",
		"556",
		"563",
		"587",
		"601",
		"636",
		"989",
		"990",
		"993",
		"995",
		"1719",
		"1720",
		"1723",
		"2049",
		"3659",
		"4045",
		"5060",
		"5061",
		"6000",
		"6566",
		"6665",
		"6666",
		"6667",
		"6668",
		"6669",
		"6697",
		"10080"
	];
	const badPortsSet$1 = new Set(badPorts);
	const referrerPolicy$1 = [
		"",
		"no-referrer",
		"no-referrer-when-downgrade",
		"same-origin",
		"origin",
		"strict-origin",
		"origin-when-cross-origin",
		"strict-origin-when-cross-origin",
		"unsafe-url"
	];
	const referrerPolicySet = new Set(referrerPolicy$1);
	const requestRedirect$1 = [
		"follow",
		"manual",
		"error"
	];
	const safeMethods = [
		"GET",
		"HEAD",
		"OPTIONS",
		"TRACE"
	];
	const safeMethodsSet$1 = new Set(safeMethods);
	const requestMode$1 = [
		"navigate",
		"same-origin",
		"no-cors",
		"cors"
	];
	const requestCredentials$1 = [
		"omit",
		"same-origin",
		"include"
	];
	const requestCache$1 = [
		"default",
		"no-store",
		"reload",
		"no-cache",
		"force-cache",
		"only-if-cached"
	];
	const requestBodyHeader$1 = [
		"content-encoding",
		"content-language",
		"content-location",
		"content-type",
		"content-length"
	];
	const requestDuplex$1 = ["half"];
	const forbiddenMethods = [
		"CONNECT",
		"TRACE",
		"TRACK"
	];
	const forbiddenMethodsSet$1 = new Set(forbiddenMethods);
	const subresource = [
		"audio",
		"audioworklet",
		"font",
		"image",
		"manifest",
		"paintworklet",
		"script",
		"style",
		"track",
		"video",
		"xslt",
		""
	];
	const subresourceSet$1 = new Set(subresource);
	/** @type {globalThis['DOMException']} */
	const DOMException$7 = globalThis.DOMException ?? (() => {
		try {
			atob("~");
		} catch (err) {
			return Object.getPrototypeOf(err).constructor;
		}
	})();
	let channel;
	/** @type {globalThis['structuredClone']} */
	const structuredClone$2 = globalThis.structuredClone ?? function structuredClone$3(value, options = void 0) {
		if (arguments.length === 0) throw new TypeError("missing argument");
		if (!channel) channel = new MessageChannel();
		channel.port1.unref();
		channel.port2.unref();
		channel.port1.postMessage(value, options?.transfer);
		return receiveMessageOnPort(channel.port2).message;
	};
	module.exports = {
		DOMException: DOMException$7,
		structuredClone: structuredClone$2,
		subresource,
		forbiddenMethods,
		requestBodyHeader: requestBodyHeader$1,
		referrerPolicy: referrerPolicy$1,
		requestRedirect: requestRedirect$1,
		requestMode: requestMode$1,
		requestCredentials: requestCredentials$1,
		requestCache: requestCache$1,
		redirectStatus: redirectStatus$1,
		corsSafeListedMethods,
		nullBodyStatus: nullBodyStatus$2,
		safeMethods,
		badPorts,
		requestDuplex: requestDuplex$1,
		subresourceSet: subresourceSet$1,
		badPortsSet: badPortsSet$1,
		redirectStatusSet: redirectStatusSet$3,
		corsSafeListedMethodsSet: corsSafeListedMethodsSet$1,
		safeMethodsSet: safeMethodsSet$1,
		forbiddenMethodsSet: forbiddenMethodsSet$1,
		referrerPolicySet
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/global.js
var require_global$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const globalOrigin = Symbol.for("undici.globalOrigin.1");
	function getGlobalOrigin$4() {
		return globalThis[globalOrigin];
	}
	function setGlobalOrigin(newOrigin) {
		if (newOrigin === void 0) {
			Object.defineProperty(globalThis, globalOrigin, {
				value: void 0,
				writable: true,
				enumerable: false,
				configurable: false
			});
			return;
		}
		const parsedURL = new URL(newOrigin);
		if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
		Object.defineProperty(globalThis, globalOrigin, {
			value: parsedURL,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	module.exports = {
		getGlobalOrigin: getGlobalOrigin$4,
		setGlobalOrigin
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/util.js
var require_util$7 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { redirectStatusSet: redirectStatusSet$2, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants$4();
	const { getGlobalOrigin: getGlobalOrigin$3 } = require_global$1();
	const { performance: performance$1 } = require("perf_hooks");
	const { isBlobLike: isBlobLike$6, toUSVString: toUSVString$4, ReadableStreamFrom: ReadableStreamFrom$2 } = require_util$8();
	const assert$18 = require("assert");
	const { isUint8Array: isUint8Array$1 } = require("util/types");
	let supportedHashes = [];
	/** @type {import('crypto')|undefined} */
	let crypto$5;
	try {
		crypto$5 = require("crypto");
		const possibleRelevantHashes = [
			"sha256",
			"sha384",
			"sha512"
		];
		supportedHashes = crypto$5.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
	} catch {}
	function responseURL(response) {
		const urlList = response.urlList;
		const length = urlList.length;
		return length === 0 ? null : urlList[length - 1].toString();
	}
	function responseLocationURL$1(response, requestFragment) {
		if (!redirectStatusSet$2.has(response.status)) return null;
		let location = response.headersList.get("location");
		if (location !== null && isValidHeaderValue$1(location)) location = new URL(location, responseURL(response));
		if (location && !location.hash) location.hash = requestFragment;
		return location;
	}
	/** @returns {URL} */
	function requestCurrentURL$1(request$3) {
		return request$3.urlList[request$3.urlList.length - 1];
	}
	function requestBadPort$1(request$3) {
		const url = requestCurrentURL$1(request$3);
		if (urlIsHttpHttpsScheme$2(url) && badPortsSet.has(url.port)) return "blocked";
		return "allowed";
	}
	function isErrorLike$2(object) {
		return object instanceof Error || object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException";
	}
	function isValidReasonPhrase$1(statusText) {
		for (let i$2 = 0; i$2 < statusText.length; ++i$2) {
			const c = statusText.charCodeAt(i$2);
			if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) return false;
		}
		return true;
	}
	/**
	* @see https://tools.ietf.org/html/rfc7230#section-3.2.6
	* @param {number} c
	*/
	function isTokenCharCode(c) {
		switch (c) {
			case 34:
			case 40:
			case 41:
			case 44:
			case 47:
			case 58:
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 91:
			case 92:
			case 93:
			case 123:
			case 125: return false;
			default: return c >= 33 && c <= 126;
		}
	}
	/**
	* @param {string} characters
	*/
	function isValidHTTPToken$1(characters) {
		if (characters.length === 0) return false;
		for (let i$2 = 0; i$2 < characters.length; ++i$2) if (!isTokenCharCode(characters.charCodeAt(i$2))) return false;
		return true;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-name
	* @param {string} potentialValue
	*/
	function isValidHeaderName$2(potentialValue) {
		return isValidHTTPToken$1(potentialValue);
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-value
	* @param {string} potentialValue
	*/
	function isValidHeaderValue$1(potentialValue) {
		if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) return false;
		if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) return false;
		return true;
	}
	function setRequestReferrerPolicyOnRedirect$1(request$3, actualResponse) {
		const { headersList } = actualResponse;
		const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
		let policy = "";
		if (policyHeader.length > 0) for (let i$2 = policyHeader.length; i$2 !== 0; i$2--) {
			const token = policyHeader[i$2 - 1].trim();
			if (referrerPolicyTokens.has(token)) {
				policy = token;
				break;
			}
		}
		if (policy !== "") request$3.referrerPolicy = policy;
	}
	function crossOriginResourcePolicyCheck$1() {
		return "allowed";
	}
	function corsCheck$1() {
		return "success";
	}
	function TAOCheck$1() {
		return "success";
	}
	function appendFetchMetadata$1(httpRequest) {
		let header = null;
		header = httpRequest.mode;
		httpRequest.headersList.set("sec-fetch-mode", header);
	}
	function appendRequestOriginHeader$1(request$3) {
		let serializedOrigin = request$3.origin;
		if (request$3.responseTainting === "cors" || request$3.mode === "websocket") {
			if (serializedOrigin) request$3.headersList.append("origin", serializedOrigin);
		} else if (request$3.method !== "GET" && request$3.method !== "HEAD") {
			switch (request$3.referrerPolicy) {
				case "no-referrer":
					serializedOrigin = null;
					break;
				case "no-referrer-when-downgrade":
				case "strict-origin":
				case "strict-origin-when-cross-origin":
					if (request$3.origin && urlHasHttpsScheme$1(request$3.origin) && !urlHasHttpsScheme$1(requestCurrentURL$1(request$3))) serializedOrigin = null;
					break;
				case "same-origin":
					if (!sameOrigin$2(request$3, requestCurrentURL$1(request$3))) serializedOrigin = null;
					break;
				default:
			}
			if (serializedOrigin) request$3.headersList.append("origin", serializedOrigin);
		}
	}
	function coarsenedSharedCurrentTime$1(crossOriginIsolatedCapability) {
		return performance$1.now();
	}
	function createOpaqueTimingInfo$1(timingInfo) {
		return {
			startTime: timingInfo.startTime ?? 0,
			redirectStartTime: 0,
			redirectEndTime: 0,
			postRedirectStartTime: timingInfo.startTime ?? 0,
			finalServiceWorkerStartTime: 0,
			finalNetworkResponseStartTime: 0,
			finalNetworkRequestStartTime: 0,
			endTime: 0,
			encodedBodySize: 0,
			decodedBodySize: 0,
			finalConnectionTimingInfo: null
		};
	}
	function makePolicyContainer$2() {
		return { referrerPolicy: "strict-origin-when-cross-origin" };
	}
	function clonePolicyContainer$1(policyContainer) {
		return { referrerPolicy: policyContainer.referrerPolicy };
	}
	function determineRequestsReferrer$2(request$3) {
		const policy = request$3.referrerPolicy;
		assert$18(policy);
		let referrerSource = null;
		if (request$3.referrer === "client") {
			const globalOrigin$1 = getGlobalOrigin$3();
			if (!globalOrigin$1 || globalOrigin$1.origin === "null") return "no-referrer";
			referrerSource = new URL(globalOrigin$1);
		} else if (request$3.referrer instanceof URL) referrerSource = request$3.referrer;
		let referrerURL = stripURLForReferrer(referrerSource);
		const referrerOrigin = stripURLForReferrer(referrerSource, true);
		if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
		const areSameOrigin = sameOrigin$2(request$3, referrerURL);
		const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request$3.url);
		switch (policy) {
			case "origin": return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
			case "unsafe-url": return referrerURL;
			case "same-origin": return areSameOrigin ? referrerOrigin : "no-referrer";
			case "origin-when-cross-origin": return areSameOrigin ? referrerURL : referrerOrigin;
			case "strict-origin-when-cross-origin": {
				const currentURL = requestCurrentURL$1(request$3);
				if (sameOrigin$2(referrerURL, currentURL)) return referrerURL;
				if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) return "no-referrer";
				return referrerOrigin;
			}
			case "strict-origin":
			case "no-referrer-when-downgrade":
			default: return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
	* @param {URL} url
	* @param {boolean|undefined} originOnly
	*/
	function stripURLForReferrer(url, originOnly) {
		assert$18(url instanceof URL);
		if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") return "no-referrer";
		url.username = "";
		url.password = "";
		url.hash = "";
		if (originOnly) {
			url.pathname = "";
			url.search = "";
		}
		return url;
	}
	function isURLPotentiallyTrustworthy(url) {
		if (!(url instanceof URL)) return false;
		if (url.href === "about:blank" || url.href === "about:srcdoc") return true;
		if (url.protocol === "data:") return true;
		if (url.protocol === "file:") return true;
		return isOriginPotentiallyTrustworthy$1(url.origin);
		function isOriginPotentiallyTrustworthy$1(origin) {
			if (origin == null || origin === "null") return false;
			const originAsURL = new URL(origin);
			if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") return true;
			if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.") || originAsURL.hostname.endsWith(".localhost")) return true;
			return false;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
	* @param {Uint8Array} bytes
	* @param {string} metadataList
	*/
	function bytesMatch$1(bytes, metadataList) {
		/* istanbul ignore if: only if node is built with --without-ssl */
		if (crypto$5 === void 0) return true;
		const parsedMetadata = parseMetadata(metadataList);
		if (parsedMetadata === "no metadata") return true;
		if (parsedMetadata.length === 0) return true;
		const metadata = filterMetadataListByAlgorithm(parsedMetadata, getStrongestMetadata(parsedMetadata));
		for (const item of metadata) {
			const algorithm = item.algo;
			const expectedValue = item.hash;
			let actualValue = crypto$5.createHash(algorithm).update(bytes).digest("base64");
			if (actualValue[actualValue.length - 1] === "=") if (actualValue[actualValue.length - 2] === "=") actualValue = actualValue.slice(0, -2);
			else actualValue = actualValue.slice(0, -1);
			if (compareBase64Mixed(actualValue, expectedValue)) return true;
		}
		return false;
	}
	const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
	* @param {string} metadata
	*/
	function parseMetadata(metadata) {
		/** @type {{ algo: string, hash: string }[]} */
		const result = [];
		let empty = true;
		for (const token of metadata.split(" ")) {
			empty = false;
			const parsedToken = parseHashWithOptions.exec(token);
			if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) continue;
			const algorithm = parsedToken.groups.algo.toLowerCase();
			if (supportedHashes.includes(algorithm)) result.push(parsedToken.groups);
		}
		if (empty === true) return "no metadata";
		return result;
	}
	/**
	* @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
	*/
	function getStrongestMetadata(metadataList) {
		let algorithm = metadataList[0].algo;
		if (algorithm[3] === "5") return algorithm;
		for (let i$2 = 1; i$2 < metadataList.length; ++i$2) {
			const metadata = metadataList[i$2];
			if (metadata.algo[3] === "5") {
				algorithm = "sha512";
				break;
			} else if (algorithm[3] === "3") continue;
			else if (metadata.algo[3] === "3") algorithm = "sha384";
		}
		return algorithm;
	}
	function filterMetadataListByAlgorithm(metadataList, algorithm) {
		if (metadataList.length === 1) return metadataList;
		let pos = 0;
		for (let i$2 = 0; i$2 < metadataList.length; ++i$2) if (metadataList[i$2].algo === algorithm) metadataList[pos++] = metadataList[i$2];
		metadataList.length = pos;
		return metadataList;
	}
	/**
	* Compares two base64 strings, allowing for base64url
	* in the second string.
	*
	* @param {string} actualValue always base64
	* @param {string} expectedValue base64 or base64url
	* @returns {boolean}
	*/
	function compareBase64Mixed(actualValue, expectedValue) {
		if (actualValue.length !== expectedValue.length) return false;
		for (let i$2 = 0; i$2 < actualValue.length; ++i$2) if (actualValue[i$2] !== expectedValue[i$2]) {
			if (actualValue[i$2] === "+" && expectedValue[i$2] === "-" || actualValue[i$2] === "/" && expectedValue[i$2] === "_") continue;
			return false;
		}
		return true;
	}
	function tryUpgradeRequestToAPotentiallyTrustworthyURL$1(request$3) {}
	/**
	* @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
	* @param {URL} A
	* @param {URL} B
	*/
	function sameOrigin$2(A$1, B) {
		if (A$1.origin === B.origin && A$1.origin === "null") return true;
		if (A$1.protocol === B.protocol && A$1.hostname === B.hostname && A$1.port === B.port) return true;
		return false;
	}
	function createDeferredPromise$3() {
		let res;
		let rej;
		return {
			promise: new Promise((resolve, reject) => {
				res = resolve;
				rej = reject;
			}),
			resolve: res,
			reject: rej
		};
	}
	function isAborted$2(fetchParams) {
		return fetchParams.controller.state === "aborted";
	}
	function isCancelled$2(fetchParams) {
		return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
	}
	const normalizeMethodRecord$1 = {
		delete: "DELETE",
		DELETE: "DELETE",
		get: "GET",
		GET: "GET",
		head: "HEAD",
		HEAD: "HEAD",
		options: "OPTIONS",
		OPTIONS: "OPTIONS",
		post: "POST",
		POST: "POST",
		put: "PUT",
		PUT: "PUT"
	};
	Object.setPrototypeOf(normalizeMethodRecord$1, null);
	/**
	* @see https://fetch.spec.whatwg.org/#concept-method-normalize
	* @param {string} method
	*/
	function normalizeMethod$1(method) {
		return normalizeMethodRecord$1[method.toLowerCase()] ?? method;
	}
	function serializeJavascriptValueToJSONString$1(value) {
		const result = JSON.stringify(value);
		if (result === void 0) throw new TypeError("Value is not JSON serializable");
		assert$18(typeof result === "string");
		return result;
	}
	const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
	/**
	* @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
	* @param {() => unknown[]} iterator
	* @param {string} name name of the instance
	* @param {'key'|'value'|'key+value'} kind
	*/
	function makeIterator$2(iterator$1, name, kind) {
		const object = {
			index: 0,
			kind,
			target: iterator$1
		};
		const i$2 = {
			next() {
				if (Object.getPrototypeOf(this) !== i$2) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
				const { index, kind: kind$1, target } = object;
				const values = target();
				if (index >= values.length) return {
					value: void 0,
					done: true
				};
				const pair = values[index];
				object.index = index + 1;
				return iteratorResult(pair, kind$1);
			},
			[Symbol.toStringTag]: `${name} Iterator`
		};
		Object.setPrototypeOf(i$2, esIteratorPrototype);
		return Object.setPrototypeOf({}, i$2);
	}
	function iteratorResult(pair, kind) {
		let result;
		switch (kind) {
			case "key":
				result = pair[0];
				break;
			case "value":
				result = pair[1];
				break;
			case "key+value":
				result = pair;
				break;
		}
		return {
			value: result,
			done: false
		};
	}
	/**
	* @see https://fetch.spec.whatwg.org/#body-fully-read
	*/
	async function fullyReadBody$2(body, processBody, processBodyError) {
		const successSteps = processBody;
		const errorSteps = processBodyError;
		let reader;
		try {
			reader = body.stream.getReader();
		} catch (e$1) {
			errorSteps(e$1);
			return;
		}
		try {
			successSteps(await readAllBytes$1(reader));
		} catch (e$1) {
			errorSteps(e$1);
		}
	}
	/** @type {ReadableStream} */
	let ReadableStream$4 = globalThis.ReadableStream;
	function isReadableStreamLike$1(stream$6) {
		if (!ReadableStream$4) ReadableStream$4 = require("stream/web").ReadableStream;
		return stream$6 instanceof ReadableStream$4 || stream$6[Symbol.toStringTag] === "ReadableStream" && typeof stream$6.tee === "function";
	}
	const MAXIMUM_ARGUMENT_LENGTH = 65535;
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-decode
	* @param {number[]|Uint8Array} input
	*/
	function isomorphicDecode$1(input) {
		if (input.length < MAXIMUM_ARGUMENT_LENGTH) return String.fromCharCode(...input);
		return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
	}
	/**
	* @param {ReadableStreamController<Uint8Array>} controller
	*/
	function readableStreamClose$2(controller) {
		try {
			controller.close();
		} catch (err) {
			if (!err.message.includes("Controller is already closed")) throw err;
		}
	}
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-encode
	* @param {string} input
	*/
	function isomorphicEncode$2(input) {
		for (let i$2 = 0; i$2 < input.length; i$2++) assert$18(input.charCodeAt(i$2) <= 255);
		return input;
	}
	/**
	* @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
	* @see https://streams.spec.whatwg.org/#read-loop
	* @param {ReadableStreamDefaultReader} reader
	*/
	async function readAllBytes$1(reader) {
		const bytes = [];
		let byteLength$1 = 0;
		while (true) {
			const { done, value: chunk } = await reader.read();
			if (done) return Buffer.concat(bytes, byteLength$1);
			if (!isUint8Array$1(chunk)) throw new TypeError("Received non-Uint8Array chunk");
			bytes.push(chunk);
			byteLength$1 += chunk.length;
		}
	}
	/**
	* @see https://fetch.spec.whatwg.org/#is-local
	* @param {URL} url
	*/
	function urlIsLocal$1(url) {
		assert$18("protocol" in url);
		const protocol = url.protocol;
		return protocol === "about:" || protocol === "blob:" || protocol === "data:";
	}
	/**
	* @param {string|URL} url
	*/
	function urlHasHttpsScheme$1(url) {
		if (typeof url === "string") return url.startsWith("https:");
		return url.protocol === "https:";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-scheme
	* @param {URL} url
	*/
	function urlIsHttpHttpsScheme$2(url) {
		assert$18("protocol" in url);
		const protocol = url.protocol;
		return protocol === "http:" || protocol === "https:";
	}
	/**
	* Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
	*/
	const hasOwn$2 = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
	module.exports = {
		isAborted: isAborted$2,
		isCancelled: isCancelled$2,
		createDeferredPromise: createDeferredPromise$3,
		ReadableStreamFrom: ReadableStreamFrom$2,
		toUSVString: toUSVString$4,
		tryUpgradeRequestToAPotentiallyTrustworthyURL: tryUpgradeRequestToAPotentiallyTrustworthyURL$1,
		coarsenedSharedCurrentTime: coarsenedSharedCurrentTime$1,
		determineRequestsReferrer: determineRequestsReferrer$2,
		makePolicyContainer: makePolicyContainer$2,
		clonePolicyContainer: clonePolicyContainer$1,
		appendFetchMetadata: appendFetchMetadata$1,
		appendRequestOriginHeader: appendRequestOriginHeader$1,
		TAOCheck: TAOCheck$1,
		corsCheck: corsCheck$1,
		crossOriginResourcePolicyCheck: crossOriginResourcePolicyCheck$1,
		createOpaqueTimingInfo: createOpaqueTimingInfo$1,
		setRequestReferrerPolicyOnRedirect: setRequestReferrerPolicyOnRedirect$1,
		isValidHTTPToken: isValidHTTPToken$1,
		requestBadPort: requestBadPort$1,
		requestCurrentURL: requestCurrentURL$1,
		responseURL,
		responseLocationURL: responseLocationURL$1,
		isBlobLike: isBlobLike$6,
		isURLPotentiallyTrustworthy,
		isValidReasonPhrase: isValidReasonPhrase$1,
		sameOrigin: sameOrigin$2,
		normalizeMethod: normalizeMethod$1,
		serializeJavascriptValueToJSONString: serializeJavascriptValueToJSONString$1,
		makeIterator: makeIterator$2,
		isValidHeaderName: isValidHeaderName$2,
		isValidHeaderValue: isValidHeaderValue$1,
		hasOwn: hasOwn$2,
		isErrorLike: isErrorLike$2,
		fullyReadBody: fullyReadBody$2,
		bytesMatch: bytesMatch$1,
		isReadableStreamLike: isReadableStreamLike$1,
		readableStreamClose: readableStreamClose$2,
		isomorphicEncode: isomorphicEncode$2,
		isomorphicDecode: isomorphicDecode$1,
		urlIsLocal: urlIsLocal$1,
		urlHasHttpsScheme: urlHasHttpsScheme$1,
		urlIsHttpHttpsScheme: urlIsHttpHttpsScheme$2,
		readAllBytes: readAllBytes$1,
		normalizeMethodRecord: normalizeMethodRecord$1,
		parseMetadata
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/symbols.js
var require_symbols$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kUrl: Symbol("url"),
		kHeaders: Symbol("headers"),
		kSignal: Symbol("signal"),
		kState: Symbol("state"),
		kGuard: Symbol("guard"),
		kRealm: Symbol("realm")
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/webidl.js
var require_webidl = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { types: types$6 } = require("util");
	const { hasOwn: hasOwn$1, toUSVString: toUSVString$3 } = require_util$7();
	/** @type {import('../../types/webidl').Webidl} */
	const webidl$14 = {};
	webidl$14.converters = {};
	webidl$14.util = {};
	webidl$14.errors = {};
	webidl$14.errors.exception = function(message) {
		return /* @__PURE__ */ new TypeError(`${message.header}: ${message.message}`);
	};
	webidl$14.errors.conversionFailed = function(context) {
		const plural$1 = context.types.length === 1 ? "" : " one of";
		const message = `${context.argument} could not be converted to${plural$1}: ${context.types.join(", ")}.`;
		return webidl$14.errors.exception({
			header: context.prefix,
			message
		});
	};
	webidl$14.errors.invalidArgument = function(context) {
		return webidl$14.errors.exception({
			header: context.prefix,
			message: `"${context.value}" is an invalid ${context.type}.`
		});
	};
	webidl$14.brandCheck = function(V, I, opts = void 0) {
		if (opts?.strict !== false && !(V instanceof I)) throw new TypeError("Illegal invocation");
		else return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
	};
	webidl$14.argumentLengthCheck = function({ length }, min, ctx) {
		if (length < min) throw webidl$14.errors.exception({
			message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
			...ctx
		});
	};
	webidl$14.illegalConstructor = function() {
		throw webidl$14.errors.exception({
			header: "TypeError",
			message: "Illegal constructor"
		});
	};
	webidl$14.util.Type = function(V) {
		switch (typeof V) {
			case "undefined": return "Undefined";
			case "boolean": return "Boolean";
			case "string": return "String";
			case "symbol": return "Symbol";
			case "number": return "Number";
			case "bigint": return "BigInt";
			case "function":
			case "object":
				if (V === null) return "Null";
				return "Object";
		}
	};
	webidl$14.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
		let upperBound;
		let lowerBound;
		if (bitLength === 64) {
			upperBound = Math.pow(2, 53) - 1;
			if (signedness === "unsigned") lowerBound = 0;
			else lowerBound = Math.pow(-2, 53) + 1;
		} else if (signedness === "unsigned") {
			lowerBound = 0;
			upperBound = Math.pow(2, bitLength) - 1;
		} else {
			lowerBound = Math.pow(-2, bitLength) - 1;
			upperBound = Math.pow(2, bitLength - 1) - 1;
		}
		let x$1 = Number(V);
		if (x$1 === 0) x$1 = 0;
		if (opts.enforceRange === true) {
			if (Number.isNaN(x$1) || x$1 === Number.POSITIVE_INFINITY || x$1 === Number.NEGATIVE_INFINITY) throw webidl$14.errors.exception({
				header: "Integer conversion",
				message: `Could not convert ${V} to an integer.`
			});
			x$1 = webidl$14.util.IntegerPart(x$1);
			if (x$1 < lowerBound || x$1 > upperBound) throw webidl$14.errors.exception({
				header: "Integer conversion",
				message: `Value must be between ${lowerBound}-${upperBound}, got ${x$1}.`
			});
			return x$1;
		}
		if (!Number.isNaN(x$1) && opts.clamp === true) {
			x$1 = Math.min(Math.max(x$1, lowerBound), upperBound);
			if (Math.floor(x$1) % 2 === 0) x$1 = Math.floor(x$1);
			else x$1 = Math.ceil(x$1);
			return x$1;
		}
		if (Number.isNaN(x$1) || x$1 === 0 && Object.is(0, x$1) || x$1 === Number.POSITIVE_INFINITY || x$1 === Number.NEGATIVE_INFINITY) return 0;
		x$1 = webidl$14.util.IntegerPart(x$1);
		x$1 = x$1 % Math.pow(2, bitLength);
		if (signedness === "signed" && x$1 >= Math.pow(2, bitLength) - 1) return x$1 - Math.pow(2, bitLength);
		return x$1;
	};
	webidl$14.util.IntegerPart = function(n) {
		const r$1 = Math.floor(Math.abs(n));
		if (n < 0) return -1 * r$1;
		return r$1;
	};
	webidl$14.sequenceConverter = function(converter) {
		return (V) => {
			if (webidl$14.util.Type(V) !== "Object") throw webidl$14.errors.exception({
				header: "Sequence",
				message: `Value of type ${webidl$14.util.Type(V)} is not an Object.`
			});
			/** @type {Generator} */
			const method = V?.[Symbol.iterator]?.();
			const seq = [];
			if (method === void 0 || typeof method.next !== "function") throw webidl$14.errors.exception({
				header: "Sequence",
				message: "Object is not an iterator."
			});
			while (true) {
				const { done, value } = method.next();
				if (done) break;
				seq.push(converter(value));
			}
			return seq;
		};
	};
	webidl$14.recordConverter = function(keyConverter, valueConverter) {
		return (O) => {
			if (webidl$14.util.Type(O) !== "Object") throw webidl$14.errors.exception({
				header: "Record",
				message: `Value of type ${webidl$14.util.Type(O)} is not an Object.`
			});
			const result = {};
			if (!types$6.isProxy(O)) {
				const keys$1 = Object.keys(O);
				for (const key of keys$1) {
					const typedKey = keyConverter(key);
					result[typedKey] = valueConverter(O[key]);
				}
				return result;
			}
			const keys = Reflect.ownKeys(O);
			for (const key of keys) if (Reflect.getOwnPropertyDescriptor(O, key)?.enumerable) {
				const typedKey = keyConverter(key);
				result[typedKey] = valueConverter(O[key]);
			}
			return result;
		};
	};
	webidl$14.interfaceConverter = function(i$2) {
		return (V, opts = {}) => {
			if (opts.strict !== false && !(V instanceof i$2)) throw webidl$14.errors.exception({
				header: i$2.name,
				message: `Expected ${V} to be an instance of ${i$2.name}.`
			});
			return V;
		};
	};
	webidl$14.dictionaryConverter = function(converters) {
		return (dictionary) => {
			const type = webidl$14.util.Type(dictionary);
			const dict = {};
			if (type === "Null" || type === "Undefined") return dict;
			else if (type !== "Object") throw webidl$14.errors.exception({
				header: "Dictionary",
				message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
			});
			for (const options of converters) {
				const { key, defaultValue, required, converter } = options;
				if (required === true) {
					if (!hasOwn$1(dictionary, key)) throw webidl$14.errors.exception({
						header: "Dictionary",
						message: `Missing required key "${key}".`
					});
				}
				let value = dictionary[key];
				const hasDefault = hasOwn$1(options, "defaultValue");
				if (hasDefault && value !== null) value = value ?? defaultValue;
				if (required || hasDefault || value !== void 0) {
					value = converter(value);
					if (options.allowedValues && !options.allowedValues.includes(value)) throw webidl$14.errors.exception({
						header: "Dictionary",
						message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
					});
					dict[key] = value;
				}
			}
			return dict;
		};
	};
	webidl$14.nullableConverter = function(converter) {
		return (V) => {
			if (V === null) return V;
			return converter(V);
		};
	};
	webidl$14.converters.DOMString = function(V, opts = {}) {
		if (V === null && opts.legacyNullToEmptyString) return "";
		if (typeof V === "symbol") throw new TypeError("Could not convert argument of type symbol to string.");
		return String(V);
	};
	webidl$14.converters.ByteString = function(V) {
		const x$1 = webidl$14.converters.DOMString(V);
		for (let index = 0; index < x$1.length; index++) if (x$1.charCodeAt(index) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x$1.charCodeAt(index)} which is greater than 255.`);
		return x$1;
	};
	webidl$14.converters.USVString = toUSVString$3;
	webidl$14.converters.boolean = function(V) {
		return Boolean(V);
	};
	webidl$14.converters.any = function(V) {
		return V;
	};
	webidl$14.converters["long long"] = function(V) {
		return webidl$14.util.ConvertToInt(V, 64, "signed");
	};
	webidl$14.converters["unsigned long long"] = function(V) {
		return webidl$14.util.ConvertToInt(V, 64, "unsigned");
	};
	webidl$14.converters["unsigned long"] = function(V) {
		return webidl$14.util.ConvertToInt(V, 32, "unsigned");
	};
	webidl$14.converters["unsigned short"] = function(V, opts) {
		return webidl$14.util.ConvertToInt(V, 16, "unsigned", opts);
	};
	webidl$14.converters.ArrayBuffer = function(V, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$6.isAnyArrayBuffer(V)) throw webidl$14.errors.conversionFailed({
			prefix: `${V}`,
			argument: `${V}`,
			types: ["ArrayBuffer"]
		});
		if (opts.allowShared === false && types$6.isSharedArrayBuffer(V)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.TypedArray = function(V, T, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$6.isTypedArray(V) || V.constructor.name !== T.name) throw webidl$14.errors.conversionFailed({
			prefix: `${T.name}`,
			argument: `${V}`,
			types: [T.name]
		});
		if (opts.allowShared === false && types$6.isSharedArrayBuffer(V.buffer)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.DataView = function(V, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$6.isDataView(V)) throw webidl$14.errors.exception({
			header: "DataView",
			message: "Object is not a DataView."
		});
		if (opts.allowShared === false && types$6.isSharedArrayBuffer(V.buffer)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.BufferSource = function(V, opts = {}) {
		if (types$6.isAnyArrayBuffer(V)) return webidl$14.converters.ArrayBuffer(V, opts);
		if (types$6.isTypedArray(V)) return webidl$14.converters.TypedArray(V, V.constructor);
		if (types$6.isDataView(V)) return webidl$14.converters.DataView(V, opts);
		throw new TypeError(`Could not convert ${V} to a BufferSource.`);
	};
	webidl$14.converters["sequence<ByteString>"] = webidl$14.sequenceConverter(webidl$14.converters.ByteString);
	webidl$14.converters["sequence<sequence<ByteString>>"] = webidl$14.sequenceConverter(webidl$14.converters["sequence<ByteString>"]);
	webidl$14.converters["record<ByteString, ByteString>"] = webidl$14.recordConverter(webidl$14.converters.ByteString, webidl$14.converters.ByteString);
	module.exports = { webidl: webidl$14 };
}));

//#endregion
//#region node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$17 = require("assert");
	const { atob: atob$1 } = require("buffer");
	const { isomorphicDecode } = require_util$7();
	const encoder$1 = new TextEncoder();
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-token-code-point
	*/
	const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
	const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
	*/
	const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
	/** @param {URL} dataURL */
	function dataURLProcessor$1(dataURL) {
		assert$17(dataURL.protocol === "data:");
		let input = URLSerializer$4(dataURL, true);
		input = input.slice(5);
		const position = { position: 0 };
		let mimeType = collectASequenceOfCodePointsFast$1(",", input, position);
		const mimeTypeLength = mimeType.length;
		mimeType = removeASCIIWhitespace(mimeType, true, true);
		if (position.position >= input.length) return "failure";
		position.position++;
		let body = stringPercentDecode(input.slice(mimeTypeLength + 1));
		if (/;(\u0020){0,}base64$/i.test(mimeType)) {
			body = forgivingBase64(isomorphicDecode(body));
			if (body === "failure") return "failure";
			mimeType = mimeType.slice(0, -6);
			mimeType = mimeType.replace(/(\u0020)+$/, "");
			mimeType = mimeType.slice(0, -1);
		}
		if (mimeType.startsWith(";")) mimeType = "text/plain" + mimeType;
		let mimeTypeRecord = parseMIMEType$3(mimeType);
		if (mimeTypeRecord === "failure") mimeTypeRecord = parseMIMEType$3("text/plain;charset=US-ASCII");
		return {
			mimeType: mimeTypeRecord,
			body
		};
	}
	/**
	* @param {URL} url
	* @param {boolean} excludeFragment
	*/
	function URLSerializer$4(url, excludeFragment = false) {
		if (!excludeFragment) return url.href;
		const href = url.href;
		const hashLength = url.hash.length;
		return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
	}
	/**
	* @param {(char: string) => boolean} condition
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePoints(condition, input, position) {
		let result = "";
		while (position.position < input.length && condition(input[position.position])) {
			result += input[position.position];
			position.position++;
		}
		return result;
	}
	/**
	* A faster collectASequenceOfCodePoints that only works when comparing a single character.
	* @param {string} char
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePointsFast$1(char, input, position) {
		const idx = input.indexOf(char, position.position);
		const start = position.position;
		if (idx === -1) {
			position.position = input.length;
			return input.slice(start);
		}
		position.position = idx;
		return input.slice(start, position.position);
	}
	/** @param {string} input */
	function stringPercentDecode(input) {
		return percentDecode(encoder$1.encode(input));
	}
	/** @param {Uint8Array} input */
	function percentDecode(input) {
		/** @type {number[]} */
		const output = [];
		for (let i$2 = 0; i$2 < input.length; i$2++) {
			const byte = input[i$2];
			if (byte !== 37) output.push(byte);
			else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i$2 + 1], input[i$2 + 2]))) output.push(37);
			else {
				const nextTwoBytes = String.fromCharCode(input[i$2 + 1], input[i$2 + 2]);
				const bytePoint = Number.parseInt(nextTwoBytes, 16);
				output.push(bytePoint);
				i$2 += 2;
			}
		}
		return Uint8Array.from(output);
	}
	/** @param {string} input */
	function parseMIMEType$3(input) {
		input = removeHTTPWhitespace(input, true, true);
		const position = { position: 0 };
		const type = collectASequenceOfCodePointsFast$1("/", input, position);
		if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) return "failure";
		if (position.position > input.length) return "failure";
		position.position++;
		let subtype = collectASequenceOfCodePointsFast$1(";", input, position);
		subtype = removeHTTPWhitespace(subtype, false, true);
		if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) return "failure";
		const typeLowercase = type.toLowerCase();
		const subtypeLowercase = subtype.toLowerCase();
		const mimeType = {
			type: typeLowercase,
			subtype: subtypeLowercase,
			parameters: /* @__PURE__ */ new Map(),
			essence: `${typeLowercase}/${subtypeLowercase}`
		};
		while (position.position < input.length) {
			position.position++;
			collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
			let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
			parameterName = parameterName.toLowerCase();
			if (position.position < input.length) {
				if (input[position.position] === ";") continue;
				position.position++;
			}
			if (position.position > input.length) break;
			let parameterValue = null;
			if (input[position.position] === "\"") {
				parameterValue = collectAnHTTPQuotedString(input, position, true);
				collectASequenceOfCodePointsFast$1(";", input, position);
			} else {
				parameterValue = collectASequenceOfCodePointsFast$1(";", input, position);
				parameterValue = removeHTTPWhitespace(parameterValue, false, true);
				if (parameterValue.length === 0) continue;
			}
			if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) mimeType.parameters.set(parameterName, parameterValue);
		}
		return mimeType;
	}
	/** @param {string} data */
	function forgivingBase64(data) {
		data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
		if (data.length % 4 === 0) data = data.replace(/=?=$/, "");
		if (data.length % 4 === 1) return "failure";
		if (/[^+/0-9A-Za-z]/.test(data)) return "failure";
		const binary = atob$1(data);
		const bytes = new Uint8Array(binary.length);
		for (let byte = 0; byte < binary.length; byte++) bytes[byte] = binary.charCodeAt(byte);
		return bytes;
	}
	/**
	* @param {string} input
	* @param {{ position: number }} position
	* @param {boolean?} extractValue
	*/
	function collectAnHTTPQuotedString(input, position, extractValue) {
		const positionStart = position.position;
		let value = "";
		assert$17(input[position.position] === "\"");
		position.position++;
		while (true) {
			value += collectASequenceOfCodePoints((char) => char !== "\"" && char !== "\\", input, position);
			if (position.position >= input.length) break;
			const quoteOrBackslash = input[position.position];
			position.position++;
			if (quoteOrBackslash === "\\") {
				if (position.position >= input.length) {
					value += "\\";
					break;
				}
				value += input[position.position];
				position.position++;
			} else {
				assert$17(quoteOrBackslash === "\"");
				break;
			}
		}
		if (extractValue) return value;
		return input.slice(positionStart, position.position);
	}
	/**
	* @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
	*/
	function serializeAMimeType$4(mimeType) {
		assert$17(mimeType !== "failure");
		const { parameters, essence } = mimeType;
		let serialization = essence;
		for (let [name, value] of parameters.entries()) {
			serialization += ";";
			serialization += name;
			serialization += "=";
			if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
				value = value.replace(/(\\|")/g, "\\$1");
				value = "\"" + value;
				value += "\"";
			}
			serialization += value;
		}
		return serialization;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {string} char
	*/
	function isHTTPWhiteSpace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === " ";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {string} str
	*/
	function removeHTTPWhitespace(str, leading = true, trailing = true) {
		let lead = 0;
		let trail = str.length - 1;
		if (leading) for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
		if (trailing) for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
		return str.slice(lead, trail + 1);
	}
	/**
	* @see https://infra.spec.whatwg.org/#ascii-whitespace
	* @param {string} char
	*/
	function isASCIIWhitespace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
	}
	/**
	* @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
	*/
	function removeASCIIWhitespace(str, leading = true, trailing = true) {
		let lead = 0;
		let trail = str.length - 1;
		if (leading) for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
		if (trailing) for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
		return str.slice(lead, trail + 1);
	}
	module.exports = {
		dataURLProcessor: dataURLProcessor$1,
		URLSerializer: URLSerializer$4,
		collectASequenceOfCodePoints,
		collectASequenceOfCodePointsFast: collectASequenceOfCodePointsFast$1,
		stringPercentDecode,
		parseMIMEType: parseMIMEType$3,
		collectAnHTTPQuotedString,
		serializeAMimeType: serializeAMimeType$4
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/file.js
var require_file = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Blob: Blob$5, File: NativeFile$2 } = require("buffer");
	const { types: types$5 } = require("util");
	const { kState: kState$9 } = require_symbols$3();
	const { isBlobLike: isBlobLike$5 } = require_util$7();
	const { webidl: webidl$13 } = require_webidl();
	const { parseMIMEType: parseMIMEType$2, serializeAMimeType: serializeAMimeType$3 } = require_dataURL();
	const { kEnumerableProperty: kEnumerableProperty$8 } = require_util$8();
	const encoder = new TextEncoder();
	var File$4 = class File$4 extends Blob$5 {
		constructor(fileBits, fileName, options = {}) {
			webidl$13.argumentLengthCheck(arguments, 2, { header: "File constructor" });
			fileBits = webidl$13.converters["sequence<BlobPart>"](fileBits);
			fileName = webidl$13.converters.USVString(fileName);
			options = webidl$13.converters.FilePropertyBag(options);
			const n = fileName;
			let t$1 = options.type;
			let d$1;
			substep: {
				if (t$1) {
					t$1 = parseMIMEType$2(t$1);
					if (t$1 === "failure") {
						t$1 = "";
						break substep;
					}
					t$1 = serializeAMimeType$3(t$1).toLowerCase();
				}
				d$1 = options.lastModified;
			}
			super(processBlobParts(fileBits, options), { type: t$1 });
			this[kState$9] = {
				name: n,
				lastModified: d$1,
				type: t$1
			};
		}
		get name() {
			webidl$13.brandCheck(this, File$4);
			return this[kState$9].name;
		}
		get lastModified() {
			webidl$13.brandCheck(this, File$4);
			return this[kState$9].lastModified;
		}
		get type() {
			webidl$13.brandCheck(this, File$4);
			return this[kState$9].type;
		}
	};
	var FileLike$1 = class FileLike$1 {
		constructor(blobLike, fileName, options = {}) {
			this[kState$9] = {
				blobLike,
				name: fileName,
				type: options.type,
				lastModified: options.lastModified ?? Date.now()
			};
		}
		stream(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.stream(...args);
		}
		arrayBuffer(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.arrayBuffer(...args);
		}
		slice(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.slice(...args);
		}
		text(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.text(...args);
		}
		get size() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.size;
		}
		get type() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.type;
		}
		get name() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].name;
		}
		get lastModified() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].lastModified;
		}
		get [Symbol.toStringTag]() {
			return "File";
		}
	};
	Object.defineProperties(File$4.prototype, {
		[Symbol.toStringTag]: {
			value: "File",
			configurable: true
		},
		name: kEnumerableProperty$8,
		lastModified: kEnumerableProperty$8
	});
	webidl$13.converters.Blob = webidl$13.interfaceConverter(Blob$5);
	webidl$13.converters.BlobPart = function(V, opts) {
		if (webidl$13.util.Type(V) === "Object") {
			if (isBlobLike$5(V)) return webidl$13.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types$5.isAnyArrayBuffer(V)) return webidl$13.converters.BufferSource(V, opts);
		}
		return webidl$13.converters.USVString(V, opts);
	};
	webidl$13.converters["sequence<BlobPart>"] = webidl$13.sequenceConverter(webidl$13.converters.BlobPart);
	webidl$13.converters.FilePropertyBag = webidl$13.dictionaryConverter([
		{
			key: "lastModified",
			converter: webidl$13.converters["long long"],
			get defaultValue() {
				return Date.now();
			}
		},
		{
			key: "type",
			converter: webidl$13.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "endings",
			converter: (value) => {
				value = webidl$13.converters.DOMString(value);
				value = value.toLowerCase();
				if (value !== "native") value = "transparent";
				return value;
			},
			defaultValue: "transparent"
		}
	]);
	/**
	* @see https://www.w3.org/TR/FileAPI/#process-blob-parts
	* @param {(NodeJS.TypedArray|Blob|string)[]} parts
	* @param {{ type: string, endings: string }} options
	*/
	function processBlobParts(parts, options) {
		/** @type {NodeJS.TypedArray[]} */
		const bytes = [];
		for (const element of parts) if (typeof element === "string") {
			let s$2 = element;
			if (options.endings === "native") s$2 = convertLineEndingsNative(s$2);
			bytes.push(encoder.encode(s$2));
		} else if (types$5.isAnyArrayBuffer(element) || types$5.isTypedArray(element)) if (!element.buffer) bytes.push(new Uint8Array(element));
		else bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
		else if (isBlobLike$5(element)) bytes.push(element);
		return bytes;
	}
	/**
	* @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
	* @param {string} s
	*/
	function convertLineEndingsNative(s$2) {
		let nativeLineEnding = "\n";
		if (process.platform === "win32") nativeLineEnding = "\r\n";
		return s$2.replace(/\r?\n/g, nativeLineEnding);
	}
	function isFileLike$1(object) {
		return NativeFile$2 && object instanceof NativeFile$2 || object instanceof File$4 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
	}
	module.exports = {
		File: File$4,
		FileLike: FileLike$1,
		isFileLike: isFileLike$1
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/formdata.js
var require_formdata = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { isBlobLike: isBlobLike$4, toUSVString: toUSVString$2, makeIterator: makeIterator$1 } = require_util$7();
	const { kState: kState$8 } = require_symbols$3();
	const { File: UndiciFile$1, FileLike, isFileLike } = require_file();
	const { webidl: webidl$12 } = require_webidl();
	const { Blob: Blob$4, File: NativeFile$1 } = require("buffer");
	/** @type {globalThis['File']} */
	const File$3 = NativeFile$1 ?? UndiciFile$1;
	var FormData$4 = class FormData$4 {
		constructor(form) {
			if (form !== void 0) throw webidl$12.errors.conversionFailed({
				prefix: "FormData constructor",
				argument: "Argument 1",
				types: ["undefined"]
			});
			this[kState$8] = [];
		}
		append(name, value, filename = void 0) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
			if (arguments.length === 3 && !isBlobLike$4(value)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl$12.converters.USVString(name);
			value = isBlobLike$4(value) ? webidl$12.converters.Blob(value, { strict: false }) : webidl$12.converters.USVString(value);
			filename = arguments.length === 3 ? webidl$12.converters.USVString(filename) : void 0;
			const entry = makeEntry(name, value, filename);
			this[kState$8].push(entry);
		}
		delete(name) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
			name = webidl$12.converters.USVString(name);
			this[kState$8] = this[kState$8].filter((entry) => entry.name !== name);
		}
		get(name) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
			name = webidl$12.converters.USVString(name);
			const idx = this[kState$8].findIndex((entry) => entry.name === name);
			if (idx === -1) return null;
			return this[kState$8][idx].value;
		}
		getAll(name) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
			name = webidl$12.converters.USVString(name);
			return this[kState$8].filter((entry) => entry.name === name).map((entry) => entry.value);
		}
		has(name) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
			name = webidl$12.converters.USVString(name);
			return this[kState$8].findIndex((entry) => entry.name === name) !== -1;
		}
		set(name, value, filename = void 0) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
			if (arguments.length === 3 && !isBlobLike$4(value)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl$12.converters.USVString(name);
			value = isBlobLike$4(value) ? webidl$12.converters.Blob(value, { strict: false }) : webidl$12.converters.USVString(value);
			filename = arguments.length === 3 ? toUSVString$2(filename) : void 0;
			const entry = makeEntry(name, value, filename);
			const idx = this[kState$8].findIndex((entry$1) => entry$1.name === name);
			if (idx !== -1) this[kState$8] = [
				...this[kState$8].slice(0, idx),
				entry,
				...this[kState$8].slice(idx + 1).filter((entry$1) => entry$1.name !== name)
			];
			else this[kState$8].push(entry);
		}
		entries() {
			webidl$12.brandCheck(this, FormData$4);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
		}
		keys() {
			webidl$12.brandCheck(this, FormData$4);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "key");
		}
		values() {
			webidl$12.brandCheck(this, FormData$4);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "value");
		}
		/**
		* @param {(value: string, key: string, self: FormData) => void} callbackFn
		* @param {unknown} thisArg
		*/
		forEach(callbackFn, thisArg = globalThis) {
			webidl$12.brandCheck(this, FormData$4);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
			for (const [key, value] of this) callbackFn.apply(thisArg, [
				value,
				key,
				this
			]);
		}
	};
	FormData$4.prototype[Symbol.iterator] = FormData$4.prototype.entries;
	Object.defineProperties(FormData$4.prototype, { [Symbol.toStringTag]: {
		value: "FormData",
		configurable: true
	} });
	/**
	* @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
	* @param {string} name
	* @param {string|Blob} value
	* @param {?string} filename
	* @returns
	*/
	function makeEntry(name, value, filename) {
		name = Buffer.from(name).toString("utf8");
		if (typeof value === "string") value = Buffer.from(value).toString("utf8");
		else {
			if (!isFileLike(value)) value = value instanceof Blob$4 ? new File$3([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
			if (filename !== void 0) {
				/** @type {FilePropertyBag} */
				const options = {
					type: value.type,
					lastModified: value.lastModified
				};
				value = NativeFile$1 && value instanceof NativeFile$1 || value instanceof UndiciFile$1 ? new File$3([value], filename, options) : new FileLike(value, filename, options);
			}
		}
		return {
			name,
			value
		};
	}
	module.exports = { FormData: FormData$4 };
}));

//#endregion
//#region node_modules/undici/lib/fetch/body.js
var require_body = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Busboy = require_main();
	const util$22 = require_util$8();
	const { ReadableStreamFrom: ReadableStreamFrom$1, isBlobLike: isBlobLike$3, isReadableStreamLike, readableStreamClose: readableStreamClose$1, createDeferredPromise: createDeferredPromise$2, fullyReadBody: fullyReadBody$1 } = require_util$7();
	const { FormData: FormData$3 } = require_formdata();
	const { kState: kState$7 } = require_symbols$3();
	const { webidl: webidl$11 } = require_webidl();
	const { DOMException: DOMException$6, structuredClone: structuredClone$1 } = require_constants$4();
	const { Blob: Blob$3, File: NativeFile } = require("buffer");
	const { kBodyUsed: kBodyUsed$1 } = require_symbols$4();
	const assert$16 = require("assert");
	const { isErrored: isErrored$1 } = require_util$8();
	const { isUint8Array, isArrayBuffer } = require("util/types");
	const { File: UndiciFile } = require_file();
	const { parseMIMEType: parseMIMEType$1, serializeAMimeType: serializeAMimeType$2 } = require_dataURL();
	let random;
	try {
		const crypto$7 = require("node:crypto");
		random = (max) => crypto$7.randomInt(0, max);
	} catch {
		random = (max) => Math.floor(Math.random(max));
	}
	let ReadableStream$3 = globalThis.ReadableStream;
	/** @type {globalThis['File']} */
	const File$2 = NativeFile ?? UndiciFile;
	const textEncoder$1 = new TextEncoder();
	const textDecoder = new TextDecoder();
	function extractBody$3(object, keepalive = false) {
		if (!ReadableStream$3) ReadableStream$3 = require("stream/web").ReadableStream;
		let stream$6 = null;
		if (object instanceof ReadableStream$3) stream$6 = object;
		else if (isBlobLike$3(object)) stream$6 = object.stream();
		else stream$6 = new ReadableStream$3({
			async pull(controller) {
				controller.enqueue(typeof source === "string" ? textEncoder$1.encode(source) : source);
				queueMicrotask(() => readableStreamClose$1(controller));
			},
			start() {},
			type: void 0
		});
		assert$16(isReadableStreamLike(stream$6));
		let action = null;
		let source = null;
		let length = null;
		let type = null;
		if (typeof object === "string") {
			source = object;
			type = "text/plain;charset=UTF-8";
		} else if (object instanceof URLSearchParams) {
			source = object.toString();
			type = "application/x-www-form-urlencoded;charset=UTF-8";
		} else if (isArrayBuffer(object)) source = new Uint8Array(object.slice());
		else if (ArrayBuffer.isView(object)) source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
		else if (util$22.isFormDataLike(object)) {
			const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
			const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
			/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
			const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
			const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
			const blobParts = [];
			const rn = new Uint8Array([13, 10]);
			length = 0;
			let hasUnknownSizeValue = false;
			for (const [name, value] of object) if (typeof value === "string") {
				const chunk$1 = textEncoder$1.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
				blobParts.push(chunk$1);
				length += chunk$1.byteLength;
			} else {
				const chunk$1 = textEncoder$1.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`);
				blobParts.push(chunk$1, value, rn);
				if (typeof value.size === "number") length += chunk$1.byteLength + value.size + rn.byteLength;
				else hasUnknownSizeValue = true;
			}
			const chunk = textEncoder$1.encode(`--${boundary}--`);
			blobParts.push(chunk);
			length += chunk.byteLength;
			if (hasUnknownSizeValue) length = null;
			source = object;
			action = async function* () {
				for (const part of blobParts) if (part.stream) yield* part.stream();
				else yield part;
			};
			type = "multipart/form-data; boundary=" + boundary;
		} else if (isBlobLike$3(object)) {
			source = object;
			length = object.size;
			if (object.type) type = object.type;
		} else if (typeof object[Symbol.asyncIterator] === "function") {
			if (keepalive) throw new TypeError("keepalive");
			if (util$22.isDisturbed(object) || object.locked) throw new TypeError("Response body object should not be disturbed or locked");
			stream$6 = object instanceof ReadableStream$3 ? object : ReadableStreamFrom$1(object);
		}
		if (typeof source === "string" || util$22.isBuffer(source)) length = Buffer.byteLength(source);
		if (action != null) {
			let iterator$1;
			stream$6 = new ReadableStream$3({
				async start() {
					iterator$1 = action(object)[Symbol.asyncIterator]();
				},
				async pull(controller) {
					const { value, done } = await iterator$1.next();
					if (done) queueMicrotask(() => {
						controller.close();
					});
					else if (!isErrored$1(stream$6)) controller.enqueue(new Uint8Array(value));
					return controller.desiredSize > 0;
				},
				async cancel(reason) {
					await iterator$1.return();
				},
				type: void 0
			});
		}
		return [{
			stream: stream$6,
			source,
			length
		}, type];
	}
	function safelyExtractBody$1(object, keepalive = false) {
		if (!ReadableStream$3)
 // istanbul ignore next
		ReadableStream$3 = require("stream/web").ReadableStream;
		if (object instanceof ReadableStream$3) {
			// istanbul ignore next
			assert$16(!util$22.isDisturbed(object), "The body has already been consumed.");
			// istanbul ignore next
			assert$16(!object.locked, "The stream is locked.");
		}
		return extractBody$3(object, keepalive);
	}
	function cloneBody$2(body) {
		const [out1, out2] = body.stream.tee();
		const [, finalClone] = structuredClone$1(out2, { transfer: [out2] }).tee();
		body.stream = out1;
		return {
			stream: finalClone,
			length: body.length,
			source: body.source
		};
	}
	async function* consumeBody$1(body) {
		if (body) if (isUint8Array(body)) yield body;
		else {
			const stream$6 = body.stream;
			if (util$22.isDisturbed(stream$6)) throw new TypeError("The body has already been consumed.");
			if (stream$6.locked) throw new TypeError("The stream is locked.");
			stream$6[kBodyUsed$1] = true;
			yield* stream$6;
		}
	}
	function throwIfAborted(state) {
		if (state.aborted) throw new DOMException$6("The operation was aborted.", "AbortError");
	}
	function bodyMixinMethods(instance$1) {
		return {
			blob() {
				return specConsumeBody(this, (bytes) => {
					let mimeType = bodyMimeType(this);
					if (mimeType === "failure") mimeType = "";
					else if (mimeType) mimeType = serializeAMimeType$2(mimeType);
					return new Blob$3([bytes], { type: mimeType });
				}, instance$1);
			},
			arrayBuffer() {
				return specConsumeBody(this, (bytes) => {
					return new Uint8Array(bytes).buffer;
				}, instance$1);
			},
			text() {
				return specConsumeBody(this, utf8DecodeBytes, instance$1);
			},
			json() {
				return specConsumeBody(this, parseJSONFromBytes, instance$1);
			},
			async formData() {
				webidl$11.brandCheck(this, instance$1);
				throwIfAborted(this[kState$7]);
				const contentType = this.headers.get("Content-Type");
				if (/multipart\/form-data/.test(contentType)) {
					const headers = {};
					for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
					const responseFormData = new FormData$3();
					let busboy;
					try {
						busboy = new Busboy({
							headers,
							preservePath: true
						});
					} catch (err) {
						throw new DOMException$6(`${err}`, "AbortError");
					}
					busboy.on("field", (name, value) => {
						responseFormData.append(name, value);
					});
					busboy.on("file", (name, value, filename, encoding, mimeType) => {
						const chunks = [];
						if (encoding === "base64" || encoding.toLowerCase() === "base64") {
							let base64chunk = "";
							value.on("data", (chunk) => {
								base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
								const end = base64chunk.length - base64chunk.length % 4;
								chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
								base64chunk = base64chunk.slice(end);
							});
							value.on("end", () => {
								chunks.push(Buffer.from(base64chunk, "base64"));
								responseFormData.append(name, new File$2(chunks, filename, { type: mimeType }));
							});
						} else {
							value.on("data", (chunk) => {
								chunks.push(chunk);
							});
							value.on("end", () => {
								responseFormData.append(name, new File$2(chunks, filename, { type: mimeType }));
							});
						}
					});
					const busboyResolve = new Promise((resolve, reject) => {
						busboy.on("finish", resolve);
						busboy.on("error", (err) => reject(new TypeError(err)));
					});
					if (this.body !== null) for await (const chunk of consumeBody$1(this[kState$7].body)) busboy.write(chunk);
					busboy.end();
					await busboyResolve;
					return responseFormData;
				} else if (/application\/x-www-form-urlencoded/.test(contentType)) {
					let entries;
					try {
						let text = "";
						const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
						for await (const chunk of consumeBody$1(this[kState$7].body)) {
							if (!isUint8Array(chunk)) throw new TypeError("Expected Uint8Array chunk");
							text += streamingDecoder.decode(chunk, { stream: true });
						}
						text += streamingDecoder.decode();
						entries = new URLSearchParams(text);
					} catch (err) {
						// istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
						throw Object.assign(/* @__PURE__ */ new TypeError(), { cause: err });
					}
					const formData = new FormData$3();
					for (const [name, value] of entries) formData.append(name, value);
					return formData;
				} else {
					await Promise.resolve();
					throwIfAborted(this[kState$7]);
					throw webidl$11.errors.exception({
						header: `${instance$1.name}.formData`,
						message: "Could not parse content as FormData."
					});
				}
			}
		};
	}
	function mixinBody$2(prototype) {
		Object.assign(prototype.prototype, bodyMixinMethods(prototype));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-consume-body
	* @param {Response|Request} object
	* @param {(value: unknown) => unknown} convertBytesToJSValue
	* @param {Response|Request} instance
	*/
	async function specConsumeBody(object, convertBytesToJSValue, instance$1) {
		webidl$11.brandCheck(object, instance$1);
		throwIfAborted(object[kState$7]);
		if (bodyUnusable(object[kState$7].body)) throw new TypeError("Body is unusable");
		const promise = createDeferredPromise$2();
		const errorSteps = (error$1) => promise.reject(error$1);
		const successSteps = (data) => {
			try {
				promise.resolve(convertBytesToJSValue(data));
			} catch (e$1) {
				errorSteps(e$1);
			}
		};
		if (object[kState$7].body == null) {
			successSteps(new Uint8Array());
			return promise.promise;
		}
		await fullyReadBody$1(object[kState$7].body, successSteps, errorSteps);
		return promise.promise;
	}
	function bodyUnusable(body) {
		return body != null && (body.stream.locked || util$22.isDisturbed(body.stream));
	}
	/**
	* @see https://encoding.spec.whatwg.org/#utf-8-decode
	* @param {Buffer} buffer
	*/
	function utf8DecodeBytes(buffer$1) {
		if (buffer$1.length === 0) return "";
		if (buffer$1[0] === 239 && buffer$1[1] === 187 && buffer$1[2] === 191) buffer$1 = buffer$1.subarray(3);
		return textDecoder.decode(buffer$1);
	}
	/**
	* @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
	* @param {Uint8Array} bytes
	*/
	function parseJSONFromBytes(bytes) {
		return JSON.parse(utf8DecodeBytes(bytes));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-mime-type
	* @param {import('./response').Response|import('./request').Request} object
	*/
	function bodyMimeType(object) {
		const { headersList } = object[kState$7];
		const contentType = headersList.get("content-type");
		if (contentType === null) return "failure";
		return parseMIMEType$1(contentType);
	}
	module.exports = {
		extractBody: extractBody$3,
		safelyExtractBody: safelyExtractBody$1,
		cloneBody: cloneBody$2,
		mixinBody: mixinBody$2
	};
}));

//#endregion
//#region node_modules/undici/lib/core/request.js
var require_request$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { InvalidArgumentError: InvalidArgumentError$20, NotSupportedError: NotSupportedError$1 } = require_errors();
	const assert$15 = require("assert");
	const { kHTTP2BuildRequest: kHTTP2BuildRequest$1, kHTTP2CopyHeaders: kHTTP2CopyHeaders$1, kHTTP1BuildRequest: kHTTP1BuildRequest$1 } = require_symbols$4();
	const util$21 = require_util$8();
	/**
	* Verifies that the given val is a valid HTTP token
	* per the rules defined in RFC 7230
	* See https://tools.ietf.org/html/rfc7230#section-3.2.6
	*/
	const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
	/**
	* Matches if val contains an invalid field-vchar
	*  field-value    = *( field-content / obs-fold )
	*  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	*  field-vchar    = VCHAR / obs-text
	*/
	const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
	const invalidPathRegex = /[^\u0021-\u00ff]/;
	const kHandler = Symbol("handler");
	const channels$3 = {};
	let extractBody$2;
	try {
		const diagnosticsChannel$2 = require("diagnostics_channel");
		channels$3.create = diagnosticsChannel$2.channel("undici:request:create");
		channels$3.bodySent = diagnosticsChannel$2.channel("undici:request:bodySent");
		channels$3.headers = diagnosticsChannel$2.channel("undici:request:headers");
		channels$3.trailers = diagnosticsChannel$2.channel("undici:request:trailers");
		channels$3.error = diagnosticsChannel$2.channel("undici:request:error");
	} catch {
		channels$3.create = { hasSubscribers: false };
		channels$3.bodySent = { hasSubscribers: false };
		channels$3.headers = { hasSubscribers: false };
		channels$3.trailers = { hasSubscribers: false };
		channels$3.error = { hasSubscribers: false };
	}
	var Request$5 = class Request$5 {
		constructor(origin, { path: path$9, method, body, headers, query, idempotent, blocking, upgrade: upgrade$1, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue }, handler$1) {
			if (typeof path$9 !== "string") throw new InvalidArgumentError$20("path must be a string");
			else if (path$9[0] !== "/" && !(path$9.startsWith("http://") || path$9.startsWith("https://")) && method !== "CONNECT") throw new InvalidArgumentError$20("path must be an absolute URL or start with a slash");
			else if (invalidPathRegex.exec(path$9) !== null) throw new InvalidArgumentError$20("invalid request path");
			if (typeof method !== "string") throw new InvalidArgumentError$20("method must be a string");
			else if (tokenRegExp.exec(method) === null) throw new InvalidArgumentError$20("invalid request method");
			if (upgrade$1 && typeof upgrade$1 !== "string") throw new InvalidArgumentError$20("upgrade must be a string");
			if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$20("invalid headersTimeout");
			if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$20("invalid bodyTimeout");
			if (reset != null && typeof reset !== "boolean") throw new InvalidArgumentError$20("invalid reset");
			if (expectContinue != null && typeof expectContinue !== "boolean") throw new InvalidArgumentError$20("invalid expectContinue");
			this.headersTimeout = headersTimeout;
			this.bodyTimeout = bodyTimeout;
			this.throwOnError = throwOnError === true;
			this.method = method;
			this.abort = null;
			if (body == null) this.body = null;
			else if (util$21.isStream(body)) {
				this.body = body;
				const rState = this.body._readableState;
				if (!rState || !rState.autoDestroy) {
					this.endHandler = function autoDestroy() {
						util$21.destroy(this);
					};
					this.body.on("end", this.endHandler);
				}
				this.errorHandler = (err) => {
					if (this.abort) this.abort(err);
					else this.error = err;
				};
				this.body.on("error", this.errorHandler);
			} else if (util$21.isBuffer(body)) this.body = body.byteLength ? body : null;
			else if (ArrayBuffer.isView(body)) this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
			else if (body instanceof ArrayBuffer) this.body = body.byteLength ? Buffer.from(body) : null;
			else if (typeof body === "string") this.body = body.length ? Buffer.from(body) : null;
			else if (util$21.isFormDataLike(body) || util$21.isIterable(body) || util$21.isBlobLike(body)) this.body = body;
			else throw new InvalidArgumentError$20("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
			this.completed = false;
			this.aborted = false;
			this.upgrade = upgrade$1 || null;
			this.path = query ? util$21.buildURL(path$9, query) : path$9;
			this.origin = origin;
			this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
			this.blocking = blocking == null ? false : blocking;
			this.reset = reset == null ? null : reset;
			this.host = null;
			this.contentLength = null;
			this.contentType = null;
			this.headers = "";
			this.expectContinue = expectContinue != null ? expectContinue : false;
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError$20("headers array must be even");
				for (let i$2 = 0; i$2 < headers.length; i$2 += 2) processHeader(this, headers[i$2], headers[i$2 + 1]);
			} else if (headers && typeof headers === "object") {
				const keys = Object.keys(headers);
				for (let i$2 = 0; i$2 < keys.length; i$2++) {
					const key = keys[i$2];
					processHeader(this, key, headers[key]);
				}
			} else if (headers != null) throw new InvalidArgumentError$20("headers must be an object or an array");
			if (util$21.isFormDataLike(this.body)) {
				if (util$21.nodeMajor < 16 || util$21.nodeMajor === 16 && util$21.nodeMinor < 8) throw new InvalidArgumentError$20("Form-Data bodies are only supported in node v16.8 and newer.");
				if (!extractBody$2) extractBody$2 = require_body().extractBody;
				const [bodyStream, contentType] = extractBody$2(body);
				if (this.contentType == null) {
					this.contentType = contentType;
					this.headers += `content-type: ${contentType}\r\n`;
				}
				this.body = bodyStream.stream;
				this.contentLength = bodyStream.length;
			} else if (util$21.isBlobLike(body) && this.contentType == null && body.type) {
				this.contentType = body.type;
				this.headers += `content-type: ${body.type}\r\n`;
			}
			util$21.validateHandler(handler$1, method, upgrade$1);
			this.servername = util$21.getServerName(this.host);
			this[kHandler] = handler$1;
			if (channels$3.create.hasSubscribers) channels$3.create.publish({ request: this });
		}
		onBodySent(chunk) {
			if (this[kHandler].onBodySent) try {
				return this[kHandler].onBodySent(chunk);
			} catch (err) {
				this.abort(err);
			}
		}
		onRequestSent() {
			if (channels$3.bodySent.hasSubscribers) channels$3.bodySent.publish({ request: this });
			if (this[kHandler].onRequestSent) try {
				return this[kHandler].onRequestSent();
			} catch (err) {
				this.abort(err);
			}
		}
		onConnect(abort$1) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			if (this.error) abort$1(this.error);
			else {
				this.abort = abort$1;
				return this[kHandler].onConnect(abort$1);
			}
		}
		onHeaders(statusCode, headers, resume$3, statusText) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			if (channels$3.headers.hasSubscribers) channels$3.headers.publish({
				request: this,
				response: {
					statusCode,
					headers,
					statusText
				}
			});
			try {
				return this[kHandler].onHeaders(statusCode, headers, resume$3, statusText);
			} catch (err) {
				this.abort(err);
			}
		}
		onData(chunk) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			try {
				return this[kHandler].onData(chunk);
			} catch (err) {
				this.abort(err);
				return false;
			}
		}
		onUpgrade(statusCode, headers, socket) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			return this[kHandler].onUpgrade(statusCode, headers, socket);
		}
		onComplete(trailers) {
			this.onFinally();
			assert$15(!this.aborted);
			this.completed = true;
			if (channels$3.trailers.hasSubscribers) channels$3.trailers.publish({
				request: this,
				trailers
			});
			try {
				return this[kHandler].onComplete(trailers);
			} catch (err) {
				this.onError(err);
			}
		}
		onError(error$1) {
			this.onFinally();
			if (channels$3.error.hasSubscribers) channels$3.error.publish({
				request: this,
				error: error$1
			});
			if (this.aborted) return;
			this.aborted = true;
			return this[kHandler].onError(error$1);
		}
		onFinally() {
			if (this.errorHandler) {
				this.body.off("error", this.errorHandler);
				this.errorHandler = null;
			}
			if (this.endHandler) {
				this.body.off("end", this.endHandler);
				this.endHandler = null;
			}
		}
		addHeader(key, value) {
			processHeader(this, key, value);
			return this;
		}
		static [kHTTP1BuildRequest$1](origin, opts, handler$1) {
			return new Request$5(origin, opts, handler$1);
		}
		static [kHTTP2BuildRequest$1](origin, opts, handler$1) {
			const headers = opts.headers;
			opts = {
				...opts,
				headers: null
			};
			const request$3 = new Request$5(origin, opts, handler$1);
			request$3.headers = {};
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError$20("headers array must be even");
				for (let i$2 = 0; i$2 < headers.length; i$2 += 2) processHeader(request$3, headers[i$2], headers[i$2 + 1], true);
			} else if (headers && typeof headers === "object") {
				const keys = Object.keys(headers);
				for (let i$2 = 0; i$2 < keys.length; i$2++) {
					const key = keys[i$2];
					processHeader(request$3, key, headers[key], true);
				}
			} else if (headers != null) throw new InvalidArgumentError$20("headers must be an object or an array");
			return request$3;
		}
		static [kHTTP2CopyHeaders$1](raw) {
			const rawHeaders = raw.split("\r\n");
			const headers = {};
			for (const header of rawHeaders) {
				const [key, value] = header.split(": ");
				if (value == null || value.length === 0) continue;
				if (headers[key]) headers[key] += `,${value}`;
				else headers[key] = value;
			}
			return headers;
		}
	};
	function processHeaderValue(key, val, skipAppend) {
		if (val && typeof val === "object") throw new InvalidArgumentError$20(`invalid ${key} header`);
		val = val != null ? `${val}` : "";
		if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError$20(`invalid ${key} header`);
		return skipAppend ? val : `${key}: ${val}\r\n`;
	}
	function processHeader(request$3, key, val, skipAppend = false) {
		if (val && typeof val === "object" && !Array.isArray(val)) throw new InvalidArgumentError$20(`invalid ${key} header`);
		else if (val === void 0) return;
		if (request$3.host === null && key.length === 4 && key.toLowerCase() === "host") {
			if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError$20(`invalid ${key} header`);
			request$3.host = val;
		} else if (request$3.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
			request$3.contentLength = parseInt(val, 10);
			if (!Number.isFinite(request$3.contentLength)) throw new InvalidArgumentError$20("invalid content-length header");
		} else if (request$3.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
			request$3.contentType = val;
			if (skipAppend) request$3.headers[key] = processHeaderValue(key, val, skipAppend);
			else request$3.headers += processHeaderValue(key, val);
		} else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") throw new InvalidArgumentError$20("invalid transfer-encoding header");
		else if (key.length === 10 && key.toLowerCase() === "connection") {
			const value = typeof val === "string" ? val.toLowerCase() : null;
			if (value !== "close" && value !== "keep-alive") throw new InvalidArgumentError$20("invalid connection header");
			else if (value === "close") request$3.reset = true;
		} else if (key.length === 10 && key.toLowerCase() === "keep-alive") throw new InvalidArgumentError$20("invalid keep-alive header");
		else if (key.length === 7 && key.toLowerCase() === "upgrade") throw new InvalidArgumentError$20("invalid upgrade header");
		else if (key.length === 6 && key.toLowerCase() === "expect") throw new NotSupportedError$1("expect header not supported");
		else if (tokenRegExp.exec(key) === null) throw new InvalidArgumentError$20("invalid header key");
		else if (Array.isArray(val)) for (let i$2 = 0; i$2 < val.length; i$2++) if (skipAppend) if (request$3.headers[key]) request$3.headers[key] += `,${processHeaderValue(key, val[i$2], skipAppend)}`;
		else request$3.headers[key] = processHeaderValue(key, val[i$2], skipAppend);
		else request$3.headers += processHeaderValue(key, val[i$2]);
		else if (skipAppend) request$3.headers[key] = processHeaderValue(key, val, skipAppend);
		else request$3.headers += processHeaderValue(key, val);
	}
	module.exports = Request$5;
}));

//#endregion
//#region node_modules/undici/lib/dispatcher.js
var require_dispatcher = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter$2 = require("events");
	var Dispatcher$3 = class extends EventEmitter$2 {
		dispatch() {
			throw new Error("not implemented");
		}
		close() {
			throw new Error("not implemented");
		}
		destroy() {
			throw new Error("not implemented");
		}
	};
	module.exports = Dispatcher$3;
}));

//#endregion
//#region node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Dispatcher$2 = require_dispatcher();
	const { ClientDestroyedError: ClientDestroyedError$1, ClientClosedError, InvalidArgumentError: InvalidArgumentError$19 } = require_errors();
	const { kDestroy: kDestroy$4, kClose: kClose$6, kDispatch: kDispatch$3, kInterceptors: kInterceptors$5 } = require_symbols$4();
	const kDestroyed = Symbol("destroyed");
	const kClosed = Symbol("closed");
	const kOnDestroyed = Symbol("onDestroyed");
	const kOnClosed = Symbol("onClosed");
	const kInterceptedDispatch = Symbol("Intercepted Dispatch");
	var DispatcherBase$4 = class extends Dispatcher$2 {
		constructor() {
			super();
			this[kDestroyed] = false;
			this[kOnDestroyed] = null;
			this[kClosed] = false;
			this[kOnClosed] = [];
		}
		get destroyed() {
			return this[kDestroyed];
		}
		get closed() {
			return this[kClosed];
		}
		get interceptors() {
			return this[kInterceptors$5];
		}
		set interceptors(newInterceptors) {
			if (newInterceptors) {
				for (let i$2 = newInterceptors.length - 1; i$2 >= 0; i$2--) if (typeof this[kInterceptors$5][i$2] !== "function") throw new InvalidArgumentError$19("interceptor must be an function");
			}
			this[kInterceptors$5] = newInterceptors;
		}
		close(callback) {
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.close((err, data) => {
					return err ? reject(err) : resolve(data);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError$19("invalid callback");
			if (this[kDestroyed]) {
				queueMicrotask(() => callback(new ClientDestroyedError$1(), null));
				return;
			}
			if (this[kClosed]) {
				if (this[kOnClosed]) this[kOnClosed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			this[kClosed] = true;
			this[kOnClosed].push(callback);
			const onClosed = () => {
				const callbacks = this[kOnClosed];
				this[kOnClosed] = null;
				for (let i$2 = 0; i$2 < callbacks.length; i$2++) callbacks[i$2](null, null);
			};
			this[kClose$6]().then(() => this.destroy()).then(() => {
				queueMicrotask(onClosed);
			});
		}
		destroy(err, callback) {
			if (typeof err === "function") {
				callback = err;
				err = null;
			}
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.destroy(err, (err$1, data) => {
					return err$1 ? reject(err$1) : resolve(data);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError$19("invalid callback");
			if (this[kDestroyed]) {
				if (this[kOnDestroyed]) this[kOnDestroyed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			if (!err) err = new ClientDestroyedError$1();
			this[kDestroyed] = true;
			this[kOnDestroyed] = this[kOnDestroyed] || [];
			this[kOnDestroyed].push(callback);
			const onDestroyed = () => {
				const callbacks = this[kOnDestroyed];
				this[kOnDestroyed] = null;
				for (let i$2 = 0; i$2 < callbacks.length; i$2++) callbacks[i$2](null, null);
			};
			this[kDestroy$4](err).then(() => {
				queueMicrotask(onDestroyed);
			});
		}
		[kInterceptedDispatch](opts, handler$1) {
			if (!this[kInterceptors$5] || this[kInterceptors$5].length === 0) {
				this[kInterceptedDispatch] = this[kDispatch$3];
				return this[kDispatch$3](opts, handler$1);
			}
			let dispatch = this[kDispatch$3].bind(this);
			for (let i$2 = this[kInterceptors$5].length - 1; i$2 >= 0; i$2--) dispatch = this[kInterceptors$5][i$2](dispatch);
			this[kInterceptedDispatch] = dispatch;
			return dispatch(opts, handler$1);
		}
		dispatch(opts, handler$1) {
			if (!handler$1 || typeof handler$1 !== "object") throw new InvalidArgumentError$19("handler must be an object");
			try {
				if (!opts || typeof opts !== "object") throw new InvalidArgumentError$19("opts must be an object.");
				if (this[kDestroyed] || this[kOnDestroyed]) throw new ClientDestroyedError$1();
				if (this[kClosed]) throw new ClientClosedError();
				return this[kInterceptedDispatch](opts, handler$1);
			} catch (err) {
				if (typeof handler$1.onError !== "function") throw new InvalidArgumentError$19("invalid onError method");
				handler$1.onError(err);
				return false;
			}
		}
	};
	module.exports = DispatcherBase$4;
}));

//#endregion
//#region node_modules/undici/lib/core/connect.js
var require_connect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const net$4 = require("net");
	const assert$14 = require("assert");
	const util$20 = require_util$8();
	const { InvalidArgumentError: InvalidArgumentError$18, ConnectTimeoutError } = require_errors();
	let tls$2;
	let SessionCache;
	if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) SessionCache = class WeakSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = /* @__PURE__ */ new Map();
			this._sessionRegistry = new global.FinalizationRegistry((key) => {
				if (this._sessionCache.size < this._maxCachedSessions) return;
				const ref = this._sessionCache.get(key);
				if (ref !== void 0 && ref.deref() === void 0) this._sessionCache.delete(key);
			});
		}
		get(sessionKey) {
			const ref = this._sessionCache.get(sessionKey);
			return ref ? ref.deref() : null;
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			this._sessionCache.set(sessionKey, new WeakRef(session));
			this._sessionRegistry.register(session, sessionKey);
		}
	};
	else SessionCache = class SimpleSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = /* @__PURE__ */ new Map();
		}
		get(sessionKey) {
			return this._sessionCache.get(sessionKey);
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			if (this._sessionCache.size >= this._maxCachedSessions) {
				const { value: oldestKey } = this._sessionCache.keys().next();
				this._sessionCache.delete(oldestKey);
			}
			this._sessionCache.set(sessionKey, session);
		}
	};
	function buildConnector$4({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
		if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new InvalidArgumentError$18("maxCachedSessions must be a positive integer or zero");
		const options = {
			path: socketPath,
			...opts
		};
		const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
		timeout = timeout == null ? 1e4 : timeout;
		allowH2 = allowH2 != null ? allowH2 : false;
		return function connect$2({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
			let socket;
			if (protocol === "https:") {
				if (!tls$2) tls$2 = require("tls");
				servername = servername || options.servername || util$20.getServerName(host) || null;
				const sessionKey = servername || hostname;
				const session = sessionCache.get(sessionKey) || null;
				assert$14(sessionKey);
				socket = tls$2.connect({
					highWaterMark: 16384,
					...options,
					servername,
					session,
					localAddress,
					ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
					socket: httpSocket,
					port: port || 443,
					host: hostname
				});
				socket.on("session", function(session$1) {
					sessionCache.set(sessionKey, session$1);
				});
			} else {
				assert$14(!httpSocket, "httpSocket can only be sent on TLS update");
				socket = net$4.connect({
					highWaterMark: 64 * 1024,
					...options,
					localAddress,
					port: port || 80,
					host: hostname
				});
			}
			if (options.keepAlive == null || options.keepAlive) {
				const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
				socket.setKeepAlive(true, keepAliveInitialDelay);
			}
			const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
			socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(null, this);
				}
			}).on("error", function(err) {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(err);
				}
			});
			return socket;
		};
	}
	function setupTimeout(onConnectTimeout$1, timeout) {
		if (!timeout) return () => {};
		let s1 = null;
		let s2 = null;
		const timeoutId = setTimeout(() => {
			s1 = setImmediate(() => {
				if (process.platform === "win32") s2 = setImmediate(() => onConnectTimeout$1());
				else onConnectTimeout$1();
			});
		}, timeout);
		return () => {
			clearTimeout(timeoutId);
			clearImmediate(s1);
			clearImmediate(s2);
		};
	}
	function onConnectTimeout(socket) {
		util$20.destroy(socket, new ConnectTimeoutError());
	}
	module.exports = buildConnector$4;
}));

//#endregion
//#region node_modules/undici/lib/llhttp/utils.js
var require_utils$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.enumToMap = void 0;
	function enumToMap(obj) {
		const res = {};
		Object.keys(obj).forEach((key) => {
			const value = obj[key];
			if (typeof value === "number") res[key] = value;
		});
		return res;
	}
	exports.enumToMap = enumToMap;
}));

//#endregion
//#region node_modules/undici/lib/llhttp/constants.js
var require_constants$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
	const utils_1$2 = require_utils$2();
	(function(ERROR) {
		ERROR[ERROR["OK"] = 0] = "OK";
		ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
		ERROR[ERROR["STRICT"] = 2] = "STRICT";
		ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
		ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
		ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
		ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
		ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
		ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
		ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
		ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
		ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
		ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
		ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
		ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
		ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
		ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
		ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
		ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
		ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
		ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
		ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
		ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
		ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
		ERROR[ERROR["USER"] = 24] = "USER";
	})(exports.ERROR || (exports.ERROR = {}));
	(function(TYPE) {
		TYPE[TYPE["BOTH"] = 0] = "BOTH";
		TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
		TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
	})(exports.TYPE || (exports.TYPE = {}));
	(function(FLAGS) {
		FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
		FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
		FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
		FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
		FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
		FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
		FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
		FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
		FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
	})(exports.FLAGS || (exports.FLAGS = {}));
	(function(LENIENT_FLAGS) {
		LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
		LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
		LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
	})(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
	var METHODS;
	(function(METHODS$1) {
		METHODS$1[METHODS$1["DELETE"] = 0] = "DELETE";
		METHODS$1[METHODS$1["GET"] = 1] = "GET";
		METHODS$1[METHODS$1["HEAD"] = 2] = "HEAD";
		METHODS$1[METHODS$1["POST"] = 3] = "POST";
		METHODS$1[METHODS$1["PUT"] = 4] = "PUT";
		METHODS$1[METHODS$1["CONNECT"] = 5] = "CONNECT";
		METHODS$1[METHODS$1["OPTIONS"] = 6] = "OPTIONS";
		METHODS$1[METHODS$1["TRACE"] = 7] = "TRACE";
		METHODS$1[METHODS$1["COPY"] = 8] = "COPY";
		METHODS$1[METHODS$1["LOCK"] = 9] = "LOCK";
		METHODS$1[METHODS$1["MKCOL"] = 10] = "MKCOL";
		METHODS$1[METHODS$1["MOVE"] = 11] = "MOVE";
		METHODS$1[METHODS$1["PROPFIND"] = 12] = "PROPFIND";
		METHODS$1[METHODS$1["PROPPATCH"] = 13] = "PROPPATCH";
		METHODS$1[METHODS$1["SEARCH"] = 14] = "SEARCH";
		METHODS$1[METHODS$1["UNLOCK"] = 15] = "UNLOCK";
		METHODS$1[METHODS$1["BIND"] = 16] = "BIND";
		METHODS$1[METHODS$1["REBIND"] = 17] = "REBIND";
		METHODS$1[METHODS$1["UNBIND"] = 18] = "UNBIND";
		METHODS$1[METHODS$1["ACL"] = 19] = "ACL";
		METHODS$1[METHODS$1["REPORT"] = 20] = "REPORT";
		METHODS$1[METHODS$1["MKACTIVITY"] = 21] = "MKACTIVITY";
		METHODS$1[METHODS$1["CHECKOUT"] = 22] = "CHECKOUT";
		METHODS$1[METHODS$1["MERGE"] = 23] = "MERGE";
		METHODS$1[METHODS$1["M-SEARCH"] = 24] = "M-SEARCH";
		METHODS$1[METHODS$1["NOTIFY"] = 25] = "NOTIFY";
		METHODS$1[METHODS$1["SUBSCRIBE"] = 26] = "SUBSCRIBE";
		METHODS$1[METHODS$1["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
		METHODS$1[METHODS$1["PATCH"] = 28] = "PATCH";
		METHODS$1[METHODS$1["PURGE"] = 29] = "PURGE";
		METHODS$1[METHODS$1["MKCALENDAR"] = 30] = "MKCALENDAR";
		METHODS$1[METHODS$1["LINK"] = 31] = "LINK";
		METHODS$1[METHODS$1["UNLINK"] = 32] = "UNLINK";
		METHODS$1[METHODS$1["SOURCE"] = 33] = "SOURCE";
		METHODS$1[METHODS$1["PRI"] = 34] = "PRI";
		METHODS$1[METHODS$1["DESCRIBE"] = 35] = "DESCRIBE";
		METHODS$1[METHODS$1["ANNOUNCE"] = 36] = "ANNOUNCE";
		METHODS$1[METHODS$1["SETUP"] = 37] = "SETUP";
		METHODS$1[METHODS$1["PLAY"] = 38] = "PLAY";
		METHODS$1[METHODS$1["PAUSE"] = 39] = "PAUSE";
		METHODS$1[METHODS$1["TEARDOWN"] = 40] = "TEARDOWN";
		METHODS$1[METHODS$1["GET_PARAMETER"] = 41] = "GET_PARAMETER";
		METHODS$1[METHODS$1["SET_PARAMETER"] = 42] = "SET_PARAMETER";
		METHODS$1[METHODS$1["REDIRECT"] = 43] = "REDIRECT";
		METHODS$1[METHODS$1["RECORD"] = 44] = "RECORD";
		METHODS$1[METHODS$1["FLUSH"] = 45] = "FLUSH";
	})(METHODS = exports.METHODS || (exports.METHODS = {}));
	exports.METHODS_HTTP = [
		METHODS.DELETE,
		METHODS.GET,
		METHODS.HEAD,
		METHODS.POST,
		METHODS.PUT,
		METHODS.CONNECT,
		METHODS.OPTIONS,
		METHODS.TRACE,
		METHODS.COPY,
		METHODS.LOCK,
		METHODS.MKCOL,
		METHODS.MOVE,
		METHODS.PROPFIND,
		METHODS.PROPPATCH,
		METHODS.SEARCH,
		METHODS.UNLOCK,
		METHODS.BIND,
		METHODS.REBIND,
		METHODS.UNBIND,
		METHODS.ACL,
		METHODS.REPORT,
		METHODS.MKACTIVITY,
		METHODS.CHECKOUT,
		METHODS.MERGE,
		METHODS["M-SEARCH"],
		METHODS.NOTIFY,
		METHODS.SUBSCRIBE,
		METHODS.UNSUBSCRIBE,
		METHODS.PATCH,
		METHODS.PURGE,
		METHODS.MKCALENDAR,
		METHODS.LINK,
		METHODS.UNLINK,
		METHODS.PRI,
		METHODS.SOURCE
	];
	exports.METHODS_ICE = [METHODS.SOURCE];
	exports.METHODS_RTSP = [
		METHODS.OPTIONS,
		METHODS.DESCRIBE,
		METHODS.ANNOUNCE,
		METHODS.SETUP,
		METHODS.PLAY,
		METHODS.PAUSE,
		METHODS.TEARDOWN,
		METHODS.GET_PARAMETER,
		METHODS.SET_PARAMETER,
		METHODS.REDIRECT,
		METHODS.RECORD,
		METHODS.FLUSH,
		METHODS.GET,
		METHODS.POST
	];
	exports.METHOD_MAP = utils_1$2.enumToMap(METHODS);
	exports.H_METHOD_MAP = {};
	Object.keys(exports.METHOD_MAP).forEach((key) => {
		if (/^H/.test(key)) exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
	});
	(function(FINISH) {
		FINISH[FINISH["SAFE"] = 0] = "SAFE";
		FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
		FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
	})(exports.FINISH || (exports.FINISH = {}));
	exports.ALPHA = [];
	for (let i$2 = "A".charCodeAt(0); i$2 <= "Z".charCodeAt(0); i$2++) {
		exports.ALPHA.push(String.fromCharCode(i$2));
		exports.ALPHA.push(String.fromCharCode(i$2 + 32));
	}
	exports.NUM_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9
	};
	exports.HEX_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15
	};
	exports.NUM = [
		"0",
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9"
	];
	exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
	exports.MARK = [
		"-",
		"_",
		".",
		"!",
		"~",
		"*",
		"'",
		"(",
		")"
	];
	exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([
		"%",
		";",
		":",
		"&",
		"=",
		"+",
		"$",
		","
	]);
	exports.STRICT_URL_CHAR = [
		"!",
		"\"",
		"$",
		"%",
		"&",
		"'",
		"(",
		")",
		"*",
		"+",
		",",
		"-",
		".",
		"/",
		":",
		";",
		"<",
		"=",
		">",
		"@",
		"[",
		"\\",
		"]",
		"^",
		"_",
		"`",
		"{",
		"|",
		"}",
		"~"
	].concat(exports.ALPHANUM);
	exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
	for (let i$2 = 128; i$2 <= 255; i$2++) exports.URL_CHAR.push(i$2);
	exports.HEX = exports.NUM.concat([
		"a",
		"b",
		"c",
		"d",
		"e",
		"f",
		"A",
		"B",
		"C",
		"D",
		"E",
		"F"
	]);
	exports.STRICT_TOKEN = [
		"!",
		"#",
		"$",
		"%",
		"&",
		"'",
		"*",
		"+",
		"-",
		".",
		"^",
		"_",
		"`",
		"|",
		"~"
	].concat(exports.ALPHANUM);
	exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
	exports.HEADER_CHARS = ["	"];
	for (let i$2 = 32; i$2 <= 255; i$2++) if (i$2 !== 127) exports.HEADER_CHARS.push(i$2);
	exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
	exports.MAJOR = exports.NUM_MAP;
	exports.MINOR = exports.MAJOR;
	var HEADER_STATE;
	(function(HEADER_STATE$1) {
		HEADER_STATE$1[HEADER_STATE$1["GENERAL"] = 0] = "GENERAL";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION"] = 1] = "CONNECTION";
		HEADER_STATE$1[HEADER_STATE$1["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
		HEADER_STATE$1[HEADER_STATE$1["UPGRADE"] = 4] = "UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
	})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
	exports.SPECIAL_HEADERS = {
		"connection": HEADER_STATE.CONNECTION,
		"content-length": HEADER_STATE.CONTENT_LENGTH,
		"proxy-connection": HEADER_STATE.CONNECTION,
		"transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
		"upgrade": HEADER_STATE.UPGRADE
	};
}));

//#endregion
//#region node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const util$19 = require_util$8();
	const { kBodyUsed } = require_symbols$4();
	const assert$13 = require("assert");
	const { InvalidArgumentError: InvalidArgumentError$17 } = require_errors();
	const EE$1 = require("events");
	const redirectableStatusCodes = [
		300,
		301,
		302,
		303,
		307,
		308
	];
	const kBody$1 = Symbol("body");
	var BodyAsyncIterable = class {
		constructor(body) {
			this[kBody$1] = body;
			this[kBodyUsed] = false;
		}
		async *[Symbol.asyncIterator]() {
			assert$13(!this[kBodyUsed], "disturbed");
			this[kBodyUsed] = true;
			yield* this[kBody$1];
		}
	};
	var RedirectHandler$2 = class {
		constructor(dispatch, maxRedirections, opts, handler$1) {
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$17("maxRedirections must be a positive number");
			util$19.validateHandler(handler$1, opts.method, opts.upgrade);
			this.dispatch = dispatch;
			this.location = null;
			this.abort = null;
			this.opts = {
				...opts,
				maxRedirections: 0
			};
			this.maxRedirections = maxRedirections;
			this.handler = handler$1;
			this.history = [];
			if (util$19.isStream(this.opts.body)) {
				if (util$19.bodyLength(this.opts.body) === 0) this.opts.body.on("data", function() {
					assert$13(false);
				});
				if (typeof this.opts.body.readableDidRead !== "boolean") {
					this.opts.body[kBodyUsed] = false;
					EE$1.prototype.on.call(this.opts.body, "data", function() {
						this[kBodyUsed] = true;
					});
				}
			} else if (this.opts.body && typeof this.opts.body.pipeTo === "function") this.opts.body = new BodyAsyncIterable(this.opts.body);
			else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util$19.isIterable(this.opts.body)) this.opts.body = new BodyAsyncIterable(this.opts.body);
		}
		onConnect(abort$1) {
			this.abort = abort$1;
			this.handler.onConnect(abort$1, { history: this.history });
		}
		onUpgrade(statusCode, headers, socket) {
			this.handler.onUpgrade(statusCode, headers, socket);
		}
		onError(error$1) {
			this.handler.onError(error$1);
		}
		onHeaders(statusCode, headers, resume$3, statusText) {
			this.location = this.history.length >= this.maxRedirections || util$19.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
			if (this.opts.origin) this.history.push(new URL(this.opts.path, this.opts.origin));
			if (!this.location) return this.handler.onHeaders(statusCode, headers, resume$3, statusText);
			const { origin, pathname, search } = util$19.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
			const path$9 = search ? `${pathname}${search}` : pathname;
			this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
			this.opts.path = path$9;
			this.opts.origin = origin;
			this.opts.maxRedirections = 0;
			this.opts.query = null;
			if (statusCode === 303 && this.opts.method !== "HEAD") {
				this.opts.method = "GET";
				this.opts.body = null;
			}
		}
		onData(chunk) {
			if (this.location) {} else return this.handler.onData(chunk);
		}
		onComplete(trailers) {
			if (this.location) {
				this.location = null;
				this.abort = null;
				this.dispatch(this.opts, this);
			} else this.handler.onComplete(trailers);
		}
		onBodySent(chunk) {
			if (this.handler.onBodySent) this.handler.onBodySent(chunk);
		}
	};
	function parseLocation(statusCode, headers) {
		if (redirectableStatusCodes.indexOf(statusCode) === -1) return null;
		for (let i$2 = 0; i$2 < headers.length; i$2 += 2) if (headers[i$2].toString().toLowerCase() === "location") return headers[i$2 + 1];
	}
	function shouldRemoveHeader(header, removeContent, unknownOrigin) {
		if (header.length === 4) return util$19.headerNameToString(header) === "host";
		if (removeContent && util$19.headerNameToString(header).startsWith("content-")) return true;
		if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
			const name = util$19.headerNameToString(header);
			return name === "authorization" || name === "cookie" || name === "proxy-authorization";
		}
		return false;
	}
	function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
		const ret = [];
		if (Array.isArray(headers)) {
			for (let i$2 = 0; i$2 < headers.length; i$2 += 2) if (!shouldRemoveHeader(headers[i$2], removeContent, unknownOrigin)) ret.push(headers[i$2], headers[i$2 + 1]);
		} else if (headers && typeof headers === "object") {
			for (const key of Object.keys(headers)) if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) ret.push(key, headers[key]);
		} else assert$13(headers == null, "headers must be an object or an array");
		return ret;
	}
	module.exports = RedirectHandler$2;
}));

//#endregion
//#region node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const RedirectHandler$1 = require_RedirectHandler();
	function createRedirectInterceptor$3({ maxRedirections: defaultMaxRedirections }) {
		return (dispatch) => {
			return function Intercept(opts, handler$1) {
				const { maxRedirections = defaultMaxRedirections } = opts;
				if (!maxRedirections) return dispatch(opts, handler$1);
				const redirectHandler = new RedirectHandler$1(dispatch, maxRedirections, opts, handler$1);
				opts = {
					...opts,
					maxRedirections: 0
				};
				return dispatch(opts, redirectHandler);
			};
		};
	}
	module.exports = createRedirectInterceptor$3;
}));

//#endregion
//#region node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
}));

//#endregion
//#region node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
}));

//#endregion
//#region node_modules/undici/lib/client.js
var require_client = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$12 = require("assert");
	const net$3 = require("net");
	const http$7 = require("http");
	const { pipeline: pipeline$3 } = require("stream");
	const util$18 = require_util$8();
	const timers = require_timers();
	const Request$4 = require_request$1();
	const DispatcherBase$3 = require_dispatcher_base();
	const { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, InvalidArgumentError: InvalidArgumentError$16, RequestAbortedError: RequestAbortedError$8, HeadersTimeoutError, HeadersOverflowError, SocketError: SocketError$2, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError, ClientDestroyedError } = require_errors();
	const buildConnector$3 = require_connect();
	const { kUrl: kUrl$3, kReset, kServerName, kClient: kClient$1, kBusy: kBusy$1, kParser, kConnect, kBlocking, kResuming, kRunning: kRunning$3, kPending: kPending$2, kSize: kSize$4, kWriting, kQueue: kQueue$1, kConnected: kConnected$5, kConnecting, kNeedDrain: kNeedDrain$3, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError: kError$4, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections: kMaxRedirections$1, kMaxRequests, kCounter, kClose: kClose$5, kDestroy: kDestroy$3, kDispatch: kDispatch$2, kInterceptors: kInterceptors$4, kLocalAddress, kMaxResponseSize, kHTTPConnVersion, kHost, kHTTP2Session, kHTTP2SessionState, kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols$4();
	/** @type {import('http2')} */
	let http2;
	try {
		http2 = require("http2");
	} catch {
		http2 = { constants: {} };
	}
	const { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;
	let h2ExperimentalWarned = false;
	const FastBuffer$3 = Buffer[Symbol.species];
	const kClosedResolve$1 = Symbol("kClosedResolve");
	const channels$2 = {};
	try {
		const diagnosticsChannel$2 = require("diagnostics_channel");
		channels$2.sendHeaders = diagnosticsChannel$2.channel("undici:client:sendHeaders");
		channels$2.beforeConnect = diagnosticsChannel$2.channel("undici:client:beforeConnect");
		channels$2.connectError = diagnosticsChannel$2.channel("undici:client:connectError");
		channels$2.connected = diagnosticsChannel$2.channel("undici:client:connected");
	} catch {
		channels$2.sendHeaders = { hasSubscribers: false };
		channels$2.beforeConnect = { hasSubscribers: false };
		channels$2.connectError = { hasSubscribers: false };
		channels$2.connected = { hasSubscribers: false };
	}
	/**
	* @type {import('../types/client').default}
	*/
	var Client$4 = class extends DispatcherBase$3 {
		/**
		*
		* @param {string|URL} url
		* @param {import('../types/client').Client.Options} options
		*/
		constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout: requestTimeout$1, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls: tls$4, strictContentLength, maxCachedSessions, maxRedirections, connect: connect$2, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, maxConcurrentStreams } = {}) {
			super();
			if (keepAlive !== void 0) throw new InvalidArgumentError$16("unsupported keepAlive, use pipelining=0 instead");
			if (socketTimeout !== void 0) throw new InvalidArgumentError$16("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
			if (requestTimeout$1 !== void 0) throw new InvalidArgumentError$16("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
			if (idleTimeout !== void 0) throw new InvalidArgumentError$16("unsupported idleTimeout, use keepAliveTimeout instead");
			if (maxKeepAliveTimeout !== void 0) throw new InvalidArgumentError$16("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
			if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) throw new InvalidArgumentError$16("invalid maxHeaderSize");
			if (socketPath != null && typeof socketPath !== "string") throw new InvalidArgumentError$16("invalid socketPath");
			if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new InvalidArgumentError$16("invalid connectTimeout");
			if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new InvalidArgumentError$16("invalid keepAliveTimeout");
			if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new InvalidArgumentError$16("invalid keepAliveMaxTimeout");
			if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) throw new InvalidArgumentError$16("invalid keepAliveTimeoutThreshold");
			if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$16("headersTimeout must be a positive integer or zero");
			if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$16("bodyTimeout must be a positive integer or zero");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$16("connect must be a function or an object");
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$16("maxRedirections must be a positive number");
			if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new InvalidArgumentError$16("maxRequestsPerClient must be a positive number");
			if (localAddress != null && (typeof localAddress !== "string" || net$3.isIP(localAddress) === 0)) throw new InvalidArgumentError$16("localAddress must be valid string IP address");
			if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new InvalidArgumentError$16("maxResponseSize must be a positive number");
			if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new InvalidArgumentError$16("autoSelectFamilyAttemptTimeout must be a positive number");
			if (allowH2 != null && typeof allowH2 !== "boolean") throw new InvalidArgumentError$16("allowH2 must be a valid boolean value");
			if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) throw new InvalidArgumentError$16("maxConcurrentStreams must be a possitive integer, greater than 0");
			if (typeof connect$2 !== "function") connect$2 = buildConnector$3({
				...tls$4,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util$18.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect$2
			});
			this[kInterceptors$4] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor$2({ maxRedirections })];
			this[kUrl$3] = util$18.parseOrigin(url);
			this[kConnector] = connect$2;
			this[kSocket] = null;
			this[kPipelining] = pipelining != null ? pipelining : 1;
			this[kMaxHeadersSize] = maxHeaderSize || http$7.maxHeaderSize;
			this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
			this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
			this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
			this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
			this[kServerName] = null;
			this[kLocalAddress] = localAddress != null ? localAddress : null;
			this[kResuming] = 0;
			this[kNeedDrain$3] = 0;
			this[kHostHeader] = `host: ${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}\r\n`;
			this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
			this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
			this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
			this[kMaxRedirections$1] = maxRedirections;
			this[kMaxRequests] = maxRequestsPerClient;
			this[kClosedResolve$1] = null;
			this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
			this[kHTTPConnVersion] = "h1";
			this[kHTTP2Session] = null;
			this[kHTTP2SessionState] = !allowH2 ? null : {
				openStreams: 0,
				maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
			};
			this[kHost] = `${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}`;
			this[kQueue$1] = [];
			this[kRunningIdx] = 0;
			this[kPendingIdx] = 0;
		}
		get pipelining() {
			return this[kPipelining];
		}
		set pipelining(value) {
			this[kPipelining] = value;
			resume$2(this, true);
		}
		get [kPending$2]() {
			return this[kQueue$1].length - this[kPendingIdx];
		}
		get [kRunning$3]() {
			return this[kPendingIdx] - this[kRunningIdx];
		}
		get [kSize$4]() {
			return this[kQueue$1].length - this[kRunningIdx];
		}
		get [kConnected$5]() {
			return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
		}
		get [kBusy$1]() {
			const socket = this[kSocket];
			return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize$4] >= (this[kPipelining] || 1) || this[kPending$2] > 0;
		}
		/* istanbul ignore: only used for test */
		[kConnect](cb) {
			connect$1(this);
			this.once("connect", cb);
		}
		[kDispatch$2](opts, handler$1) {
			const origin = opts.origin || this[kUrl$3].origin;
			const request$3 = this[kHTTPConnVersion] === "h2" ? Request$4[kHTTP2BuildRequest](origin, opts, handler$1) : Request$4[kHTTP1BuildRequest](origin, opts, handler$1);
			this[kQueue$1].push(request$3);
			if (this[kResuming]) {} else if (util$18.bodyLength(request$3.body) == null && util$18.isIterable(request$3.body)) {
				this[kResuming] = 1;
				process.nextTick(resume$2, this);
			} else resume$2(this, true);
			if (this[kResuming] && this[kNeedDrain$3] !== 2 && this[kBusy$1]) this[kNeedDrain$3] = 2;
			return this[kNeedDrain$3] < 2;
		}
		async [kClose$5]() {
			return new Promise((resolve) => {
				if (!this[kSize$4]) resolve(null);
				else this[kClosedResolve$1] = resolve;
			});
		}
		async [kDestroy$3](err) {
			return new Promise((resolve) => {
				const requests = this[kQueue$1].splice(this[kPendingIdx]);
				for (let i$2 = 0; i$2 < requests.length; i$2++) {
					const request$3 = requests[i$2];
					errorRequest(this, request$3, err);
				}
				const callback = () => {
					if (this[kClosedResolve$1]) {
						this[kClosedResolve$1]();
						this[kClosedResolve$1] = null;
					}
					resolve();
				};
				if (this[kHTTP2Session] != null) {
					util$18.destroy(this[kHTTP2Session], err);
					this[kHTTP2Session] = null;
					this[kHTTP2SessionState] = null;
				}
				if (!this[kSocket]) queueMicrotask(callback);
				else util$18.destroy(this[kSocket].on("close", callback), err);
				resume$2(this);
			});
		}
	};
	function onHttp2SessionError(err) {
		assert$12(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		this[kSocket][kError$4] = err;
		onError$1(this[kClient$1], err);
	}
	function onHttp2FrameError(type, code$1, id) {
		const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code$1}`);
		if (id === 0) {
			this[kSocket][kError$4] = err;
			onError$1(this[kClient$1], err);
		}
	}
	function onHttp2SessionEnd() {
		util$18.destroy(this, new SocketError$2("other side closed"));
		util$18.destroy(this[kSocket], new SocketError$2("other side closed"));
	}
	function onHTTP2GoAway(code$1) {
		const client = this[kClient$1];
		const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code$1}`);
		client[kSocket] = null;
		client[kHTTP2Session] = null;
		if (client.destroyed) {
			assert$12(this[kPending$2] === 0);
			const requests = client[kQueue$1].splice(client[kRunningIdx]);
			for (let i$2 = 0; i$2 < requests.length; i$2++) {
				const request$3 = requests[i$2];
				errorRequest(this, request$3, err);
			}
		} else if (client[kRunning$3] > 0) {
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			client[kQueue$1][client[kRunningIdx]++] = null;
			errorRequest(client, request$3, err);
		}
		client[kPendingIdx] = client[kRunningIdx];
		assert$12(client[kRunning$3] === 0);
		client.emit("disconnect", client[kUrl$3], [client], err);
		resume$2(client);
	}
	const constants = require_constants$3();
	const createRedirectInterceptor$2 = require_redirectInterceptor();
	const EMPTY_BUF = Buffer.alloc(0);
	async function lazyllhttp() {
		const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
		let mod;
		try {
			mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
		} catch (e$1) {
			/* istanbul ignore next */
			mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
		}
		return await WebAssembly.instantiate(mod, { env: {
			wasm_on_url: (p, at, len$1) => {
				/* istanbul ignore next */
				return 0;
			},
			wasm_on_status: (p, at, len$1) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start = at - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onStatus(new FastBuffer$3(currentBufferRef.buffer, start, len$1)) || 0;
			},
			wasm_on_message_begin: (p) => {
				assert$12.strictEqual(currentParser.ptr, p);
				return currentParser.onMessageBegin() || 0;
			},
			wasm_on_header_field: (p, at, len$1) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start = at - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderField(new FastBuffer$3(currentBufferRef.buffer, start, len$1)) || 0;
			},
			wasm_on_header_value: (p, at, len$1) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start = at - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderValue(new FastBuffer$3(currentBufferRef.buffer, start, len$1)) || 0;
			},
			wasm_on_headers_complete: (p, statusCode, upgrade$1, shouldKeepAlive) => {
				assert$12.strictEqual(currentParser.ptr, p);
				return currentParser.onHeadersComplete(statusCode, Boolean(upgrade$1), Boolean(shouldKeepAlive)) || 0;
			},
			wasm_on_body: (p, at, len$1) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start = at - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onBody(new FastBuffer$3(currentBufferRef.buffer, start, len$1)) || 0;
			},
			wasm_on_message_complete: (p) => {
				assert$12.strictEqual(currentParser.ptr, p);
				return currentParser.onMessageComplete() || 0;
			}
		} });
	}
	let llhttpInstance = null;
	let llhttpPromise = lazyllhttp();
	llhttpPromise.catch();
	let currentParser = null;
	let currentBufferRef = null;
	let currentBufferSize = 0;
	let currentBufferPtr = null;
	const TIMEOUT_HEADERS = 1;
	const TIMEOUT_BODY = 2;
	const TIMEOUT_IDLE = 3;
	var Parser = class {
		constructor(client, socket, { exports: exports$1 }) {
			assert$12(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
			this.llhttp = exports$1;
			this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
			this.client = client;
			this.socket = socket;
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.statusCode = null;
			this.statusText = "";
			this.upgrade = false;
			this.headers = [];
			this.headersSize = 0;
			this.headersMaxSize = client[kMaxHeadersSize];
			this.shouldKeepAlive = false;
			this.paused = false;
			this.resume = this.resume.bind(this);
			this.bytesRead = 0;
			this.keepAlive = "";
			this.contentLength = "";
			this.connection = "";
			this.maxResponseSize = client[kMaxResponseSize];
		}
		setTimeout(value, type) {
			this.timeoutType = type;
			if (value !== this.timeoutValue) {
				timers.clearTimeout(this.timeout);
				if (value) {
					this.timeout = timers.setTimeout(onParserTimeout, value, this);
					// istanbul ignore else: only for jest
					if (this.timeout.unref) this.timeout.unref();
				} else this.timeout = null;
				this.timeoutValue = value;
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
		}
		resume() {
			if (this.socket.destroyed || !this.paused) return;
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			this.llhttp.llhttp_resume(this.ptr);
			assert$12(this.timeoutType === TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			this.paused = false;
			this.execute(this.socket.read() || EMPTY_BUF);
			this.readMore();
		}
		readMore() {
			while (!this.paused && this.ptr) {
				const chunk = this.socket.read();
				if (chunk === null) break;
				this.execute(chunk);
			}
		}
		execute(data) {
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			assert$12(!this.paused);
			const { socket, llhttp } = this;
			if (data.length > currentBufferSize) {
				if (currentBufferPtr) llhttp.free(currentBufferPtr);
				currentBufferSize = Math.ceil(data.length / 4096) * 4096;
				currentBufferPtr = llhttp.malloc(currentBufferSize);
			}
			new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
			try {
				let ret;
				try {
					currentBufferRef = data;
					currentParser = this;
					ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
				} catch (err) {
					/* istanbul ignore next: difficult to make a test case for */
					throw err;
				} finally {
					currentParser = null;
					currentBufferRef = null;
				}
				const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
				if (ret === constants.ERROR.PAUSED_UPGRADE) this.onUpgrade(data.slice(offset));
				else if (ret === constants.ERROR.PAUSED) {
					this.paused = true;
					socket.unshift(data.slice(offset));
				} else if (ret !== constants.ERROR.OK) {
					const ptr = llhttp.llhttp_get_error_reason(this.ptr);
					let message = "";
					/* istanbul ignore else: difficult to make a test case for */
					if (ptr) {
						const len$1 = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
						message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len$1).toString() + ")";
					}
					throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
				}
			} catch (err) {
				util$18.destroy(socket, err);
			}
		}
		destroy() {
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			this.llhttp.llhttp_free(this.ptr);
			this.ptr = null;
			timers.clearTimeout(this.timeout);
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.paused = false;
		}
		onStatus(buf) {
			this.statusText = buf.toString();
		}
		onMessageBegin() {
			const { socket, client } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			if (!client[kQueue$1][client[kRunningIdx]]) return -1;
		}
		onHeaderField(buf) {
			const len$1 = this.headers.length;
			if ((len$1 & 1) === 0) this.headers.push(buf);
			else this.headers[len$1 - 1] = Buffer.concat([this.headers[len$1 - 1], buf]);
			this.trackHeader(buf.length);
		}
		onHeaderValue(buf) {
			let len$1 = this.headers.length;
			if ((len$1 & 1) === 1) {
				this.headers.push(buf);
				len$1 += 1;
			} else this.headers[len$1 - 1] = Buffer.concat([this.headers[len$1 - 1], buf]);
			const key = this.headers[len$1 - 2];
			if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") this.keepAlive += buf.toString();
			else if (key.length === 10 && key.toString().toLowerCase() === "connection") this.connection += buf.toString();
			else if (key.length === 14 && key.toString().toLowerCase() === "content-length") this.contentLength += buf.toString();
			this.trackHeader(buf.length);
		}
		trackHeader(len$1) {
			this.headersSize += len$1;
			if (this.headersSize >= this.headersMaxSize) util$18.destroy(this.socket, new HeadersOverflowError());
		}
		onUpgrade(head) {
			const { upgrade: upgrade$1, client, socket, headers, statusCode } = this;
			assert$12(upgrade$1);
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			assert$12(request$3);
			assert$12(!socket.destroyed);
			assert$12(socket === client[kSocket]);
			assert$12(!this.paused);
			assert$12(request$3.upgrade || request$3.method === "CONNECT");
			this.statusCode = null;
			this.statusText = "";
			this.shouldKeepAlive = null;
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			socket.unshift(head);
			socket[kParser].destroy();
			socket[kParser] = null;
			socket[kClient$1] = null;
			socket[kError$4] = null;
			socket.removeListener("error", onSocketError$1).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose$1);
			client[kSocket] = null;
			client[kQueue$1][client[kRunningIdx]++] = null;
			client.emit("disconnect", client[kUrl$3], [client], new InformationalError("upgrade"));
			try {
				request$3.onUpgrade(statusCode, headers, socket);
			} catch (err) {
				util$18.destroy(socket, err);
			}
			resume$2(client);
		}
		onHeadersComplete(statusCode, upgrade$1, shouldKeepAlive) {
			const { client, socket, headers, statusText } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			/* istanbul ignore next: difficult to make a test case for */
			if (!request$3) return -1;
			assert$12(!this.upgrade);
			assert$12(this.statusCode < 200);
			if (statusCode === 100) {
				util$18.destroy(socket, new SocketError$2("bad response", util$18.getSocketInfo(socket)));
				return -1;
			}
			if (upgrade$1 && !request$3.upgrade) {
				util$18.destroy(socket, new SocketError$2("bad upgrade", util$18.getSocketInfo(socket)));
				return -1;
			}
			assert$12.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
			this.statusCode = statusCode;
			this.shouldKeepAlive = shouldKeepAlive || request$3.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
			if (this.statusCode >= 200) {
				const bodyTimeout = request$3.bodyTimeout != null ? request$3.bodyTimeout : client[kBodyTimeout];
				this.setTimeout(bodyTimeout, TIMEOUT_BODY);
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			if (request$3.method === "CONNECT") {
				assert$12(client[kRunning$3] === 1);
				this.upgrade = true;
				return 2;
			}
			if (upgrade$1) {
				assert$12(client[kRunning$3] === 1);
				this.upgrade = true;
				return 2;
			}
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (this.shouldKeepAlive && client[kPipelining]) {
				const keepAliveTimeout = this.keepAlive ? util$18.parseKeepAliveTimeout(this.keepAlive) : null;
				if (keepAliveTimeout != null) {
					const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
					if (timeout <= 0) socket[kReset] = true;
					else client[kKeepAliveTimeoutValue] = timeout;
				} else client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
			} else socket[kReset] = true;
			const pause = request$3.onHeaders(statusCode, headers, this.resume, statusText) === false;
			if (request$3.aborted) return -1;
			if (request$3.method === "HEAD") return 1;
			if (statusCode < 200) return 1;
			if (socket[kBlocking]) {
				socket[kBlocking] = false;
				resume$2(client);
			}
			return pause ? constants.ERROR.PAUSED : 0;
		}
		onBody(buf) {
			const { client, socket, statusCode, maxResponseSize } = this;
			if (socket.destroyed) return -1;
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			assert$12(request$3);
			assert$12.strictEqual(this.timeoutType, TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			assert$12(statusCode >= 200);
			if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
				util$18.destroy(socket, new ResponseExceededMaxSizeError());
				return -1;
			}
			this.bytesRead += buf.length;
			if (request$3.onData(buf) === false) return constants.ERROR.PAUSED;
		}
		onMessageComplete() {
			const { client, socket, statusCode, upgrade: upgrade$1, headers, contentLength, bytesRead, shouldKeepAlive } = this;
			if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;
			if (upgrade$1) return;
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			assert$12(request$3);
			assert$12(statusCode >= 100);
			this.statusCode = null;
			this.statusText = "";
			this.bytesRead = 0;
			this.contentLength = "";
			this.keepAlive = "";
			this.connection = "";
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (statusCode < 200) return;
			/* istanbul ignore next: should be handled by llhttp? */
			if (request$3.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
				util$18.destroy(socket, new ResponseContentLengthMismatchError());
				return -1;
			}
			request$3.onComplete(headers);
			client[kQueue$1][client[kRunningIdx]++] = null;
			if (socket[kWriting]) {
				assert$12.strictEqual(client[kRunning$3], 0);
				util$18.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (!shouldKeepAlive) {
				util$18.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (socket[kReset] && client[kRunning$3] === 0) {
				util$18.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (client[kPipelining] === 1) setImmediate(resume$2, client);
			else resume$2(client);
		}
	};
	function onParserTimeout(parser) {
		const { socket, timeoutType, client } = parser;
		/* istanbul ignore else */
		if (timeoutType === TIMEOUT_HEADERS) {
			if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning$3] > 1) {
				assert$12(!parser.paused, "cannot be paused while waiting for headers");
				util$18.destroy(socket, new HeadersTimeoutError());
			}
		} else if (timeoutType === TIMEOUT_BODY) {
			if (!parser.paused) util$18.destroy(socket, new BodyTimeoutError());
		} else if (timeoutType === TIMEOUT_IDLE) {
			assert$12(client[kRunning$3] === 0 && client[kKeepAliveTimeoutValue]);
			util$18.destroy(socket, new InformationalError("socket idle timeout"));
		}
	}
	function onSocketReadable() {
		const { [kParser]: parser } = this;
		if (parser) parser.readMore();
	}
	function onSocketError$1(err) {
		const { [kClient$1]: client, [kParser]: parser } = this;
		assert$12(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		if (client[kHTTPConnVersion] !== "h2") {
			if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
				parser.onMessageComplete();
				return;
			}
		}
		this[kError$4] = err;
		onError$1(this[kClient$1], err);
	}
	function onError$1(client, err) {
		if (client[kRunning$3] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
			assert$12(client[kPendingIdx] === client[kRunningIdx]);
			const requests = client[kQueue$1].splice(client[kRunningIdx]);
			for (let i$2 = 0; i$2 < requests.length; i$2++) {
				const request$3 = requests[i$2];
				errorRequest(client, request$3, err);
			}
			assert$12(client[kSize$4] === 0);
		}
	}
	function onSocketEnd() {
		const { [kParser]: parser, [kClient$1]: client } = this;
		if (client[kHTTPConnVersion] !== "h2") {
			if (parser.statusCode && !parser.shouldKeepAlive) {
				parser.onMessageComplete();
				return;
			}
		}
		util$18.destroy(this, new SocketError$2("other side closed", util$18.getSocketInfo(this)));
	}
	function onSocketClose$1() {
		const { [kClient$1]: client, [kParser]: parser } = this;
		if (client[kHTTPConnVersion] === "h1" && parser) {
			if (!this[kError$4] && parser.statusCode && !parser.shouldKeepAlive) parser.onMessageComplete();
			this[kParser].destroy();
			this[kParser] = null;
		}
		const err = this[kError$4] || new SocketError$2("closed", util$18.getSocketInfo(this));
		client[kSocket] = null;
		if (client.destroyed) {
			assert$12(client[kPending$2] === 0);
			const requests = client[kQueue$1].splice(client[kRunningIdx]);
			for (let i$2 = 0; i$2 < requests.length; i$2++) {
				const request$3 = requests[i$2];
				errorRequest(client, request$3, err);
			}
		} else if (client[kRunning$3] > 0 && err.code !== "UND_ERR_INFO") {
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			client[kQueue$1][client[kRunningIdx]++] = null;
			errorRequest(client, request$3, err);
		}
		client[kPendingIdx] = client[kRunningIdx];
		assert$12(client[kRunning$3] === 0);
		client.emit("disconnect", client[kUrl$3], [client], err);
		resume$2(client);
	}
	async function connect$1(client) {
		assert$12(!client[kConnecting]);
		assert$12(!client[kSocket]);
		let { host, hostname, protocol, port } = client[kUrl$3];
		if (hostname[0] === "[") {
			const idx = hostname.indexOf("]");
			assert$12(idx !== -1);
			const ip = hostname.substring(1, idx);
			assert$12(net$3.isIP(ip));
			hostname = ip;
		}
		client[kConnecting] = true;
		if (channels$2.beforeConnect.hasSubscribers) channels$2.beforeConnect.publish({
			connectParams: {
				host,
				hostname,
				protocol,
				port,
				servername: client[kServerName],
				localAddress: client[kLocalAddress]
			},
			connector: client[kConnector]
		});
		try {
			const socket = await new Promise((resolve, reject) => {
				client[kConnector]({
					host,
					hostname,
					protocol,
					port,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				}, (err, socket$1) => {
					if (err) reject(err);
					else resolve(socket$1);
				});
			});
			if (client.destroyed) {
				util$18.destroy(socket.on("error", () => {}), new ClientDestroyedError());
				return;
			}
			client[kConnecting] = false;
			assert$12(socket);
			if (socket.alpnProtocol === "h2") {
				if (!h2ExperimentalWarned) {
					h2ExperimentalWarned = true;
					process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" });
				}
				const session = http2.connect(client[kUrl$3], {
					createConnection: () => socket,
					peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
				});
				client[kHTTPConnVersion] = "h2";
				session[kClient$1] = client;
				session[kSocket] = socket;
				session.on("error", onHttp2SessionError);
				session.on("frameError", onHttp2FrameError);
				session.on("end", onHttp2SessionEnd);
				session.on("goaway", onHTTP2GoAway);
				session.on("close", onSocketClose$1);
				session.unref();
				client[kHTTP2Session] = session;
				socket[kHTTP2Session] = session;
			} else {
				if (!llhttpInstance) {
					llhttpInstance = await llhttpPromise;
					llhttpPromise = null;
				}
				socket[kNoRef] = false;
				socket[kWriting] = false;
				socket[kReset] = false;
				socket[kBlocking] = false;
				socket[kParser] = new Parser(client, socket, llhttpInstance);
			}
			socket[kCounter] = 0;
			socket[kMaxRequests] = client[kMaxRequests];
			socket[kClient$1] = client;
			socket[kError$4] = null;
			socket.on("error", onSocketError$1).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose$1);
			client[kSocket] = socket;
			if (channels$2.connected.hasSubscribers) channels$2.connected.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				},
				connector: client[kConnector],
				socket
			});
			client.emit("connect", client[kUrl$3], [client]);
		} catch (err) {
			if (client.destroyed) return;
			client[kConnecting] = false;
			if (channels$2.connectError.hasSubscribers) channels$2.connectError.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				},
				connector: client[kConnector],
				error: err
			});
			if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
				assert$12(client[kRunning$3] === 0);
				while (client[kPending$2] > 0 && client[kQueue$1][client[kPendingIdx]].servername === client[kServerName]) {
					const request$3 = client[kQueue$1][client[kPendingIdx]++];
					errorRequest(client, request$3, err);
				}
			} else onError$1(client, err);
			client.emit("connectionError", client[kUrl$3], [client], err);
		}
		resume$2(client);
	}
	function emitDrain(client) {
		client[kNeedDrain$3] = 0;
		client.emit("drain", client[kUrl$3], [client]);
	}
	function resume$2(client, sync) {
		if (client[kResuming] === 2) return;
		client[kResuming] = 2;
		_resume(client, sync);
		client[kResuming] = 0;
		if (client[kRunningIdx] > 256) {
			client[kQueue$1].splice(0, client[kRunningIdx]);
			client[kPendingIdx] -= client[kRunningIdx];
			client[kRunningIdx] = 0;
		}
	}
	function _resume(client, sync) {
		while (true) {
			if (client.destroyed) {
				assert$12(client[kPending$2] === 0);
				return;
			}
			if (client[kClosedResolve$1] && !client[kSize$4]) {
				client[kClosedResolve$1]();
				client[kClosedResolve$1] = null;
				return;
			}
			const socket = client[kSocket];
			if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
				if (client[kSize$4] === 0) {
					if (!socket[kNoRef] && socket.unref) {
						socket.unref();
						socket[kNoRef] = true;
					}
				} else if (socket[kNoRef] && socket.ref) {
					socket.ref();
					socket[kNoRef] = false;
				}
				if (client[kSize$4] === 0) {
					if (socket[kParser].timeoutType !== TIMEOUT_IDLE) socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
				} else if (client[kRunning$3] > 0 && socket[kParser].statusCode < 200) {
					if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
						const request$4 = client[kQueue$1][client[kRunningIdx]];
						const headersTimeout = request$4.headersTimeout != null ? request$4.headersTimeout : client[kHeadersTimeout];
						socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
					}
				}
			}
			if (client[kBusy$1]) client[kNeedDrain$3] = 2;
			else if (client[kNeedDrain$3] === 2) {
				if (sync) {
					client[kNeedDrain$3] = 1;
					process.nextTick(emitDrain, client);
				} else emitDrain(client);
				continue;
			}
			if (client[kPending$2] === 0) return;
			if (client[kRunning$3] >= (client[kPipelining] || 1)) return;
			const request$3 = client[kQueue$1][client[kPendingIdx]];
			if (client[kUrl$3].protocol === "https:" && client[kServerName] !== request$3.servername) {
				if (client[kRunning$3] > 0) return;
				client[kServerName] = request$3.servername;
				if (socket && socket.servername !== request$3.servername) {
					util$18.destroy(socket, new InformationalError("servername changed"));
					return;
				}
			}
			if (client[kConnecting]) return;
			if (!socket && !client[kHTTP2Session]) {
				connect$1(client);
				return;
			}
			if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) return;
			if (client[kRunning$3] > 0 && !request$3.idempotent) return;
			if (client[kRunning$3] > 0 && (request$3.upgrade || request$3.method === "CONNECT")) return;
			if (client[kRunning$3] > 0 && util$18.bodyLength(request$3.body) !== 0 && (util$18.isStream(request$3.body) || util$18.isAsyncIterable(request$3.body))) return;
			if (!request$3.aborted && write(client, request$3)) client[kPendingIdx]++;
			else client[kQueue$1].splice(client[kPendingIdx], 1);
		}
	}
	function shouldSendContentLength(method) {
		return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
	}
	function write(client, request$3) {
		if (client[kHTTPConnVersion] === "h2") {
			writeH2(client, client[kHTTP2Session], request$3);
			return;
		}
		const { body, method, path: path$9, host, upgrade: upgrade$1, headers, blocking, reset } = request$3;
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		const bodyLength$1 = util$18.bodyLength(body);
		let contentLength = bodyLength$1;
		if (contentLength === null) contentLength = request$3.contentLength;
		if (contentLength === 0 && !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$3.contentLength !== null && request$3.contentLength !== contentLength) {
			if (client[kStrictContentLength]) {
				errorRequest(client, request$3, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		const socket = client[kSocket];
		try {
			request$3.onConnect((err) => {
				if (request$3.aborted || request$3.completed) return;
				errorRequest(client, request$3, err || new RequestAbortedError$8());
				util$18.destroy(socket, new InformationalError("aborted"));
			});
		} catch (err) {
			errorRequest(client, request$3, err);
		}
		if (request$3.aborted) return false;
		if (method === "HEAD") socket[kReset] = true;
		if (upgrade$1 || method === "CONNECT") socket[kReset] = true;
		if (reset != null) socket[kReset] = reset;
		if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) socket[kReset] = true;
		if (blocking) socket[kBlocking] = true;
		let header = `${method} ${path$9} HTTP/1.1\r\n`;
		if (typeof host === "string") header += `host: ${host}\r\n`;
		else header += client[kHostHeader];
		if (upgrade$1) header += `connection: upgrade\r\nupgrade: ${upgrade$1}\r\n`;
		else if (client[kPipelining] && !socket[kReset]) header += "connection: keep-alive\r\n";
		else header += "connection: close\r\n";
		if (headers) header += headers;
		if (channels$2.sendHeaders.hasSubscribers) channels$2.sendHeaders.publish({
			request: request$3,
			headers: header,
			socket
		});
		/* istanbul ignore else: assertion */
		if (!body || bodyLength$1 === 0) {
			if (contentLength === 0) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else {
				assert$12(contentLength === null, "no body must not have content length");
				socket.write(`${header}\r\n`, "latin1");
			}
			request$3.onRequestSent();
		} else if (util$18.isBuffer(body)) {
			assert$12(contentLength === body.byteLength, "buffer body must have content length");
			socket.cork();
			socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			socket.write(body);
			socket.uncork();
			request$3.onBodySent(body);
			request$3.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
		} else if (util$18.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
			body: body.stream(),
			client,
			request: request$3,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else writeBlob({
			body,
			client,
			request: request$3,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util$18.isStream(body)) writeStream({
			body,
			client,
			request: request$3,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util$18.isIterable(body)) writeIterable({
			body,
			client,
			request: request$3,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else assert$12(false);
		return true;
	}
	function writeH2(client, session, request$3) {
		const { body, method, path: path$9, host, upgrade: upgrade$1, expectContinue, signal, headers: reqHeaders } = request$3;
		let headers;
		if (typeof reqHeaders === "string") headers = Request$4[kHTTP2CopyHeaders](reqHeaders.trim());
		else headers = reqHeaders;
		if (upgrade$1) {
			errorRequest(client, request$3, /* @__PURE__ */ new Error("Upgrade not supported for H2"));
			return false;
		}
		try {
			request$3.onConnect((err) => {
				if (request$3.aborted || request$3.completed) return;
				errorRequest(client, request$3, err || new RequestAbortedError$8());
			});
		} catch (err) {
			errorRequest(client, request$3, err);
		}
		if (request$3.aborted) return false;
		/** @type {import('node:http2').ClientHttp2Stream} */
		let stream$6;
		const h2State = client[kHTTP2SessionState];
		headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
		headers[HTTP2_HEADER_METHOD] = method;
		if (method === "CONNECT") {
			session.ref();
			stream$6 = session.request(headers, {
				endStream: false,
				signal
			});
			if (stream$6.id && !stream$6.pending) {
				request$3.onUpgrade(null, null, stream$6);
				++h2State.openStreams;
			} else stream$6.once("ready", () => {
				request$3.onUpgrade(null, null, stream$6);
				++h2State.openStreams;
			});
			stream$6.once("close", () => {
				h2State.openStreams -= 1;
				if (h2State.openStreams === 0) session.unref();
			});
			return true;
		}
		headers[HTTP2_HEADER_PATH] = path$9;
		headers[HTTP2_HEADER_SCHEME] = "https";
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		let contentLength = util$18.bodyLength(body);
		if (contentLength == null) contentLength = request$3.contentLength;
		if (contentLength === 0 || !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$3.contentLength != null && request$3.contentLength !== contentLength) {
			if (client[kStrictContentLength]) {
				errorRequest(client, request$3, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		if (contentLength != null) {
			assert$12(body, "no body must not have content length");
			headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
		}
		session.ref();
		const shouldEndStream = method === "GET" || method === "HEAD";
		if (expectContinue) {
			headers[HTTP2_HEADER_EXPECT] = "100-continue";
			stream$6 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			stream$6.once("continue", writeBodyH2);
		} else {
			stream$6 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			writeBodyH2();
		}
		++h2State.openStreams;
		stream$6.once("response", (headers$1) => {
			const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers$1;
			if (request$3.onHeaders(Number(statusCode), realHeaders, stream$6.resume.bind(stream$6), "") === false) stream$6.pause();
		});
		stream$6.once("end", () => {
			request$3.onComplete([]);
		});
		stream$6.on("data", (chunk) => {
			if (request$3.onData(chunk) === false) stream$6.pause();
		});
		stream$6.once("close", () => {
			h2State.openStreams -= 1;
			if (h2State.openStreams === 0) session.unref();
		});
		stream$6.once("error", function(err) {
			if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util$18.destroy(stream$6, err);
			}
		});
		stream$6.once("frameError", (type, code$1) => {
			const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code$1}`);
			errorRequest(client, request$3, err);
			if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util$18.destroy(stream$6, err);
			}
		});
		return true;
		function writeBodyH2() {
			/* istanbul ignore else: assertion */
			if (!body) request$3.onRequestSent();
			else if (util$18.isBuffer(body)) {
				assert$12(contentLength === body.byteLength, "buffer body must have content length");
				stream$6.cork();
				stream$6.write(body);
				stream$6.uncork();
				stream$6.end();
				request$3.onBodySent(body);
				request$3.onRequestSent();
			} else if (util$18.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
				client,
				request: request$3,
				contentLength,
				h2stream: stream$6,
				expectsPayload,
				body: body.stream(),
				socket: client[kSocket],
				header: ""
			});
			else writeBlob({
				body,
				client,
				request: request$3,
				contentLength,
				expectsPayload,
				h2stream: stream$6,
				header: "",
				socket: client[kSocket]
			});
			else if (util$18.isStream(body)) writeStream({
				body,
				client,
				request: request$3,
				contentLength,
				expectsPayload,
				socket: client[kSocket],
				h2stream: stream$6,
				header: ""
			});
			else if (util$18.isIterable(body)) writeIterable({
				body,
				client,
				request: request$3,
				contentLength,
				expectsPayload,
				header: "",
				h2stream: stream$6,
				socket: client[kSocket]
			});
			else assert$12(false);
		}
	}
	function writeStream({ h2stream, body, client, request: request$3, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength !== 0 || client[kRunning$3] === 0, "stream body cannot be pipelined");
		if (client[kHTTPConnVersion] === "h2") {
			const pipe = pipeline$3(body, h2stream, (err) => {
				if (err) {
					util$18.destroy(body, err);
					util$18.destroy(h2stream, err);
				} else request$3.onRequestSent();
			});
			pipe.on("data", onPipeData);
			pipe.once("end", () => {
				pipe.removeListener("data", onPipeData);
				util$18.destroy(pipe);
			});
			function onPipeData(chunk) {
				request$3.onBodySent(chunk);
			}
			return;
		}
		let finished$2 = false;
		const writer = new AsyncWriter({
			socket,
			request: request$3,
			contentLength,
			client,
			expectsPayload,
			header
		});
		const onData = function(chunk) {
			if (finished$2) return;
			try {
				if (!writer.write(chunk) && this.pause) this.pause();
			} catch (err) {
				util$18.destroy(this, err);
			}
		};
		const onDrain = function() {
			if (finished$2) return;
			if (body.resume) body.resume();
		};
		const onAbort = function() {
			if (finished$2) return;
			const err = new RequestAbortedError$8();
			queueMicrotask(() => onFinished(err));
		};
		const onFinished = function(err) {
			if (finished$2) return;
			finished$2 = true;
			assert$12(socket.destroyed || socket[kWriting] && client[kRunning$3] <= 1);
			socket.off("drain", onDrain).off("error", onFinished);
			body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
			if (!err) try {
				writer.end();
			} catch (er) {
				err = er;
			}
			writer.destroy(err);
			if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) util$18.destroy(body, err);
			else util$18.destroy(body);
		};
		body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
		if (body.resume) body.resume();
		socket.on("drain", onDrain).on("error", onFinished);
	}
	async function writeBlob({ h2stream, body, client, request: request$3, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength === body.size, "blob body must have content length");
		const isH2 = client[kHTTPConnVersion] === "h2";
		try {
			if (contentLength != null && contentLength !== body.size) throw new RequestContentLengthMismatchError();
			const buffer$1 = Buffer.from(await body.arrayBuffer());
			if (isH2) {
				h2stream.cork();
				h2stream.write(buffer$1);
				h2stream.uncork();
			} else {
				socket.cork();
				socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
				socket.write(buffer$1);
				socket.uncork();
			}
			request$3.onBodySent(buffer$1);
			request$3.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
			resume$2(client);
		} catch (err) {
			util$18.destroy(isH2 ? h2stream : socket, err);
		}
	}
	async function writeIterable({ h2stream, body, client, request: request$3, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength !== 0 || client[kRunning$3] === 0, "iterator body cannot be pipelined");
		let callback = null;
		function onDrain() {
			if (callback) {
				const cb = callback;
				callback = null;
				cb();
			}
		}
		const waitForDrain = () => new Promise((resolve, reject) => {
			assert$12(callback === null);
			if (socket[kError$4]) reject(socket[kError$4]);
			else callback = resolve;
		});
		if (client[kHTTPConnVersion] === "h2") {
			h2stream.on("close", onDrain).on("drain", onDrain);
			try {
				for await (const chunk of body) {
					if (socket[kError$4]) throw socket[kError$4];
					const res = h2stream.write(chunk);
					request$3.onBodySent(chunk);
					if (!res) await waitForDrain();
				}
			} catch (err) {
				h2stream.destroy(err);
			} finally {
				request$3.onRequestSent();
				h2stream.end();
				h2stream.off("close", onDrain).off("drain", onDrain);
			}
			return;
		}
		socket.on("close", onDrain).on("drain", onDrain);
		const writer = new AsyncWriter({
			socket,
			request: request$3,
			contentLength,
			client,
			expectsPayload,
			header
		});
		try {
			for await (const chunk of body) {
				if (socket[kError$4]) throw socket[kError$4];
				if (!writer.write(chunk)) await waitForDrain();
			}
			writer.end();
		} catch (err) {
			writer.destroy(err);
		} finally {
			socket.off("close", onDrain).off("drain", onDrain);
		}
	}
	var AsyncWriter = class {
		constructor({ socket, request: request$3, contentLength, client, expectsPayload, header }) {
			this.socket = socket;
			this.request = request$3;
			this.contentLength = contentLength;
			this.client = client;
			this.bytesWritten = 0;
			this.expectsPayload = expectsPayload;
			this.header = header;
			socket[kWriting] = true;
		}
		write(chunk) {
			const { socket, request: request$3, contentLength, client, bytesWritten, expectsPayload, header } = this;
			if (socket[kError$4]) throw socket[kError$4];
			if (socket.destroyed) return false;
			const len$1 = Buffer.byteLength(chunk);
			if (!len$1) return true;
			if (contentLength !== null && bytesWritten + len$1 > contentLength) {
				if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
				process.emitWarning(new RequestContentLengthMismatchError());
			}
			socket.cork();
			if (bytesWritten === 0) {
				if (!expectsPayload) socket[kReset] = true;
				if (contentLength === null) socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
				else socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			}
			if (contentLength === null) socket.write(`\r\n${len$1.toString(16)}\r\n`, "latin1");
			this.bytesWritten += len$1;
			const ret = socket.write(chunk);
			socket.uncork();
			request$3.onBodySent(chunk);
			if (!ret) {
				if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
					// istanbul ignore else: only for jest
					if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
				}
			}
			return ret;
		}
		end() {
			const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request$3 } = this;
			request$3.onRequestSent();
			socket[kWriting] = false;
			if (socket[kError$4]) throw socket[kError$4];
			if (socket.destroyed) return;
			if (bytesWritten === 0) if (expectsPayload) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else socket.write(`${header}\r\n`, "latin1");
			else if (contentLength === null) socket.write("\r\n0\r\n\r\n", "latin1");
			if (contentLength !== null && bytesWritten !== contentLength) if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
			else process.emitWarning(new RequestContentLengthMismatchError());
			if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
				// istanbul ignore else: only for jest
				if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
			}
			resume$2(client);
		}
		destroy(err) {
			const { socket, client } = this;
			socket[kWriting] = false;
			if (err) {
				assert$12(client[kRunning$3] <= 1, "pipeline should only contain this request");
				util$18.destroy(socket, err);
			}
		}
	};
	function errorRequest(client, request$3, err) {
		try {
			request$3.onError(err);
			assert$12(request$3.aborted);
		} catch (err$1) {
			client.emit("error", err$1);
		}
	}
	module.exports = Client$4;
}));

//#endregion
//#region node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const kSize$3 = 2048;
	const kMask = kSize$3 - 1;
	var FixedCircularBuffer = class {
		constructor() {
			this.bottom = 0;
			this.top = 0;
			this.list = new Array(kSize$3);
			this.next = null;
		}
		isEmpty() {
			return this.top === this.bottom;
		}
		isFull() {
			return (this.top + 1 & kMask) === this.bottom;
		}
		push(data) {
			this.list[this.top] = data;
			this.top = this.top + 1 & kMask;
		}
		shift() {
			const nextItem = this.list[this.bottom];
			if (nextItem === void 0) return null;
			this.list[this.bottom] = void 0;
			this.bottom = this.bottom + 1 & kMask;
			return nextItem;
		}
	};
	module.exports = class FixedQueue$1 {
		constructor() {
			this.head = this.tail = new FixedCircularBuffer();
		}
		isEmpty() {
			return this.head.isEmpty();
		}
		push(data) {
			if (this.head.isFull()) this.head = this.head.next = new FixedCircularBuffer();
			this.head.push(data);
		}
		shift() {
			const tail = this.tail;
			const next = tail.shift();
			if (tail.isEmpty() && tail.next !== null) this.tail = tail.next;
			return next;
		}
	};
}));

//#endregion
//#region node_modules/undici/lib/pool-stats.js
var require_pool_stats = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kFree: kFree$1, kConnected: kConnected$4, kPending: kPending$1, kQueued: kQueued$1, kRunning: kRunning$2, kSize: kSize$2 } = require_symbols$4();
	const kPool = Symbol("pool");
	var PoolStats$1 = class {
		constructor(pool) {
			this[kPool] = pool;
		}
		get connected() {
			return this[kPool][kConnected$4];
		}
		get free() {
			return this[kPool][kFree$1];
		}
		get pending() {
			return this[kPool][kPending$1];
		}
		get queued() {
			return this[kPool][kQueued$1];
		}
		get running() {
			return this[kPool][kRunning$2];
		}
		get size() {
			return this[kPool][kSize$2];
		}
	};
	module.exports = PoolStats$1;
}));

//#endregion
//#region node_modules/undici/lib/pool-base.js
var require_pool_base = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const DispatcherBase$2 = require_dispatcher_base();
	const FixedQueue = require_fixed_queue();
	const { kConnected: kConnected$3, kSize: kSize$1, kRunning: kRunning$1, kPending, kQueued, kBusy, kFree, kUrl: kUrl$2, kClose: kClose$4, kDestroy: kDestroy$2, kDispatch: kDispatch$1 } = require_symbols$4();
	const PoolStats = require_pool_stats();
	const kClients$4 = Symbol("clients");
	const kNeedDrain$2 = Symbol("needDrain");
	const kQueue = Symbol("queue");
	const kClosedResolve = Symbol("closed resolve");
	const kOnDrain$1 = Symbol("onDrain");
	const kOnConnect$1 = Symbol("onConnect");
	const kOnDisconnect$1 = Symbol("onDisconnect");
	const kOnConnectionError$1 = Symbol("onConnectionError");
	const kGetDispatcher$2 = Symbol("get dispatcher");
	const kAddClient$2 = Symbol("add client");
	const kRemoveClient$1 = Symbol("remove client");
	const kStats = Symbol("stats");
	var PoolBase$2 = class extends DispatcherBase$2 {
		constructor() {
			super();
			this[kQueue] = new FixedQueue();
			this[kClients$4] = [];
			this[kQueued] = 0;
			const pool = this;
			this[kOnDrain$1] = function onDrain(origin, targets) {
				const queue = pool[kQueue];
				let needDrain = false;
				while (!needDrain) {
					const item = queue.shift();
					if (!item) break;
					pool[kQueued]--;
					needDrain = !this.dispatch(item.opts, item.handler);
				}
				this[kNeedDrain$2] = needDrain;
				if (!this[kNeedDrain$2] && pool[kNeedDrain$2]) {
					pool[kNeedDrain$2] = false;
					pool.emit("drain", origin, [pool, ...targets]);
				}
				if (pool[kClosedResolve] && queue.isEmpty()) Promise.all(pool[kClients$4].map((c) => c.close())).then(pool[kClosedResolve]);
			};
			this[kOnConnect$1] = (origin, targets) => {
				pool.emit("connect", origin, [pool, ...targets]);
			};
			this[kOnDisconnect$1] = (origin, targets, err) => {
				pool.emit("disconnect", origin, [pool, ...targets], err);
			};
			this[kOnConnectionError$1] = (origin, targets, err) => {
				pool.emit("connectionError", origin, [pool, ...targets], err);
			};
			this[kStats] = new PoolStats(this);
		}
		get [kBusy]() {
			return this[kNeedDrain$2];
		}
		get [kConnected$3]() {
			return this[kClients$4].filter((client) => client[kConnected$3]).length;
		}
		get [kFree]() {
			return this[kClients$4].filter((client) => client[kConnected$3] && !client[kNeedDrain$2]).length;
		}
		get [kPending]() {
			let ret = this[kQueued];
			for (const { [kPending]: pending } of this[kClients$4]) ret += pending;
			return ret;
		}
		get [kRunning$1]() {
			let ret = 0;
			for (const { [kRunning$1]: running } of this[kClients$4]) ret += running;
			return ret;
		}
		get [kSize$1]() {
			let ret = this[kQueued];
			for (const { [kSize$1]: size } of this[kClients$4]) ret += size;
			return ret;
		}
		get stats() {
			return this[kStats];
		}
		async [kClose$4]() {
			if (this[kQueue].isEmpty()) return Promise.all(this[kClients$4].map((c) => c.close()));
			else return new Promise((resolve) => {
				this[kClosedResolve] = resolve;
			});
		}
		async [kDestroy$2](err) {
			while (true) {
				const item = this[kQueue].shift();
				if (!item) break;
				item.handler.onError(err);
			}
			return Promise.all(this[kClients$4].map((c) => c.destroy(err)));
		}
		[kDispatch$1](opts, handler$1) {
			const dispatcher = this[kGetDispatcher$2]();
			if (!dispatcher) {
				this[kNeedDrain$2] = true;
				this[kQueue].push({
					opts,
					handler: handler$1
				});
				this[kQueued]++;
			} else if (!dispatcher.dispatch(opts, handler$1)) {
				dispatcher[kNeedDrain$2] = true;
				this[kNeedDrain$2] = !this[kGetDispatcher$2]();
			}
			return !this[kNeedDrain$2];
		}
		[kAddClient$2](client) {
			client.on("drain", this[kOnDrain$1]).on("connect", this[kOnConnect$1]).on("disconnect", this[kOnDisconnect$1]).on("connectionError", this[kOnConnectionError$1]);
			this[kClients$4].push(client);
			if (this[kNeedDrain$2]) process.nextTick(() => {
				if (this[kNeedDrain$2]) this[kOnDrain$1](client[kUrl$2], [this, client]);
			});
			return this;
		}
		[kRemoveClient$1](client) {
			client.close(() => {
				const idx = this[kClients$4].indexOf(client);
				if (idx !== -1) this[kClients$4].splice(idx, 1);
			});
			this[kNeedDrain$2] = this[kClients$4].some((dispatcher) => !dispatcher[kNeedDrain$2] && dispatcher.closed !== true && dispatcher.destroyed !== true);
		}
	};
	module.exports = {
		PoolBase: PoolBase$2,
		kClients: kClients$4,
		kNeedDrain: kNeedDrain$2,
		kAddClient: kAddClient$2,
		kRemoveClient: kRemoveClient$1,
		kGetDispatcher: kGetDispatcher$2
	};
}));

//#endregion
//#region node_modules/undici/lib/pool.js
var require_pool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { PoolBase: PoolBase$1, kClients: kClients$3, kNeedDrain: kNeedDrain$1, kAddClient: kAddClient$1, kGetDispatcher: kGetDispatcher$1 } = require_pool_base();
	const Client$3 = require_client();
	const { InvalidArgumentError: InvalidArgumentError$15 } = require_errors();
	const util$17 = require_util$8();
	const { kUrl: kUrl$1, kInterceptors: kInterceptors$3 } = require_symbols$4();
	const buildConnector$2 = require_connect();
	const kOptions$3 = Symbol("options");
	const kConnections = Symbol("connections");
	const kFactory$3 = Symbol("factory");
	function defaultFactory$3(origin, opts) {
		return new Client$3(origin, opts);
	}
	var Pool$5 = class extends PoolBase$1 {
		constructor(origin, { connections, factory = defaultFactory$3, connect: connect$2, connectTimeout, tls: tls$4, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}) {
			super();
			if (connections != null && (!Number.isFinite(connections) || connections < 0)) throw new InvalidArgumentError$15("invalid connections");
			if (typeof factory !== "function") throw new InvalidArgumentError$15("factory must be a function.");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$15("connect must be a function or an object");
			if (typeof connect$2 !== "function") connect$2 = buildConnector$2({
				...tls$4,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util$17.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect$2
			});
			this[kInterceptors$3] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
			this[kConnections] = connections || null;
			this[kUrl$1] = util$17.parseOrigin(origin);
			this[kOptions$3] = {
				...util$17.deepClone(options),
				connect: connect$2,
				allowH2
			};
			this[kOptions$3].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kFactory$3] = factory;
			this.on("connectionError", (origin$1, targets, error$1) => {
				for (const target of targets) {
					const idx = this[kClients$3].indexOf(target);
					if (idx !== -1) this[kClients$3].splice(idx, 1);
				}
			});
		}
		[kGetDispatcher$1]() {
			let dispatcher = this[kClients$3].find((dispatcher$1) => !dispatcher$1[kNeedDrain$1]);
			if (dispatcher) return dispatcher;
			if (!this[kConnections] || this[kClients$3].length < this[kConnections]) {
				dispatcher = this[kFactory$3](this[kUrl$1], this[kOptions$3]);
				this[kAddClient$1](dispatcher);
			}
			return dispatcher;
		}
	};
	module.exports = Pool$5;
}));

//#endregion
//#region node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { BalancedPoolMissingUpstreamError, InvalidArgumentError: InvalidArgumentError$14 } = require_errors();
	const { PoolBase, kClients: kClients$2, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = require_pool_base();
	const Pool$4 = require_pool();
	const { kUrl, kInterceptors: kInterceptors$2 } = require_symbols$4();
	const { parseOrigin } = require_util$8();
	const kFactory$2 = Symbol("factory");
	const kOptions$2 = Symbol("options");
	const kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
	const kCurrentWeight = Symbol("kCurrentWeight");
	const kIndex = Symbol("kIndex");
	const kWeight = Symbol("kWeight");
	const kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
	const kErrorPenalty = Symbol("kErrorPenalty");
	function getGreatestCommonDivisor(a, b) {
		if (b === 0) return a;
		return getGreatestCommonDivisor(b, a % b);
	}
	function defaultFactory$2(origin, opts) {
		return new Pool$4(origin, opts);
	}
	var BalancedPool$1 = class extends PoolBase {
		constructor(upstreams = [], { factory = defaultFactory$2, ...opts } = {}) {
			super();
			this[kOptions$2] = opts;
			this[kIndex] = -1;
			this[kCurrentWeight] = 0;
			this[kMaxWeightPerServer] = this[kOptions$2].maxWeightPerServer || 100;
			this[kErrorPenalty] = this[kOptions$2].errorPenalty || 15;
			if (!Array.isArray(upstreams)) upstreams = [upstreams];
			if (typeof factory !== "function") throw new InvalidArgumentError$14("factory must be a function.");
			this[kInterceptors$2] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
			this[kFactory$2] = factory;
			for (const upstream of upstreams) this.addUpstream(upstream);
			this._updateBalancedPoolStats();
		}
		addUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			if (this[kClients$2].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true)) return this;
			const pool = this[kFactory$2](upstreamOrigin, Object.assign({}, this[kOptions$2]));
			this[kAddClient](pool);
			pool.on("connect", () => {
				pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
			});
			pool.on("connectionError", () => {
				pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
				this._updateBalancedPoolStats();
			});
			pool.on("disconnect", (...args) => {
				const err = args[2];
				if (err && err.code === "UND_ERR_SOCKET") {
					pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
					this._updateBalancedPoolStats();
				}
			});
			for (const client of this[kClients$2]) client[kWeight] = this[kMaxWeightPerServer];
			this._updateBalancedPoolStats();
			return this;
		}
		_updateBalancedPoolStats() {
			this[kGreatestCommonDivisor] = this[kClients$2].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
		}
		removeUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			const pool = this[kClients$2].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true);
			if (pool) this[kRemoveClient](pool);
			return this;
		}
		get upstreams() {
			return this[kClients$2].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
		}
		[kGetDispatcher]() {
			if (this[kClients$2].length === 0) throw new BalancedPoolMissingUpstreamError();
			if (!this[kClients$2].find((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true)) return;
			if (this[kClients$2].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true)) return;
			let counter = 0;
			let maxWeightIndex = this[kClients$2].findIndex((pool) => !pool[kNeedDrain]);
			while (counter++ < this[kClients$2].length) {
				this[kIndex] = (this[kIndex] + 1) % this[kClients$2].length;
				const pool = this[kClients$2][this[kIndex]];
				if (pool[kWeight] > this[kClients$2][maxWeightIndex][kWeight] && !pool[kNeedDrain]) maxWeightIndex = this[kIndex];
				if (this[kIndex] === 0) {
					this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
					if (this[kCurrentWeight] <= 0) this[kCurrentWeight] = this[kMaxWeightPerServer];
				}
				if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) return pool;
			}
			this[kCurrentWeight] = this[kClients$2][maxWeightIndex][kWeight];
			this[kIndex] = maxWeightIndex;
			return this[kClients$2][maxWeightIndex];
		}
	};
	module.exports = BalancedPool$1;
}));

//#endregion
//#region node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/* istanbul ignore file: only for Node 12 */
	const { kConnected: kConnected$2, kSize } = require_symbols$4();
	var CompatWeakRef = class {
		constructor(value) {
			this.value = value;
		}
		deref() {
			return this.value[kConnected$2] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
		}
	};
	var CompatFinalizer = class {
		constructor(finalizer) {
			this.finalizer = finalizer;
		}
		register(dispatcher, key) {
			if (dispatcher.on) dispatcher.on("disconnect", () => {
				if (dispatcher[kConnected$2] === 0 && dispatcher[kSize] === 0) this.finalizer(key);
			});
		}
	};
	module.exports = function() {
		if (process.env.NODE_V8_COVERAGE) return {
			WeakRef: CompatWeakRef,
			FinalizationRegistry: CompatFinalizer
		};
		return {
			WeakRef: global.WeakRef || CompatWeakRef,
			FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
		};
	};
}));

//#endregion
//#region node_modules/undici/lib/agent.js
var require_agent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { InvalidArgumentError: InvalidArgumentError$13 } = require_errors();
	const { kClients: kClients$1, kRunning, kClose: kClose$3, kDestroy: kDestroy$1, kDispatch, kInterceptors: kInterceptors$1 } = require_symbols$4();
	const DispatcherBase$1 = require_dispatcher_base();
	const Pool$3 = require_pool();
	const Client$2 = require_client();
	const util$16 = require_util$8();
	const createRedirectInterceptor$1 = require_redirectInterceptor();
	const { WeakRef: WeakRef$1, FinalizationRegistry: FinalizationRegistry$1 } = require_dispatcher_weakref()();
	const kOnConnect = Symbol("onConnect");
	const kOnDisconnect = Symbol("onDisconnect");
	const kOnConnectionError = Symbol("onConnectionError");
	const kMaxRedirections = Symbol("maxRedirections");
	const kOnDrain = Symbol("onDrain");
	const kFactory$1 = Symbol("factory");
	const kFinalizer = Symbol("finalizer");
	const kOptions$1 = Symbol("options");
	function defaultFactory$1(origin, opts) {
		return opts && opts.connections === 1 ? new Client$2(origin, opts) : new Pool$3(origin, opts);
	}
	var Agent$5 = class extends DispatcherBase$1 {
		constructor({ factory = defaultFactory$1, maxRedirections = 0, connect: connect$2, ...options } = {}) {
			super();
			if (typeof factory !== "function") throw new InvalidArgumentError$13("factory must be a function.");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$13("connect must be a function or an object");
			if (!Number.isInteger(maxRedirections) || maxRedirections < 0) throw new InvalidArgumentError$13("maxRedirections must be a positive number");
			if (connect$2 && typeof connect$2 !== "function") connect$2 = { ...connect$2 };
			this[kInterceptors$1] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor$1({ maxRedirections })];
			this[kOptions$1] = {
				...util$16.deepClone(options),
				connect: connect$2
			};
			this[kOptions$1].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kMaxRedirections] = maxRedirections;
			this[kFactory$1] = factory;
			this[kClients$1] = /* @__PURE__ */ new Map();
			this[kFinalizer] = new FinalizationRegistry$1(
				/* istanbul ignore next: gc is undeterministic */
				(key) => {
					const ref = this[kClients$1].get(key);
					if (ref !== void 0 && ref.deref() === void 0) this[kClients$1].delete(key);
				}
			);
			const agent = this;
			this[kOnDrain] = (origin, targets) => {
				agent.emit("drain", origin, [agent, ...targets]);
			};
			this[kOnConnect] = (origin, targets) => {
				agent.emit("connect", origin, [agent, ...targets]);
			};
			this[kOnDisconnect] = (origin, targets, err) => {
				agent.emit("disconnect", origin, [agent, ...targets], err);
			};
			this[kOnConnectionError] = (origin, targets, err) => {
				agent.emit("connectionError", origin, [agent, ...targets], err);
			};
		}
		get [kRunning]() {
			let ret = 0;
			for (const ref of this[kClients$1].values()) {
				const client = ref.deref();
				/* istanbul ignore next: gc is undeterministic */
				if (client) ret += client[kRunning];
			}
			return ret;
		}
		[kDispatch](opts, handler$1) {
			let key;
			if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) key = String(opts.origin);
			else throw new InvalidArgumentError$13("opts.origin must be a non-empty string or URL.");
			const ref = this[kClients$1].get(key);
			let dispatcher = ref ? ref.deref() : null;
			if (!dispatcher) {
				dispatcher = this[kFactory$1](opts.origin, this[kOptions$1]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
				this[kClients$1].set(key, new WeakRef$1(dispatcher));
				this[kFinalizer].register(dispatcher, key);
			}
			return dispatcher.dispatch(opts, handler$1);
		}
		async [kClose$3]() {
			const closePromises = [];
			for (const ref of this[kClients$1].values()) {
				const client = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client) closePromises.push(client.close());
			}
			await Promise.all(closePromises);
		}
		async [kDestroy$1](err) {
			const destroyPromises = [];
			for (const ref of this[kClients$1].values()) {
				const client = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client) destroyPromises.push(client.destroy(err));
			}
			await Promise.all(destroyPromises);
		}
	};
	module.exports = Agent$5;
}));

//#endregion
//#region node_modules/undici/lib/api/readable.js
var require_readable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$11 = require("assert");
	const { Readable: Readable$5 } = require("stream");
	const { RequestAbortedError: RequestAbortedError$7, NotSupportedError, InvalidArgumentError: InvalidArgumentError$12 } = require_errors();
	const util$15 = require_util$8();
	const { ReadableStreamFrom, toUSVString: toUSVString$1 } = require_util$8();
	let Blob$2;
	const kConsume = Symbol("kConsume");
	const kReading = Symbol("kReading");
	const kBody = Symbol("kBody");
	const kAbort = Symbol("abort");
	const kContentType = Symbol("kContentType");
	const noop$2 = () => {};
	module.exports = class BodyReadable extends Readable$5 {
		constructor({ resume: resume$3, abort: abort$1, contentType = "", highWaterMark = 64 * 1024 }) {
			super({
				autoDestroy: true,
				read: resume$3,
				highWaterMark
			});
			this._readableState.dataEmitted = false;
			this[kAbort] = abort$1;
			this[kConsume] = null;
			this[kBody] = null;
			this[kContentType] = contentType;
			this[kReading] = false;
		}
		destroy(err) {
			if (this.destroyed) return this;
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$7();
			if (err) this[kAbort]();
			return super.destroy(err);
		}
		emit(ev, ...args) {
			if (ev === "data") this._readableState.dataEmitted = true;
			else if (ev === "error") this._readableState.errorEmitted = true;
			return super.emit(ev, ...args);
		}
		on(ev, ...args) {
			if (ev === "data" || ev === "readable") this[kReading] = true;
			return super.on(ev, ...args);
		}
		addListener(ev, ...args) {
			return this.on(ev, ...args);
		}
		off(ev, ...args) {
			const ret = super.off(ev, ...args);
			if (ev === "data" || ev === "readable") this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
			return ret;
		}
		removeListener(ev, ...args) {
			return this.off(ev, ...args);
		}
		push(chunk) {
			if (this[kConsume] && chunk !== null && this.readableLength === 0) {
				consumePush(this[kConsume], chunk);
				return this[kReading] ? super.push(chunk) : true;
			}
			return super.push(chunk);
		}
		async text() {
			return consume(this, "text");
		}
		async json() {
			return consume(this, "json");
		}
		async blob() {
			return consume(this, "blob");
		}
		async arrayBuffer() {
			return consume(this, "arrayBuffer");
		}
		async formData() {
			throw new NotSupportedError();
		}
		get bodyUsed() {
			return util$15.isDisturbed(this);
		}
		get body() {
			if (!this[kBody]) {
				this[kBody] = ReadableStreamFrom(this);
				if (this[kConsume]) {
					this[kBody].getReader();
					assert$11(this[kBody].locked);
				}
			}
			return this[kBody];
		}
		dump(opts) {
			let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
			const signal = opts && opts.signal;
			if (signal) try {
				if (typeof signal !== "object" || !("aborted" in signal)) throw new InvalidArgumentError$12("signal must be an AbortSignal");
				util$15.throwIfAborted(signal);
			} catch (err) {
				return Promise.reject(err);
			}
			if (this.closed) return Promise.resolve(null);
			return new Promise((resolve, reject) => {
				const signalListenerCleanup = signal ? util$15.addAbortListener(signal, () => {
					this.destroy();
				}) : noop$2;
				this.on("close", function() {
					signalListenerCleanup();
					if (signal && signal.aborted) reject(signal.reason || Object.assign(/* @__PURE__ */ new Error("The operation was aborted"), { name: "AbortError" }));
					else resolve(null);
				}).on("error", noop$2).on("data", function(chunk) {
					limit -= chunk.length;
					if (limit <= 0) this.destroy();
				}).resume();
			});
		}
	};
	function isLocked(self$1) {
		return self$1[kBody] && self$1[kBody].locked === true || self$1[kConsume];
	}
	function isUnusable(self$1) {
		return util$15.isDisturbed(self$1) || isLocked(self$1);
	}
	async function consume(stream$6, type) {
		if (isUnusable(stream$6)) throw new TypeError("unusable");
		assert$11(!stream$6[kConsume]);
		return new Promise((resolve, reject) => {
			stream$6[kConsume] = {
				type,
				stream: stream$6,
				resolve,
				reject,
				length: 0,
				body: []
			};
			stream$6.on("error", function(err) {
				consumeFinish(this[kConsume], err);
			}).on("close", function() {
				if (this[kConsume].body !== null) consumeFinish(this[kConsume], new RequestAbortedError$7());
			});
			process.nextTick(consumeStart, stream$6[kConsume]);
		});
	}
	function consumeStart(consume$1) {
		if (consume$1.body === null) return;
		const { _readableState: state } = consume$1.stream;
		for (const chunk of state.buffer) consumePush(consume$1, chunk);
		if (state.endEmitted) consumeEnd(this[kConsume]);
		else consume$1.stream.on("end", function() {
			consumeEnd(this[kConsume]);
		});
		consume$1.stream.resume();
		while (consume$1.stream.read() != null);
	}
	function consumeEnd(consume$1) {
		const { type, body, resolve, stream: stream$6, length } = consume$1;
		try {
			if (type === "text") resolve(toUSVString$1(Buffer.concat(body)));
			else if (type === "json") resolve(JSON.parse(Buffer.concat(body)));
			else if (type === "arrayBuffer") {
				const dst = new Uint8Array(length);
				let pos = 0;
				for (const buf of body) {
					dst.set(buf, pos);
					pos += buf.byteLength;
				}
				resolve(dst.buffer);
			} else if (type === "blob") {
				if (!Blob$2) Blob$2 = require("buffer").Blob;
				resolve(new Blob$2(body, { type: stream$6[kContentType] }));
			}
			consumeFinish(consume$1);
		} catch (err) {
			stream$6.destroy(err);
		}
	}
	function consumePush(consume$1, chunk) {
		consume$1.length += chunk.length;
		consume$1.body.push(chunk);
	}
	function consumeFinish(consume$1, err) {
		if (consume$1.body === null) return;
		if (err) consume$1.reject(err);
		else consume$1.resolve();
		consume$1.type = null;
		consume$1.stream = null;
		consume$1.resolve = null;
		consume$1.reject = null;
		consume$1.length = 0;
		consume$1.body = null;
	}
}));

//#endregion
//#region node_modules/undici/lib/api/util.js
var require_util$6 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$10 = require("assert");
	const { ResponseStatusCodeError } = require_errors();
	const { toUSVString } = require_util$8();
	async function getResolveErrorBodyCallback$2({ callback, body, contentType, statusCode, statusMessage, headers }) {
		assert$10(body);
		let chunks = [];
		let limit = 0;
		for await (const chunk of body) {
			chunks.push(chunk);
			limit += chunk.length;
			if (limit > 128 * 1024) {
				chunks = null;
				break;
			}
		}
		if (statusCode === 204 || !contentType || !chunks) {
			process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
			return;
		}
		try {
			if (contentType.startsWith("application/json")) {
				const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
				return;
			}
			if (contentType.startsWith("text/")) {
				const payload = toUSVString(Buffer.concat(chunks));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
				return;
			}
		} catch (err) {}
		process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
	}
	module.exports = { getResolveErrorBodyCallback: getResolveErrorBodyCallback$2 };
}));

//#endregion
//#region node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { addAbortListener: addAbortListener$1 } = require_util$8();
	const { RequestAbortedError: RequestAbortedError$6 } = require_errors();
	const kListener$2 = Symbol("kListener");
	const kSignal$1 = Symbol("kSignal");
	function abort(self$1) {
		if (self$1.abort) self$1.abort();
		else self$1.onError(new RequestAbortedError$6());
	}
	function addSignal$5(self$1, signal) {
		self$1[kSignal$1] = null;
		self$1[kListener$2] = null;
		if (!signal) return;
		if (signal.aborted) {
			abort(self$1);
			return;
		}
		self$1[kSignal$1] = signal;
		self$1[kListener$2] = () => {
			abort(self$1);
		};
		addAbortListener$1(self$1[kSignal$1], self$1[kListener$2]);
	}
	function removeSignal$5(self$1) {
		if (!self$1[kSignal$1]) return;
		if ("removeEventListener" in self$1[kSignal$1]) self$1[kSignal$1].removeEventListener("abort", self$1[kListener$2]);
		else self$1[kSignal$1].removeListener("abort", self$1[kListener$2]);
		self$1[kSignal$1] = null;
		self$1[kListener$2] = null;
	}
	module.exports = {
		addSignal: addSignal$5,
		removeSignal: removeSignal$5
	};
}));

//#endregion
//#region node_modules/undici/lib/api/api-request.js
var require_api_request = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Readable$4 = require_readable();
	const { InvalidArgumentError: InvalidArgumentError$11, RequestAbortedError: RequestAbortedError$5 } = require_errors();
	const util$14 = require_util$8();
	const { getResolveErrorBodyCallback: getResolveErrorBodyCallback$1 } = require_util$6();
	const { AsyncResource: AsyncResource$4 } = require("async_hooks");
	const { addSignal: addSignal$4, removeSignal: removeSignal$4 } = require_abort_signal();
	var RequestHandler = class extends AsyncResource$4 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$11("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError$11("invalid callback");
				if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) throw new InvalidArgumentError$11("invalid highWaterMark");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$11("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError$11("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$11("invalid onInfo callback");
				super("UNDICI_REQUEST");
			} catch (err) {
				if (util$14.isStream(body)) util$14.destroy(body.on("error", util$14.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.body = body;
			this.trailers = {};
			this.context = null;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError;
			this.highWaterMark = highWaterMark;
			if (util$14.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal$4(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$5();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders(statusCode, rawHeaders, resume$3, statusMessage) {
			const { callback, opaque, abort: abort$1, context, responseHeaders, highWaterMark } = this;
			const headers = responseHeaders === "raw" ? util$14.parseRawHeaders(rawHeaders) : util$14.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			const contentType = (responseHeaders === "raw" ? util$14.parseHeaders(rawHeaders) : headers)["content-type"];
			const body = new Readable$4({
				resume: resume$3,
				abort: abort$1,
				contentType,
				highWaterMark
			});
			this.callback = null;
			this.res = body;
			if (callback !== null) if (this.throwOnError && statusCode >= 400) this.runInAsyncScope(getResolveErrorBodyCallback$1, null, {
				callback,
				body,
				contentType,
				statusCode,
				statusMessage,
				headers
			});
			else this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				trailers: this.trailers,
				opaque,
				body,
				context
			});
		}
		onData(chunk) {
			const { res } = this;
			return res.push(chunk);
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal$4(this);
			util$14.parseHeaders(trailers, this.trailers);
			res.push(null);
		}
		onError(err) {
			const { res, callback, body, opaque } = this;
			removeSignal$4(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (res) {
				this.res = null;
				queueMicrotask(() => {
					util$14.destroy(res, err);
				});
			}
			if (body) {
				this.body = null;
				util$14.destroy(body, err);
			}
		}
	};
	function request$2(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			request$2.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			this.dispatch(opts, new RequestHandler(opts, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = request$2;
	module.exports.RequestHandler = RequestHandler;
}));

//#endregion
//#region node_modules/undici/lib/api/api-stream.js
var require_api_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { finished: finished$1, PassThrough: PassThrough$3 } = require("stream");
	const { InvalidArgumentError: InvalidArgumentError$10, InvalidReturnValueError: InvalidReturnValueError$1, RequestAbortedError: RequestAbortedError$4 } = require_errors();
	const util$13 = require_util$8();
	const { getResolveErrorBodyCallback } = require_util$6();
	const { AsyncResource: AsyncResource$3 } = require("async_hooks");
	const { addSignal: addSignal$3, removeSignal: removeSignal$3 } = require_abort_signal();
	var StreamHandler = class extends AsyncResource$3 {
		constructor(opts, factory, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$10("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError$10("invalid callback");
				if (typeof factory !== "function") throw new InvalidArgumentError$10("invalid factory");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$10("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError$10("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$10("invalid onInfo callback");
				super("UNDICI_STREAM");
			} catch (err) {
				if (util$13.isStream(body)) util$13.destroy(body.on("error", util$13.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.factory = factory;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.context = null;
			this.trailers = null;
			this.body = body;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError || false;
			if (util$13.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal$3(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$4();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders(statusCode, rawHeaders, resume$3, statusMessage) {
			const { factory, opaque, context, callback, responseHeaders } = this;
			const headers = responseHeaders === "raw" ? util$13.parseRawHeaders(rawHeaders) : util$13.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			this.factory = null;
			let res;
			if (this.throwOnError && statusCode >= 400) {
				const contentType = (responseHeaders === "raw" ? util$13.parseHeaders(rawHeaders) : headers)["content-type"];
				res = new PassThrough$3();
				this.callback = null;
				this.runInAsyncScope(getResolveErrorBodyCallback, null, {
					callback,
					body: res,
					contentType,
					statusCode,
					statusMessage,
					headers
				});
			} else {
				if (factory === null) return;
				res = this.runInAsyncScope(factory, null, {
					statusCode,
					headers,
					opaque,
					context
				});
				if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") throw new InvalidReturnValueError$1("expected Writable");
				finished$1(res, { readable: false }, (err) => {
					const { callback: callback$1, res: res$1, opaque: opaque$1, trailers, abort: abort$1 } = this;
					this.res = null;
					if (err || !res$1.readable) util$13.destroy(res$1, err);
					this.callback = null;
					this.runInAsyncScope(callback$1, null, err || null, {
						opaque: opaque$1,
						trailers
					});
					if (err) abort$1();
				});
			}
			res.on("drain", resume$3);
			this.res = res;
			return (res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain) !== true;
		}
		onData(chunk) {
			const { res } = this;
			return res ? res.write(chunk) : true;
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal$3(this);
			if (!res) return;
			this.trailers = util$13.parseHeaders(trailers);
			res.end();
		}
		onError(err) {
			const { res, callback, opaque, body } = this;
			removeSignal$3(this);
			this.factory = null;
			if (res) {
				this.res = null;
				util$13.destroy(res, err);
			} else if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (body) {
				this.body = null;
				util$13.destroy(body, err);
			}
		}
	};
	function stream$4(opts, factory, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			stream$4.call(this, opts, factory, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			this.dispatch(opts, new StreamHandler(opts, factory, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = stream$4;
}));

//#endregion
//#region node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Readable: Readable$3, Duplex: Duplex$4, PassThrough: PassThrough$2 } = require("stream");
	const { InvalidArgumentError: InvalidArgumentError$9, InvalidReturnValueError, RequestAbortedError: RequestAbortedError$3 } = require_errors();
	const util$12 = require_util$8();
	const { AsyncResource: AsyncResource$2 } = require("async_hooks");
	const { addSignal: addSignal$2, removeSignal: removeSignal$2 } = require_abort_signal();
	const assert$9 = require("assert");
	const kResume = Symbol("resume");
	var PipelineRequest = class extends Readable$3 {
		constructor() {
			super({ autoDestroy: true });
			this[kResume] = null;
		}
		_read() {
			const { [kResume]: resume$3 } = this;
			if (resume$3) {
				this[kResume] = null;
				resume$3();
			}
		}
		_destroy(err, callback) {
			this._read();
			callback(err);
		}
	};
	var PipelineResponse = class extends Readable$3 {
		constructor(resume$3) {
			super({ autoDestroy: true });
			this[kResume] = resume$3;
		}
		_read() {
			this[kResume]();
		}
		_destroy(err, callback) {
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$3();
			callback(err);
		}
	};
	var PipelineHandler = class extends AsyncResource$2 {
		constructor(opts, handler$1) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$9("invalid opts");
			if (typeof handler$1 !== "function") throw new InvalidArgumentError$9("invalid handler");
			const { signal, method, opaque, onInfo, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$9("signal must be an EventEmitter or EventTarget");
			if (method === "CONNECT") throw new InvalidArgumentError$9("invalid method");
			if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$9("invalid onInfo callback");
			super("UNDICI_PIPELINE");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.handler = handler$1;
			this.abort = null;
			this.context = null;
			this.onInfo = onInfo || null;
			this.req = new PipelineRequest().on("error", util$12.nop);
			this.ret = new Duplex$4({
				readableObjectMode: opts.objectMode,
				autoDestroy: true,
				read: () => {
					const { body } = this;
					if (body && body.resume) body.resume();
				},
				write: (chunk, encoding, callback) => {
					const { req: req$1 } = this;
					if (req$1.push(chunk, encoding) || req$1._readableState.destroyed) callback();
					else req$1[kResume] = callback;
				},
				destroy: (err, callback) => {
					const { body, req: req$1, res, ret, abort: abort$1 } = this;
					if (!err && !ret._readableState.endEmitted) err = new RequestAbortedError$3();
					if (abort$1 && err) abort$1();
					util$12.destroy(body, err);
					util$12.destroy(req$1, err);
					util$12.destroy(res, err);
					removeSignal$2(this);
					callback(err);
				}
			}).on("prefinish", () => {
				const { req: req$1 } = this;
				req$1.push(null);
			});
			this.res = null;
			addSignal$2(this, signal);
		}
		onConnect(abort$1, context) {
			const { ret, res } = this;
			assert$9(!res, "pipeline cannot be retried");
			if (ret.destroyed) throw new RequestAbortedError$3();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders(statusCode, rawHeaders, resume$3) {
			const { opaque, handler: handler$1, context } = this;
			if (statusCode < 200) {
				if (this.onInfo) {
					const headers = this.responseHeaders === "raw" ? util$12.parseRawHeaders(rawHeaders) : util$12.parseHeaders(rawHeaders);
					this.onInfo({
						statusCode,
						headers
					});
				}
				return;
			}
			this.res = new PipelineResponse(resume$3);
			let body;
			try {
				this.handler = null;
				const headers = this.responseHeaders === "raw" ? util$12.parseRawHeaders(rawHeaders) : util$12.parseHeaders(rawHeaders);
				body = this.runInAsyncScope(handler$1, null, {
					statusCode,
					headers,
					opaque,
					body: this.res,
					context
				});
			} catch (err) {
				this.res.on("error", util$12.nop);
				throw err;
			}
			if (!body || typeof body.on !== "function") throw new InvalidReturnValueError("expected Readable");
			body.on("data", (chunk) => {
				const { ret, body: body$1 } = this;
				if (!ret.push(chunk) && body$1.pause) body$1.pause();
			}).on("error", (err) => {
				const { ret } = this;
				util$12.destroy(ret, err);
			}).on("end", () => {
				const { ret } = this;
				ret.push(null);
			}).on("close", () => {
				const { ret } = this;
				if (!ret._readableState.ended) util$12.destroy(ret, new RequestAbortedError$3());
			});
			this.body = body;
		}
		onData(chunk) {
			const { res } = this;
			return res.push(chunk);
		}
		onComplete(trailers) {
			const { res } = this;
			res.push(null);
		}
		onError(err) {
			const { ret } = this;
			this.handler = null;
			util$12.destroy(ret, err);
		}
	};
	function pipeline$2(opts, handler$1) {
		try {
			const pipelineHandler = new PipelineHandler(opts, handler$1);
			this.dispatch({
				...opts,
				body: pipelineHandler.req
			}, pipelineHandler);
			return pipelineHandler.ret;
		} catch (err) {
			return new PassThrough$2().destroy(err);
		}
	}
	module.exports = pipeline$2;
}));

//#endregion
//#region node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { InvalidArgumentError: InvalidArgumentError$8, RequestAbortedError: RequestAbortedError$2, SocketError: SocketError$1 } = require_errors();
	const { AsyncResource: AsyncResource$1 } = require("async_hooks");
	const util$11 = require_util$8();
	const { addSignal: addSignal$1, removeSignal: removeSignal$1 } = require_abort_signal();
	const assert$8 = require("assert");
	var UpgradeHandler = class extends AsyncResource$1 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$8("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError$8("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$8("signal must be an EventEmitter or EventTarget");
			super("UNDICI_UPGRADE");
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.abort = null;
			this.context = null;
			addSignal$1(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$2();
			this.abort = abort$1;
			this.context = null;
		}
		onHeaders() {
			throw new SocketError$1("bad upgrade", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context } = this;
			assert$8.strictEqual(statusCode, 101);
			removeSignal$1(this);
			this.callback = null;
			const headers = this.responseHeaders === "raw" ? util$11.parseRawHeaders(rawHeaders) : util$11.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				headers,
				socket,
				opaque,
				context
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal$1(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function upgrade(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			upgrade.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			const upgradeHandler = new UpgradeHandler(opts, callback);
			this.dispatch({
				...opts,
				method: opts.method || "GET",
				upgrade: opts.protocol || "Websocket"
			}, upgradeHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = upgrade;
}));

//#endregion
//#region node_modules/undici/lib/api/api-connect.js
var require_api_connect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { AsyncResource } = require("async_hooks");
	const { InvalidArgumentError: InvalidArgumentError$7, RequestAbortedError: RequestAbortedError$1, SocketError } = require_errors();
	const util$10 = require_util$8();
	const { addSignal, removeSignal } = require_abort_signal();
	var ConnectHandler = class extends AsyncResource {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$7("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError$7("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$7("signal must be an EventEmitter or EventTarget");
			super("UNDICI_CONNECT");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.callback = callback;
			this.abort = null;
			addSignal(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$1();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders() {
			throw new SocketError("bad connect", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context } = this;
			removeSignal(this);
			this.callback = null;
			let headers = rawHeaders;
			if (headers != null) headers = this.responseHeaders === "raw" ? util$10.parseRawHeaders(rawHeaders) : util$10.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				socket,
				opaque,
				context
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function connect(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			connect.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			const connectHandler = new ConnectHandler(opts, callback);
			this.dispatch({
				...opts,
				method: "CONNECT"
			}, connectHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = connect;
}));

//#endregion
//#region node_modules/undici/lib/api/index.js
var require_api = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports.request = require_api_request();
	module.exports.stream = require_api_stream();
	module.exports.pipeline = require_api_pipeline();
	module.exports.upgrade = require_api_upgrade();
	module.exports.connect = require_api_connect();
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { UndiciError: UndiciError$1 } = require_errors();
	var MockNotMatchedError$1 = class MockNotMatchedError$1 extends UndiciError$1 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, MockNotMatchedError$1);
			this.name = "MockNotMatchedError";
			this.message = message || "The request does not match any registered mock dispatches";
			this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
		}
	};
	module.exports = { MockNotMatchedError: MockNotMatchedError$1 };
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kAgent: Symbol("agent"),
		kOptions: Symbol("options"),
		kFactory: Symbol("factory"),
		kDispatches: Symbol("dispatches"),
		kDispatchKey: Symbol("dispatch key"),
		kDefaultHeaders: Symbol("default headers"),
		kDefaultTrailers: Symbol("default trailers"),
		kContentLength: Symbol("content length"),
		kMockAgent: Symbol("mock agent"),
		kMockAgentSet: Symbol("mock agent set"),
		kMockAgentGet: Symbol("mock agent get"),
		kMockDispatch: Symbol("mock dispatch"),
		kClose: Symbol("close"),
		kOriginalClose: Symbol("original agent close"),
		kOrigin: Symbol("origin"),
		kIsMockActive: Symbol("is mock active"),
		kNetConnect: Symbol("net connect"),
		kGetNetConnect: Symbol("get net connect"),
		kConnected: Symbol("connected")
	};
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { MockNotMatchedError } = require_mock_errors();
	const { kDispatches: kDispatches$4, kMockAgent: kMockAgent$2, kOriginalDispatch: kOriginalDispatch$2, kOrigin: kOrigin$2, kGetNetConnect: kGetNetConnect$1 } = require_mock_symbols();
	const { buildURL: buildURL$1, nop } = require_util$8();
	const { STATUS_CODES: STATUS_CODES$1 } = require("http");
	const { types: { isPromise } } = require("util");
	function matchValue$1(match, value) {
		if (typeof match === "string") return match === value;
		if (match instanceof RegExp) return match.test(value);
		if (typeof match === "function") return match(value) === true;
		return false;
	}
	function lowerCaseEntries(headers) {
		return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
			return [headerName.toLocaleLowerCase(), headerValue];
		}));
	}
	/**
	* @param {import('../../index').Headers|string[]|Record<string, string>} headers
	* @param {string} key
	*/
	function getHeaderByName(headers, key) {
		if (Array.isArray(headers)) {
			for (let i$2 = 0; i$2 < headers.length; i$2 += 2) if (headers[i$2].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers[i$2 + 1];
			return;
		} else if (typeof headers.get === "function") return headers.get(key);
		else return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
	}
	/** @param {string[]} headers */
	function buildHeadersFromArray(headers) {
		const clone$1 = headers.slice();
		const entries = [];
		for (let index = 0; index < clone$1.length; index += 2) entries.push([clone$1[index], clone$1[index + 1]]);
		return Object.fromEntries(entries);
	}
	function matchHeaders(mockDispatch$1, headers) {
		if (typeof mockDispatch$1.headers === "function") {
			if (Array.isArray(headers)) headers = buildHeadersFromArray(headers);
			return mockDispatch$1.headers(headers ? lowerCaseEntries(headers) : {});
		}
		if (typeof mockDispatch$1.headers === "undefined") return true;
		if (typeof headers !== "object" || typeof mockDispatch$1.headers !== "object") return false;
		for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch$1.headers)) if (!matchValue$1(matchHeaderValue, getHeaderByName(headers, matchHeaderName))) return false;
		return true;
	}
	function safeUrl(path$9) {
		if (typeof path$9 !== "string") return path$9;
		const pathSegments = path$9.split("?");
		if (pathSegments.length !== 2) return path$9;
		const qp = new URLSearchParams(pathSegments.pop());
		qp.sort();
		return [...pathSegments, qp.toString()].join("?");
	}
	function matchKey(mockDispatch$1, { path: path$9, method, body, headers }) {
		const pathMatch = matchValue$1(mockDispatch$1.path, path$9);
		const methodMatch = matchValue$1(mockDispatch$1.method, method);
		const bodyMatch = typeof mockDispatch$1.body !== "undefined" ? matchValue$1(mockDispatch$1.body, body) : true;
		const headersMatch = matchHeaders(mockDispatch$1, headers);
		return pathMatch && methodMatch && bodyMatch && headersMatch;
	}
	function getResponseData$2(data) {
		if (Buffer.isBuffer(data)) return data;
		else if (typeof data === "object") return JSON.stringify(data);
		else return data.toString();
	}
	function getMockDispatch(mockDispatches, key) {
		const basePath = key.query ? buildURL$1(key.path, key.query) : key.path;
		const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
		let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path$9 }) => matchValue$1(safeUrl(path$9), resolvedPath));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue$1(method, key.method));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue$1(body, key.body) : true);
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
		matchedMockDispatches = matchedMockDispatches.filter((mockDispatch$1) => matchHeaders(mockDispatch$1, key.headers));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
		return matchedMockDispatches[0];
	}
	function addMockDispatch$1(mockDispatches, key, data) {
		const baseData = {
			timesInvoked: 0,
			times: 1,
			persist: false,
			consumed: false
		};
		const replyData = typeof data === "function" ? { callback: data } : { ...data };
		const newMockDispatch = {
			...baseData,
			...key,
			pending: true,
			data: {
				error: null,
				...replyData
			}
		};
		mockDispatches.push(newMockDispatch);
		return newMockDispatch;
	}
	function deleteMockDispatch(mockDispatches, key) {
		const index = mockDispatches.findIndex((dispatch) => {
			if (!dispatch.consumed) return false;
			return matchKey(dispatch, key);
		});
		if (index !== -1) mockDispatches.splice(index, 1);
	}
	function buildKey$1(opts) {
		const { path: path$9, method, body, headers, query } = opts;
		return {
			path: path$9,
			method,
			body,
			headers,
			query
		};
	}
	function generateKeyValues(data) {
		return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
			...keyValuePairs,
			Buffer.from(`${key}`),
			Array.isArray(value) ? value.map((x$1) => Buffer.from(`${x$1}`)) : Buffer.from(`${value}`)
		], []);
	}
	/**
	* @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
	* @param {number} statusCode
	*/
	function getStatusText(statusCode) {
		return STATUS_CODES$1[statusCode] || "unknown";
	}
	async function getResponse(body) {
		const buffers = [];
		for await (const data of body) buffers.push(data);
		return Buffer.concat(buffers).toString("utf8");
	}
	/**
	* Mock dispatch function used to simulate undici dispatches
	*/
	function mockDispatch(opts, handler$1) {
		const key = buildKey$1(opts);
		const mockDispatch$1 = getMockDispatch(this[kDispatches$4], key);
		mockDispatch$1.timesInvoked++;
		if (mockDispatch$1.data.callback) mockDispatch$1.data = {
			...mockDispatch$1.data,
			...mockDispatch$1.data.callback(opts)
		};
		const { data: { statusCode, data, headers, trailers, error: error$1 }, delay, persist } = mockDispatch$1;
		const { timesInvoked, times } = mockDispatch$1;
		mockDispatch$1.consumed = !persist && timesInvoked >= times;
		mockDispatch$1.pending = timesInvoked < times;
		if (error$1 !== null) {
			deleteMockDispatch(this[kDispatches$4], key);
			handler$1.onError(error$1);
			return true;
		}
		if (typeof delay === "number" && delay > 0) setTimeout(() => {
			handleReply(this[kDispatches$4]);
		}, delay);
		else handleReply(this[kDispatches$4]);
		function handleReply(mockDispatches, _data = data) {
			const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
			const body = typeof _data === "function" ? _data({
				...opts,
				headers: optsHeaders
			}) : _data;
			if (isPromise(body)) {
				body.then((newData) => handleReply(mockDispatches, newData));
				return;
			}
			const responseData = getResponseData$2(body);
			const responseHeaders = generateKeyValues(headers);
			const responseTrailers = generateKeyValues(trailers);
			handler$1.abort = nop;
			handler$1.onHeaders(statusCode, responseHeaders, resume$3, getStatusText(statusCode));
			handler$1.onData(Buffer.from(responseData));
			handler$1.onComplete(responseTrailers);
			deleteMockDispatch(mockDispatches, key);
		}
		function resume$3() {}
		return true;
	}
	function buildMockDispatch$2() {
		const agent = this[kMockAgent$2];
		const origin = this[kOrigin$2];
		const originalDispatch = this[kOriginalDispatch$2];
		return function dispatch(opts, handler$1) {
			if (agent.isMockActive) try {
				mockDispatch.call(this, opts, handler$1);
			} catch (error$1) {
				if (error$1 instanceof MockNotMatchedError) {
					const netConnect$1 = agent[kGetNetConnect$1]();
					if (netConnect$1 === false) throw new MockNotMatchedError(`${error$1.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
					if (checkNetConnect(netConnect$1, origin)) originalDispatch.call(this, opts, handler$1);
					else throw new MockNotMatchedError(`${error$1.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
				} else throw error$1;
			}
			else originalDispatch.call(this, opts, handler$1);
		};
	}
	function checkNetConnect(netConnect$1, origin) {
		const url = new URL(origin);
		if (netConnect$1 === true) return true;
		else if (Array.isArray(netConnect$1) && netConnect$1.some((matcher) => matchValue$1(matcher, url.host))) return true;
		return false;
	}
	function buildMockOptions$1(opts) {
		if (opts) {
			const { agent, ...mockOptions } = opts;
			return mockOptions;
		}
	}
	module.exports = {
		getResponseData: getResponseData$2,
		getMockDispatch,
		addMockDispatch: addMockDispatch$1,
		deleteMockDispatch,
		buildKey: buildKey$1,
		generateKeyValues,
		matchValue: matchValue$1,
		getResponse,
		getStatusText,
		mockDispatch,
		buildMockDispatch: buildMockDispatch$2,
		checkNetConnect,
		buildMockOptions: buildMockOptions$1,
		getHeaderByName
	};
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { getResponseData: getResponseData$1, buildKey, addMockDispatch } = require_mock_utils();
	const { kDispatches: kDispatches$3, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = require_mock_symbols();
	const { InvalidArgumentError: InvalidArgumentError$6 } = require_errors();
	const { buildURL } = require_util$8();
	/**
	* Defines the scope API for an interceptor reply
	*/
	var MockScope = class {
		constructor(mockDispatch$1) {
			this[kMockDispatch] = mockDispatch$1;
		}
		/**
		* Delay a reply by a set amount in ms.
		*/
		delay(waitInMs) {
			if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) throw new InvalidArgumentError$6("waitInMs must be a valid integer > 0");
			this[kMockDispatch].delay = waitInMs;
			return this;
		}
		/**
		* For a defined reply, never mark as consumed.
		*/
		persist() {
			this[kMockDispatch].persist = true;
			return this;
		}
		/**
		* Allow one to define a reply for a set amount of matching requests.
		*/
		times(repeatTimes) {
			if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) throw new InvalidArgumentError$6("repeatTimes must be a valid integer > 0");
			this[kMockDispatch].times = repeatTimes;
			return this;
		}
	};
	/**
	* Defines an interceptor for a Mock
	*/
	var MockInterceptor$2 = class {
		constructor(opts, mockDispatches) {
			if (typeof opts !== "object") throw new InvalidArgumentError$6("opts must be an object");
			if (typeof opts.path === "undefined") throw new InvalidArgumentError$6("opts.path must be defined");
			if (typeof opts.method === "undefined") opts.method = "GET";
			if (typeof opts.path === "string") if (opts.query) opts.path = buildURL(opts.path, opts.query);
			else {
				const parsedURL = new URL(opts.path, "data://");
				opts.path = parsedURL.pathname + parsedURL.search;
			}
			if (typeof opts.method === "string") opts.method = opts.method.toUpperCase();
			this[kDispatchKey] = buildKey(opts);
			this[kDispatches$3] = mockDispatches;
			this[kDefaultHeaders] = {};
			this[kDefaultTrailers] = {};
			this[kContentLength] = false;
		}
		createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
			const responseData = getResponseData$1(data);
			const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
			return {
				statusCode,
				data,
				headers: {
					...this[kDefaultHeaders],
					...contentLength,
					...responseOptions.headers
				},
				trailers: {
					...this[kDefaultTrailers],
					...responseOptions.trailers
				}
			};
		}
		validateReplyParameters(statusCode, data, responseOptions) {
			if (typeof statusCode === "undefined") throw new InvalidArgumentError$6("statusCode must be defined");
			if (typeof data === "undefined") throw new InvalidArgumentError$6("data must be defined");
			if (typeof responseOptions !== "object") throw new InvalidArgumentError$6("responseOptions must be an object");
		}
		/**
		* Mock an undici request with a defined reply.
		*/
		reply(replyData) {
			if (typeof replyData === "function") {
				const wrappedDefaultsCallback = (opts) => {
					const resolvedData = replyData(opts);
					if (typeof resolvedData !== "object") throw new InvalidArgumentError$6("reply options callback must return an object");
					const { statusCode: statusCode$1, data: data$1 = "", responseOptions: responseOptions$1 = {} } = resolvedData;
					this.validateReplyParameters(statusCode$1, data$1, responseOptions$1);
					return { ...this.createMockScopeDispatchData(statusCode$1, data$1, responseOptions$1) };
				};
				return new MockScope(addMockDispatch(this[kDispatches$3], this[kDispatchKey], wrappedDefaultsCallback));
			}
			const [statusCode, data = "", responseOptions = {}] = [...arguments];
			this.validateReplyParameters(statusCode, data, responseOptions);
			const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
			return new MockScope(addMockDispatch(this[kDispatches$3], this[kDispatchKey], dispatchData));
		}
		/**
		* Mock an undici request with a defined error.
		*/
		replyWithError(error$1) {
			if (typeof error$1 === "undefined") throw new InvalidArgumentError$6("error must be defined");
			return new MockScope(addMockDispatch(this[kDispatches$3], this[kDispatchKey], { error: error$1 }));
		}
		/**
		* Set default reply headers on the interceptor for subsequent replies
		*/
		defaultReplyHeaders(headers) {
			if (typeof headers === "undefined") throw new InvalidArgumentError$6("headers must be defined");
			this[kDefaultHeaders] = headers;
			return this;
		}
		/**
		* Set default reply trailers on the interceptor for subsequent replies
		*/
		defaultReplyTrailers(trailers) {
			if (typeof trailers === "undefined") throw new InvalidArgumentError$6("trailers must be defined");
			this[kDefaultTrailers] = trailers;
			return this;
		}
		/**
		* Set reply content length header for replies on the interceptor
		*/
		replyContentLength() {
			this[kContentLength] = true;
			return this;
		}
	};
	module.exports.MockInterceptor = MockInterceptor$2;
	module.exports.MockScope = MockScope;
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-client.js
var require_mock_client = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { promisify: promisify$2 } = require("util");
	const Client$1 = require_client();
	const { buildMockDispatch: buildMockDispatch$1 } = require_mock_utils();
	const { kDispatches: kDispatches$2, kMockAgent: kMockAgent$1, kClose: kClose$2, kOriginalClose: kOriginalClose$1, kOrigin: kOrigin$1, kOriginalDispatch: kOriginalDispatch$1, kConnected: kConnected$1 } = require_mock_symbols();
	const { MockInterceptor: MockInterceptor$1 } = require_mock_interceptor();
	const Symbols$1 = require_symbols$4();
	const { InvalidArgumentError: InvalidArgumentError$5 } = require_errors();
	/**
	* MockClient provides an API that extends the Client to influence the mockDispatches.
	*/
	var MockClient$2 = class extends Client$1 {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$5("Argument opts.agent must implement Agent");
			this[kMockAgent$1] = opts.agent;
			this[kOrigin$1] = origin;
			this[kDispatches$2] = [];
			this[kConnected$1] = 1;
			this[kOriginalDispatch$1] = this.dispatch;
			this[kOriginalClose$1] = this.close.bind(this);
			this.dispatch = buildMockDispatch$1.call(this);
			this.close = this[kClose$2];
		}
		get [Symbols$1.kConnected]() {
			return this[kConnected$1];
		}
		/**
		* Sets up the base interceptor for mocking replies from undici.
		*/
		intercept(opts) {
			return new MockInterceptor$1(opts, this[kDispatches$2]);
		}
		async [kClose$2]() {
			await promisify$2(this[kOriginalClose$1])();
			this[kConnected$1] = 0;
			this[kMockAgent$1][Symbols$1.kClients].delete(this[kOrigin$1]);
		}
	};
	module.exports = MockClient$2;
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { promisify: promisify$1 } = require("util");
	const Pool$2 = require_pool();
	const { buildMockDispatch } = require_mock_utils();
	const { kDispatches: kDispatches$1, kMockAgent, kClose: kClose$1, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = require_mock_symbols();
	const { MockInterceptor } = require_mock_interceptor();
	const Symbols = require_symbols$4();
	const { InvalidArgumentError: InvalidArgumentError$4 } = require_errors();
	/**
	* MockPool provides an API that extends the Pool to influence the mockDispatches.
	*/
	var MockPool$2 = class extends Pool$2 {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$4("Argument opts.agent must implement Agent");
			this[kMockAgent] = opts.agent;
			this[kOrigin] = origin;
			this[kDispatches$1] = [];
			this[kConnected] = 1;
			this[kOriginalDispatch] = this.dispatch;
			this[kOriginalClose] = this.close.bind(this);
			this.dispatch = buildMockDispatch.call(this);
			this.close = this[kClose$1];
		}
		get [Symbols.kConnected]() {
			return this[kConnected];
		}
		/**
		* Sets up the base interceptor for mocking replies from undici.
		*/
		intercept(opts) {
			return new MockInterceptor(opts, this[kDispatches$1]);
		}
		async [kClose$1]() {
			await promisify$1(this[kOriginalClose])();
			this[kConnected] = 0;
			this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
		}
	};
	module.exports = MockPool$2;
}));

//#endregion
//#region node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const singulars = {
		pronoun: "it",
		is: "is",
		was: "was",
		this: "this"
	};
	const plurals = {
		pronoun: "they",
		is: "are",
		was: "were",
		this: "these"
	};
	module.exports = class Pluralizer$1 {
		constructor(singular, plural$1) {
			this.singular = singular;
			this.plural = plural$1;
		}
		pluralize(count) {
			const one = count === 1;
			const keys = one ? singulars : plurals;
			const noun = one ? this.singular : this.plural;
			return {
				...keys,
				count,
				noun
			};
		}
	};
}));

//#endregion
//#region node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Transform } = require("stream");
	const { Console } = require("console");
	/**
	* Gets the output of `console.table()` as a string.
	*/
	module.exports = class PendingInterceptorsFormatter$1 {
		constructor({ disableColors } = {}) {
			this.transform = new Transform({ transform(chunk, _enc, cb) {
				cb(null, chunk);
			} });
			this.logger = new Console({
				stdout: this.transform,
				inspectOptions: { colors: !disableColors && !process.env.CI }
			});
		}
		format(pendingInterceptors) {
			const withPrettyHeaders = pendingInterceptors.map(({ method, path: path$9, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
				Method: method,
				Origin: origin,
				Path: path$9,
				"Status code": statusCode,
				Persistent: persist ? "" : "",
				Invocations: timesInvoked,
				Remaining: persist ? Infinity : times - timesInvoked
			}));
			this.logger.table(withPrettyHeaders);
			return this.transform.read().toString();
		}
	};
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kClients } = require_symbols$4();
	const Agent$4 = require_agent();
	const { kAgent: kAgent$1, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = require_mock_symbols();
	const MockClient$1 = require_mock_client();
	const MockPool$1 = require_mock_pool();
	const { matchValue, buildMockOptions } = require_mock_utils();
	const { InvalidArgumentError: InvalidArgumentError$3, UndiciError } = require_errors();
	const Dispatcher$1 = require_dispatcher();
	const Pluralizer = require_pluralizer();
	const PendingInterceptorsFormatter = require_pending_interceptors_formatter();
	var FakeWeakRef = class {
		constructor(value) {
			this.value = value;
		}
		deref() {
			return this.value;
		}
	};
	var MockAgent$1 = class extends Dispatcher$1 {
		constructor(opts) {
			super(opts);
			this[kNetConnect] = true;
			this[kIsMockActive] = true;
			if (opts && opts.agent && typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$3("Argument opts.agent must implement Agent");
			const agent = opts && opts.agent ? opts.agent : new Agent$4(opts);
			this[kAgent$1] = agent;
			this[kClients] = agent[kClients];
			this[kOptions] = buildMockOptions(opts);
		}
		get(origin) {
			let dispatcher = this[kMockAgentGet](origin);
			if (!dispatcher) {
				dispatcher = this[kFactory](origin);
				this[kMockAgentSet](origin, dispatcher);
			}
			return dispatcher;
		}
		dispatch(opts, handler$1) {
			this.get(opts.origin);
			return this[kAgent$1].dispatch(opts, handler$1);
		}
		async close() {
			await this[kAgent$1].close();
			this[kClients].clear();
		}
		deactivate() {
			this[kIsMockActive] = false;
		}
		activate() {
			this[kIsMockActive] = true;
		}
		enableNetConnect(matcher) {
			if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) if (Array.isArray(this[kNetConnect])) this[kNetConnect].push(matcher);
			else this[kNetConnect] = [matcher];
			else if (typeof matcher === "undefined") this[kNetConnect] = true;
			else throw new InvalidArgumentError$3("Unsupported matcher. Must be one of String|Function|RegExp.");
		}
		disableNetConnect() {
			this[kNetConnect] = false;
		}
		get isMockActive() {
			return this[kIsMockActive];
		}
		[kMockAgentSet](origin, dispatcher) {
			this[kClients].set(origin, new FakeWeakRef(dispatcher));
		}
		[kFactory](origin) {
			const mockOptions = Object.assign({ agent: this }, this[kOptions]);
			return this[kOptions] && this[kOptions].connections === 1 ? new MockClient$1(origin, mockOptions) : new MockPool$1(origin, mockOptions);
		}
		[kMockAgentGet](origin) {
			const ref = this[kClients].get(origin);
			if (ref) return ref.deref();
			if (typeof origin !== "string") {
				const dispatcher = this[kFactory]("http://localhost:9999");
				this[kMockAgentSet](origin, dispatcher);
				return dispatcher;
			}
			for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
				const nonExplicitDispatcher = nonExplicitRef.deref();
				if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
					const dispatcher = this[kFactory](origin);
					this[kMockAgentSet](origin, dispatcher);
					dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
					return dispatcher;
				}
			}
		}
		[kGetNetConnect]() {
			return this[kNetConnect];
		}
		pendingInterceptors() {
			const mockAgentClients = this[kClients];
			return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({
				...dispatch,
				origin
			}))).filter(({ pending }) => pending);
		}
		assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
			const pending = this.pendingInterceptors();
			if (pending.length === 0) return;
			const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
			throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
		}
	};
	module.exports = MockAgent$1;
}));

//#endregion
//#region node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kProxy, kClose, kDestroy, kInterceptors } = require_symbols$4();
	const { URL: URL$2 } = require("url");
	const Agent$3 = require_agent();
	const Pool$1 = require_pool();
	const DispatcherBase = require_dispatcher_base();
	const { InvalidArgumentError: InvalidArgumentError$2, RequestAbortedError } = require_errors();
	const buildConnector$1 = require_connect();
	const kAgent = Symbol("proxy agent");
	const kClient = Symbol("proxy client");
	const kProxyHeaders = Symbol("proxy headers");
	const kRequestTls = Symbol("request tls settings");
	const kProxyTls = Symbol("proxy tls settings");
	const kConnectEndpoint = Symbol("connect endpoint function");
	function defaultProtocolPort(protocol) {
		return protocol === "https:" ? 443 : 80;
	}
	function buildProxyOptions(opts) {
		if (typeof opts === "string") opts = { uri: opts };
		if (!opts || !opts.uri) throw new InvalidArgumentError$2("Proxy opts.uri is mandatory");
		return {
			uri: opts.uri,
			protocol: opts.protocol || "https"
		};
	}
	function defaultFactory(origin, opts) {
		return new Pool$1(origin, opts);
	}
	var ProxyAgent$1 = class extends DispatcherBase {
		constructor(opts) {
			super(opts);
			this[kProxy] = buildProxyOptions(opts);
			this[kAgent] = new Agent$3(opts);
			this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
			if (typeof opts === "string") opts = { uri: opts };
			if (!opts || !opts.uri) throw new InvalidArgumentError$2("Proxy opts.uri is mandatory");
			const { clientFactory = defaultFactory } = opts;
			if (typeof clientFactory !== "function") throw new InvalidArgumentError$2("Proxy opts.clientFactory must be a function.");
			this[kRequestTls] = opts.requestTls;
			this[kProxyTls] = opts.proxyTls;
			this[kProxyHeaders] = opts.headers || {};
			const resolvedUrl = new URL$2(opts.uri);
			const { origin, port, host, username, password } = resolvedUrl;
			if (opts.auth && opts.token) throw new InvalidArgumentError$2("opts.auth cannot be used in combination with opts.token");
			else if (opts.auth) this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
			else if (opts.token) this[kProxyHeaders]["proxy-authorization"] = opts.token;
			else if (username && password) this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
			const connect$2 = buildConnector$1({ ...opts.proxyTls });
			this[kConnectEndpoint] = buildConnector$1({ ...opts.requestTls });
			this[kClient] = clientFactory(resolvedUrl, { connect: connect$2 });
			this[kAgent] = new Agent$3({
				...opts,
				connect: async (opts$1, callback) => {
					let requestedHost = opts$1.host;
					if (!opts$1.port) requestedHost += `:${defaultProtocolPort(opts$1.protocol)}`;
					try {
						const { socket, statusCode } = await this[kClient].connect({
							origin,
							port,
							path: requestedHost,
							signal: opts$1.signal,
							headers: {
								...this[kProxyHeaders],
								host
							}
						});
						if (statusCode !== 200) {
							socket.on("error", () => {}).destroy();
							callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
						}
						if (opts$1.protocol !== "https:") {
							callback(null, socket);
							return;
						}
						let servername;
						if (this[kRequestTls]) servername = this[kRequestTls].servername;
						else servername = opts$1.servername;
						this[kConnectEndpoint]({
							...opts$1,
							servername,
							httpSocket: socket
						}, callback);
					} catch (err) {
						callback(err);
					}
				}
			});
		}
		dispatch(opts, handler$1) {
			const { host } = new URL$2(opts.origin);
			const headers = buildHeaders(opts.headers);
			throwIfProxyAuthIsSent(headers);
			return this[kAgent].dispatch({
				...opts,
				headers: {
					...headers,
					host
				}
			}, handler$1);
		}
		async [kClose]() {
			await this[kAgent].close();
			await this[kClient].close();
		}
		async [kDestroy]() {
			await this[kAgent].destroy();
			await this[kClient].destroy();
		}
	};
	/**
	* @param {string[] | Record<string, string>} headers
	* @returns {Record<string, string>}
	*/
	function buildHeaders(headers) {
		if (Array.isArray(headers)) {
			/** @type {Record<string, string>} */
			const headersPair = {};
			for (let i$2 = 0; i$2 < headers.length; i$2 += 2) headersPair[headers[i$2]] = headers[i$2 + 1];
			return headersPair;
		}
		return headers;
	}
	/**
	* @param {Record<string, string>} headers
	*
	* Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
	* Nevertheless, it was changed and to avoid a security vulnerability by end users
	* this check was created.
	* It should be removed in the next major version for performance reasons
	*/
	function throwIfProxyAuthIsSent(headers) {
		if (headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization")) throw new InvalidArgumentError$2("Proxy-Authorization should be sent in ProxyAgent constructor");
	}
	module.exports = ProxyAgent$1;
}));

//#endregion
//#region node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$7 = require("assert");
	const { kRetryHandlerDefaultRetry } = require_symbols$4();
	const { RequestRetryError } = require_errors();
	const { isDisturbed: isDisturbed$1, parseHeaders, parseRangeHeader } = require_util$8();
	function calculateRetryAfterHeader(retryAfter) {
		const current = Date.now();
		return new Date(retryAfter).getTime() - current;
	}
	var RetryHandler$1 = class RetryHandler$1 {
		constructor(opts, handlers) {
			const { retryOptions, ...dispatchOpts } = opts;
			const { retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};
			this.dispatch = handlers.dispatch;
			this.handler = handlers.handler;
			this.opts = dispatchOpts;
			this.abort = null;
			this.aborted = false;
			this.retryOpts = {
				retry: retryFn ?? RetryHandler$1[kRetryHandlerDefaultRetry],
				retryAfter: retryAfter ?? true,
				maxTimeout: maxTimeout ?? 30 * 1e3,
				timeout: minTimeout ?? 500,
				timeoutFactor: timeoutFactor ?? 2,
				maxRetries: maxRetries ?? 5,
				methods: methods ?? [
					"GET",
					"HEAD",
					"OPTIONS",
					"PUT",
					"DELETE",
					"TRACE"
				],
				statusCodes: statusCodes ?? [
					500,
					502,
					503,
					504,
					429
				],
				errorCodes: errorCodes ?? [
					"ECONNRESET",
					"ECONNREFUSED",
					"ENOTFOUND",
					"ENETDOWN",
					"ENETUNREACH",
					"EHOSTDOWN",
					"EHOSTUNREACH",
					"EPIPE"
				]
			};
			this.retryCount = 0;
			this.start = 0;
			this.end = null;
			this.etag = null;
			this.resume = null;
			this.handler.onConnect((reason) => {
				this.aborted = true;
				if (this.abort) this.abort(reason);
				else this.reason = reason;
			});
		}
		onRequestSent() {
			if (this.handler.onRequestSent) this.handler.onRequestSent();
		}
		onUpgrade(statusCode, headers, socket) {
			if (this.handler.onUpgrade) this.handler.onUpgrade(statusCode, headers, socket);
		}
		onConnect(abort$1) {
			if (this.aborted) abort$1(this.reason);
			else this.abort = abort$1;
		}
		onBodySent(chunk) {
			if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
		}
		static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
			const { statusCode, code: code$1, headers } = err;
			const { method, retryOptions } = opts;
			const { maxRetries, timeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;
			let { counter, currentTimeout } = state;
			currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
			if (code$1 && code$1 !== "UND_ERR_REQ_RETRY" && code$1 !== "UND_ERR_SOCKET" && !errorCodes.includes(code$1)) {
				cb(err);
				return;
			}
			if (Array.isArray(methods) && !methods.includes(method)) {
				cb(err);
				return;
			}
			if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
				cb(err);
				return;
			}
			if (counter > maxRetries) {
				cb(err);
				return;
			}
			let retryAfterHeader = headers != null && headers["retry-after"];
			if (retryAfterHeader) {
				retryAfterHeader = Number(retryAfterHeader);
				retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
			}
			const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
			state.currentTimeout = retryTimeout;
			setTimeout(() => cb(null), retryTimeout);
		}
		onHeaders(statusCode, rawHeaders, resume$3, statusMessage) {
			const headers = parseHeaders(rawHeaders);
			this.retryCount += 1;
			if (statusCode >= 300) {
				this.abort(new RequestRetryError("Request failed", statusCode, {
					headers,
					count: this.retryCount
				}));
				return false;
			}
			if (this.resume != null) {
				this.resume = null;
				if (statusCode !== 206) return true;
				const contentRange = parseRangeHeader(headers["content-range"]);
				if (!contentRange) {
					this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				if (this.etag != null && this.etag !== headers.etag) {
					this.abort(new RequestRetryError("ETag mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				const { start, size, end = size } = contentRange;
				assert$7(this.start === start, "content-range mismatch");
				assert$7(this.end == null || this.end === end, "content-range mismatch");
				this.resume = resume$3;
				return true;
			}
			if (this.end == null) {
				if (statusCode === 206) {
					const range = parseRangeHeader(headers["content-range"]);
					if (range == null) return this.handler.onHeaders(statusCode, rawHeaders, resume$3, statusMessage);
					const { start, size, end = size } = range;
					assert$7(start != null && Number.isFinite(start) && this.start !== start, "content-range mismatch");
					assert$7(Number.isFinite(start));
					assert$7(end != null && Number.isFinite(end) && this.end !== end, "invalid content-length");
					this.start = start;
					this.end = end;
				}
				if (this.end == null) {
					const contentLength = headers["content-length"];
					this.end = contentLength != null ? Number(contentLength) : null;
				}
				assert$7(Number.isFinite(this.start));
				assert$7(this.end == null || Number.isFinite(this.end), "invalid content-length");
				this.resume = resume$3;
				this.etag = headers.etag != null ? headers.etag : null;
				return this.handler.onHeaders(statusCode, rawHeaders, resume$3, statusMessage);
			}
			const err = new RequestRetryError("Request failed", statusCode, {
				headers,
				count: this.retryCount
			});
			this.abort(err);
			return false;
		}
		onData(chunk) {
			this.start += chunk.length;
			return this.handler.onData(chunk);
		}
		onComplete(rawTrailers) {
			this.retryCount = 0;
			return this.handler.onComplete(rawTrailers);
		}
		onError(err) {
			if (this.aborted || isDisturbed$1(this.opts.body)) return this.handler.onError(err);
			this.retryOpts.retry(err, {
				state: {
					counter: this.retryCount++,
					currentTimeout: this.retryAfter
				},
				opts: {
					retryOptions: this.retryOpts,
					...this.opts
				}
			}, onRetry.bind(this));
			function onRetry(err$1) {
				if (err$1 != null || this.aborted || isDisturbed$1(this.opts.body)) return this.handler.onError(err$1);
				if (this.start !== 0) this.opts = {
					...this.opts,
					headers: {
						...this.opts.headers,
						range: `bytes=${this.start}-${this.end ?? ""}`
					}
				};
				try {
					this.dispatch(this.opts, this);
				} catch (err$2) {
					this.handler.onError(err$2);
				}
			}
		}
	};
	module.exports = RetryHandler$1;
}));

//#endregion
//#region node_modules/undici/lib/global.js
var require_global = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const globalDispatcher = Symbol.for("undici.globalDispatcher.1");
	const { InvalidArgumentError: InvalidArgumentError$1 } = require_errors();
	const Agent$2 = require_agent();
	if (getGlobalDispatcher$5() === void 0) setGlobalDispatcher$1(new Agent$2());
	function setGlobalDispatcher$1(agent) {
		if (!agent || typeof agent.dispatch !== "function") throw new InvalidArgumentError$1("Argument agent must implement Agent");
		Object.defineProperty(globalThis, globalDispatcher, {
			value: agent,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	function getGlobalDispatcher$5() {
		return globalThis[globalDispatcher];
	}
	module.exports = {
		setGlobalDispatcher: setGlobalDispatcher$1,
		getGlobalDispatcher: getGlobalDispatcher$5
	};
}));

//#endregion
//#region node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = class DecoratorHandler$1 {
		constructor(handler$1) {
			this.handler = handler$1;
		}
		onConnect(...args) {
			return this.handler.onConnect(...args);
		}
		onError(...args) {
			return this.handler.onError(...args);
		}
		onUpgrade(...args) {
			return this.handler.onUpgrade(...args);
		}
		onHeaders(...args) {
			return this.handler.onHeaders(...args);
		}
		onData(...args) {
			return this.handler.onData(...args);
		}
		onComplete(...args) {
			return this.handler.onComplete(...args);
		}
		onBodySent(...args) {
			return this.handler.onBodySent(...args);
		}
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/headers.js
var require_headers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kHeadersList: kHeadersList$5, kConstruct: kConstruct$4 } = require_symbols$4();
	const { kGuard: kGuard$4 } = require_symbols$3();
	const { kEnumerableProperty: kEnumerableProperty$7 } = require_util$8();
	const { makeIterator, isValidHeaderName: isValidHeaderName$1, isValidHeaderValue } = require_util$7();
	const util$9 = require("util");
	const { webidl: webidl$10 } = require_webidl();
	const assert$6 = require("assert");
	const kHeadersMap = Symbol("headers map");
	const kHeadersSortedMap = Symbol("headers map sorted");
	/**
	* @param {number} code
	*/
	function isHTTPWhiteSpaceCharCode(code$1) {
		return code$1 === 10 || code$1 === 13 || code$1 === 9 || code$1 === 32;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
	* @param {string} potentialValue
	*/
	function headerValueNormalize(potentialValue) {
		let i$2 = 0;
		let j = potentialValue.length;
		while (j > i$2 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
		while (j > i$2 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i$2))) ++i$2;
		return i$2 === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i$2, j);
	}
	function fill$1(headers, object) {
		if (Array.isArray(object)) for (let i$2 = 0; i$2 < object.length; ++i$2) {
			const header = object[i$2];
			if (header.length !== 2) throw webidl$10.errors.exception({
				header: "Headers constructor",
				message: `expected name/value pair to be length 2, found ${header.length}.`
			});
			appendHeader(headers, header[0], header[1]);
		}
		else if (typeof object === "object" && object !== null) {
			const keys = Object.keys(object);
			for (let i$2 = 0; i$2 < keys.length; ++i$2) appendHeader(headers, keys[i$2], object[keys[i$2]]);
		} else throw webidl$10.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-headers-append
	*/
	function appendHeader(headers, name, value) {
		value = headerValueNormalize(value);
		if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
			prefix: "Headers.append",
			value: name,
			type: "header name"
		});
		else if (!isValidHeaderValue(value)) throw webidl$10.errors.invalidArgument({
			prefix: "Headers.append",
			value,
			type: "header value"
		});
		if (headers[kGuard$4] === "immutable") throw new TypeError("immutable");
		else if (headers[kGuard$4] === "request-no-cors") {}
		return headers[kHeadersList$5].append(name, value);
	}
	var HeadersList$2 = class HeadersList$2 {
		/** @type {[string, string][]|null} */
		cookies = null;
		constructor(init$1) {
			if (init$1 instanceof HeadersList$2) {
				this[kHeadersMap] = new Map(init$1[kHeadersMap]);
				this[kHeadersSortedMap] = init$1[kHeadersSortedMap];
				this.cookies = init$1.cookies === null ? null : [...init$1.cookies];
			} else {
				this[kHeadersMap] = new Map(init$1);
				this[kHeadersSortedMap] = null;
			}
		}
		contains(name) {
			name = name.toLowerCase();
			return this[kHeadersMap].has(name);
		}
		clear() {
			this[kHeadersMap].clear();
			this[kHeadersSortedMap] = null;
			this.cookies = null;
		}
		append(name, value) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			const exists$1 = this[kHeadersMap].get(lowercaseName);
			if (exists$1) {
				const delimiter = lowercaseName === "cookie" ? "; " : ", ";
				this[kHeadersMap].set(lowercaseName, {
					name: exists$1.name,
					value: `${exists$1.value}${delimiter}${value}`
				});
			} else this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
			if (lowercaseName === "set-cookie") {
				this.cookies ??= [];
				this.cookies.push(value);
			}
		}
		set(name, value) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			if (lowercaseName === "set-cookie") this.cookies = [value];
			this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
		}
		delete(name) {
			this[kHeadersSortedMap] = null;
			name = name.toLowerCase();
			if (name === "set-cookie") this.cookies = null;
			this[kHeadersMap].delete(name);
		}
		get(name) {
			const value = this[kHeadersMap].get(name.toLowerCase());
			return value === void 0 ? null : value.value;
		}
		*[Symbol.iterator]() {
			for (const [name, { value }] of this[kHeadersMap]) yield [name, value];
		}
		get entries() {
			const headers = {};
			if (this[kHeadersMap].size) for (const { name, value } of this[kHeadersMap].values()) headers[name] = value;
			return headers;
		}
	};
	var Headers$8 = class Headers$8 {
		constructor(init$1 = void 0) {
			if (init$1 === kConstruct$4) return;
			this[kHeadersList$5] = new HeadersList$2();
			this[kGuard$4] = "none";
			if (init$1 !== void 0) {
				init$1 = webidl$10.converters.HeadersInit(init$1);
				fill$1(this, init$1);
			}
		}
		append(name, value) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
			name = webidl$10.converters.ByteString(name);
			value = webidl$10.converters.ByteString(value);
			return appendHeader(this, name, value);
		}
		delete(name) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.delete",
				value: name,
				type: "header name"
			});
			if (this[kGuard$4] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard$4] === "request-no-cors") {}
			if (!this[kHeadersList$5].contains(name)) return;
			this[kHeadersList$5].delete(name);
		}
		get(name) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.get",
				value: name,
				type: "header name"
			});
			return this[kHeadersList$5].get(name);
		}
		has(name) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.has",
				value: name,
				type: "header name"
			});
			return this[kHeadersList$5].contains(name);
		}
		set(name, value) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
			name = webidl$10.converters.ByteString(name);
			value = webidl$10.converters.ByteString(value);
			value = headerValueNormalize(value);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.set",
				value: name,
				type: "header name"
			});
			else if (!isValidHeaderValue(value)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.set",
				value,
				type: "header value"
			});
			if (this[kGuard$4] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard$4] === "request-no-cors") {}
			this[kHeadersList$5].set(name, value);
		}
		getSetCookie() {
			webidl$10.brandCheck(this, Headers$8);
			const list = this[kHeadersList$5].cookies;
			if (list) return [...list];
			return [];
		}
		get [kHeadersSortedMap]() {
			if (this[kHeadersList$5][kHeadersSortedMap]) return this[kHeadersList$5][kHeadersSortedMap];
			const headers = [];
			const names = [...this[kHeadersList$5]].sort((a, b) => a[0] < b[0] ? -1 : 1);
			const cookies = this[kHeadersList$5].cookies;
			for (let i$2 = 0; i$2 < names.length; ++i$2) {
				const [name, value] = names[i$2];
				if (name === "set-cookie") for (let j = 0; j < cookies.length; ++j) headers.push([name, cookies[j]]);
				else {
					assert$6(value !== null);
					headers.push([name, value]);
				}
			}
			this[kHeadersList$5][kHeadersSortedMap] = headers;
			return headers;
		}
		keys() {
			webidl$10.brandCheck(this, Headers$8);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "key");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
		}
		values() {
			webidl$10.brandCheck(this, Headers$8);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
		}
		entries() {
			webidl$10.brandCheck(this, Headers$8);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "key+value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
		}
		/**
		* @param {(value: string, key: string, self: Headers) => void} callbackFn
		* @param {unknown} thisArg
		*/
		forEach(callbackFn, thisArg = globalThis) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
			for (const [key, value] of this) callbackFn.apply(thisArg, [
				value,
				key,
				this
			]);
		}
		[Symbol.for("nodejs.util.inspect.custom")]() {
			webidl$10.brandCheck(this, Headers$8);
			return this[kHeadersList$5];
		}
	};
	Headers$8.prototype[Symbol.iterator] = Headers$8.prototype.entries;
	Object.defineProperties(Headers$8.prototype, {
		append: kEnumerableProperty$7,
		delete: kEnumerableProperty$7,
		get: kEnumerableProperty$7,
		has: kEnumerableProperty$7,
		set: kEnumerableProperty$7,
		getSetCookie: kEnumerableProperty$7,
		keys: kEnumerableProperty$7,
		values: kEnumerableProperty$7,
		entries: kEnumerableProperty$7,
		forEach: kEnumerableProperty$7,
		[Symbol.iterator]: { enumerable: false },
		[Symbol.toStringTag]: {
			value: "Headers",
			configurable: true
		},
		[util$9.inspect.custom]: { enumerable: false }
	});
	webidl$10.converters.HeadersInit = function(V) {
		if (webidl$10.util.Type(V) === "Object") {
			if (V[Symbol.iterator]) return webidl$10.converters["sequence<sequence<ByteString>>"](V);
			return webidl$10.converters["record<ByteString, ByteString>"](V);
		}
		throw webidl$10.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	};
	module.exports = {
		fill: fill$1,
		Headers: Headers$8,
		HeadersList: HeadersList$2
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/response.js
var require_response = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Headers: Headers$7, HeadersList: HeadersList$1, fill } = require_headers();
	const { extractBody: extractBody$1, cloneBody: cloneBody$1, mixinBody: mixinBody$1 } = require_body();
	const util$8 = require_util$8();
	const { kEnumerableProperty: kEnumerableProperty$6 } = util$8;
	const { isValidReasonPhrase, isCancelled: isCancelled$1, isAborted: isAborted$1, isBlobLike: isBlobLike$2, serializeJavascriptValueToJSONString, isErrorLike: isErrorLike$1, isomorphicEncode: isomorphicEncode$1 } = require_util$7();
	const { redirectStatusSet: redirectStatusSet$1, nullBodyStatus: nullBodyStatus$1, DOMException: DOMException$5 } = require_constants$4();
	const { kState: kState$6, kHeaders: kHeaders$3, kGuard: kGuard$3, kRealm: kRealm$3 } = require_symbols$3();
	const { webidl: webidl$9 } = require_webidl();
	const { FormData: FormData$2 } = require_formdata();
	const { getGlobalOrigin: getGlobalOrigin$2 } = require_global$1();
	const { URLSerializer: URLSerializer$3 } = require_dataURL();
	const { kHeadersList: kHeadersList$4, kConstruct: kConstruct$3 } = require_symbols$4();
	const assert$5 = require("assert");
	const { types: types$4 } = require("util");
	const ReadableStream$2 = globalThis.ReadableStream || require("stream/web").ReadableStream;
	const textEncoder = new TextEncoder("utf-8");
	var Response$4 = class Response$4 {
		static error() {
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response$4();
			responseObject[kState$6] = makeNetworkError$1();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kHeadersList$4] = responseObject[kState$6].headersList;
			responseObject[kHeaders$3][kGuard$3] = "immutable";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			return responseObject;
		}
		static json(data, init$1 = {}) {
			webidl$9.argumentLengthCheck(arguments, 1, { header: "Response.json" });
			if (init$1 !== null) init$1 = webidl$9.converters.ResponseInit(init$1);
			const body = extractBody$1(textEncoder.encode(serializeJavascriptValueToJSONString(data)));
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response$4();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kGuard$3] = "response";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			initializeResponse(responseObject, init$1, {
				body: body[0],
				type: "application/json"
			});
			return responseObject;
		}
		static redirect(url, status = 302) {
			const relevantRealm = { settingsObject: {} };
			webidl$9.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
			url = webidl$9.converters.USVString(url);
			status = webidl$9.converters["unsigned short"](status);
			let parsedURL;
			try {
				parsedURL = new URL(url, getGlobalOrigin$2());
			} catch (err) {
				throw Object.assign(/* @__PURE__ */ new TypeError("Failed to parse URL from " + url), { cause: err });
			}
			if (!redirectStatusSet$1.has(status)) throw new RangeError("Invalid status code " + status);
			const responseObject = new Response$4();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kGuard$3] = "immutable";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			responseObject[kState$6].status = status;
			const value = isomorphicEncode$1(URLSerializer$3(parsedURL));
			responseObject[kState$6].headersList.append("location", value);
			return responseObject;
		}
		constructor(body = null, init$1 = {}) {
			if (body !== null) body = webidl$9.converters.BodyInit(body);
			init$1 = webidl$9.converters.ResponseInit(init$1);
			this[kRealm$3] = { settingsObject: {} };
			this[kState$6] = makeResponse$1({});
			this[kHeaders$3] = new Headers$7(kConstruct$3);
			this[kHeaders$3][kGuard$3] = "response";
			this[kHeaders$3][kHeadersList$4] = this[kState$6].headersList;
			this[kHeaders$3][kRealm$3] = this[kRealm$3];
			let bodyWithType = null;
			if (body != null) {
				const [extractedBody, type] = extractBody$1(body);
				bodyWithType = {
					body: extractedBody,
					type
				};
			}
			initializeResponse(this, init$1, bodyWithType);
		}
		get type() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].type;
		}
		get url() {
			webidl$9.brandCheck(this, Response$4);
			const urlList = this[kState$6].urlList;
			const url = urlList[urlList.length - 1] ?? null;
			if (url === null) return "";
			return URLSerializer$3(url, true);
		}
		get redirected() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].urlList.length > 1;
		}
		get status() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].status;
		}
		get ok() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].status >= 200 && this[kState$6].status <= 299;
		}
		get statusText() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].statusText;
		}
		get headers() {
			webidl$9.brandCheck(this, Response$4);
			return this[kHeaders$3];
		}
		get body() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].body ? this[kState$6].body.stream : null;
		}
		get bodyUsed() {
			webidl$9.brandCheck(this, Response$4);
			return !!this[kState$6].body && util$8.isDisturbed(this[kState$6].body.stream);
		}
		clone() {
			webidl$9.brandCheck(this, Response$4);
			if (this.bodyUsed || this.body && this.body.locked) throw webidl$9.errors.exception({
				header: "Response.clone",
				message: "Body has already been consumed."
			});
			const clonedResponse = cloneResponse$1(this[kState$6]);
			const clonedResponseObject = new Response$4();
			clonedResponseObject[kState$6] = clonedResponse;
			clonedResponseObject[kRealm$3] = this[kRealm$3];
			clonedResponseObject[kHeaders$3][kHeadersList$4] = clonedResponse.headersList;
			clonedResponseObject[kHeaders$3][kGuard$3] = this[kHeaders$3][kGuard$3];
			clonedResponseObject[kHeaders$3][kRealm$3] = this[kHeaders$3][kRealm$3];
			return clonedResponseObject;
		}
	};
	mixinBody$1(Response$4);
	Object.defineProperties(Response$4.prototype, {
		type: kEnumerableProperty$6,
		url: kEnumerableProperty$6,
		status: kEnumerableProperty$6,
		ok: kEnumerableProperty$6,
		redirected: kEnumerableProperty$6,
		statusText: kEnumerableProperty$6,
		headers: kEnumerableProperty$6,
		clone: kEnumerableProperty$6,
		body: kEnumerableProperty$6,
		bodyUsed: kEnumerableProperty$6,
		[Symbol.toStringTag]: {
			value: "Response",
			configurable: true
		}
	});
	Object.defineProperties(Response$4, {
		json: kEnumerableProperty$6,
		redirect: kEnumerableProperty$6,
		error: kEnumerableProperty$6
	});
	function cloneResponse$1(response) {
		if (response.internalResponse) return filterResponse$1(cloneResponse$1(response.internalResponse), response.type);
		const newResponse = makeResponse$1({
			...response,
			body: null
		});
		if (response.body != null) newResponse.body = cloneBody$1(response.body);
		return newResponse;
	}
	function makeResponse$1(init$1) {
		return {
			aborted: false,
			rangeRequested: false,
			timingAllowPassed: false,
			requestIncludesCredentials: false,
			type: "default",
			status: 200,
			timingInfo: null,
			cacheState: "",
			statusText: "",
			...init$1,
			headersList: init$1.headersList ? new HeadersList$1(init$1.headersList) : new HeadersList$1(),
			urlList: init$1.urlList ? [...init$1.urlList] : []
		};
	}
	function makeNetworkError$1(reason) {
		return makeResponse$1({
			type: "error",
			status: 0,
			error: isErrorLike$1(reason) ? reason : new Error(reason ? String(reason) : reason),
			aborted: reason && reason.name === "AbortError"
		});
	}
	function makeFilteredResponse(response, state) {
		state = {
			internalResponse: response,
			...state
		};
		return new Proxy(response, {
			get(target, p) {
				return p in state ? state[p] : target[p];
			},
			set(target, p, value) {
				assert$5(!(p in state));
				target[p] = value;
				return true;
			}
		});
	}
	function filterResponse$1(response, type) {
		if (type === "basic") return makeFilteredResponse(response, {
			type: "basic",
			headersList: response.headersList
		});
		else if (type === "cors") return makeFilteredResponse(response, {
			type: "cors",
			headersList: response.headersList
		});
		else if (type === "opaque") return makeFilteredResponse(response, {
			type: "opaque",
			urlList: Object.freeze([]),
			status: 0,
			statusText: "",
			body: null
		});
		else if (type === "opaqueredirect") return makeFilteredResponse(response, {
			type: "opaqueredirect",
			status: 0,
			statusText: "",
			headersList: [],
			body: null
		});
		else assert$5(false);
	}
	function makeAppropriateNetworkError$1(fetchParams, err = null) {
		assert$5(isCancelled$1(fetchParams));
		return isAborted$1(fetchParams) ? makeNetworkError$1(Object.assign(new DOMException$5("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError$1(Object.assign(new DOMException$5("Request was cancelled."), { cause: err }));
	}
	function initializeResponse(response, init$1, body) {
		if (init$1.status !== null && (init$1.status < 200 || init$1.status > 599)) throw new RangeError("init[\"status\"] must be in the range of 200 to 599, inclusive.");
		if ("statusText" in init$1 && init$1.statusText != null) {
			if (!isValidReasonPhrase(String(init$1.statusText))) throw new TypeError("Invalid statusText");
		}
		if ("status" in init$1 && init$1.status != null) response[kState$6].status = init$1.status;
		if ("statusText" in init$1 && init$1.statusText != null) response[kState$6].statusText = init$1.statusText;
		if ("headers" in init$1 && init$1.headers != null) fill(response[kHeaders$3], init$1.headers);
		if (body) {
			if (nullBodyStatus$1.includes(response.status)) throw webidl$9.errors.exception({
				header: "Response constructor",
				message: "Invalid response status code " + response.status
			});
			response[kState$6].body = body.body;
			if (body.type != null && !response[kState$6].headersList.contains("Content-Type")) response[kState$6].headersList.append("content-type", body.type);
		}
	}
	webidl$9.converters.ReadableStream = webidl$9.interfaceConverter(ReadableStream$2);
	webidl$9.converters.FormData = webidl$9.interfaceConverter(FormData$2);
	webidl$9.converters.URLSearchParams = webidl$9.interfaceConverter(URLSearchParams);
	webidl$9.converters.XMLHttpRequestBodyInit = function(V) {
		if (typeof V === "string") return webidl$9.converters.USVString(V);
		if (isBlobLike$2(V)) return webidl$9.converters.Blob(V, { strict: false });
		if (types$4.isArrayBuffer(V) || types$4.isTypedArray(V) || types$4.isDataView(V)) return webidl$9.converters.BufferSource(V);
		if (util$8.isFormDataLike(V)) return webidl$9.converters.FormData(V, { strict: false });
		if (V instanceof URLSearchParams) return webidl$9.converters.URLSearchParams(V);
		return webidl$9.converters.DOMString(V);
	};
	webidl$9.converters.BodyInit = function(V) {
		if (V instanceof ReadableStream$2) return webidl$9.converters.ReadableStream(V);
		if (V?.[Symbol.asyncIterator]) return V;
		return webidl$9.converters.XMLHttpRequestBodyInit(V);
	};
	webidl$9.converters.ResponseInit = webidl$9.dictionaryConverter([
		{
			key: "status",
			converter: webidl$9.converters["unsigned short"],
			defaultValue: 200
		},
		{
			key: "statusText",
			converter: webidl$9.converters.ByteString,
			defaultValue: ""
		},
		{
			key: "headers",
			converter: webidl$9.converters.HeadersInit
		}
	]);
	module.exports = {
		makeNetworkError: makeNetworkError$1,
		makeResponse: makeResponse$1,
		makeAppropriateNetworkError: makeAppropriateNetworkError$1,
		filterResponse: filterResponse$1,
		Response: Response$4,
		cloneResponse: cloneResponse$1
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/request.js
var require_request = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { extractBody, mixinBody, cloneBody } = require_body();
	const { Headers: Headers$6, fill: fillHeaders, HeadersList } = require_headers();
	const { FinalizationRegistry } = require_dispatcher_weakref()();
	const util$7 = require_util$8();
	const { isValidHTTPToken, sameOrigin: sameOrigin$1, normalizeMethod, makePolicyContainer: makePolicyContainer$1, normalizeMethodRecord } = require_util$7();
	const { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = require_constants$4();
	const { kEnumerableProperty: kEnumerableProperty$5 } = util$7;
	const { kHeaders: kHeaders$2, kSignal, kState: kState$5, kGuard: kGuard$2, kRealm: kRealm$2 } = require_symbols$3();
	const { webidl: webidl$8 } = require_webidl();
	const { getGlobalOrigin: getGlobalOrigin$1 } = require_global$1();
	const { URLSerializer: URLSerializer$2 } = require_dataURL();
	const { kHeadersList: kHeadersList$3, kConstruct: kConstruct$2 } = require_symbols$4();
	const assert$4 = require("assert");
	const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require("events");
	let TransformStream$1 = globalThis.TransformStream;
	const kAbortController = Symbol("abortController");
	const requestFinalizer = new FinalizationRegistry(({ signal, abort: abort$1 }) => {
		signal.removeEventListener("abort", abort$1);
	});
	var Request$3 = class Request$3 {
		constructor(input, init$1 = {}) {
			if (input === kConstruct$2) return;
			webidl$8.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
			input = webidl$8.converters.RequestInfo(input);
			init$1 = webidl$8.converters.RequestInit(init$1);
			this[kRealm$2] = { settingsObject: {
				baseUrl: getGlobalOrigin$1(),
				get origin() {
					return this.baseUrl?.origin;
				},
				policyContainer: makePolicyContainer$1()
			} };
			let request$3 = null;
			let fallbackMode = null;
			const baseUrl$1 = this[kRealm$2].settingsObject.baseUrl;
			let signal = null;
			if (typeof input === "string") {
				let parsedURL;
				try {
					parsedURL = new URL(input, baseUrl$1);
				} catch (err) {
					throw new TypeError("Failed to parse URL from " + input, { cause: err });
				}
				if (parsedURL.username || parsedURL.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
				request$3 = makeRequest$2({ urlList: [parsedURL] });
				fallbackMode = "cors";
			} else {
				assert$4(input instanceof Request$3);
				request$3 = input[kState$5];
				signal = input[kSignal];
			}
			const origin = this[kRealm$2].settingsObject.origin;
			let window$1 = "client";
			if (request$3.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin$1(request$3.window, origin)) window$1 = request$3.window;
			if (init$1.window != null) throw new TypeError(`'window' option '${window$1}' must be null`);
			if ("window" in init$1) window$1 = "no-window";
			request$3 = makeRequest$2({
				method: request$3.method,
				headersList: request$3.headersList,
				unsafeRequest: request$3.unsafeRequest,
				client: this[kRealm$2].settingsObject,
				window: window$1,
				priority: request$3.priority,
				origin: request$3.origin,
				referrer: request$3.referrer,
				referrerPolicy: request$3.referrerPolicy,
				mode: request$3.mode,
				credentials: request$3.credentials,
				cache: request$3.cache,
				redirect: request$3.redirect,
				integrity: request$3.integrity,
				keepalive: request$3.keepalive,
				reloadNavigation: request$3.reloadNavigation,
				historyNavigation: request$3.historyNavigation,
				urlList: [...request$3.urlList]
			});
			const initHasKey = Object.keys(init$1).length !== 0;
			if (initHasKey) {
				if (request$3.mode === "navigate") request$3.mode = "same-origin";
				request$3.reloadNavigation = false;
				request$3.historyNavigation = false;
				request$3.origin = "client";
				request$3.referrer = "client";
				request$3.referrerPolicy = "";
				request$3.url = request$3.urlList[request$3.urlList.length - 1];
				request$3.urlList = [request$3.url];
			}
			if (init$1.referrer !== void 0) {
				const referrer = init$1.referrer;
				if (referrer === "") request$3.referrer = "no-referrer";
				else {
					let parsedReferrer;
					try {
						parsedReferrer = new URL(referrer, baseUrl$1);
					} catch (err) {
						throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
					}
					if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin$1(parsedReferrer, this[kRealm$2].settingsObject.baseUrl)) request$3.referrer = "client";
					else request$3.referrer = parsedReferrer;
				}
			}
			if (init$1.referrerPolicy !== void 0) request$3.referrerPolicy = init$1.referrerPolicy;
			let mode;
			if (init$1.mode !== void 0) mode = init$1.mode;
			else mode = fallbackMode;
			if (mode === "navigate") throw webidl$8.errors.exception({
				header: "Request constructor",
				message: "invalid request mode navigate."
			});
			if (mode != null) request$3.mode = mode;
			if (init$1.credentials !== void 0) request$3.credentials = init$1.credentials;
			if (init$1.cache !== void 0) request$3.cache = init$1.cache;
			if (request$3.cache === "only-if-cached" && request$3.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
			if (init$1.redirect !== void 0) request$3.redirect = init$1.redirect;
			if (init$1.integrity != null) request$3.integrity = String(init$1.integrity);
			if (init$1.keepalive !== void 0) request$3.keepalive = Boolean(init$1.keepalive);
			if (init$1.method !== void 0) {
				let method = init$1.method;
				if (!isValidHTTPToken(method)) throw new TypeError(`'${method}' is not a valid HTTP method.`);
				if (forbiddenMethodsSet.has(method.toUpperCase())) throw new TypeError(`'${method}' HTTP method is unsupported.`);
				method = normalizeMethodRecord[method] ?? normalizeMethod(method);
				request$3.method = method;
			}
			if (init$1.signal !== void 0) signal = init$1.signal;
			this[kState$5] = request$3;
			const ac = new AbortController();
			this[kSignal] = ac.signal;
			this[kSignal][kRealm$2] = this[kRealm$2];
			if (signal != null) {
				if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
				if (signal.aborted) ac.abort(signal.reason);
				else {
					this[kAbortController] = ac;
					const acRef = new WeakRef(ac);
					const abort$1 = function() {
						const ac$1 = acRef.deref();
						if (ac$1 !== void 0) ac$1.abort(this.reason);
					};
					try {
						if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) setMaxListeners(100, signal);
						else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) setMaxListeners(100, signal);
					} catch {}
					util$7.addAbortListener(signal, abort$1);
					requestFinalizer.register(ac, {
						signal,
						abort: abort$1
					});
				}
			}
			this[kHeaders$2] = new Headers$6(kConstruct$2);
			this[kHeaders$2][kHeadersList$3] = request$3.headersList;
			this[kHeaders$2][kGuard$2] = "request";
			this[kHeaders$2][kRealm$2] = this[kRealm$2];
			if (mode === "no-cors") {
				if (!corsSafeListedMethodsSet.has(request$3.method)) throw new TypeError(`'${request$3.method} is unsupported in no-cors mode.`);
				this[kHeaders$2][kGuard$2] = "request-no-cors";
			}
			if (initHasKey) {
				/** @type {HeadersList} */
				const headersList = this[kHeaders$2][kHeadersList$3];
				const headers = init$1.headers !== void 0 ? init$1.headers : new HeadersList(headersList);
				headersList.clear();
				if (headers instanceof HeadersList) {
					for (const [key, val] of headers) headersList.append(key, val);
					headersList.cookies = headers.cookies;
				} else fillHeaders(this[kHeaders$2], headers);
			}
			const inputBody = input instanceof Request$3 ? input[kState$5].body : null;
			if ((init$1.body != null || inputBody != null) && (request$3.method === "GET" || request$3.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
			let initBody = null;
			if (init$1.body != null) {
				const [extractedBody, contentType] = extractBody(init$1.body, request$3.keepalive);
				initBody = extractedBody;
				if (contentType && !this[kHeaders$2][kHeadersList$3].contains("content-type")) this[kHeaders$2].append("content-type", contentType);
			}
			const inputOrInitBody = initBody ?? inputBody;
			if (inputOrInitBody != null && inputOrInitBody.source == null) {
				if (initBody != null && init$1.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
				if (request$3.mode !== "same-origin" && request$3.mode !== "cors") throw new TypeError("If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"");
				request$3.useCORSPreflightFlag = true;
			}
			let finalBody = inputOrInitBody;
			if (initBody == null && inputBody != null) {
				if (util$7.isDisturbed(inputBody.stream) || inputBody.stream.locked) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
				if (!TransformStream$1) TransformStream$1 = require("stream/web").TransformStream;
				const identityTransform = new TransformStream$1();
				inputBody.stream.pipeThrough(identityTransform);
				finalBody = {
					source: inputBody.source,
					length: inputBody.length,
					stream: identityTransform.readable
				};
			}
			this[kState$5].body = finalBody;
		}
		get method() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].method;
		}
		get url() {
			webidl$8.brandCheck(this, Request$3);
			return URLSerializer$2(this[kState$5].url);
		}
		get headers() {
			webidl$8.brandCheck(this, Request$3);
			return this[kHeaders$2];
		}
		get destination() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].destination;
		}
		get referrer() {
			webidl$8.brandCheck(this, Request$3);
			if (this[kState$5].referrer === "no-referrer") return "";
			if (this[kState$5].referrer === "client") return "about:client";
			return this[kState$5].referrer.toString();
		}
		get referrerPolicy() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].referrerPolicy;
		}
		get mode() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].mode;
		}
		get credentials() {
			return this[kState$5].credentials;
		}
		get cache() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].cache;
		}
		get redirect() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].redirect;
		}
		get integrity() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].integrity;
		}
		get keepalive() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].keepalive;
		}
		get isReloadNavigation() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].reloadNavigation;
		}
		get isHistoryNavigation() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].historyNavigation;
		}
		get signal() {
			webidl$8.brandCheck(this, Request$3);
			return this[kSignal];
		}
		get body() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].body ? this[kState$5].body.stream : null;
		}
		get bodyUsed() {
			webidl$8.brandCheck(this, Request$3);
			return !!this[kState$5].body && util$7.isDisturbed(this[kState$5].body.stream);
		}
		get duplex() {
			webidl$8.brandCheck(this, Request$3);
			return "half";
		}
		clone() {
			webidl$8.brandCheck(this, Request$3);
			if (this.bodyUsed || this.body?.locked) throw new TypeError("unusable");
			const clonedRequest = cloneRequest(this[kState$5]);
			const clonedRequestObject = new Request$3(kConstruct$2);
			clonedRequestObject[kState$5] = clonedRequest;
			clonedRequestObject[kRealm$2] = this[kRealm$2];
			clonedRequestObject[kHeaders$2] = new Headers$6(kConstruct$2);
			clonedRequestObject[kHeaders$2][kHeadersList$3] = clonedRequest.headersList;
			clonedRequestObject[kHeaders$2][kGuard$2] = this[kHeaders$2][kGuard$2];
			clonedRequestObject[kHeaders$2][kRealm$2] = this[kHeaders$2][kRealm$2];
			const ac = new AbortController();
			if (this.signal.aborted) ac.abort(this.signal.reason);
			else util$7.addAbortListener(this.signal, () => {
				ac.abort(this.signal.reason);
			});
			clonedRequestObject[kSignal] = ac.signal;
			return clonedRequestObject;
		}
	};
	mixinBody(Request$3);
	function makeRequest$2(init$1) {
		const request$3 = {
			method: "GET",
			localURLsOnly: false,
			unsafeRequest: false,
			body: null,
			client: null,
			reservedClient: null,
			replacesClientId: "",
			window: "client",
			keepalive: false,
			serviceWorkers: "all",
			initiator: "",
			destination: "",
			priority: null,
			origin: "client",
			policyContainer: "client",
			referrer: "client",
			referrerPolicy: "",
			mode: "no-cors",
			useCORSPreflightFlag: false,
			credentials: "same-origin",
			useCredentials: false,
			cache: "default",
			redirect: "follow",
			integrity: "",
			cryptoGraphicsNonceMetadata: "",
			parserMetadata: "",
			reloadNavigation: false,
			historyNavigation: false,
			userActivation: false,
			taintedOrigin: false,
			redirectCount: 0,
			responseTainting: "basic",
			preventNoCacheCacheControlHeaderModification: false,
			done: false,
			timingAllowFailed: false,
			...init$1,
			headersList: init$1.headersList ? new HeadersList(init$1.headersList) : new HeadersList()
		};
		request$3.url = request$3.urlList[0];
		return request$3;
	}
	function cloneRequest(request$3) {
		const newRequest = makeRequest$2({
			...request$3,
			body: null
		});
		if (request$3.body != null) newRequest.body = cloneBody(request$3.body);
		return newRequest;
	}
	Object.defineProperties(Request$3.prototype, {
		method: kEnumerableProperty$5,
		url: kEnumerableProperty$5,
		headers: kEnumerableProperty$5,
		redirect: kEnumerableProperty$5,
		clone: kEnumerableProperty$5,
		signal: kEnumerableProperty$5,
		duplex: kEnumerableProperty$5,
		destination: kEnumerableProperty$5,
		body: kEnumerableProperty$5,
		bodyUsed: kEnumerableProperty$5,
		isHistoryNavigation: kEnumerableProperty$5,
		isReloadNavigation: kEnumerableProperty$5,
		keepalive: kEnumerableProperty$5,
		integrity: kEnumerableProperty$5,
		cache: kEnumerableProperty$5,
		credentials: kEnumerableProperty$5,
		attribute: kEnumerableProperty$5,
		referrerPolicy: kEnumerableProperty$5,
		referrer: kEnumerableProperty$5,
		mode: kEnumerableProperty$5,
		[Symbol.toStringTag]: {
			value: "Request",
			configurable: true
		}
	});
	webidl$8.converters.Request = webidl$8.interfaceConverter(Request$3);
	webidl$8.converters.RequestInfo = function(V) {
		if (typeof V === "string") return webidl$8.converters.USVString(V);
		if (V instanceof Request$3) return webidl$8.converters.Request(V);
		return webidl$8.converters.USVString(V);
	};
	webidl$8.converters.AbortSignal = webidl$8.interfaceConverter(AbortSignal);
	webidl$8.converters.RequestInit = webidl$8.dictionaryConverter([
		{
			key: "method",
			converter: webidl$8.converters.ByteString
		},
		{
			key: "headers",
			converter: webidl$8.converters.HeadersInit
		},
		{
			key: "body",
			converter: webidl$8.nullableConverter(webidl$8.converters.BodyInit)
		},
		{
			key: "referrer",
			converter: webidl$8.converters.USVString
		},
		{
			key: "referrerPolicy",
			converter: webidl$8.converters.DOMString,
			allowedValues: referrerPolicy
		},
		{
			key: "mode",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestMode
		},
		{
			key: "credentials",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestCredentials
		},
		{
			key: "cache",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestCache
		},
		{
			key: "redirect",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestRedirect
		},
		{
			key: "integrity",
			converter: webidl$8.converters.DOMString
		},
		{
			key: "keepalive",
			converter: webidl$8.converters.boolean
		},
		{
			key: "signal",
			converter: webidl$8.nullableConverter((signal) => webidl$8.converters.AbortSignal(signal, { strict: false }))
		},
		{
			key: "window",
			converter: webidl$8.converters.any
		},
		{
			key: "duplex",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestDuplex
		}
	]);
	module.exports = {
		Request: Request$3,
		makeRequest: makeRequest$2
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/index.js
var require_fetch = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Response: Response$3, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = require_response();
	const { Headers: Headers$5 } = require_headers();
	const { Request: Request$2, makeRequest: makeRequest$1 } = require_request();
	const zlib$2 = require("zlib");
	const { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer: determineRequestsReferrer$1, coarsenedSharedCurrentTime, createDeferredPromise: createDeferredPromise$1, isBlobLike: isBlobLike$1, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme: urlIsHttpHttpsScheme$1, urlHasHttpsScheme } = require_util$7();
	const { kState: kState$4, kHeaders: kHeaders$1, kGuard: kGuard$1, kRealm: kRealm$1 } = require_symbols$3();
	const assert$3 = require("assert");
	const { safelyExtractBody } = require_body();
	const { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet, DOMException: DOMException$4 } = require_constants$4();
	const { kHeadersList: kHeadersList$2 } = require_symbols$4();
	const EE = require("events");
	const { Readable: Readable$2, pipeline: pipeline$1 } = require("stream");
	const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util$8();
	const { dataURLProcessor, serializeAMimeType: serializeAMimeType$1 } = require_dataURL();
	const { TransformStream } = require("stream/web");
	const { getGlobalDispatcher: getGlobalDispatcher$4 } = require_global();
	const { webidl: webidl$7 } = require_webidl();
	const { STATUS_CODES } = require("http");
	const GET_OR_HEAD = ["GET", "HEAD"];
	/** @type {import('buffer').resolveObjectURL} */
	let resolveObjectURL;
	let ReadableStream$1 = globalThis.ReadableStream;
	var Fetch = class extends EE {
		constructor(dispatcher) {
			super();
			this.dispatcher = dispatcher;
			this.connection = null;
			this.dump = false;
			this.state = "ongoing";
			this.setMaxListeners(21);
		}
		terminate(reason) {
			if (this.state !== "ongoing") return;
			this.state = "terminated";
			this.connection?.destroy(reason);
			this.emit("terminated", reason);
		}
		abort(error$1) {
			if (this.state !== "ongoing") return;
			this.state = "aborted";
			if (!error$1) error$1 = new DOMException$4("The operation was aborted.", "AbortError");
			this.serializedAbortReason = error$1;
			this.connection?.destroy(error$1);
			this.emit("terminated", error$1);
		}
	};
	function fetch$2(input, init$1 = {}) {
		webidl$7.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
		const p = createDeferredPromise$1();
		let requestObject;
		try {
			requestObject = new Request$2(input, init$1);
		} catch (e$1) {
			p.reject(e$1);
			return p.promise;
		}
		const request$3 = requestObject[kState$4];
		if (requestObject.signal.aborted) {
			abortFetch(p, request$3, null, requestObject.signal.reason);
			return p.promise;
		}
		if (request$3.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope") request$3.serviceWorkers = "none";
		let responseObject = null;
		const relevantRealm = null;
		let locallyAborted = false;
		let controller = null;
		addAbortListener(requestObject.signal, () => {
			locallyAborted = true;
			assert$3(controller != null);
			controller.abort(requestObject.signal.reason);
			abortFetch(p, request$3, responseObject, requestObject.signal.reason);
		});
		const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
		const processResponse = (response) => {
			if (locallyAborted) return Promise.resolve();
			if (response.aborted) {
				abortFetch(p, request$3, responseObject, controller.serializedAbortReason);
				return Promise.resolve();
			}
			if (response.type === "error") {
				p.reject(Object.assign(/* @__PURE__ */ new TypeError("fetch failed"), { cause: response.error }));
				return Promise.resolve();
			}
			responseObject = new Response$3();
			responseObject[kState$4] = response;
			responseObject[kRealm$1] = relevantRealm;
			responseObject[kHeaders$1][kHeadersList$2] = response.headersList;
			responseObject[kHeaders$1][kGuard$1] = "immutable";
			responseObject[kHeaders$1][kRealm$1] = relevantRealm;
			p.resolve(responseObject);
		};
		controller = fetching$2({
			request: request$3,
			processResponseEndOfBody: handleFetchDone,
			processResponse,
			dispatcher: init$1.dispatcher ?? getGlobalDispatcher$4()
		});
		return p.promise;
	}
	function finalizeAndReportTiming(response, initiatorType = "other") {
		if (response.type === "error" && response.aborted) return;
		if (!response.urlList?.length) return;
		const originalURL = response.urlList[0];
		let timingInfo = response.timingInfo;
		let cacheState = response.cacheState;
		if (!urlIsHttpHttpsScheme$1(originalURL)) return;
		if (timingInfo === null) return;
		if (!response.timingAllowPassed) {
			timingInfo = createOpaqueTimingInfo({ startTime: timingInfo.startTime });
			cacheState = "";
		}
		timingInfo.endTime = coarsenedSharedCurrentTime();
		response.timingInfo = timingInfo;
		markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
	}
	function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis$1, cacheState) {
		if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis$1, cacheState);
	}
	function abortFetch(p, request$3, responseObject, error$1) {
		if (!error$1) error$1 = new DOMException$4("The operation was aborted.", "AbortError");
		p.reject(error$1);
		if (request$3.body != null && isReadable(request$3.body?.stream)) request$3.body.stream.cancel(error$1).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
		if (responseObject == null) return;
		const response = responseObject[kState$4];
		if (response.body != null && isReadable(response.body?.stream)) response.body.stream.cancel(error$1).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
	}
	function fetching$2({ request: request$3, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher }) {
		let taskDestination = null;
		let crossOriginIsolatedCapability = false;
		if (request$3.client != null) {
			taskDestination = request$3.client.globalObject;
			crossOriginIsolatedCapability = request$3.client.crossOriginIsolatedCapability;
		}
		const timingInfo = createOpaqueTimingInfo({ startTime: coarsenedSharedCurrentTime(crossOriginIsolatedCapability) });
		const fetchParams = {
			controller: new Fetch(dispatcher),
			request: request$3,
			timingInfo,
			processRequestBodyChunkLength,
			processRequestEndOfBody,
			processResponse,
			processResponseConsumeBody,
			processResponseEndOfBody,
			taskDestination,
			crossOriginIsolatedCapability
		};
		assert$3(!request$3.body || request$3.body.stream);
		if (request$3.window === "client") request$3.window = request$3.client?.globalObject?.constructor?.name === "Window" ? request$3.client : "no-window";
		if (request$3.origin === "client") request$3.origin = request$3.client?.origin;
		if (request$3.policyContainer === "client") if (request$3.client != null) request$3.policyContainer = clonePolicyContainer(request$3.client.policyContainer);
		else request$3.policyContainer = makePolicyContainer();
		if (!request$3.headersList.contains("accept")) request$3.headersList.append("accept", "*/*");
		if (!request$3.headersList.contains("accept-language")) request$3.headersList.append("accept-language", "*");
		if (request$3.priority === null) {}
		if (subresourceSet.has(request$3.destination)) {}
		mainFetch(fetchParams).catch((err) => {
			fetchParams.controller.terminate(err);
		});
		return fetchParams.controller;
	}
	async function mainFetch(fetchParams, recursive = false) {
		const request$3 = fetchParams.request;
		let response = null;
		if (request$3.localURLsOnly && !urlIsLocal(requestCurrentURL(request$3))) response = makeNetworkError("local URLs only");
		tryUpgradeRequestToAPotentiallyTrustworthyURL(request$3);
		if (requestBadPort(request$3) === "blocked") response = makeNetworkError("bad port");
		if (request$3.referrerPolicy === "") request$3.referrerPolicy = request$3.policyContainer.referrerPolicy;
		if (request$3.referrer !== "no-referrer") request$3.referrer = determineRequestsReferrer$1(request$3);
		if (response === null) response = await (async () => {
			const currentURL = requestCurrentURL(request$3);
			if (sameOrigin(currentURL, request$3.url) && request$3.responseTainting === "basic" || currentURL.protocol === "data:" || request$3.mode === "navigate" || request$3.mode === "websocket") {
				request$3.responseTainting = "basic";
				return await schemeFetch(fetchParams);
			}
			if (request$3.mode === "same-origin") return makeNetworkError("request mode cannot be \"same-origin\"");
			if (request$3.mode === "no-cors") {
				if (request$3.redirect !== "follow") return makeNetworkError("redirect mode cannot be \"follow\" for \"no-cors\" request");
				request$3.responseTainting = "opaque";
				return await schemeFetch(fetchParams);
			}
			if (!urlIsHttpHttpsScheme$1(requestCurrentURL(request$3))) return makeNetworkError("URL scheme must be a HTTP(S) scheme");
			request$3.responseTainting = "cors";
			return await httpFetch(fetchParams);
		})();
		if (recursive) return response;
		if (response.status !== 0 && !response.internalResponse) {
			if (request$3.responseTainting === "cors") {}
			if (request$3.responseTainting === "basic") response = filterResponse(response, "basic");
			else if (request$3.responseTainting === "cors") response = filterResponse(response, "cors");
			else if (request$3.responseTainting === "opaque") response = filterResponse(response, "opaque");
			else assert$3(false);
		}
		let internalResponse = response.status === 0 ? response : response.internalResponse;
		if (internalResponse.urlList.length === 0) internalResponse.urlList.push(...request$3.urlList);
		if (!request$3.timingAllowFailed) response.timingAllowPassed = true;
		if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request$3.headers.contains("range")) response = internalResponse = makeNetworkError();
		if (response.status !== 0 && (request$3.method === "HEAD" || request$3.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
			internalResponse.body = null;
			fetchParams.controller.dump = true;
		}
		if (request$3.integrity) {
			const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
			if (request$3.responseTainting === "opaque" || response.body == null) {
				processBodyError(response.error);
				return;
			}
			const processBody = (bytes) => {
				if (!bytesMatch(bytes, request$3.integrity)) {
					processBodyError("integrity mismatch");
					return;
				}
				response.body = safelyExtractBody(bytes)[0];
				fetchFinale(fetchParams, response);
			};
			await fullyReadBody(response.body, processBody, processBodyError);
		} else fetchFinale(fetchParams, response);
	}
	function schemeFetch(fetchParams) {
		if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) return Promise.resolve(makeAppropriateNetworkError(fetchParams));
		const { request: request$3 } = fetchParams;
		const { protocol: scheme } = requestCurrentURL(request$3);
		switch (scheme) {
			case "about:": return Promise.resolve(makeNetworkError("about scheme is not supported"));
			case "blob:": {
				if (!resolveObjectURL) resolveObjectURL = require("buffer").resolveObjectURL;
				const blobURLEntry = requestCurrentURL(request$3);
				if (blobURLEntry.search.length !== 0) return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
				const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
				if (request$3.method !== "GET" || !isBlobLike$1(blobURLEntryObject)) return Promise.resolve(makeNetworkError("invalid method"));
				const bodyWithType = safelyExtractBody(blobURLEntryObject);
				const body = bodyWithType[0];
				const length = isomorphicEncode(`${body.length}`);
				const type = bodyWithType[1] ?? "";
				const response = makeResponse({
					statusText: "OK",
					headersList: [["content-length", {
						name: "Content-Length",
						value: length
					}], ["content-type", {
						name: "Content-Type",
						value: type
					}]]
				});
				response.body = body;
				return Promise.resolve(response);
			}
			case "data:": {
				const dataURLStruct = dataURLProcessor(requestCurrentURL(request$3));
				if (dataURLStruct === "failure") return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
				const mimeType = serializeAMimeType$1(dataURLStruct.mimeType);
				return Promise.resolve(makeResponse({
					statusText: "OK",
					headersList: [["content-type", {
						name: "Content-Type",
						value: mimeType
					}]],
					body: safelyExtractBody(dataURLStruct.body)[0]
				}));
			}
			case "file:": return Promise.resolve(makeNetworkError("not implemented... yet..."));
			case "http:":
			case "https:": return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
			default: return Promise.resolve(makeNetworkError("unknown scheme"));
		}
	}
	function finalizeResponse(fetchParams, response) {
		fetchParams.request.done = true;
		if (fetchParams.processResponseDone != null) queueMicrotask(() => fetchParams.processResponseDone(response));
	}
	function fetchFinale(fetchParams, response) {
		if (response.type === "error") {
			response.urlList = [fetchParams.request.urlList[0]];
			response.timingInfo = createOpaqueTimingInfo({ startTime: fetchParams.timingInfo.startTime });
		}
		const processResponseEndOfBody = () => {
			fetchParams.request.done = true;
			if (fetchParams.processResponseEndOfBody != null) queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
		};
		if (fetchParams.processResponse != null) queueMicrotask(() => fetchParams.processResponse(response));
		if (response.body == null) processResponseEndOfBody();
		else {
			const identityTransformAlgorithm = (chunk, controller) => {
				controller.enqueue(chunk);
			};
			const transformStream = new TransformStream({
				start() {},
				transform: identityTransformAlgorithm,
				flush: processResponseEndOfBody
			}, { size() {
				return 1;
			} }, { size() {
				return 1;
			} });
			response.body = { stream: response.body.stream.pipeThrough(transformStream) };
		}
		if (fetchParams.processResponseConsumeBody != null) {
			const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
			const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
			if (response.body == null) queueMicrotask(() => processBody(null));
			else return fullyReadBody(response.body, processBody, processBodyError);
			return Promise.resolve();
		}
	}
	async function httpFetch(fetchParams) {
		const request$3 = fetchParams.request;
		let response = null;
		let actualResponse = null;
		const timingInfo = fetchParams.timingInfo;
		if (request$3.serviceWorkers === "all") {}
		if (response === null) {
			if (request$3.redirect === "follow") request$3.serviceWorkers = "none";
			actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
			if (request$3.responseTainting === "cors" && corsCheck(request$3, response) === "failure") return makeNetworkError("cors failure");
			if (TAOCheck(request$3, response) === "failure") request$3.timingAllowFailed = true;
		}
		if ((request$3.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request$3.origin, request$3.client, request$3.destination, actualResponse) === "blocked") return makeNetworkError("blocked");
		if (redirectStatusSet.has(actualResponse.status)) {
			if (request$3.redirect !== "manual") fetchParams.controller.connection.destroy();
			if (request$3.redirect === "error") response = makeNetworkError("unexpected redirect");
			else if (request$3.redirect === "manual") response = actualResponse;
			else if (request$3.redirect === "follow") response = await httpRedirectFetch(fetchParams, response);
			else assert$3(false);
		}
		response.timingInfo = timingInfo;
		return response;
	}
	function httpRedirectFetch(fetchParams, response) {
		const request$3 = fetchParams.request;
		const actualResponse = response.internalResponse ? response.internalResponse : response;
		let locationURL;
		try {
			locationURL = responseLocationURL(actualResponse, requestCurrentURL(request$3).hash);
			if (locationURL == null) return response;
		} catch (err) {
			return Promise.resolve(makeNetworkError(err));
		}
		if (!urlIsHttpHttpsScheme$1(locationURL)) return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
		if (request$3.redirectCount === 20) return Promise.resolve(makeNetworkError("redirect count exceeded"));
		request$3.redirectCount += 1;
		if (request$3.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request$3, locationURL)) return Promise.resolve(makeNetworkError("cross origin not allowed for request mode \"cors\""));
		if (request$3.responseTainting === "cors" && (locationURL.username || locationURL.password)) return Promise.resolve(makeNetworkError("URL cannot contain credentials for request mode \"cors\""));
		if (actualResponse.status !== 303 && request$3.body != null && request$3.body.source == null) return Promise.resolve(makeNetworkError());
		if ([301, 302].includes(actualResponse.status) && request$3.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request$3.method)) {
			request$3.method = "GET";
			request$3.body = null;
			for (const headerName of requestBodyHeader) request$3.headersList.delete(headerName);
		}
		if (!sameOrigin(requestCurrentURL(request$3), locationURL)) {
			request$3.headersList.delete("authorization");
			request$3.headersList.delete("proxy-authorization", true);
			request$3.headersList.delete("cookie");
			request$3.headersList.delete("host");
		}
		if (request$3.body != null) {
			assert$3(request$3.body.source != null);
			request$3.body = safelyExtractBody(request$3.body.source)[0];
		}
		const timingInfo = fetchParams.timingInfo;
		timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
		if (timingInfo.redirectStartTime === 0) timingInfo.redirectStartTime = timingInfo.startTime;
		request$3.urlList.push(locationURL);
		setRequestReferrerPolicyOnRedirect(request$3, actualResponse);
		return mainFetch(fetchParams, true);
	}
	async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
		const request$3 = fetchParams.request;
		let httpFetchParams = null;
		let httpRequest = null;
		let response = null;
		const httpCache = null;
		if (request$3.window === "no-window" && request$3.redirect === "error") {
			httpFetchParams = fetchParams;
			httpRequest = request$3;
		} else {
			httpRequest = makeRequest$1(request$3);
			httpFetchParams = { ...fetchParams };
			httpFetchParams.request = httpRequest;
		}
		const includeCredentials = request$3.credentials === "include" || request$3.credentials === "same-origin" && request$3.responseTainting === "basic";
		const contentLength = httpRequest.body ? httpRequest.body.length : null;
		let contentLengthHeaderValue = null;
		if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) contentLengthHeaderValue = "0";
		if (contentLength != null) contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
		if (contentLengthHeaderValue != null) httpRequest.headersList.append("content-length", contentLengthHeaderValue);
		if (contentLength != null && httpRequest.keepalive) {}
		if (httpRequest.referrer instanceof URL) httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
		appendRequestOriginHeader(httpRequest);
		appendFetchMetadata(httpRequest);
		if (!httpRequest.headersList.contains("user-agent")) httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
		if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) httpRequest.cache = "no-store";
		if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) httpRequest.headersList.append("cache-control", "max-age=0");
		if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
			if (!httpRequest.headersList.contains("pragma")) httpRequest.headersList.append("pragma", "no-cache");
			if (!httpRequest.headersList.contains("cache-control")) httpRequest.headersList.append("cache-control", "no-cache");
		}
		if (httpRequest.headersList.contains("range")) httpRequest.headersList.append("accept-encoding", "identity");
		if (!httpRequest.headersList.contains("accept-encoding")) if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
		else httpRequest.headersList.append("accept-encoding", "gzip, deflate");
		httpRequest.headersList.delete("host");
		if (includeCredentials) {}
		if (httpCache == null) httpRequest.cache = "no-store";
		if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {}
		if (response == null) {
			if (httpRequest.mode === "only-if-cached") return makeNetworkError("only if cached");
			const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
			if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {}
			if (response == null) response = forwardResponse;
		}
		response.urlList = [...httpRequest.urlList];
		if (httpRequest.headersList.contains("range")) response.rangeRequested = true;
		response.requestIncludesCredentials = includeCredentials;
		if (response.status === 407) {
			if (request$3.window === "no-window") return makeNetworkError();
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			return makeNetworkError("proxy authentication required");
		}
		if (response.status === 421 && !isNewConnectionFetch && (request$3.body == null || request$3.body.source != null)) {
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			fetchParams.controller.connection.destroy();
			response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
		}
		if (isAuthenticationFetch) {}
		return response;
	}
	async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
		assert$3(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
		fetchParams.controller.connection = {
			abort: null,
			destroyed: false,
			destroy(err) {
				if (!this.destroyed) {
					this.destroyed = true;
					this.abort?.(err ?? new DOMException$4("The operation was aborted.", "AbortError"));
				}
			}
		};
		const request$3 = fetchParams.request;
		let response = null;
		const timingInfo = fetchParams.timingInfo;
		request$3.cache = "no-store";
		if (request$3.mode === "websocket") {}
		let requestBody = null;
		if (request$3.body == null && fetchParams.processRequestEndOfBody) queueMicrotask(() => fetchParams.processRequestEndOfBody());
		else if (request$3.body != null) {
			const processBodyChunk = async function* (bytes) {
				if (isCancelled(fetchParams)) return;
				yield bytes;
				fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
			};
			const processEndOfBody = () => {
				if (isCancelled(fetchParams)) return;
				if (fetchParams.processRequestEndOfBody) fetchParams.processRequestEndOfBody();
			};
			const processBodyError = (e$1) => {
				if (isCancelled(fetchParams)) return;
				if (e$1.name === "AbortError") fetchParams.controller.abort();
				else fetchParams.controller.terminate(e$1);
			};
			requestBody = (async function* () {
				try {
					for await (const bytes of request$3.body.stream) yield* processBodyChunk(bytes);
					processEndOfBody();
				} catch (err) {
					processBodyError(err);
				}
			})();
		}
		try {
			const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
			if (socket) response = makeResponse({
				status,
				statusText,
				headersList,
				socket
			});
			else {
				const iterator$1 = body[Symbol.asyncIterator]();
				fetchParams.controller.next = () => iterator$1.next();
				response = makeResponse({
					status,
					statusText,
					headersList
				});
			}
		} catch (err) {
			if (err.name === "AbortError") {
				fetchParams.controller.connection.destroy();
				return makeAppropriateNetworkError(fetchParams, err);
			}
			return makeNetworkError(err);
		}
		const pullAlgorithm = () => {
			fetchParams.controller.resume();
		};
		const cancelAlgorithm = (reason) => {
			fetchParams.controller.abort(reason);
		};
		if (!ReadableStream$1) ReadableStream$1 = require("stream/web").ReadableStream;
		const stream$6 = new ReadableStream$1({
			async start(controller) {
				fetchParams.controller.controller = controller;
			},
			async pull(controller) {
				await pullAlgorithm(controller);
			},
			async cancel(reason) {
				await cancelAlgorithm(reason);
			}
		}, {
			highWaterMark: 0,
			size() {
				return 1;
			}
		});
		response.body = { stream: stream$6 };
		fetchParams.controller.on("terminated", onAborted);
		fetchParams.controller.resume = async () => {
			while (true) {
				let bytes;
				let isFailure;
				try {
					const { done, value } = await fetchParams.controller.next();
					if (isAborted(fetchParams)) break;
					bytes = done ? void 0 : value;
				} catch (err) {
					if (fetchParams.controller.ended && !timingInfo.encodedBodySize) bytes = void 0;
					else {
						bytes = err;
						isFailure = true;
					}
				}
				if (bytes === void 0) {
					readableStreamClose(fetchParams.controller.controller);
					finalizeResponse(fetchParams, response);
					return;
				}
				timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
				if (isFailure) {
					fetchParams.controller.terminate(bytes);
					return;
				}
				fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
				if (isErrored(stream$6)) {
					fetchParams.controller.terminate();
					return;
				}
				if (!fetchParams.controller.controller.desiredSize) return;
			}
		};
		function onAborted(reason) {
			if (isAborted(fetchParams)) {
				response.aborted = true;
				if (isReadable(stream$6)) fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
			} else if (isReadable(stream$6)) fetchParams.controller.controller.error(new TypeError("terminated", { cause: isErrorLike(reason) ? reason : void 0 }));
			fetchParams.controller.connection.destroy();
		}
		return response;
		async function dispatch({ body }) {
			const url = requestCurrentURL(request$3);
			/** @type {import('../..').Agent} */
			const agent = fetchParams.controller.dispatcher;
			return new Promise((resolve, reject) => agent.dispatch({
				path: url.pathname + url.search,
				origin: url.origin,
				method: request$3.method,
				body: fetchParams.controller.dispatcher.isMockActive ? request$3.body && (request$3.body.source || request$3.body.stream) : body,
				headers: request$3.headersList.entries,
				maxRedirections: 0,
				upgrade: request$3.mode === "websocket" ? "websocket" : void 0
			}, {
				body: null,
				abort: null,
				onConnect(abort$1) {
					const { connection } = fetchParams.controller;
					if (connection.destroyed) abort$1(new DOMException$4("The operation was aborted.", "AbortError"));
					else {
						fetchParams.controller.on("terminated", abort$1);
						this.abort = connection.abort = abort$1;
					}
				},
				onHeaders(status, headersList, resume$3, statusText) {
					if (status < 200) return;
					let codings = [];
					let location = "";
					const headers = new Headers$5();
					if (Array.isArray(headersList)) for (let n = 0; n < headersList.length; n += 2) {
						const key = headersList[n + 0].toString("latin1");
						const val = headersList[n + 1].toString("latin1");
						if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x$1) => x$1.trim());
						else if (key.toLowerCase() === "location") location = val;
						headers[kHeadersList$2].append(key, val);
					}
					else {
						const keys = Object.keys(headersList);
						for (const key of keys) {
							const val = headersList[key];
							if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x$1) => x$1.trim()).reverse();
							else if (key.toLowerCase() === "location") location = val;
							headers[kHeadersList$2].append(key, val);
						}
					}
					this.body = new Readable$2({ read: resume$3 });
					const decoders$1 = [];
					const willFollow = request$3.redirect === "follow" && location && redirectStatusSet.has(status);
					if (request$3.method !== "HEAD" && request$3.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) for (const coding of codings) if (coding === "x-gzip" || coding === "gzip") decoders$1.push(zlib$2.createGunzip({
						flush: zlib$2.constants.Z_SYNC_FLUSH,
						finishFlush: zlib$2.constants.Z_SYNC_FLUSH
					}));
					else if (coding === "deflate") decoders$1.push(zlib$2.createInflate());
					else if (coding === "br") decoders$1.push(zlib$2.createBrotliDecompress());
					else {
						decoders$1.length = 0;
						break;
					}
					resolve({
						status,
						statusText,
						headersList: headers[kHeadersList$2],
						body: decoders$1.length ? pipeline$1(this.body, ...decoders$1, () => {}) : this.body.on("error", () => {})
					});
					return true;
				},
				onData(chunk) {
					if (fetchParams.controller.dump) return;
					const bytes = chunk;
					timingInfo.encodedBodySize += bytes.byteLength;
					return this.body.push(bytes);
				},
				onComplete() {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					fetchParams.controller.ended = true;
					this.body.push(null);
				},
				onError(error$1) {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					this.body?.destroy(error$1);
					fetchParams.controller.terminate(error$1);
					reject(error$1);
				},
				onUpgrade(status, headersList, socket) {
					if (status !== 101) return;
					const headers = new Headers$5();
					for (let n = 0; n < headersList.length; n += 2) {
						const key = headersList[n + 0].toString("latin1");
						const val = headersList[n + 1].toString("latin1");
						headers[kHeadersList$2].append(key, val);
					}
					resolve({
						status,
						statusText: STATUS_CODES[status],
						headersList: headers[kHeadersList$2],
						socket
					});
					return true;
				}
			}));
		}
	}
	module.exports = {
		fetch: fetch$2,
		Fetch,
		fetching: fetching$2,
		finalizeAndReportTiming
	};
}));

//#endregion
//#region node_modules/undici/lib/fileapi/symbols.js
var require_symbols$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kState: Symbol("FileReader state"),
		kResult: Symbol("FileReader result"),
		kError: Symbol("FileReader error"),
		kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
		kEvents: Symbol("FileReader events"),
		kAborted: Symbol("FileReader aborted")
	};
}));

//#endregion
//#region node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { webidl: webidl$6 } = require_webidl();
	const kState$3 = Symbol("ProgressEvent state");
	/**
	* @see https://xhr.spec.whatwg.org/#progressevent
	*/
	var ProgressEvent$1 = class ProgressEvent$1 extends Event {
		constructor(type, eventInitDict = {}) {
			type = webidl$6.converters.DOMString(type);
			eventInitDict = webidl$6.converters.ProgressEventInit(eventInitDict ?? {});
			super(type, eventInitDict);
			this[kState$3] = {
				lengthComputable: eventInitDict.lengthComputable,
				loaded: eventInitDict.loaded,
				total: eventInitDict.total
			};
		}
		get lengthComputable() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].lengthComputable;
		}
		get loaded() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].loaded;
		}
		get total() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].total;
		}
	};
	webidl$6.converters.ProgressEventInit = webidl$6.dictionaryConverter([
		{
			key: "lengthComputable",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "loaded",
			converter: webidl$6.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "total",
			converter: webidl$6.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "bubbles",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		}
	]);
	module.exports = { ProgressEvent: ProgressEvent$1 };
}));

//#endregion
//#region node_modules/undici/lib/fileapi/encoding.js
var require_encoding = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* @see https://encoding.spec.whatwg.org/#concept-encoding-get
	* @param {string|undefined} label
	*/
	function getEncoding$1(label) {
		if (!label) return "failure";
		switch (label.trim().toLowerCase()) {
			case "unicode-1-1-utf-8":
			case "unicode11utf8":
			case "unicode20utf8":
			case "utf-8":
			case "utf8":
			case "x-unicode20utf8": return "UTF-8";
			case "866":
			case "cp866":
			case "csibm866":
			case "ibm866": return "IBM866";
			case "csisolatin2":
			case "iso-8859-2":
			case "iso-ir-101":
			case "iso8859-2":
			case "iso88592":
			case "iso_8859-2":
			case "iso_8859-2:1987":
			case "l2":
			case "latin2": return "ISO-8859-2";
			case "csisolatin3":
			case "iso-8859-3":
			case "iso-ir-109":
			case "iso8859-3":
			case "iso88593":
			case "iso_8859-3":
			case "iso_8859-3:1988":
			case "l3":
			case "latin3": return "ISO-8859-3";
			case "csisolatin4":
			case "iso-8859-4":
			case "iso-ir-110":
			case "iso8859-4":
			case "iso88594":
			case "iso_8859-4":
			case "iso_8859-4:1988":
			case "l4":
			case "latin4": return "ISO-8859-4";
			case "csisolatincyrillic":
			case "cyrillic":
			case "iso-8859-5":
			case "iso-ir-144":
			case "iso8859-5":
			case "iso88595":
			case "iso_8859-5":
			case "iso_8859-5:1988": return "ISO-8859-5";
			case "arabic":
			case "asmo-708":
			case "csiso88596e":
			case "csiso88596i":
			case "csisolatinarabic":
			case "ecma-114":
			case "iso-8859-6":
			case "iso-8859-6-e":
			case "iso-8859-6-i":
			case "iso-ir-127":
			case "iso8859-6":
			case "iso88596":
			case "iso_8859-6":
			case "iso_8859-6:1987": return "ISO-8859-6";
			case "csisolatingreek":
			case "ecma-118":
			case "elot_928":
			case "greek":
			case "greek8":
			case "iso-8859-7":
			case "iso-ir-126":
			case "iso8859-7":
			case "iso88597":
			case "iso_8859-7":
			case "iso_8859-7:1987":
			case "sun_eu_greek": return "ISO-8859-7";
			case "csiso88598e":
			case "csisolatinhebrew":
			case "hebrew":
			case "iso-8859-8":
			case "iso-8859-8-e":
			case "iso-ir-138":
			case "iso8859-8":
			case "iso88598":
			case "iso_8859-8":
			case "iso_8859-8:1988":
			case "visual": return "ISO-8859-8";
			case "csiso88598i":
			case "iso-8859-8-i":
			case "logical": return "ISO-8859-8-I";
			case "csisolatin6":
			case "iso-8859-10":
			case "iso-ir-157":
			case "iso8859-10":
			case "iso885910":
			case "l6":
			case "latin6": return "ISO-8859-10";
			case "iso-8859-13":
			case "iso8859-13":
			case "iso885913": return "ISO-8859-13";
			case "iso-8859-14":
			case "iso8859-14":
			case "iso885914": return "ISO-8859-14";
			case "csisolatin9":
			case "iso-8859-15":
			case "iso8859-15":
			case "iso885915":
			case "iso_8859-15":
			case "l9": return "ISO-8859-15";
			case "iso-8859-16": return "ISO-8859-16";
			case "cskoi8r":
			case "koi":
			case "koi8":
			case "koi8-r":
			case "koi8_r": return "KOI8-R";
			case "koi8-ru":
			case "koi8-u": return "KOI8-U";
			case "csmacintosh":
			case "mac":
			case "macintosh":
			case "x-mac-roman": return "macintosh";
			case "iso-8859-11":
			case "iso8859-11":
			case "iso885911":
			case "tis-620":
			case "windows-874": return "windows-874";
			case "cp1250":
			case "windows-1250":
			case "x-cp1250": return "windows-1250";
			case "cp1251":
			case "windows-1251":
			case "x-cp1251": return "windows-1251";
			case "ansi_x3.4-1968":
			case "ascii":
			case "cp1252":
			case "cp819":
			case "csisolatin1":
			case "ibm819":
			case "iso-8859-1":
			case "iso-ir-100":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "iso_8859-1:1987":
			case "l1":
			case "latin1":
			case "us-ascii":
			case "windows-1252":
			case "x-cp1252": return "windows-1252";
			case "cp1253":
			case "windows-1253":
			case "x-cp1253": return "windows-1253";
			case "cp1254":
			case "csisolatin5":
			case "iso-8859-9":
			case "iso-ir-148":
			case "iso8859-9":
			case "iso88599":
			case "iso_8859-9":
			case "iso_8859-9:1989":
			case "l5":
			case "latin5":
			case "windows-1254":
			case "x-cp1254": return "windows-1254";
			case "cp1255":
			case "windows-1255":
			case "x-cp1255": return "windows-1255";
			case "cp1256":
			case "windows-1256":
			case "x-cp1256": return "windows-1256";
			case "cp1257":
			case "windows-1257":
			case "x-cp1257": return "windows-1257";
			case "cp1258":
			case "windows-1258":
			case "x-cp1258": return "windows-1258";
			case "x-mac-cyrillic":
			case "x-mac-ukrainian": return "x-mac-cyrillic";
			case "chinese":
			case "csgb2312":
			case "csiso58gb231280":
			case "gb2312":
			case "gb_2312":
			case "gb_2312-80":
			case "gbk":
			case "iso-ir-58":
			case "x-gbk": return "GBK";
			case "gb18030": return "gb18030";
			case "big5":
			case "big5-hkscs":
			case "cn-big5":
			case "csbig5":
			case "x-x-big5": return "Big5";
			case "cseucpkdfmtjapanese":
			case "euc-jp":
			case "x-euc-jp": return "EUC-JP";
			case "csiso2022jp":
			case "iso-2022-jp": return "ISO-2022-JP";
			case "csshiftjis":
			case "ms932":
			case "ms_kanji":
			case "shift-jis":
			case "shift_jis":
			case "sjis":
			case "windows-31j":
			case "x-sjis": return "Shift_JIS";
			case "cseuckr":
			case "csksc56011987":
			case "euc-kr":
			case "iso-ir-149":
			case "korean":
			case "ks_c_5601-1987":
			case "ks_c_5601-1989":
			case "ksc5601":
			case "ksc_5601":
			case "windows-949": return "EUC-KR";
			case "csiso2022kr":
			case "hz-gb-2312":
			case "iso-2022-cn":
			case "iso-2022-cn-ext":
			case "iso-2022-kr":
			case "replacement": return "replacement";
			case "unicodefffe":
			case "utf-16be": return "UTF-16BE";
			case "csunicode":
			case "iso-10646-ucs-2":
			case "ucs-2":
			case "unicode":
			case "unicodefeff":
			case "utf-16":
			case "utf-16le": return "UTF-16LE";
			case "x-user-defined": return "x-user-defined";
			default: return "failure";
		}
	}
	module.exports = { getEncoding: getEncoding$1 };
}));

//#endregion
//#region node_modules/undici/lib/fileapi/util.js
var require_util$5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kState: kState$2, kError: kError$3, kResult: kResult$1, kAborted: kAborted$2, kLastProgressEventFired } = require_symbols$2();
	const { ProgressEvent } = require_progressevent();
	const { getEncoding } = require_encoding();
	const { DOMException: DOMException$3 } = require_constants$4();
	const { serializeAMimeType, parseMIMEType } = require_dataURL();
	const { types: types$3 } = require("util");
	const { StringDecoder } = require("string_decoder");
	const { btoa: btoa$1 } = require("buffer");
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors$3 = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	/**
	* @see https://w3c.github.io/FileAPI/#readOperation
	* @param {import('./filereader').FileReader} fr
	* @param {import('buffer').Blob} blob
	* @param {string} type
	* @param {string?} encodingName
	*/
	function readOperation$1(fr, blob, type, encodingName) {
		if (fr[kState$2] === "loading") throw new DOMException$3("Invalid state", "InvalidStateError");
		fr[kState$2] = "loading";
		fr[kResult$1] = null;
		fr[kError$3] = null;
		const reader = blob.stream().getReader();
		/** @type {Uint8Array[]} */
		const bytes = [];
		let chunkPromise = reader.read();
		let isFirstChunk = true;
		(async () => {
			while (!fr[kAborted$2]) try {
				const { done, value } = await chunkPromise;
				if (isFirstChunk && !fr[kAborted$2]) queueMicrotask(() => {
					fireAProgressEvent$1("loadstart", fr);
				});
				isFirstChunk = false;
				if (!done && types$3.isUint8Array(value)) {
					bytes.push(value);
					if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted$2]) {
						fr[kLastProgressEventFired] = Date.now();
						queueMicrotask(() => {
							fireAProgressEvent$1("progress", fr);
						});
					}
					chunkPromise = reader.read();
				} else if (done) {
					queueMicrotask(() => {
						fr[kState$2] = "done";
						try {
							const result = packageData(bytes, type, blob.type, encodingName);
							if (fr[kAborted$2]) return;
							fr[kResult$1] = result;
							fireAProgressEvent$1("load", fr);
						} catch (error$1) {
							fr[kError$3] = error$1;
							fireAProgressEvent$1("error", fr);
						}
						if (fr[kState$2] !== "loading") fireAProgressEvent$1("loadend", fr);
					});
					break;
				}
			} catch (error$1) {
				if (fr[kAborted$2]) return;
				queueMicrotask(() => {
					fr[kState$2] = "done";
					fr[kError$3] = error$1;
					fireAProgressEvent$1("error", fr);
					if (fr[kState$2] !== "loading") fireAProgressEvent$1("loadend", fr);
				});
				break;
			}
		})();
	}
	/**
	* @see https://w3c.github.io/FileAPI/#fire-a-progress-event
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e The name of the event
	* @param {import('./filereader').FileReader} reader
	*/
	function fireAProgressEvent$1(e$1, reader) {
		const event = new ProgressEvent(e$1, {
			bubbles: false,
			cancelable: false
		});
		reader.dispatchEvent(event);
	}
	/**
	* @see https://w3c.github.io/FileAPI/#blob-package-data
	* @param {Uint8Array[]} bytes
	* @param {string} type
	* @param {string?} mimeType
	* @param {string?} encodingName
	*/
	function packageData(bytes, type, mimeType, encodingName) {
		switch (type) {
			case "DataURL": {
				let dataURL = "data:";
				const parsed = parseMIMEType(mimeType || "application/octet-stream");
				if (parsed !== "failure") dataURL += serializeAMimeType(parsed);
				dataURL += ";base64,";
				const decoder = new StringDecoder("latin1");
				for (const chunk of bytes) dataURL += btoa$1(decoder.write(chunk));
				dataURL += btoa$1(decoder.end());
				return dataURL;
			}
			case "Text": {
				let encoding = "failure";
				if (encodingName) encoding = getEncoding(encodingName);
				if (encoding === "failure" && mimeType) {
					const type$1 = parseMIMEType(mimeType);
					if (type$1 !== "failure") encoding = getEncoding(type$1.parameters.get("charset"));
				}
				if (encoding === "failure") encoding = "UTF-8";
				return decode(bytes, encoding);
			}
			case "ArrayBuffer": return combineByteSequences(bytes).buffer;
			case "BinaryString": {
				let binaryString = "";
				const decoder = new StringDecoder("latin1");
				for (const chunk of bytes) binaryString += decoder.write(chunk);
				binaryString += decoder.end();
				return binaryString;
			}
		}
	}
	/**
	* @see https://encoding.spec.whatwg.org/#decode
	* @param {Uint8Array[]} ioQueue
	* @param {string} encoding
	*/
	function decode(ioQueue, encoding) {
		const bytes = combineByteSequences(ioQueue);
		const BOMEncoding = BOMSniffing(bytes);
		let slice = 0;
		if (BOMEncoding !== null) {
			encoding = BOMEncoding;
			slice = BOMEncoding === "UTF-8" ? 3 : 2;
		}
		const sliced = bytes.slice(slice);
		return new TextDecoder(encoding).decode(sliced);
	}
	/**
	* @see https://encoding.spec.whatwg.org/#bom-sniff
	* @param {Uint8Array} ioQueue
	*/
	function BOMSniffing(ioQueue) {
		const [a, b, c] = ioQueue;
		if (a === 239 && b === 187 && c === 191) return "UTF-8";
		else if (a === 254 && b === 255) return "UTF-16BE";
		else if (a === 255 && b === 254) return "UTF-16LE";
		return null;
	}
	/**
	* @param {Uint8Array[]} sequences
	*/
	function combineByteSequences(sequences) {
		const size = sequences.reduce((a, b) => {
			return a + b.byteLength;
		}, 0);
		let offset = 0;
		return sequences.reduce((a, b) => {
			a.set(b, offset);
			offset += b.byteLength;
			return a;
		}, new Uint8Array(size));
	}
	module.exports = {
		staticPropertyDescriptors: staticPropertyDescriptors$3,
		readOperation: readOperation$1,
		fireAProgressEvent: fireAProgressEvent$1
	};
}));

//#endregion
//#region node_modules/undici/lib/fileapi/filereader.js
var require_filereader = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { staticPropertyDescriptors: staticPropertyDescriptors$2, readOperation, fireAProgressEvent } = require_util$5();
	const { kState: kState$1, kError: kError$2, kResult, kEvents, kAborted: kAborted$1 } = require_symbols$2();
	const { webidl: webidl$5 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$4 } = require_util$8();
	var FileReader = class FileReader extends EventTarget {
		constructor() {
			super();
			this[kState$1] = "empty";
			this[kResult] = null;
			this[kError$2] = null;
			this[kEvents] = {
				loadend: null,
				error: null,
				abort: null,
				load: null,
				progress: null,
				loadstart: null
			};
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
		* @param {import('buffer').Blob} blob
		*/
		readAsArrayBuffer(blob) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "ArrayBuffer");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsBinaryString
		* @param {import('buffer').Blob} blob
		*/
		readAsBinaryString(blob) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "BinaryString");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsDataText
		* @param {import('buffer').Blob} blob
		* @param {string?} encoding
		*/
		readAsText(blob, encoding = void 0) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			if (encoding !== void 0) encoding = webidl$5.converters.DOMString(encoding);
			readOperation(this, blob, "Text", encoding);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
		* @param {import('buffer').Blob} blob
		*/
		readAsDataURL(blob) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "DataURL");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-abort
		*/
		abort() {
			if (this[kState$1] === "empty" || this[kState$1] === "done") {
				this[kResult] = null;
				return;
			}
			if (this[kState$1] === "loading") {
				this[kState$1] = "done";
				this[kResult] = null;
			}
			this[kAborted$1] = true;
			fireAProgressEvent("abort", this);
			if (this[kState$1] !== "loading") fireAProgressEvent("loadend", this);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
		*/
		get readyState() {
			webidl$5.brandCheck(this, FileReader);
			switch (this[kState$1]) {
				case "empty": return this.EMPTY;
				case "loading": return this.LOADING;
				case "done": return this.DONE;
			}
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-result
		*/
		get result() {
			webidl$5.brandCheck(this, FileReader);
			return this[kResult];
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-error
		*/
		get error() {
			webidl$5.brandCheck(this, FileReader);
			return this[kError$2];
		}
		get onloadend() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].loadend;
		}
		set onloadend(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].loadend) this.removeEventListener("loadend", this[kEvents].loadend);
			if (typeof fn === "function") {
				this[kEvents].loadend = fn;
				this.addEventListener("loadend", fn);
			} else this[kEvents].loadend = null;
		}
		get onerror() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].error;
		}
		set onerror(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].error) this.removeEventListener("error", this[kEvents].error);
			if (typeof fn === "function") {
				this[kEvents].error = fn;
				this.addEventListener("error", fn);
			} else this[kEvents].error = null;
		}
		get onloadstart() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].loadstart;
		}
		set onloadstart(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].loadstart) this.removeEventListener("loadstart", this[kEvents].loadstart);
			if (typeof fn === "function") {
				this[kEvents].loadstart = fn;
				this.addEventListener("loadstart", fn);
			} else this[kEvents].loadstart = null;
		}
		get onprogress() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].progress;
		}
		set onprogress(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].progress) this.removeEventListener("progress", this[kEvents].progress);
			if (typeof fn === "function") {
				this[kEvents].progress = fn;
				this.addEventListener("progress", fn);
			} else this[kEvents].progress = null;
		}
		get onload() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].load;
		}
		set onload(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].load) this.removeEventListener("load", this[kEvents].load);
			if (typeof fn === "function") {
				this[kEvents].load = fn;
				this.addEventListener("load", fn);
			} else this[kEvents].load = null;
		}
		get onabort() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].abort;
		}
		set onabort(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].abort) this.removeEventListener("abort", this[kEvents].abort);
			if (typeof fn === "function") {
				this[kEvents].abort = fn;
				this.addEventListener("abort", fn);
			} else this[kEvents].abort = null;
		}
	};
	FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
	FileReader.LOADING = FileReader.prototype.LOADING = 1;
	FileReader.DONE = FileReader.prototype.DONE = 2;
	Object.defineProperties(FileReader.prototype, {
		EMPTY: staticPropertyDescriptors$2,
		LOADING: staticPropertyDescriptors$2,
		DONE: staticPropertyDescriptors$2,
		readAsArrayBuffer: kEnumerableProperty$4,
		readAsBinaryString: kEnumerableProperty$4,
		readAsText: kEnumerableProperty$4,
		readAsDataURL: kEnumerableProperty$4,
		abort: kEnumerableProperty$4,
		readyState: kEnumerableProperty$4,
		result: kEnumerableProperty$4,
		error: kEnumerableProperty$4,
		onloadstart: kEnumerableProperty$4,
		onprogress: kEnumerableProperty$4,
		onload: kEnumerableProperty$4,
		onabort: kEnumerableProperty$4,
		onerror: kEnumerableProperty$4,
		onloadend: kEnumerableProperty$4,
		[Symbol.toStringTag]: {
			value: "FileReader",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(FileReader, {
		EMPTY: staticPropertyDescriptors$2,
		LOADING: staticPropertyDescriptors$2,
		DONE: staticPropertyDescriptors$2
	});
	module.exports = { FileReader };
}));

//#endregion
//#region node_modules/undici/lib/cache/symbols.js
var require_symbols$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = { kConstruct: require_symbols$4().kConstruct };
}));

//#endregion
//#region node_modules/undici/lib/cache/util.js
var require_util$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$2 = require("assert");
	const { URLSerializer: URLSerializer$1 } = require_dataURL();
	const { isValidHeaderName } = require_util$7();
	/**
	* @see https://url.spec.whatwg.org/#concept-url-equals
	* @param {URL} A
	* @param {URL} B
	* @param {boolean | undefined} excludeFragment
	* @returns {boolean}
	*/
	function urlEquals$1(A$1, B, excludeFragment = false) {
		return URLSerializer$1(A$1, excludeFragment) === URLSerializer$1(B, excludeFragment);
	}
	/**
	* @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
	* @param {string} header
	*/
	function fieldValues(header) {
		assert$2(header !== null);
		const values = [];
		for (let value of header.split(",")) {
			value = value.trim();
			if (!value.length) continue;
			else if (!isValidHeaderName(value)) continue;
			values.push(value);
		}
		return values;
	}
	module.exports = {
		urlEquals: urlEquals$1,
		fieldValues
	};
}));

//#endregion
//#region node_modules/undici/lib/cache/cache.js
var require_cache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kConstruct: kConstruct$1 } = require_symbols$1();
	const { urlEquals, fieldValues: getFieldValues } = require_util$4();
	const { kEnumerableProperty: kEnumerableProperty$3, isDisturbed } = require_util$8();
	const { kHeadersList: kHeadersList$1 } = require_symbols$4();
	const { webidl: webidl$4 } = require_webidl();
	const { Response: Response$2, cloneResponse } = require_response();
	const { Request: Request$1 } = require_request();
	const { kState, kHeaders, kGuard, kRealm } = require_symbols$3();
	const { fetching: fetching$1 } = require_fetch();
	const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util$7();
	const assert$1 = require("assert");
	const { getGlobalDispatcher: getGlobalDispatcher$3 } = require_global();
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
	* @typedef {Object} CacheBatchOperation
	* @property {'delete' | 'put'} type
	* @property {any} request
	* @property {any} response
	* @property {import('../../types/cache').CacheQueryOptions} options
	*/
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
	* @typedef {[any, any][]} requestResponseList
	*/
	var Cache$1 = class Cache$1 {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
		* @type {requestResponseList}
		*/
		#relevantRequestResponseList;
		constructor() {
			if (arguments[0] !== kConstruct$1) webidl$4.illegalConstructor();
			this.#relevantRequestResponseList = arguments[1];
		}
		async match(request$3, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
			request$3 = webidl$4.converters.RequestInfo(request$3);
			options = webidl$4.converters.CacheQueryOptions(options);
			const p = await this.matchAll(request$3, options);
			if (p.length === 0) return;
			return p[0];
		}
		async matchAll(request$3 = void 0, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			if (request$3 !== void 0) request$3 = webidl$4.converters.RequestInfo(request$3);
			options = webidl$4.converters.CacheQueryOptions(options);
			let r$1 = null;
			if (request$3 !== void 0) {
				if (request$3 instanceof Request$1) {
					r$1 = request$3[kState];
					if (r$1.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$3 === "string") r$1 = new Request$1(request$3)[kState];
			}
			const responses = [];
			if (request$3 === void 0) for (const requestResponse of this.#relevantRequestResponseList) responses.push(requestResponse[1]);
			else {
				const requestResponses = this.#queryCache(r$1, options);
				for (const requestResponse of requestResponses) responses.push(requestResponse[1]);
			}
			const responseList = [];
			for (const response of responses) {
				const responseObject = new Response$2(response.body?.source ?? null);
				const body = responseObject[kState].body;
				responseObject[kState] = response;
				responseObject[kState].body = body;
				responseObject[kHeaders][kHeadersList$1] = response.headersList;
				responseObject[kHeaders][kGuard] = "immutable";
				responseList.push(responseObject);
			}
			return Object.freeze(responseList);
		}
		async add(request$3) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
			request$3 = webidl$4.converters.RequestInfo(request$3);
			const requests = [request$3];
			return await this.addAll(requests);
		}
		async addAll(requests) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
			requests = webidl$4.converters["sequence<RequestInfo>"](requests);
			const responsePromises = [];
			const requestList = [];
			for (const request$3 of requests) {
				if (typeof request$3 === "string") continue;
				const r$1 = request$3[kState];
				if (!urlIsHttpHttpsScheme(r$1.url) || r$1.method !== "GET") throw webidl$4.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme when method is not GET."
				});
			}
			/** @type {ReturnType<typeof fetching>[]} */
			const fetchControllers = [];
			for (const request$3 of requests) {
				const r$1 = new Request$1(request$3)[kState];
				if (!urlIsHttpHttpsScheme(r$1.url)) throw webidl$4.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme."
				});
				r$1.initiator = "fetch";
				r$1.destination = "subresource";
				requestList.push(r$1);
				const responsePromise = createDeferredPromise();
				fetchControllers.push(fetching$1({
					request: r$1,
					dispatcher: getGlobalDispatcher$3(),
					processResponse(response) {
						if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) responsePromise.reject(webidl$4.errors.exception({
							header: "Cache.addAll",
							message: "Received an invalid status code or the request failed."
						}));
						else if (response.headersList.contains("vary")) {
							const fieldValues$1 = getFieldValues(response.headersList.get("vary"));
							for (const fieldValue of fieldValues$1) if (fieldValue === "*") {
								responsePromise.reject(webidl$4.errors.exception({
									header: "Cache.addAll",
									message: "invalid vary field value"
								}));
								for (const controller of fetchControllers) controller.abort();
								return;
							}
						}
					},
					processResponseEndOfBody(response) {
						if (response.aborted) {
							responsePromise.reject(new DOMException("aborted", "AbortError"));
							return;
						}
						responsePromise.resolve(response);
					}
				}));
				responsePromises.push(responsePromise.promise);
			}
			const responses = await Promise.all(responsePromises);
			const operations = [];
			let index = 0;
			for (const response of responses) {
				/** @type {CacheBatchOperation} */
				const operation = {
					type: "put",
					request: requestList[index],
					response
				};
				operations.push(operation);
				index++;
			}
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e$1) {
				errorData = e$1;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(void 0);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async put(request$3, response) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
			request$3 = webidl$4.converters.RequestInfo(request$3);
			response = webidl$4.converters.Response(response);
			let innerRequest = null;
			if (request$3 instanceof Request$1) innerRequest = request$3[kState];
			else innerRequest = new Request$1(request$3)[kState];
			if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Expected an http/s scheme when method is not GET"
			});
			const innerResponse = response[kState];
			if (innerResponse.status === 206) throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Got 206 status"
			});
			if (innerResponse.headersList.contains("vary")) {
				const fieldValues$1 = getFieldValues(innerResponse.headersList.get("vary"));
				for (const fieldValue of fieldValues$1) if (fieldValue === "*") throw webidl$4.errors.exception({
					header: "Cache.put",
					message: "Got * vary field value"
				});
			}
			if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Response body is locked or disturbed"
			});
			const clonedResponse = cloneResponse(innerResponse);
			const bodyReadPromise = createDeferredPromise();
			if (innerResponse.body != null) readAllBytes(innerResponse.body.stream.getReader()).then(bodyReadPromise.resolve, bodyReadPromise.reject);
			else bodyReadPromise.resolve(void 0);
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation = {
				type: "put",
				request: innerRequest,
				response: clonedResponse
			};
			operations.push(operation);
			const bytes = await bodyReadPromise.promise;
			if (clonedResponse.body != null) clonedResponse.body.source = bytes;
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e$1) {
				errorData = e$1;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve();
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async delete(request$3, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
			request$3 = webidl$4.converters.RequestInfo(request$3);
			options = webidl$4.converters.CacheQueryOptions(options);
			/**
			* @type {Request}
			*/
			let r$1 = null;
			if (request$3 instanceof Request$1) {
				r$1 = request$3[kState];
				if (r$1.method !== "GET" && !options.ignoreMethod) return false;
			} else {
				assert$1(typeof request$3 === "string");
				r$1 = new Request$1(request$3)[kState];
			}
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation = {
				type: "delete",
				request: r$1,
				options
			};
			operations.push(operation);
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			let requestResponses;
			try {
				requestResponses = this.#batchCacheOperations(operations);
			} catch (e$1) {
				errorData = e$1;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(!!requestResponses?.length);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
		* @param {any} request
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @returns {readonly Request[]}
		*/
		async keys(request$3 = void 0, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			if (request$3 !== void 0) request$3 = webidl$4.converters.RequestInfo(request$3);
			options = webidl$4.converters.CacheQueryOptions(options);
			let r$1 = null;
			if (request$3 !== void 0) {
				if (request$3 instanceof Request$1) {
					r$1 = request$3[kState];
					if (r$1.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$3 === "string") r$1 = new Request$1(request$3)[kState];
			}
			const promise = createDeferredPromise();
			const requests = [];
			if (request$3 === void 0) for (const requestResponse of this.#relevantRequestResponseList) requests.push(requestResponse[0]);
			else {
				const requestResponses = this.#queryCache(r$1, options);
				for (const requestResponse of requestResponses) requests.push(requestResponse[0]);
			}
			queueMicrotask(() => {
				const requestList = [];
				for (const request$4 of requests) {
					const requestObject = new Request$1("https://a");
					requestObject[kState] = request$4;
					requestObject[kHeaders][kHeadersList$1] = request$4.headersList;
					requestObject[kHeaders][kGuard] = "immutable";
					requestObject[kRealm] = request$4.client;
					requestList.push(requestObject);
				}
				promise.resolve(Object.freeze(requestList));
			});
			return promise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
		* @param {CacheBatchOperation[]} operations
		* @returns {requestResponseList}
		*/
		#batchCacheOperations(operations) {
			const cache = this.#relevantRequestResponseList;
			const backupCache = [...cache];
			const addedItems = [];
			const resultList = [];
			try {
				for (const operation of operations) {
					if (operation.type !== "delete" && operation.type !== "put") throw webidl$4.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "operation type does not match \"delete\" or \"put\""
					});
					if (operation.type === "delete" && operation.response != null) throw webidl$4.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "delete operation should not have an associated response"
					});
					if (this.#queryCache(operation.request, operation.options, addedItems).length) throw new DOMException("???", "InvalidStateError");
					let requestResponses;
					if (operation.type === "delete") {
						requestResponses = this.#queryCache(operation.request, operation.options);
						if (requestResponses.length === 0) return [];
						for (const requestResponse of requestResponses) {
							const idx = cache.indexOf(requestResponse);
							assert$1(idx !== -1);
							cache.splice(idx, 1);
						}
					} else if (operation.type === "put") {
						if (operation.response == null) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "put operation should have an associated response"
						});
						const r$1 = operation.request;
						if (!urlIsHttpHttpsScheme(r$1.url)) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "expected http or https scheme"
						});
						if (r$1.method !== "GET") throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "not get method"
						});
						if (operation.options != null) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "options must not be defined"
						});
						requestResponses = this.#queryCache(operation.request);
						for (const requestResponse of requestResponses) {
							const idx = cache.indexOf(requestResponse);
							assert$1(idx !== -1);
							cache.splice(idx, 1);
						}
						cache.push([operation.request, operation.response]);
						addedItems.push([operation.request, operation.response]);
					}
					resultList.push([operation.request, operation.response]);
				}
				return resultList;
			} catch (e$1) {
				this.#relevantRequestResponseList.length = 0;
				this.#relevantRequestResponseList = backupCache;
				throw e$1;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#query-cache
		* @param {any} requestQuery
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @param {requestResponseList} targetStorage
		* @returns {requestResponseList}
		*/
		#queryCache(requestQuery, options, targetStorage) {
			/** @type {requestResponseList} */
			const resultList = [];
			const storage = targetStorage ?? this.#relevantRequestResponseList;
			for (const requestResponse of storage) {
				const [cachedRequest, cachedResponse] = requestResponse;
				if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) resultList.push(requestResponse);
			}
			return resultList;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
		* @param {any} requestQuery
		* @param {any} request
		* @param {any | null} response
		* @param {import('../../types/cache').CacheQueryOptions | undefined} options
		* @returns {boolean}
		*/
		#requestMatchesCachedItem(requestQuery, request$3, response = null, options) {
			const queryURL = new URL(requestQuery.url);
			const cachedURL = new URL(request$3.url);
			if (options?.ignoreSearch) {
				cachedURL.search = "";
				queryURL.search = "";
			}
			if (!urlEquals(queryURL, cachedURL, true)) return false;
			if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) return true;
			const fieldValues$1 = getFieldValues(response.headersList.get("vary"));
			for (const fieldValue of fieldValues$1) {
				if (fieldValue === "*") return false;
				if (request$3.headersList.get(fieldValue) !== requestQuery.headersList.get(fieldValue)) return false;
			}
			return true;
		}
	};
	Object.defineProperties(Cache$1.prototype, {
		[Symbol.toStringTag]: {
			value: "Cache",
			configurable: true
		},
		match: kEnumerableProperty$3,
		matchAll: kEnumerableProperty$3,
		add: kEnumerableProperty$3,
		addAll: kEnumerableProperty$3,
		put: kEnumerableProperty$3,
		delete: kEnumerableProperty$3,
		keys: kEnumerableProperty$3
	});
	const cacheQueryOptionConverters = [
		{
			key: "ignoreSearch",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreMethod",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreVary",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		}
	];
	webidl$4.converters.CacheQueryOptions = webidl$4.dictionaryConverter(cacheQueryOptionConverters);
	webidl$4.converters.MultiCacheQueryOptions = webidl$4.dictionaryConverter([...cacheQueryOptionConverters, {
		key: "cacheName",
		converter: webidl$4.converters.DOMString
	}]);
	webidl$4.converters.Response = webidl$4.interfaceConverter(Response$2);
	webidl$4.converters["sequence<RequestInfo>"] = webidl$4.sequenceConverter(webidl$4.converters.RequestInfo);
	module.exports = { Cache: Cache$1 };
}));

//#endregion
//#region node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kConstruct } = require_symbols$1();
	const { Cache } = require_cache();
	const { webidl: webidl$3 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$2 } = require_util$8();
	var CacheStorage = class CacheStorage {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
		* @type {Map<string, import('./cache').requestResponseList}
		*/
		#caches = /* @__PURE__ */ new Map();
		constructor() {
			if (arguments[0] !== kConstruct) webidl$3.illegalConstructor();
		}
		async match(request$3, options = {}) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
			request$3 = webidl$3.converters.RequestInfo(request$3);
			options = webidl$3.converters.MultiCacheQueryOptions(options);
			if (options.cacheName != null) {
				if (this.#caches.has(options.cacheName)) return await new Cache(kConstruct, this.#caches.get(options.cacheName)).match(request$3, options);
			} else for (const cacheList of this.#caches.values()) {
				const response = await new Cache(kConstruct, cacheList).match(request$3, options);
				if (response !== void 0) return response;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-has
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async has(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			return this.#caches.has(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
		* @param {string} cacheName
		* @returns {Promise<Cache>}
		*/
		async open(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			if (this.#caches.has(cacheName)) return new Cache(kConstruct, this.#caches.get(cacheName));
			const cache = [];
			this.#caches.set(cacheName, cache);
			return new Cache(kConstruct, cache);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async delete(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			return this.#caches.delete(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
		* @returns {string[]}
		*/
		async keys() {
			webidl$3.brandCheck(this, CacheStorage);
			return [...this.#caches.keys()];
		}
	};
	Object.defineProperties(CacheStorage.prototype, {
		[Symbol.toStringTag]: {
			value: "CacheStorage",
			configurable: true
		},
		match: kEnumerableProperty$2,
		has: kEnumerableProperty$2,
		open: kEnumerableProperty$2,
		delete: kEnumerableProperty$2,
		keys: kEnumerableProperty$2
	});
	module.exports = { CacheStorage };
}));

//#endregion
//#region node_modules/undici/lib/cookies/constants.js
var require_constants$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const maxAttributeValueSize$1 = 1024;
	const maxNameValuePairSize$1 = 4096;
	module.exports = {
		maxAttributeValueSize: maxAttributeValueSize$1,
		maxNameValuePairSize: maxNameValuePairSize$1
	};
}));

//#endregion
//#region node_modules/undici/lib/cookies/util.js
var require_util$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	function isCTLExcludingHtab$1(value) {
		if (value.length === 0) return false;
		for (const char of value) {
			const code$1 = char.charCodeAt(0);
			if (code$1 >= 0 || code$1 <= 8 || code$1 >= 10 || code$1 <= 31 || code$1 === 127) return false;
		}
	}
	/**
	CHAR           = <any US-ASCII character (octets 0 - 127)>
	token          = 1*<any CHAR except CTLs or separators>
	separators     = "(" | ")" | "<" | ">" | "@"
	| "," | ";" | ":" | "\" | <">
	| "/" | "[" | "]" | "?" | "="
	| "{" | "}" | SP | HT
	* @param {string} name
	*/
	function validateCookieName(name) {
		for (const char of name) {
			const code$1 = char.charCodeAt(0);
			if (code$1 <= 32 || code$1 > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") throw new Error("Invalid cookie name");
		}
	}
	/**
	cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	; US-ASCII characters excluding CTLs,
	; whitespace DQUOTE, comma, semicolon,
	; and backslash
	* @param {string} value
	*/
	function validateCookieValue(value) {
		for (const char of value) {
			const code$1 = char.charCodeAt(0);
			if (code$1 < 33 || code$1 === 34 || code$1 === 44 || code$1 === 59 || code$1 === 92 || code$1 > 126) throw new Error("Invalid header value");
		}
	}
	/**
	* path-value        = <any CHAR except CTLs or ";">
	* @param {string} path
	*/
	function validateCookiePath(path$9) {
		for (const char of path$9) if (char.charCodeAt(0) < 33 || char === ";") throw new Error("Invalid cookie path");
	}
	/**
	* I have no idea why these values aren't allowed to be honest,
	* but Deno tests these. - Khafra
	* @param {string} domain
	*/
	function validateCookieDomain(domain) {
		if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) throw new Error("Invalid cookie domain");
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
	* @param {number|Date} date
	IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
	; fixed length/zone/capitalization subset of the format
	; see Section 3.3 of [RFC5322]
	
	day-name     = %x4D.6F.6E ; "Mon", case-sensitive
	/ %x54.75.65 ; "Tue", case-sensitive
	/ %x57.65.64 ; "Wed", case-sensitive
	/ %x54.68.75 ; "Thu", case-sensitive
	/ %x46.72.69 ; "Fri", case-sensitive
	/ %x53.61.74 ; "Sat", case-sensitive
	/ %x53.75.6E ; "Sun", case-sensitive
	date1        = day SP month SP year
	; e.g., 02 Jun 1982
	
	day          = 2DIGIT
	month        = %x4A.61.6E ; "Jan", case-sensitive
	/ %x46.65.62 ; "Feb", case-sensitive
	/ %x4D.61.72 ; "Mar", case-sensitive
	/ %x41.70.72 ; "Apr", case-sensitive
	/ %x4D.61.79 ; "May", case-sensitive
	/ %x4A.75.6E ; "Jun", case-sensitive
	/ %x4A.75.6C ; "Jul", case-sensitive
	/ %x41.75.67 ; "Aug", case-sensitive
	/ %x53.65.70 ; "Sep", case-sensitive
	/ %x4F.63.74 ; "Oct", case-sensitive
	/ %x4E.6F.76 ; "Nov", case-sensitive
	/ %x44.65.63 ; "Dec", case-sensitive
	year         = 4DIGIT
	
	GMT          = %x47.4D.54 ; "GMT", case-sensitive
	
	time-of-day  = hour ":" minute ":" second
	; 00:00:00 - 23:59:60 (leap second)
	
	hour         = 2DIGIT
	minute       = 2DIGIT
	second       = 2DIGIT
	*/
	function toIMFDate(date) {
		if (typeof date === "number") date = new Date(date);
		return `${[
			"Sun",
			"Mon",
			"Tue",
			"Wed",
			"Thu",
			"Fri",
			"Sat"
		][date.getUTCDay()]}, ${date.getUTCDate().toString().padStart(2, "0")} ${[
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		][date.getUTCMonth()]} ${date.getUTCFullYear()} ${date.getUTCHours().toString().padStart(2, "0")}:${date.getUTCMinutes().toString().padStart(2, "0")}:${date.getUTCSeconds().toString().padStart(2, "0")} GMT`;
	}
	/**
	max-age-av        = "Max-Age=" non-zero-digit *DIGIT
	; In practice, both expires-av and max-age-av
	; are limited to dates representable by the
	; user agent.
	* @param {number} maxAge
	*/
	function validateCookieMaxAge(maxAge) {
		if (maxAge < 0) throw new Error("Invalid cookie max-age");
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
	* @param {import('./index').Cookie} cookie
	*/
	function stringify$1(cookie) {
		if (cookie.name.length === 0) return null;
		validateCookieName(cookie.name);
		validateCookieValue(cookie.value);
		const out = [`${cookie.name}=${cookie.value}`];
		if (cookie.name.startsWith("__Secure-")) cookie.secure = true;
		if (cookie.name.startsWith("__Host-")) {
			cookie.secure = true;
			cookie.domain = null;
			cookie.path = "/";
		}
		if (cookie.secure) out.push("Secure");
		if (cookie.httpOnly) out.push("HttpOnly");
		if (typeof cookie.maxAge === "number") {
			validateCookieMaxAge(cookie.maxAge);
			out.push(`Max-Age=${cookie.maxAge}`);
		}
		if (cookie.domain) {
			validateCookieDomain(cookie.domain);
			out.push(`Domain=${cookie.domain}`);
		}
		if (cookie.path) {
			validateCookiePath(cookie.path);
			out.push(`Path=${cookie.path}`);
		}
		if (cookie.expires && cookie.expires.toString() !== "Invalid Date") out.push(`Expires=${toIMFDate(cookie.expires)}`);
		if (cookie.sameSite) out.push(`SameSite=${cookie.sameSite}`);
		for (const part of cookie.unparsed) {
			if (!part.includes("=")) throw new Error("Invalid unparsed");
			const [key, ...value] = part.split("=");
			out.push(`${key.trim()}=${value.join("=")}`);
		}
		return out.join("; ");
	}
	module.exports = {
		isCTLExcludingHtab: isCTLExcludingHtab$1,
		validateCookieName,
		validateCookiePath,
		validateCookieValue,
		toIMFDate,
		stringify: stringify$1
	};
}));

//#endregion
//#region node_modules/undici/lib/cookies/parse.js
var require_parse$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { maxNameValuePairSize, maxAttributeValueSize } = require_constants$2();
	const { isCTLExcludingHtab } = require_util$3();
	const { collectASequenceOfCodePointsFast } = require_dataURL();
	const assert = require("assert");
	/**
	* @description Parses the field-value attributes of a set-cookie header string.
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} header
	* @returns if the header is invalid, null will be returned
	*/
	function parseSetCookie$1(header) {
		if (isCTLExcludingHtab(header)) return null;
		let nameValuePair = "";
		let unparsedAttributes = "";
		let name = "";
		let value = "";
		if (header.includes(";")) {
			const position = { position: 0 };
			nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
			unparsedAttributes = header.slice(position.position);
		} else nameValuePair = header;
		if (!nameValuePair.includes("=")) value = nameValuePair;
		else {
			const position = { position: 0 };
			name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
			value = nameValuePair.slice(position.position + 1);
		}
		name = name.trim();
		value = value.trim();
		if (name.length + value.length > maxNameValuePairSize) return null;
		return {
			name,
			value,
			...parseUnparsedAttributes(unparsedAttributes)
		};
	}
	/**
	* Parses the remaining attributes of a set-cookie header
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} unparsedAttributes
	* @param {[Object.<string, unknown>]={}} cookieAttributeList
	*/
	function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
		if (unparsedAttributes.length === 0) return cookieAttributeList;
		assert(unparsedAttributes[0] === ";");
		unparsedAttributes = unparsedAttributes.slice(1);
		let cookieAv = "";
		if (unparsedAttributes.includes(";")) {
			cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
			unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
		} else {
			cookieAv = unparsedAttributes;
			unparsedAttributes = "";
		}
		let attributeName = "";
		let attributeValue = "";
		if (cookieAv.includes("=")) {
			const position = { position: 0 };
			attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
			attributeValue = cookieAv.slice(position.position + 1);
		} else attributeName = cookieAv;
		attributeName = attributeName.trim();
		attributeValue = attributeValue.trim();
		if (attributeValue.length > maxAttributeValueSize) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
		const attributeNameLowercase = attributeName.toLowerCase();
		if (attributeNameLowercase === "expires") cookieAttributeList.expires = new Date(attributeValue);
		else if (attributeNameLowercase === "max-age") {
			const charCode = attributeValue.charCodeAt(0);
			if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			if (!/^\d+$/.test(attributeValue)) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			cookieAttributeList.maxAge = Number(attributeValue);
		} else if (attributeNameLowercase === "domain") {
			let cookieDomain = attributeValue;
			if (cookieDomain[0] === ".") cookieDomain = cookieDomain.slice(1);
			cookieDomain = cookieDomain.toLowerCase();
			cookieAttributeList.domain = cookieDomain;
		} else if (attributeNameLowercase === "path") {
			let cookiePath = "";
			if (attributeValue.length === 0 || attributeValue[0] !== "/") cookiePath = "/";
			else cookiePath = attributeValue;
			cookieAttributeList.path = cookiePath;
		} else if (attributeNameLowercase === "secure") cookieAttributeList.secure = true;
		else if (attributeNameLowercase === "httponly") cookieAttributeList.httpOnly = true;
		else if (attributeNameLowercase === "samesite") {
			let enforcement = "Default";
			const attributeValueLowercase = attributeValue.toLowerCase();
			if (attributeValueLowercase.includes("none")) enforcement = "None";
			if (attributeValueLowercase.includes("strict")) enforcement = "Strict";
			if (attributeValueLowercase.includes("lax")) enforcement = "Lax";
			cookieAttributeList.sameSite = enforcement;
		} else {
			cookieAttributeList.unparsed ??= [];
			cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
		}
		return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
	}
	module.exports = {
		parseSetCookie: parseSetCookie$1,
		parseUnparsedAttributes
	};
}));

//#endregion
//#region node_modules/undici/lib/cookies/index.js
var require_cookies = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { parseSetCookie } = require_parse$1();
	const { stringify } = require_util$3();
	const { webidl: webidl$2 } = require_webidl();
	const { Headers: Headers$4 } = require_headers();
	/**
	* @typedef {Object} Cookie
	* @property {string} name
	* @property {string} value
	* @property {Date|number|undefined} expires
	* @property {number|undefined} maxAge
	* @property {string|undefined} domain
	* @property {string|undefined} path
	* @property {boolean|undefined} secure
	* @property {boolean|undefined} httpOnly
	* @property {'Strict'|'Lax'|'None'} sameSite
	* @property {string[]} unparsed
	*/
	/**
	* @param {Headers} headers
	* @returns {Record<string, string>}
	*/
	function getCookies(headers) {
		webidl$2.argumentLengthCheck(arguments, 1, { header: "getCookies" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		const cookie = headers.get("cookie");
		const out = {};
		if (!cookie) return out;
		for (const piece of cookie.split(";")) {
			const [name, ...value] = piece.split("=");
			out[name.trim()] = value.join("=");
		}
		return out;
	}
	/**
	* @param {Headers} headers
	* @param {string} name
	* @param {{ path?: string, domain?: string }|undefined} attributes
	* @returns {void}
	*/
	function deleteCookie(headers, name, attributes) {
		webidl$2.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		name = webidl$2.converters.DOMString(name);
		attributes = webidl$2.converters.DeleteCookieAttributes(attributes);
		setCookie(headers, {
			name,
			value: "",
			expires: /* @__PURE__ */ new Date(0),
			...attributes
		});
	}
	/**
	* @param {Headers} headers
	* @returns {Cookie[]}
	*/
	function getSetCookies(headers) {
		webidl$2.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		const cookies = headers.getSetCookie();
		if (!cookies) return [];
		return cookies.map((pair) => parseSetCookie(pair));
	}
	/**
	* @param {Headers} headers
	* @param {Cookie} cookie
	* @returns {void}
	*/
	function setCookie(headers, cookie) {
		webidl$2.argumentLengthCheck(arguments, 2, { header: "setCookie" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		cookie = webidl$2.converters.Cookie(cookie);
		if (stringify(cookie)) headers.append("Set-Cookie", stringify(cookie));
	}
	webidl$2.converters.DeleteCookieAttributes = webidl$2.dictionaryConverter([{
		converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
		key: "path",
		defaultValue: null
	}, {
		converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
		key: "domain",
		defaultValue: null
	}]);
	webidl$2.converters.Cookie = webidl$2.dictionaryConverter([
		{
			converter: webidl$2.converters.DOMString,
			key: "name"
		},
		{
			converter: webidl$2.converters.DOMString,
			key: "value"
		},
		{
			converter: webidl$2.nullableConverter((value) => {
				if (typeof value === "number") return webidl$2.converters["unsigned long long"](value);
				return new Date(value);
			}),
			key: "expires",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters["long long"]),
			key: "maxAge",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
			key: "domain",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
			key: "path",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.boolean),
			key: "secure",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.boolean),
			key: "httpOnly",
			defaultValue: null
		},
		{
			converter: webidl$2.converters.USVString,
			key: "sameSite",
			allowedValues: [
				"Strict",
				"Lax",
				"None"
			]
		},
		{
			converter: webidl$2.sequenceConverter(webidl$2.converters.DOMString),
			key: "unparsed",
			defaultValue: []
		}
	]);
	module.exports = {
		getCookies,
		deleteCookie,
		getSetCookies,
		setCookie
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/constants.js
var require_constants$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const uid$1 = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors$1 = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	const states$4 = {
		CONNECTING: 0,
		OPEN: 1,
		CLOSING: 2,
		CLOSED: 3
	};
	const opcodes$3 = {
		CONTINUATION: 0,
		TEXT: 1,
		BINARY: 2,
		CLOSE: 8,
		PING: 9,
		PONG: 10
	};
	const maxUnsigned16Bit$1 = 2 ** 16 - 1;
	const parserStates$1 = {
		INFO: 0,
		PAYLOADLENGTH_16: 2,
		PAYLOADLENGTH_64: 3,
		READ_DATA: 4
	};
	const emptyBuffer$2 = Buffer.allocUnsafe(0);
	module.exports = {
		uid: uid$1,
		staticPropertyDescriptors: staticPropertyDescriptors$1,
		states: states$4,
		opcodes: opcodes$3,
		maxUnsigned16Bit: maxUnsigned16Bit$1,
		parserStates: parserStates$1,
		emptyBuffer: emptyBuffer$2
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/symbols.js
var require_symbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kWebSocketURL: Symbol("url"),
		kReadyState: Symbol("ready state"),
		kController: Symbol("controller"),
		kResponse: Symbol("response"),
		kBinaryType: Symbol("binary type"),
		kSentClose: Symbol("sent close"),
		kReceivedClose: Symbol("received close"),
		kByteParser: Symbol("byte parser")
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/events.js
var require_events = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { webidl: webidl$1 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$1 } = require_util$8();
	const { MessagePort } = require("worker_threads");
	/**
	* @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
	*/
	var MessageEvent$2 = class MessageEvent$2 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.MessageEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get data() {
			webidl$1.brandCheck(this, MessageEvent$2);
			return this.#eventInit.data;
		}
		get origin() {
			webidl$1.brandCheck(this, MessageEvent$2);
			return this.#eventInit.origin;
		}
		get lastEventId() {
			webidl$1.brandCheck(this, MessageEvent$2);
			return this.#eventInit.lastEventId;
		}
		get source() {
			webidl$1.brandCheck(this, MessageEvent$2);
			return this.#eventInit.source;
		}
		get ports() {
			webidl$1.brandCheck(this, MessageEvent$2);
			if (!Object.isFrozen(this.#eventInit.ports)) Object.freeze(this.#eventInit.ports);
			return this.#eventInit.ports;
		}
		initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
			webidl$1.brandCheck(this, MessageEvent$2);
			webidl$1.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
			return new MessageEvent$2(type, {
				bubbles,
				cancelable,
				data,
				origin,
				lastEventId,
				source,
				ports
			});
		}
	};
	/**
	* @see https://websockets.spec.whatwg.org/#the-closeevent-interface
	*/
	var CloseEvent$2 = class CloseEvent$2 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.CloseEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get wasClean() {
			webidl$1.brandCheck(this, CloseEvent$2);
			return this.#eventInit.wasClean;
		}
		get code() {
			webidl$1.brandCheck(this, CloseEvent$2);
			return this.#eventInit.code;
		}
		get reason() {
			webidl$1.brandCheck(this, CloseEvent$2);
			return this.#eventInit.reason;
		}
	};
	var ErrorEvent$2 = class ErrorEvent$2 extends Event {
		#eventInit;
		constructor(type, eventInitDict) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
			super(type, eventInitDict);
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.ErrorEventInit(eventInitDict ?? {});
			this.#eventInit = eventInitDict;
		}
		get message() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.message;
		}
		get filename() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.filename;
		}
		get lineno() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.lineno;
		}
		get colno() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.colno;
		}
		get error() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.error;
		}
	};
	Object.defineProperties(MessageEvent$2.prototype, {
		[Symbol.toStringTag]: {
			value: "MessageEvent",
			configurable: true
		},
		data: kEnumerableProperty$1,
		origin: kEnumerableProperty$1,
		lastEventId: kEnumerableProperty$1,
		source: kEnumerableProperty$1,
		ports: kEnumerableProperty$1,
		initMessageEvent: kEnumerableProperty$1
	});
	Object.defineProperties(CloseEvent$2.prototype, {
		[Symbol.toStringTag]: {
			value: "CloseEvent",
			configurable: true
		},
		reason: kEnumerableProperty$1,
		code: kEnumerableProperty$1,
		wasClean: kEnumerableProperty$1
	});
	Object.defineProperties(ErrorEvent$2.prototype, {
		[Symbol.toStringTag]: {
			value: "ErrorEvent",
			configurable: true
		},
		message: kEnumerableProperty$1,
		filename: kEnumerableProperty$1,
		lineno: kEnumerableProperty$1,
		colno: kEnumerableProperty$1,
		error: kEnumerableProperty$1
	});
	webidl$1.converters.MessagePort = webidl$1.interfaceConverter(MessagePort);
	webidl$1.converters["sequence<MessagePort>"] = webidl$1.sequenceConverter(webidl$1.converters.MessagePort);
	const eventInit = [
		{
			key: "bubbles",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		}
	];
	webidl$1.converters.MessageEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "data",
			converter: webidl$1.converters.any,
			defaultValue: null
		},
		{
			key: "origin",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lastEventId",
			converter: webidl$1.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "source",
			converter: webidl$1.nullableConverter(webidl$1.converters.MessagePort),
			defaultValue: null
		},
		{
			key: "ports",
			converter: webidl$1.converters["sequence<MessagePort>"],
			get defaultValue() {
				return [];
			}
		}
	]);
	webidl$1.converters.CloseEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "wasClean",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "code",
			converter: webidl$1.converters["unsigned short"],
			defaultValue: 0
		},
		{
			key: "reason",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		}
	]);
	webidl$1.converters.ErrorEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "message",
			converter: webidl$1.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "filename",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lineno",
			converter: webidl$1.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "colno",
			converter: webidl$1.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "error",
			converter: webidl$1.converters.any
		}
	]);
	module.exports = {
		MessageEvent: MessageEvent$2,
		CloseEvent: CloseEvent$2,
		ErrorEvent: ErrorEvent$2
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/util.js
var require_util$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kReadyState: kReadyState$3, kController: kController$1, kResponse: kResponse$2, kBinaryType: kBinaryType$1, kWebSocketURL: kWebSocketURL$1 } = require_symbols();
	const { states: states$3, opcodes: opcodes$2 } = require_constants$1();
	const { MessageEvent: MessageEvent$1, ErrorEvent: ErrorEvent$1 } = require_events();
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isEstablished$1(ws) {
		return ws[kReadyState$3] === states$3.OPEN;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isClosing$1(ws) {
		return ws[kReadyState$3] === states$3.CLOSING;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isClosed(ws) {
		return ws[kReadyState$3] === states$3.CLOSED;
	}
	/**
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e
	* @param {EventTarget} target
	* @param {EventInit | undefined} eventInitDict
	*/
	function fireEvent$2(e$1, target, eventConstructor = Event, eventInitDict) {
		const event = new eventConstructor(e$1, eventInitDict);
		target.dispatchEvent(event);
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @param {import('./websocket').WebSocket} ws
	* @param {number} type Opcode
	* @param {Buffer} data application data
	*/
	function websocketMessageReceived$1(ws, type, data) {
		if (ws[kReadyState$3] !== states$3.OPEN) return;
		let dataForEvent;
		if (type === opcodes$2.TEXT) try {
			dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
		} catch {
			failWebsocketConnection$3(ws, "Received invalid UTF-8 in text frame.");
			return;
		}
		else if (type === opcodes$2.BINARY) if (ws[kBinaryType$1] === "blob") dataForEvent = new Blob([data]);
		else dataForEvent = new Uint8Array(data).buffer;
		fireEvent$2("message", ws, MessageEvent$1, {
			origin: ws[kWebSocketURL$1].origin,
			data: dataForEvent
		});
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455
	* @see https://datatracker.ietf.org/doc/html/rfc2616
	* @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
	* @param {string} protocol
	*/
	function isValidSubprotocol$1(protocol) {
		if (protocol.length === 0) return false;
		for (const char of protocol) {
			const code$1 = char.charCodeAt(0);
			if (code$1 < 33 || code$1 > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code$1 === 32 || code$1 === 9) return false;
		}
		return true;
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
	* @param {number} code
	*/
	function isValidStatusCode$4(code$1) {
		if (code$1 >= 1e3 && code$1 < 1015) return code$1 !== 1004 && code$1 !== 1005 && code$1 !== 1006;
		return code$1 >= 3e3 && code$1 <= 4999;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	* @param {string|undefined} reason
	*/
	function failWebsocketConnection$3(ws, reason) {
		const { [kController$1]: controller, [kResponse$2]: response } = ws;
		controller.abort();
		if (response?.socket && !response.socket.destroyed) response.socket.destroy();
		if (reason) fireEvent$2("error", ws, ErrorEvent$1, { error: new Error(reason) });
	}
	module.exports = {
		isEstablished: isEstablished$1,
		isClosing: isClosing$1,
		isClosed,
		fireEvent: fireEvent$2,
		isValidSubprotocol: isValidSubprotocol$1,
		isValidStatusCode: isValidStatusCode$4,
		failWebsocketConnection: failWebsocketConnection$3,
		websocketMessageReceived: websocketMessageReceived$1
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/connection.js
var require_connection = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const diagnosticsChannel$1 = require("diagnostics_channel");
	const { uid, states: states$2 } = require_constants$1();
	const { kReadyState: kReadyState$2, kSentClose: kSentClose$2, kByteParser: kByteParser$1, kReceivedClose: kReceivedClose$1 } = require_symbols();
	const { fireEvent: fireEvent$1, failWebsocketConnection: failWebsocketConnection$2 } = require_util$2();
	const { CloseEvent: CloseEvent$1 } = require_events();
	const { makeRequest } = require_request();
	const { fetching } = require_fetch();
	const { Headers: Headers$3 } = require_headers();
	const { getGlobalDispatcher: getGlobalDispatcher$2 } = require_global();
	const { kHeadersList } = require_symbols$4();
	const channels$1 = {};
	channels$1.open = diagnosticsChannel$1.channel("undici:websocket:open");
	channels$1.close = diagnosticsChannel$1.channel("undici:websocket:close");
	channels$1.socketError = diagnosticsChannel$1.channel("undici:websocket:socket_error");
	/** @type {import('crypto')} */
	let crypto$4;
	try {
		crypto$4 = require("crypto");
	} catch {}
	/**
	* @see https://websockets.spec.whatwg.org/#concept-websocket-establish
	* @param {URL} url
	* @param {string|string[]} protocols
	* @param {import('./websocket').WebSocket} ws
	* @param {(response: any) => void} onEstablish
	* @param {Partial<import('../../types/websocket').WebSocketInit>} options
	*/
	function establishWebSocketConnection$1(url, protocols, ws, onEstablish, options) {
		const requestURL = url;
		requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
		const request$3 = makeRequest({
			urlList: [requestURL],
			serviceWorkers: "none",
			referrer: "no-referrer",
			mode: "websocket",
			credentials: "include",
			cache: "no-store",
			redirect: "error"
		});
		if (options.headers) request$3.headersList = new Headers$3(options.headers)[kHeadersList];
		const keyValue = crypto$4.randomBytes(16).toString("base64");
		request$3.headersList.append("sec-websocket-key", keyValue);
		request$3.headersList.append("sec-websocket-version", "13");
		for (const protocol of protocols) request$3.headersList.append("sec-websocket-protocol", protocol);
		const permessageDeflate = "";
		return fetching({
			request: request$3,
			useParallelQueue: true,
			dispatcher: options.dispatcher ?? getGlobalDispatcher$2(),
			processResponse(response) {
				if (response.type === "error" || response.status !== 101) {
					failWebsocketConnection$2(ws, "Received network error or non-101 status code.");
					return;
				}
				if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection$2(ws, "Server did not respond with sent protocols.");
					return;
				}
				if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
					failWebsocketConnection$2(ws, "Server did not set Upgrade header to \"websocket\".");
					return;
				}
				if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
					failWebsocketConnection$2(ws, "Server did not set Connection header to \"upgrade\".");
					return;
				}
				if (response.headersList.get("Sec-WebSocket-Accept") !== crypto$4.createHash("sha1").update(keyValue + uid).digest("base64")) {
					failWebsocketConnection$2(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
					return;
				}
				const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
				if (secExtension !== null && secExtension !== permessageDeflate) {
					failWebsocketConnection$2(ws, "Received different permessage-deflate than the one set.");
					return;
				}
				const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
				if (secProtocol !== null && secProtocol !== request$3.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection$2(ws, "Protocol was not set in the opening handshake.");
					return;
				}
				response.socket.on("data", onSocketData);
				response.socket.on("close", onSocketClose);
				response.socket.on("error", onSocketError);
				if (channels$1.open.hasSubscribers) channels$1.open.publish({
					address: response.socket.address(),
					protocol: secProtocol,
					extensions: secExtension
				});
				onEstablish(response);
			}
		});
	}
	/**
	* @param {Buffer} chunk
	*/
	function onSocketData(chunk) {
		if (!this.ws[kByteParser$1].write(chunk)) this.pause();
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
	*/
	function onSocketClose() {
		const { ws } = this;
		const wasClean = ws[kSentClose$2] && ws[kReceivedClose$1];
		let code$1 = 1005;
		let reason = "";
		const result = ws[kByteParser$1].closingInfo;
		if (result) {
			code$1 = result.code ?? 1005;
			reason = result.reason;
		} else if (!ws[kSentClose$2]) code$1 = 1006;
		ws[kReadyState$2] = states$2.CLOSED;
		fireEvent$1("close", ws, CloseEvent$1, {
			wasClean,
			code: code$1,
			reason
		});
		if (channels$1.close.hasSubscribers) channels$1.close.publish({
			websocket: ws,
			code: code$1,
			reason
		});
	}
	function onSocketError(error$1) {
		const { ws } = this;
		ws[kReadyState$2] = states$2.CLOSING;
		if (channels$1.socketError.hasSubscribers) channels$1.socketError.publish(error$1);
		this.destroy();
	}
	module.exports = { establishWebSocketConnection: establishWebSocketConnection$1 };
}));

//#endregion
//#region node_modules/undici/lib/websocket/frame.js
var require_frame = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { maxUnsigned16Bit } = require_constants$1();
	/** @type {import('crypto')} */
	let crypto$3;
	try {
		crypto$3 = require("crypto");
	} catch {}
	var WebsocketFrameSend$2 = class {
		/**
		* @param {Buffer|undefined} data
		*/
		constructor(data) {
			this.frameData = data;
			this.maskKey = crypto$3.randomBytes(4);
		}
		createFrame(opcode) {
			const bodyLength$1 = this.frameData?.byteLength ?? 0;
			/** @type {number} */
			let payloadLength = bodyLength$1;
			let offset = 6;
			if (bodyLength$1 > maxUnsigned16Bit) {
				offset += 8;
				payloadLength = 127;
			} else if (bodyLength$1 > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const buffer$1 = Buffer.allocUnsafe(bodyLength$1 + offset);
			buffer$1[0] = buffer$1[1] = 0;
			buffer$1[0] |= 128;
			buffer$1[0] = (buffer$1[0] & 240) + opcode;
			/*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
			buffer$1[offset - 4] = this.maskKey[0];
			buffer$1[offset - 3] = this.maskKey[1];
			buffer$1[offset - 2] = this.maskKey[2];
			buffer$1[offset - 1] = this.maskKey[3];
			buffer$1[1] = payloadLength;
			if (payloadLength === 126) buffer$1.writeUInt16BE(bodyLength$1, 2);
			else if (payloadLength === 127) {
				buffer$1[2] = buffer$1[3] = 0;
				buffer$1.writeUIntBE(bodyLength$1, 4, 6);
			}
			buffer$1[1] |= 128;
			for (let i$2 = 0; i$2 < bodyLength$1; i$2++) buffer$1[offset + i$2] = this.frameData[i$2] ^ this.maskKey[i$2 % 4];
			return buffer$1;
		}
	};
	module.exports = { WebsocketFrameSend: WebsocketFrameSend$2 };
}));

//#endregion
//#region node_modules/undici/lib/websocket/receiver.js
var require_receiver$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Writable: Writable$1 } = require("stream");
	const diagnosticsChannel = require("diagnostics_channel");
	const { parserStates, opcodes: opcodes$1, states: states$1, emptyBuffer: emptyBuffer$1 } = require_constants$1();
	const { kReadyState: kReadyState$1, kSentClose: kSentClose$1, kResponse: kResponse$1, kReceivedClose } = require_symbols();
	const { isValidStatusCode: isValidStatusCode$3, failWebsocketConnection: failWebsocketConnection$1, websocketMessageReceived } = require_util$2();
	const { WebsocketFrameSend: WebsocketFrameSend$1 } = require_frame();
	const channels = {};
	channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
	channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
	var ByteParser$1 = class extends Writable$1 {
		#buffers = [];
		#byteOffset = 0;
		#state = parserStates.INFO;
		#info = {};
		#fragments = [];
		constructor(ws) {
			super();
			this.ws = ws;
		}
		/**
		* @param {Buffer} chunk
		* @param {() => void} callback
		*/
		_write(chunk, _, callback) {
			this.#buffers.push(chunk);
			this.#byteOffset += chunk.length;
			this.run(callback);
		}
		/**
		* Runs whenever a new chunk is received.
		* Callback is called whenever there are no more chunks buffering,
		* or not enough bytes are buffered to parse.
		*/
		run(callback) {
			while (true) {
				if (this.#state === parserStates.INFO) {
					if (this.#byteOffset < 2) return callback();
					const buffer$1 = this.consume(2);
					this.#info.fin = (buffer$1[0] & 128) !== 0;
					this.#info.opcode = buffer$1[0] & 15;
					this.#info.originalOpcode ??= this.#info.opcode;
					this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes$1.CONTINUATION;
					if (this.#info.fragmented && this.#info.opcode !== opcodes$1.BINARY && this.#info.opcode !== opcodes$1.TEXT) {
						failWebsocketConnection$1(this.ws, "Invalid frame type was fragmented.");
						return;
					}
					const payloadLength = buffer$1[1] & 127;
					if (payloadLength <= 125) {
						this.#info.payloadLength = payloadLength;
						this.#state = parserStates.READ_DATA;
					} else if (payloadLength === 126) this.#state = parserStates.PAYLOADLENGTH_16;
					else if (payloadLength === 127) this.#state = parserStates.PAYLOADLENGTH_64;
					if (this.#info.fragmented && payloadLength > 125) {
						failWebsocketConnection$1(this.ws, "Fragmented frame exceeded 125 bytes.");
						return;
					} else if ((this.#info.opcode === opcodes$1.PING || this.#info.opcode === opcodes$1.PONG || this.#info.opcode === opcodes$1.CLOSE) && payloadLength > 125) {
						failWebsocketConnection$1(this.ws, "Payload length for control frame exceeded 125 bytes.");
						return;
					} else if (this.#info.opcode === opcodes$1.CLOSE) {
						if (payloadLength === 1) {
							failWebsocketConnection$1(this.ws, "Received close frame with a 1-byte body.");
							return;
						}
						const body = this.consume(payloadLength);
						this.#info.closeInfo = this.parseCloseBody(false, body);
						if (!this.ws[kSentClose$1]) {
							const body$1 = Buffer.allocUnsafe(2);
							body$1.writeUInt16BE(this.#info.closeInfo.code, 0);
							const closeFrame = new WebsocketFrameSend$1(body$1);
							this.ws[kResponse$1].socket.write(closeFrame.createFrame(opcodes$1.CLOSE), (err) => {
								if (!err) this.ws[kSentClose$1] = true;
							});
						}
						this.ws[kReadyState$1] = states$1.CLOSING;
						this.ws[kReceivedClose] = true;
						this.end();
						return;
					} else if (this.#info.opcode === opcodes$1.PING) {
						const body = this.consume(payloadLength);
						if (!this.ws[kReceivedClose]) {
							const frame = new WebsocketFrameSend$1(body);
							this.ws[kResponse$1].socket.write(frame.createFrame(opcodes$1.PONG));
							if (channels.ping.hasSubscribers) channels.ping.publish({ payload: body });
						}
						this.#state = parserStates.INFO;
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					} else if (this.#info.opcode === opcodes$1.PONG) {
						const body = this.consume(payloadLength);
						if (channels.pong.hasSubscribers) channels.pong.publish({ payload: body });
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					}
				} else if (this.#state === parserStates.PAYLOADLENGTH_16) {
					if (this.#byteOffset < 2) return callback();
					const buffer$1 = this.consume(2);
					this.#info.payloadLength = buffer$1.readUInt16BE(0);
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.PAYLOADLENGTH_64) {
					if (this.#byteOffset < 8) return callback();
					const buffer$1 = this.consume(8);
					const upper = buffer$1.readUInt32BE(0);
					if (upper > 2 ** 31 - 1) {
						failWebsocketConnection$1(this.ws, "Received payload length > 2^31 bytes.");
						return;
					}
					const lower$1 = buffer$1.readUInt32BE(4);
					this.#info.payloadLength = (upper << 8) + lower$1;
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.READ_DATA) {
					if (this.#byteOffset < this.#info.payloadLength) return callback();
					else if (this.#byteOffset >= this.#info.payloadLength) {
						const body = this.consume(this.#info.payloadLength);
						this.#fragments.push(body);
						if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes$1.CONTINUATION) {
							const fullMessage = Buffer.concat(this.#fragments);
							websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
							this.#info = {};
							this.#fragments.length = 0;
						}
						this.#state = parserStates.INFO;
					}
				}
				if (this.#byteOffset > 0) continue;
				else {
					callback();
					break;
				}
			}
		}
		/**
		* Take n bytes from the buffered Buffers
		* @param {number} n
		* @returns {Buffer|null}
		*/
		consume(n) {
			if (n > this.#byteOffset) return null;
			else if (n === 0) return emptyBuffer$1;
			if (this.#buffers[0].length === n) {
				this.#byteOffset -= this.#buffers[0].length;
				return this.#buffers.shift();
			}
			const buffer$1 = Buffer.allocUnsafe(n);
			let offset = 0;
			while (offset !== n) {
				const next = this.#buffers[0];
				const { length } = next;
				if (length + offset === n) {
					buffer$1.set(this.#buffers.shift(), offset);
					break;
				} else if (length + offset > n) {
					buffer$1.set(next.subarray(0, n - offset), offset);
					this.#buffers[0] = next.subarray(n - offset);
					break;
				} else {
					buffer$1.set(this.#buffers.shift(), offset);
					offset += next.length;
				}
			}
			this.#byteOffset -= n;
			return buffer$1;
		}
		parseCloseBody(onlyCode, data) {
			/** @type {number|undefined} */
			let code$1;
			if (data.length >= 2) code$1 = data.readUInt16BE(0);
			if (onlyCode) {
				if (!isValidStatusCode$3(code$1)) return null;
				return { code: code$1 };
			}
			/** @type {Buffer} */
			let reason = data.subarray(2);
			if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) reason = reason.subarray(3);
			if (code$1 !== void 0 && !isValidStatusCode$3(code$1)) return null;
			try {
				reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
			} catch {
				return null;
			}
			return {
				code: code$1,
				reason
			};
		}
		get closingInfo() {
			return this.#info.closeInfo;
		}
	};
	module.exports = { ByteParser: ByteParser$1 };
}));

//#endregion
//#region node_modules/undici/lib/websocket/websocket.js
var require_websocket$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { webidl } = require_webidl();
	const { DOMException: DOMException$2 } = require_constants$4();
	const { URLSerializer } = require_dataURL();
	const { getGlobalOrigin } = require_global$1();
	const { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants$1();
	const { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = require_symbols();
	const { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util$2();
	const { establishWebSocketConnection } = require_connection();
	const { WebsocketFrameSend } = require_frame();
	const { ByteParser } = require_receiver$1();
	const { kEnumerableProperty, isBlobLike } = require_util$8();
	const { getGlobalDispatcher: getGlobalDispatcher$1 } = require_global();
	const { types: types$2 } = require("util");
	let experimentalWarned = false;
	var WebSocket$3 = class WebSocket$3 extends EventTarget {
		#events = {
			open: null,
			error: null,
			close: null,
			message: null
		};
		#bufferedAmount = 0;
		#protocol = "";
		#extensions = "";
		/**
		* @param {string} url
		* @param {string|string[]} protocols
		*/
		constructor(url, protocols = []) {
			super();
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
			if (!experimentalWarned) {
				experimentalWarned = true;
				process.emitWarning("WebSockets are experimental, expect them to change at any time.", { code: "UNDICI-WS" });
			}
			const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
			url = webidl.converters.USVString(url);
			protocols = options.protocols;
			const baseURL = getGlobalOrigin();
			let urlRecord;
			try {
				urlRecord = new URL(url, baseURL);
			} catch (e$1) {
				throw new DOMException$2(e$1, "SyntaxError");
			}
			if (urlRecord.protocol === "http:") urlRecord.protocol = "ws:";
			else if (urlRecord.protocol === "https:") urlRecord.protocol = "wss:";
			if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") throw new DOMException$2(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
			if (urlRecord.hash || urlRecord.href.endsWith("#")) throw new DOMException$2("Got fragment", "SyntaxError");
			if (typeof protocols === "string") protocols = [protocols];
			if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) throw new DOMException$2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) throw new DOMException$2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			this[kWebSocketURL] = new URL(urlRecord.href);
			this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options);
			this[kReadyState] = WebSocket$3.CONNECTING;
			this[kBinaryType] = "blob";
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-close
		* @param {number|undefined} code
		* @param {string|undefined} reason
		*/
		close(code$1 = void 0, reason = void 0) {
			webidl.brandCheck(this, WebSocket$3);
			if (code$1 !== void 0) code$1 = webidl.converters["unsigned short"](code$1, { clamp: true });
			if (reason !== void 0) reason = webidl.converters.USVString(reason);
			if (code$1 !== void 0) {
				if (code$1 !== 1e3 && (code$1 < 3e3 || code$1 > 4999)) throw new DOMException$2("invalid code", "InvalidAccessError");
			}
			let reasonByteLength = 0;
			if (reason !== void 0) {
				reasonByteLength = Buffer.byteLength(reason);
				if (reasonByteLength > 123) throw new DOMException$2(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
			}
			if (this[kReadyState] === WebSocket$3.CLOSING || this[kReadyState] === WebSocket$3.CLOSED) {} else if (!isEstablished(this)) {
				failWebsocketConnection(this, "Connection was closed before it was established.");
				this[kReadyState] = WebSocket$3.CLOSING;
			} else if (!isClosing(this)) {
				const frame = new WebsocketFrameSend();
				if (code$1 !== void 0 && reason === void 0) {
					frame.frameData = Buffer.allocUnsafe(2);
					frame.frameData.writeUInt16BE(code$1, 0);
				} else if (code$1 !== void 0 && reason !== void 0) {
					frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
					frame.frameData.writeUInt16BE(code$1, 0);
					frame.frameData.write(reason, 2, "utf-8");
				} else frame.frameData = emptyBuffer;
				this[kResponse].socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
					if (!err) this[kSentClose] = true;
				});
				this[kReadyState] = states.CLOSING;
			} else this[kReadyState] = WebSocket$3.CLOSING;
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-send
		* @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
		*/
		send(data) {
			webidl.brandCheck(this, WebSocket$3);
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
			data = webidl.converters.WebSocketSendData(data);
			if (this[kReadyState] === WebSocket$3.CONNECTING) throw new DOMException$2("Sent before connected.", "InvalidStateError");
			if (!isEstablished(this) || isClosing(this)) return;
			/** @type {import('stream').Duplex} */
			const socket = this[kResponse].socket;
			if (typeof data === "string") {
				const value = Buffer.from(data);
				const buffer$1 = new WebsocketFrameSend(value).createFrame(opcodes.TEXT);
				this.#bufferedAmount += value.byteLength;
				socket.write(buffer$1, () => {
					this.#bufferedAmount -= value.byteLength;
				});
			} else if (types$2.isArrayBuffer(data)) {
				const value = Buffer.from(data);
				const buffer$1 = new WebsocketFrameSend(value).createFrame(opcodes.BINARY);
				this.#bufferedAmount += value.byteLength;
				socket.write(buffer$1, () => {
					this.#bufferedAmount -= value.byteLength;
				});
			} else if (ArrayBuffer.isView(data)) {
				const ab = Buffer.from(data, data.byteOffset, data.byteLength);
				const buffer$1 = new WebsocketFrameSend(ab).createFrame(opcodes.BINARY);
				this.#bufferedAmount += ab.byteLength;
				socket.write(buffer$1, () => {
					this.#bufferedAmount -= ab.byteLength;
				});
			} else if (isBlobLike(data)) {
				const frame = new WebsocketFrameSend();
				data.arrayBuffer().then((ab) => {
					const value = Buffer.from(ab);
					frame.frameData = value;
					const buffer$1 = frame.createFrame(opcodes.BINARY);
					this.#bufferedAmount += value.byteLength;
					socket.write(buffer$1, () => {
						this.#bufferedAmount -= value.byteLength;
					});
				});
			}
		}
		get readyState() {
			webidl.brandCheck(this, WebSocket$3);
			return this[kReadyState];
		}
		get bufferedAmount() {
			webidl.brandCheck(this, WebSocket$3);
			return this.#bufferedAmount;
		}
		get url() {
			webidl.brandCheck(this, WebSocket$3);
			return URLSerializer(this[kWebSocketURL]);
		}
		get extensions() {
			webidl.brandCheck(this, WebSocket$3);
			return this.#extensions;
		}
		get protocol() {
			webidl.brandCheck(this, WebSocket$3);
			return this.#protocol;
		}
		get onopen() {
			webidl.brandCheck(this, WebSocket$3);
			return this.#events.open;
		}
		set onopen(fn) {
			webidl.brandCheck(this, WebSocket$3);
			if (this.#events.open) this.removeEventListener("open", this.#events.open);
			if (typeof fn === "function") {
				this.#events.open = fn;
				this.addEventListener("open", fn);
			} else this.#events.open = null;
		}
		get onerror() {
			webidl.brandCheck(this, WebSocket$3);
			return this.#events.error;
		}
		set onerror(fn) {
			webidl.brandCheck(this, WebSocket$3);
			if (this.#events.error) this.removeEventListener("error", this.#events.error);
			if (typeof fn === "function") {
				this.#events.error = fn;
				this.addEventListener("error", fn);
			} else this.#events.error = null;
		}
		get onclose() {
			webidl.brandCheck(this, WebSocket$3);
			return this.#events.close;
		}
		set onclose(fn) {
			webidl.brandCheck(this, WebSocket$3);
			if (this.#events.close) this.removeEventListener("close", this.#events.close);
			if (typeof fn === "function") {
				this.#events.close = fn;
				this.addEventListener("close", fn);
			} else this.#events.close = null;
		}
		get onmessage() {
			webidl.brandCheck(this, WebSocket$3);
			return this.#events.message;
		}
		set onmessage(fn) {
			webidl.brandCheck(this, WebSocket$3);
			if (this.#events.message) this.removeEventListener("message", this.#events.message);
			if (typeof fn === "function") {
				this.#events.message = fn;
				this.addEventListener("message", fn);
			} else this.#events.message = null;
		}
		get binaryType() {
			webidl.brandCheck(this, WebSocket$3);
			return this[kBinaryType];
		}
		set binaryType(type) {
			webidl.brandCheck(this, WebSocket$3);
			if (type !== "blob" && type !== "arraybuffer") this[kBinaryType] = "blob";
			else this[kBinaryType] = type;
		}
		/**
		* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
		*/
		#onConnectionEstablished(response) {
			this[kResponse] = response;
			const parser = new ByteParser(this);
			parser.on("drain", function onParserDrain() {
				this.ws[kResponse].socket.resume();
			});
			response.socket.ws = this;
			this[kByteParser] = parser;
			this[kReadyState] = states.OPEN;
			const extensions = response.headersList.get("sec-websocket-extensions");
			if (extensions !== null) this.#extensions = extensions;
			const protocol = response.headersList.get("sec-websocket-protocol");
			if (protocol !== null) this.#protocol = protocol;
			fireEvent("open", this);
		}
	};
	WebSocket$3.CONNECTING = WebSocket$3.prototype.CONNECTING = states.CONNECTING;
	WebSocket$3.OPEN = WebSocket$3.prototype.OPEN = states.OPEN;
	WebSocket$3.CLOSING = WebSocket$3.prototype.CLOSING = states.CLOSING;
	WebSocket$3.CLOSED = WebSocket$3.prototype.CLOSED = states.CLOSED;
	Object.defineProperties(WebSocket$3.prototype, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors,
		url: kEnumerableProperty,
		readyState: kEnumerableProperty,
		bufferedAmount: kEnumerableProperty,
		onopen: kEnumerableProperty,
		onerror: kEnumerableProperty,
		onclose: kEnumerableProperty,
		close: kEnumerableProperty,
		onmessage: kEnumerableProperty,
		binaryType: kEnumerableProperty,
		send: kEnumerableProperty,
		extensions: kEnumerableProperty,
		protocol: kEnumerableProperty,
		[Symbol.toStringTag]: {
			value: "WebSocket",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(WebSocket$3, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors
	});
	webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
	webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
		if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) return webidl.converters["sequence<DOMString>"](V);
		return webidl.converters.DOMString(V);
	};
	webidl.converters.WebSocketInit = webidl.dictionaryConverter([
		{
			key: "protocols",
			converter: webidl.converters["DOMString or sequence<DOMString>"],
			get defaultValue() {
				return [];
			}
		},
		{
			key: "dispatcher",
			converter: (V) => V,
			get defaultValue() {
				return getGlobalDispatcher$1();
			}
		},
		{
			key: "headers",
			converter: webidl.nullableConverter(webidl.converters.HeadersInit)
		}
	]);
	webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
		if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) return webidl.converters.WebSocketInit(V);
		return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
	};
	webidl.converters.WebSocketSendData = function(V) {
		if (webidl.util.Type(V) === "Object") {
			if (isBlobLike(V)) return webidl.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types$2.isAnyArrayBuffer(V)) return webidl.converters.BufferSource(V);
		}
		return webidl.converters.USVString(V);
	};
	module.exports = { WebSocket: WebSocket$3 };
}));

//#endregion
//#region node_modules/undici/index.js
var require_undici = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Client = require_client();
	const Dispatcher = require_dispatcher();
	const errors = require_errors();
	const Pool = require_pool();
	const BalancedPool = require_balanced_pool();
	const Agent$1 = require_agent();
	const util$6 = require_util$8();
	const { InvalidArgumentError } = errors;
	const api = require_api();
	const buildConnector = require_connect();
	const MockClient = require_mock_client();
	const MockAgent = require_mock_agent();
	const MockPool = require_mock_pool();
	const mockErrors = require_mock_errors();
	const ProxyAgent = require_proxy_agent();
	const RetryHandler = require_RetryHandler();
	const { getGlobalDispatcher, setGlobalDispatcher } = require_global();
	const DecoratorHandler = require_DecoratorHandler();
	const RedirectHandler = require_RedirectHandler();
	const createRedirectInterceptor = require_redirectInterceptor();
	let hasCrypto;
	try {
		require("crypto");
		hasCrypto = true;
	} catch {
		hasCrypto = false;
	}
	Object.assign(Dispatcher.prototype, api);
	module.exports.Dispatcher = Dispatcher;
	module.exports.Client = Client;
	module.exports.Pool = Pool;
	module.exports.BalancedPool = BalancedPool;
	module.exports.Agent = Agent$1;
	module.exports.ProxyAgent = ProxyAgent;
	module.exports.RetryHandler = RetryHandler;
	module.exports.DecoratorHandler = DecoratorHandler;
	module.exports.RedirectHandler = RedirectHandler;
	module.exports.createRedirectInterceptor = createRedirectInterceptor;
	module.exports.buildConnector = buildConnector;
	module.exports.errors = errors;
	function makeDispatcher(fn) {
		return (url, opts, handler$1) => {
			if (typeof opts === "function") {
				handler$1 = opts;
				opts = null;
			}
			if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) throw new InvalidArgumentError("invalid url");
			if (opts != null && typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			if (opts && opts.path != null) {
				if (typeof opts.path !== "string") throw new InvalidArgumentError("invalid opts.path");
				let path$9 = opts.path;
				if (!opts.path.startsWith("/")) path$9 = `/${path$9}`;
				url = new URL(util$6.parseOrigin(url).origin + path$9);
			} else {
				if (!opts) opts = typeof url === "object" ? url : {};
				url = util$6.parseURL(url);
			}
			const { agent, dispatcher = getGlobalDispatcher() } = opts;
			if (agent) throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
			return fn.call(dispatcher, {
				...opts,
				origin: url.origin,
				path: url.search ? `${url.pathname}${url.search}` : url.pathname,
				method: opts.method || (opts.body ? "PUT" : "GET")
			}, handler$1);
		};
	}
	module.exports.setGlobalDispatcher = setGlobalDispatcher;
	module.exports.getGlobalDispatcher = getGlobalDispatcher;
	if (util$6.nodeMajor > 16 || util$6.nodeMajor === 16 && util$6.nodeMinor >= 8) {
		let fetchImpl = null;
		module.exports.fetch = async function fetch$3(resource) {
			if (!fetchImpl) fetchImpl = require_fetch().fetch;
			try {
				return await fetchImpl(...arguments);
			} catch (err) {
				if (typeof err === "object") Error.captureStackTrace(err, this);
				throw err;
			}
		};
		module.exports.Headers = require_headers().Headers;
		module.exports.Response = require_response().Response;
		module.exports.Request = require_request().Request;
		module.exports.FormData = require_formdata().FormData;
		module.exports.File = require_file().File;
		module.exports.FileReader = require_filereader().FileReader;
		const { setGlobalOrigin: setGlobalOrigin$1, getGlobalOrigin: getGlobalOrigin$5 } = require_global$1();
		module.exports.setGlobalOrigin = setGlobalOrigin$1;
		module.exports.getGlobalOrigin = getGlobalOrigin$5;
		const { CacheStorage: CacheStorage$1 } = require_cachestorage();
		const { kConstruct: kConstruct$5 } = require_symbols$1();
		module.exports.caches = new CacheStorage$1(kConstruct$5);
	}
	if (util$6.nodeMajor >= 16) {
		const { deleteCookie: deleteCookie$1, getCookies: getCookies$1, getSetCookies: getSetCookies$1, setCookie: setCookie$1 } = require_cookies();
		module.exports.deleteCookie = deleteCookie$1;
		module.exports.getCookies = getCookies$1;
		module.exports.getSetCookies = getSetCookies$1;
		module.exports.setCookie = setCookie$1;
		const { parseMIMEType: parseMIMEType$4, serializeAMimeType: serializeAMimeType$5 } = require_dataURL();
		module.exports.parseMIMEType = parseMIMEType$4;
		module.exports.serializeAMimeType = serializeAMimeType$5;
	}
	if (util$6.nodeMajor >= 18 && hasCrypto) {
		const { WebSocket: WebSocket$4 } = require_websocket$1();
		module.exports.WebSocket = WebSocket$4;
	}
	module.exports.request = makeDispatcher(api.request);
	module.exports.stream = makeDispatcher(api.stream);
	module.exports.pipeline = makeDispatcher(api.pipeline);
	module.exports.connect = makeDispatcher(api.connect);
	module.exports.upgrade = makeDispatcher(api.upgrade);
	module.exports.MockClient = MockClient;
	module.exports.MockPool = MockPool;
	module.exports.MockAgent = MockAgent;
	module.exports.mockErrors = mockErrors;
}));

//#endregion
//#region node_modules/@actions/http-client/lib/index.js
var require_lib = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$18 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$15 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$15 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$18(result, mod, k);
		}
		__setModuleDefault$15(result, mod);
		return result;
	};
	var __awaiter$10 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
	const http$6 = __importStar$15(require("http"));
	const https$4 = __importStar$15(require("https"));
	const pm = __importStar$15(require_proxy());
	const tunnel = __importStar$15(require_tunnel());
	const undici_1$1 = require_undici();
	var HttpCodes;
	(function(HttpCodes$1) {
		HttpCodes$1[HttpCodes$1["OK"] = 200] = "OK";
		HttpCodes$1[HttpCodes$1["MultipleChoices"] = 300] = "MultipleChoices";
		HttpCodes$1[HttpCodes$1["MovedPermanently"] = 301] = "MovedPermanently";
		HttpCodes$1[HttpCodes$1["ResourceMoved"] = 302] = "ResourceMoved";
		HttpCodes$1[HttpCodes$1["SeeOther"] = 303] = "SeeOther";
		HttpCodes$1[HttpCodes$1["NotModified"] = 304] = "NotModified";
		HttpCodes$1[HttpCodes$1["UseProxy"] = 305] = "UseProxy";
		HttpCodes$1[HttpCodes$1["SwitchProxy"] = 306] = "SwitchProxy";
		HttpCodes$1[HttpCodes$1["TemporaryRedirect"] = 307] = "TemporaryRedirect";
		HttpCodes$1[HttpCodes$1["PermanentRedirect"] = 308] = "PermanentRedirect";
		HttpCodes$1[HttpCodes$1["BadRequest"] = 400] = "BadRequest";
		HttpCodes$1[HttpCodes$1["Unauthorized"] = 401] = "Unauthorized";
		HttpCodes$1[HttpCodes$1["PaymentRequired"] = 402] = "PaymentRequired";
		HttpCodes$1[HttpCodes$1["Forbidden"] = 403] = "Forbidden";
		HttpCodes$1[HttpCodes$1["NotFound"] = 404] = "NotFound";
		HttpCodes$1[HttpCodes$1["MethodNotAllowed"] = 405] = "MethodNotAllowed";
		HttpCodes$1[HttpCodes$1["NotAcceptable"] = 406] = "NotAcceptable";
		HttpCodes$1[HttpCodes$1["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
		HttpCodes$1[HttpCodes$1["RequestTimeout"] = 408] = "RequestTimeout";
		HttpCodes$1[HttpCodes$1["Conflict"] = 409] = "Conflict";
		HttpCodes$1[HttpCodes$1["Gone"] = 410] = "Gone";
		HttpCodes$1[HttpCodes$1["TooManyRequests"] = 429] = "TooManyRequests";
		HttpCodes$1[HttpCodes$1["InternalServerError"] = 500] = "InternalServerError";
		HttpCodes$1[HttpCodes$1["NotImplemented"] = 501] = "NotImplemented";
		HttpCodes$1[HttpCodes$1["BadGateway"] = 502] = "BadGateway";
		HttpCodes$1[HttpCodes$1["ServiceUnavailable"] = 503] = "ServiceUnavailable";
		HttpCodes$1[HttpCodes$1["GatewayTimeout"] = 504] = "GatewayTimeout";
	})(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
	var Headers$2;
	(function(Headers$9) {
		Headers$9["Accept"] = "accept";
		Headers$9["ContentType"] = "content-type";
	})(Headers$2 || (exports.Headers = Headers$2 = {}));
	var MediaTypes;
	(function(MediaTypes$1) {
		MediaTypes$1["ApplicationJson"] = "application/json";
	})(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
	/**
	* Returns the proxy URL, depending upon the supplied url and proxy environment variables.
	* @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	*/
	function getProxyUrl(serverUrl) {
		const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
		return proxyUrl ? proxyUrl.href : "";
	}
	exports.getProxyUrl = getProxyUrl;
	const HttpRedirectCodes = [
		HttpCodes.MovedPermanently,
		HttpCodes.ResourceMoved,
		HttpCodes.SeeOther,
		HttpCodes.TemporaryRedirect,
		HttpCodes.PermanentRedirect
	];
	const HttpResponseRetryCodes = [
		HttpCodes.BadGateway,
		HttpCodes.ServiceUnavailable,
		HttpCodes.GatewayTimeout
	];
	const RetryableHttpVerbs = [
		"OPTIONS",
		"GET",
		"DELETE",
		"HEAD"
	];
	const ExponentialBackoffCeiling = 10;
	const ExponentialBackoffTimeSlice = 5;
	var HttpClientError = class HttpClientError extends Error {
		constructor(message, statusCode) {
			super(message);
			this.name = "HttpClientError";
			this.statusCode = statusCode;
			Object.setPrototypeOf(this, HttpClientError.prototype);
		}
	};
	exports.HttpClientError = HttpClientError;
	var HttpClientResponse = class {
		constructor(message) {
			this.message = message;
		}
		readBody() {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter$10(this, void 0, void 0, function* () {
					let output = Buffer.alloc(0);
					this.message.on("data", (chunk) => {
						output = Buffer.concat([output, chunk]);
					});
					this.message.on("end", () => {
						resolve(output.toString());
					});
				}));
			});
		}
		readBodyBuffer() {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter$10(this, void 0, void 0, function* () {
					const chunks = [];
					this.message.on("data", (chunk) => {
						chunks.push(chunk);
					});
					this.message.on("end", () => {
						resolve(Buffer.concat(chunks));
					});
				}));
			});
		}
	};
	exports.HttpClientResponse = HttpClientResponse;
	function isHttps(requestUrl) {
		return new URL(requestUrl).protocol === "https:";
	}
	exports.isHttps = isHttps;
	var HttpClient = class {
		constructor(userAgent$1, handlers, requestOptions) {
			this._ignoreSslError = false;
			this._allowRedirects = true;
			this._allowRedirectDowngrade = false;
			this._maxRedirects = 50;
			this._allowRetries = false;
			this._maxRetries = 1;
			this._keepAlive = false;
			this._disposed = false;
			this.userAgent = userAgent$1;
			this.handlers = handlers || [];
			this.requestOptions = requestOptions;
			if (requestOptions) {
				if (requestOptions.ignoreSslError != null) this._ignoreSslError = requestOptions.ignoreSslError;
				this._socketTimeout = requestOptions.socketTimeout;
				if (requestOptions.allowRedirects != null) this._allowRedirects = requestOptions.allowRedirects;
				if (requestOptions.allowRedirectDowngrade != null) this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
				if (requestOptions.maxRedirects != null) this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
				if (requestOptions.keepAlive != null) this._keepAlive = requestOptions.keepAlive;
				if (requestOptions.allowRetries != null) this._allowRetries = requestOptions.allowRetries;
				if (requestOptions.maxRetries != null) this._maxRetries = requestOptions.maxRetries;
			}
		}
		options(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
			});
		}
		get(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("GET", requestUrl, null, additionalHeaders || {});
			});
		}
		del(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("DELETE", requestUrl, null, additionalHeaders || {});
			});
		}
		post(requestUrl, data, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("POST", requestUrl, data, additionalHeaders || {});
			});
		}
		patch(requestUrl, data, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("PATCH", requestUrl, data, additionalHeaders || {});
			});
		}
		put(requestUrl, data, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("PUT", requestUrl, data, additionalHeaders || {});
			});
		}
		head(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("HEAD", requestUrl, null, additionalHeaders || {});
			});
		}
		sendStream(verb, requestUrl, stream$6, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request(verb, requestUrl, stream$6, additionalHeaders);
			});
		}
		/**
		* Gets a typed object from an endpoint
		* Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
		*/
		getJson(requestUrl, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				const res = yield this.get(requestUrl, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		postJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.post(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		putJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.put(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		patchJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.patch(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		/**
		* Makes a raw http request.
		* All other methods such as get, post, patch, and request ultimately call this.
		* Prefer get, del, post and patch
		*/
		request(verb, requestUrl, data, headers) {
			return __awaiter$10(this, void 0, void 0, function* () {
				if (this._disposed) throw new Error("Client has already been disposed.");
				const parsedUrl = new URL(requestUrl);
				let info$1 = this._prepareRequest(verb, parsedUrl, headers);
				const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
				let numTries = 0;
				let response;
				do {
					response = yield this.requestRaw(info$1, data);
					if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
						let authenticationHandler;
						for (const handler$1 of this.handlers) if (handler$1.canHandleAuthentication(response)) {
							authenticationHandler = handler$1;
							break;
						}
						if (authenticationHandler) return authenticationHandler.handleAuthentication(this, info$1, data);
						else return response;
					}
					let redirectsRemaining = this._maxRedirects;
					while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
						const redirectUrl = response.message.headers["location"];
						if (!redirectUrl) break;
						const parsedRedirectUrl = new URL(redirectUrl);
						if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
						yield response.readBody();
						if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
							for (const header in headers) if (header.toLowerCase() === "authorization") delete headers[header];
						}
						info$1 = this._prepareRequest(verb, parsedRedirectUrl, headers);
						response = yield this.requestRaw(info$1, data);
						redirectsRemaining--;
					}
					if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) return response;
					numTries += 1;
					if (numTries < maxTries) {
						yield response.readBody();
						yield this._performExponentialBackoff(numTries);
					}
				} while (numTries < maxTries);
				return response;
			});
		}
		/**
		* Needs to be called if keepAlive is set to true in request options.
		*/
		dispose() {
			if (this._agent) this._agent.destroy();
			this._disposed = true;
		}
		/**
		* Raw request.
		* @param info
		* @param data
		*/
		requestRaw(info$1, data) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => {
					function callbackForResult(err, res) {
						if (err) reject(err);
						else if (!res) reject(/* @__PURE__ */ new Error("Unknown error"));
						else resolve(res);
					}
					this.requestRawWithCallback(info$1, data, callbackForResult);
				});
			});
		}
		/**
		* Raw request with callback.
		* @param info
		* @param data
		* @param onResult
		*/
		requestRawWithCallback(info$1, data, onResult) {
			if (typeof data === "string") {
				if (!info$1.options.headers) info$1.options.headers = {};
				info$1.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
			}
			let callbackCalled = false;
			function handleResult(err, res) {
				if (!callbackCalled) {
					callbackCalled = true;
					onResult(err, res);
				}
			}
			const req$1 = info$1.httpModule.request(info$1.options, (msg) => {
				handleResult(void 0, new HttpClientResponse(msg));
			});
			let socket;
			req$1.on("socket", (sock) => {
				socket = sock;
			});
			req$1.setTimeout(this._socketTimeout || 3 * 6e4, () => {
				if (socket) socket.end();
				handleResult(/* @__PURE__ */ new Error(`Request timeout: ${info$1.options.path}`));
			});
			req$1.on("error", function(err) {
				handleResult(err);
			});
			if (data && typeof data === "string") req$1.write(data, "utf8");
			if (data && typeof data !== "string") {
				data.on("close", function() {
					req$1.end();
				});
				data.pipe(req$1);
			} else req$1.end();
		}
		/**
		* Gets an http agent. This function is useful when you need an http agent that handles
		* routing through a proxy server - depending upon the url and proxy environment variables.
		* @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
		*/
		getAgent(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			return this._getAgent(parsedUrl);
		}
		getAgentDispatcher(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			if (!(proxyUrl && proxyUrl.hostname)) return;
			return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
		}
		_prepareRequest(method, requestUrl, headers) {
			const info$1 = {};
			info$1.parsedUrl = requestUrl;
			const usingSsl = info$1.parsedUrl.protocol === "https:";
			info$1.httpModule = usingSsl ? https$4 : http$6;
			const defaultPort = usingSsl ? 443 : 80;
			info$1.options = {};
			info$1.options.host = info$1.parsedUrl.hostname;
			info$1.options.port = info$1.parsedUrl.port ? parseInt(info$1.parsedUrl.port) : defaultPort;
			info$1.options.path = (info$1.parsedUrl.pathname || "") + (info$1.parsedUrl.search || "");
			info$1.options.method = method;
			info$1.options.headers = this._mergeHeaders(headers);
			if (this.userAgent != null) info$1.options.headers["user-agent"] = this.userAgent;
			info$1.options.agent = this._getAgent(info$1.parsedUrl);
			if (this.handlers) for (const handler$1 of this.handlers) handler$1.prepareRequest(info$1.options);
			return info$1;
		}
		_mergeHeaders(headers) {
			if (this.requestOptions && this.requestOptions.headers) return Object.assign({}, lowercaseKeys$1(this.requestOptions.headers), lowercaseKeys$1(headers || {}));
			return lowercaseKeys$1(headers || {});
		}
		_getExistingOrDefaultHeader(additionalHeaders, header, _default) {
			let clientHeader;
			if (this.requestOptions && this.requestOptions.headers) clientHeader = lowercaseKeys$1(this.requestOptions.headers)[header];
			return additionalHeaders[header] || clientHeader || _default;
		}
		_getAgent(parsedUrl) {
			let agent;
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			const useProxy = proxyUrl && proxyUrl.hostname;
			if (this._keepAlive && useProxy) agent = this._proxyAgent;
			if (!useProxy) agent = this._agent;
			if (agent) return agent;
			const usingSsl = parsedUrl.protocol === "https:";
			let maxSockets = 100;
			if (this.requestOptions) maxSockets = this.requestOptions.maxSockets || http$6.globalAgent.maxSockets;
			if (proxyUrl && proxyUrl.hostname) {
				const agentOptions = {
					maxSockets,
					keepAlive: this._keepAlive,
					proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && { proxyAuth: `${proxyUrl.username}:${proxyUrl.password}` }), {
						host: proxyUrl.hostname,
						port: proxyUrl.port
					})
				};
				let tunnelAgent;
				const overHttps = proxyUrl.protocol === "https:";
				if (usingSsl) tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
				else tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
				agent = tunnelAgent(agentOptions);
				this._proxyAgent = agent;
			}
			if (!agent) {
				const options = {
					keepAlive: this._keepAlive,
					maxSockets
				};
				agent = usingSsl ? new https$4.Agent(options) : new http$6.Agent(options);
				this._agent = agent;
			}
			if (usingSsl && this._ignoreSslError) agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });
			return agent;
		}
		_getProxyAgentDispatcher(parsedUrl, proxyUrl) {
			let proxyAgent;
			if (this._keepAlive) proxyAgent = this._proxyAgentDispatcher;
			if (proxyAgent) return proxyAgent;
			const usingSsl = parsedUrl.protocol === "https:";
			proxyAgent = new undici_1$1.ProxyAgent(Object.assign({
				uri: proxyUrl.href,
				pipelining: !this._keepAlive ? 0 : 1
			}, (proxyUrl.username || proxyUrl.password) && { token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}` }));
			this._proxyAgentDispatcher = proxyAgent;
			if (usingSsl && this._ignoreSslError) proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, { rejectUnauthorized: false });
			return proxyAgent;
		}
		_performExponentialBackoff(retryNumber) {
			return __awaiter$10(this, void 0, void 0, function* () {
				retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
				const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
				return new Promise((resolve) => setTimeout(() => resolve(), ms));
			});
		}
		_processResponse(res, options) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => __awaiter$10(this, void 0, void 0, function* () {
					const statusCode = res.message.statusCode || 0;
					const response = {
						statusCode,
						result: null,
						headers: {}
					};
					if (statusCode === HttpCodes.NotFound) resolve(response);
					function dateTimeDeserializer(key, value) {
						if (typeof value === "string") {
							const a = new Date(value);
							if (!isNaN(a.valueOf())) return a;
						}
						return value;
					}
					let obj;
					let contents;
					try {
						contents = yield res.readBody();
						if (contents && contents.length > 0) {
							if (options && options.deserializeDates) obj = JSON.parse(contents, dateTimeDeserializer);
							else obj = JSON.parse(contents);
							response.result = obj;
						}
						response.headers = res.message.headers;
					} catch (err) {}
					if (statusCode > 299) {
						let msg;
						if (obj && obj.message) msg = obj.message;
						else if (contents && contents.length > 0) msg = contents;
						else msg = `Failed request: (${statusCode})`;
						const err = new HttpClientError(msg, statusCode);
						err.result = response.result;
						reject(err);
					} else resolve(response);
				}));
			});
		}
	};
	exports.HttpClient = HttpClient;
	const lowercaseKeys$1 = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
}));

//#endregion
//#region node_modules/@actions/http-client/lib/auth.js
var require_auth = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter$9 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
	var BasicCredentialHandler = class {
		constructor(username, password) {
			this.username = username;
			this.password = password;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BasicCredentialHandler = BasicCredentialHandler;
	var BearerCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Bearer ${this.token}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BearerCredentialHandler = BearerCredentialHandler;
	var PersonalAccessTokenCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
}));

//#endregion
//#region node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter$8 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OidcClient = void 0;
	const http_client_1 = require_lib();
	const auth_1 = require_auth();
	const core_1$1 = require_core();
	var OidcClient = class OidcClient {
		static createHttpClient(allowRetry = true, maxRetry = 10) {
			const requestOptions = {
				allowRetries: allowRetry,
				maxRetries: maxRetry
			};
			return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
		}
		static getRequestToken() {
			const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
			if (!token) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
			return token;
		}
		static getIDTokenUrl() {
			const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
			if (!runtimeUrl) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
			return runtimeUrl;
		}
		static getCall(id_token_url) {
			var _a$2;
			return __awaiter$8(this, void 0, void 0, function* () {
				const id_token = (_a$2 = (yield OidcClient.createHttpClient().getJson(id_token_url).catch((error$1) => {
					throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error$1.statusCode}\n 
        Error Message: ${error$1.message}`);
				})).result) === null || _a$2 === void 0 ? void 0 : _a$2.value;
				if (!id_token) throw new Error("Response json body do not have ID Token field");
				return id_token;
			});
		}
		static getIDToken(audience) {
			return __awaiter$8(this, void 0, void 0, function* () {
				try {
					let id_token_url = OidcClient.getIDTokenUrl();
					if (audience) id_token_url = `${id_token_url}&audience=${encodeURIComponent(audience)}`;
					(0, core_1$1.debug)(`ID token url is ${id_token_url}`);
					const id_token = yield OidcClient.getCall(id_token_url);
					(0, core_1$1.setSecret)(id_token);
					return id_token;
				} catch (error$1) {
					throw new Error(`Error message: ${error$1.message}`);
				}
			});
		}
	};
	exports.OidcClient = OidcClient;
}));

//#endregion
//#region node_modules/@actions/core/lib/summary.js
var require_summary = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter$7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
	const os_1$3 = require("os");
	const fs_1$2 = require("fs");
	const { access, appendFile, writeFile: writeFile$1 } = fs_1$2.promises;
	exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
	exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
	var Summary = class {
		constructor() {
			this._buffer = "";
		}
		/**
		* Finds the summary file path from the environment, rejects if env var is not found or file does not exist
		* Also checks r/w permissions.
		*
		* @returns step summary file path
		*/
		filePath() {
			return __awaiter$7(this, void 0, void 0, function* () {
				if (this._filePath) return this._filePath;
				const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
				if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
				try {
					yield access(pathFromEnv, fs_1$2.constants.R_OK | fs_1$2.constants.W_OK);
				} catch (_a$2) {
					throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
				}
				this._filePath = pathFromEnv;
				return this._filePath;
			});
		}
		/**
		* Wraps content in an HTML tag, adding any HTML attributes
		*
		* @param {string} tag HTML tag to wrap
		* @param {string | null} content content within the tag
		* @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
		*
		* @returns {string} content wrapped in HTML element
		*/
		wrap(tag, content, attrs = {}) {
			const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
			if (!content) return `<${tag}${htmlAttrs}>`;
			return `<${tag}${htmlAttrs}>${content}</${tag}>`;
		}
		/**
		* Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
		*
		* @param {SummaryWriteOptions} [options] (optional) options for write operation
		*
		* @returns {Promise<Summary>} summary instance
		*/
		write(options) {
			return __awaiter$7(this, void 0, void 0, function* () {
				const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
				const filePath = yield this.filePath();
				yield (overwrite ? writeFile$1 : appendFile)(filePath, this._buffer, { encoding: "utf8" });
				return this.emptyBuffer();
			});
		}
		/**
		* Clears the summary buffer and wipes the summary file
		*
		* @returns {Summary} summary instance
		*/
		clear() {
			return __awaiter$7(this, void 0, void 0, function* () {
				return this.emptyBuffer().write({ overwrite: true });
			});
		}
		/**
		* Returns the current summary buffer as a string
		*
		* @returns {string} string of summary buffer
		*/
		stringify() {
			return this._buffer;
		}
		/**
		* If the summary buffer is empty
		*
		* @returns {boolen} true if the buffer is empty
		*/
		isEmptyBuffer() {
			return this._buffer.length === 0;
		}
		/**
		* Resets the summary buffer without writing to summary file
		*
		* @returns {Summary} summary instance
		*/
		emptyBuffer() {
			this._buffer = "";
			return this;
		}
		/**
		* Adds raw text to the summary buffer
		*
		* @param {string} text content to add
		* @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
		*
		* @returns {Summary} summary instance
		*/
		addRaw(text, addEOL = false) {
			this._buffer += text;
			return addEOL ? this.addEOL() : this;
		}
		/**
		* Adds the operating system-specific end-of-line marker to the buffer
		*
		* @returns {Summary} summary instance
		*/
		addEOL() {
			return this.addRaw(os_1$3.EOL);
		}
		/**
		* Adds an HTML codeblock to the summary buffer
		*
		* @param {string} code content to render within fenced code block
		* @param {string} lang (optional) language to syntax highlight code
		*
		* @returns {Summary} summary instance
		*/
		addCodeBlock(code$1, lang) {
			const attrs = Object.assign({}, lang && { lang });
			const element = this.wrap("pre", this.wrap("code", code$1), attrs);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML list to the summary buffer
		*
		* @param {string[]} items list of items to render
		* @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
		*
		* @returns {Summary} summary instance
		*/
		addList(items, ordered = false) {
			const tag = ordered ? "ol" : "ul";
			const listItems = items.map((item) => this.wrap("li", item)).join("");
			const element = this.wrap(tag, listItems);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML table to the summary buffer
		*
		* @param {SummaryTableCell[]} rows table rows
		*
		* @returns {Summary} summary instance
		*/
		addTable(rows) {
			const tableBody = rows.map((row) => {
				const cells = row.map((cell) => {
					if (typeof cell === "string") return this.wrap("td", cell);
					const { header, data, colspan, rowspan } = cell;
					const tag = header ? "th" : "td";
					const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
					return this.wrap(tag, data, attrs);
				}).join("");
				return this.wrap("tr", cells);
			}).join("");
			const element = this.wrap("table", tableBody);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds a collapsable HTML details element to the summary buffer
		*
		* @param {string} label text for the closed state
		* @param {string} content collapsable content
		*
		* @returns {Summary} summary instance
		*/
		addDetails(label, content) {
			const element = this.wrap("details", this.wrap("summary", label) + content);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML image tag to the summary buffer
		*
		* @param {string} src path to the image you to embed
		* @param {string} alt text description of the image
		* @param {SummaryImageOptions} options (optional) addition image attributes
		*
		* @returns {Summary} summary instance
		*/
		addImage(src, alt, options) {
			const { width, height } = options || {};
			const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
			const element = this.wrap("img", null, Object.assign({
				src,
				alt
			}, attrs));
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML section heading element
		*
		* @param {string} text heading text
		* @param {number | string} [level=1] (optional) the heading level, default: 1
		*
		* @returns {Summary} summary instance
		*/
		addHeading(text, level) {
			const tag = `h${level}`;
			const allowedTag = [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			].includes(tag) ? tag : "h1";
			const element = this.wrap(allowedTag, text);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML thematic break (<hr>) to the summary buffer
		*
		* @returns {Summary} summary instance
		*/
		addSeparator() {
			const element = this.wrap("hr", null);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML line break (<br>) to the summary buffer
		*
		* @returns {Summary} summary instance
		*/
		addBreak() {
			const element = this.wrap("br", null);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML blockquote to the summary buffer
		*
		* @param {string} text quote text
		* @param {string} cite (optional) citation url
		*
		* @returns {Summary} summary instance
		*/
		addQuote(text, cite) {
			const attrs = Object.assign({}, cite && { cite });
			const element = this.wrap("blockquote", text, attrs);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML anchor tag to the summary buffer
		*
		* @param {string} text link text/content
		* @param {string} href hyperlink
		*
		* @returns {Summary} summary instance
		*/
		addLink(text, href) {
			const element = this.wrap("a", text, { href });
			return this.addRaw(element).addEOL();
		}
	};
	const _summary = new Summary();
	/**
	* @deprecated use `core.summary`
	*/
	exports.markdownSummary = _summary;
	exports.summary = _summary;
}));

//#endregion
//#region node_modules/@actions/core/lib/path-utils.js
var require_path_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$17 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$14 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$14 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$17(result, mod, k);
		}
		__setModuleDefault$14(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
	const path$8 = __importStar$14(require("path"));
	/**
	* toPosixPath converts the given path to the posix form. On Windows, \\ will be
	* replaced with /.
	*
	* @param pth. Path to transform.
	* @return string Posix path.
	*/
	function toPosixPath(pth) {
		return pth.replace(/[\\]/g, "/");
	}
	exports.toPosixPath = toPosixPath;
	/**
	* toWin32Path converts the given path to the win32 form. On Linux, / will be
	* replaced with \\.
	*
	* @param pth. Path to transform.
	* @return string Win32 path.
	*/
	function toWin32Path(pth) {
		return pth.replace(/[/]/g, "\\");
	}
	exports.toWin32Path = toWin32Path;
	/**
	* toPlatformPath converts the given path to a platform-specific path. It does
	* this by replacing instances of / and \ with the platform-specific path
	* separator.
	*
	* @param pth The path to platformize.
	* @return string The platform-specific path.
	*/
	function toPlatformPath(pth) {
		return pth.replace(/[/\\]/g, path$8.sep);
	}
	exports.toPlatformPath = toPlatformPath;
}));

//#endregion
//#region node_modules/@actions/io/lib/io-util.js
var require_io_util = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$16 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		});
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$13 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$13 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$16(result, mod, k);
		}
		__setModuleDefault$13(result, mod);
		return result;
	};
	var __awaiter$6 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var _a$1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
	const fs$8 = __importStar$13(require("fs"));
	const path$7 = __importStar$13(require("path"));
	_a$1 = fs$8.promises, exports.chmod = _a$1.chmod, exports.copyFile = _a$1.copyFile, exports.lstat = _a$1.lstat, exports.mkdir = _a$1.mkdir, exports.open = _a$1.open, exports.readdir = _a$1.readdir, exports.readlink = _a$1.readlink, exports.rename = _a$1.rename, exports.rm = _a$1.rm, exports.rmdir = _a$1.rmdir, exports.stat = _a$1.stat, exports.symlink = _a$1.symlink, exports.unlink = _a$1.unlink;
	exports.IS_WINDOWS = process.platform === "win32";
	exports.UV_FS_O_EXLOCK = 268435456;
	exports.READONLY = fs$8.constants.O_RDONLY;
	function exists(fsPath) {
		return __awaiter$6(this, void 0, void 0, function* () {
			try {
				yield exports.stat(fsPath);
			} catch (err) {
				if (err.code === "ENOENT") return false;
				throw err;
			}
			return true;
		});
	}
	exports.exists = exists;
	function isDirectory(fsPath, useStat = false) {
		return __awaiter$6(this, void 0, void 0, function* () {
			return (useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath)).isDirectory();
		});
	}
	exports.isDirectory = isDirectory;
	/**
	* On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
	* \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
	*/
	function isRooted(p) {
		p = normalizeSeparators(p);
		if (!p) throw new Error("isRooted() parameter \"p\" cannot be empty");
		if (exports.IS_WINDOWS) return p.startsWith("\\") || /^[A-Z]:/i.test(p);
		return p.startsWith("/");
	}
	exports.isRooted = isRooted;
	/**
	* Best effort attempt to determine whether a file exists and is executable.
	* @param filePath    file path to check
	* @param extensions  additional file extensions to try
	* @return if file exists and is executable, returns the file path. otherwise empty string.
	*/
	function tryGetExecutablePath(filePath, extensions) {
		return __awaiter$6(this, void 0, void 0, function* () {
			let stats = void 0;
			try {
				stats = yield exports.stat(filePath);
			} catch (err) {
				if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
			}
			if (stats && stats.isFile()) {
				if (exports.IS_WINDOWS) {
					const upperExt = path$7.extname(filePath).toUpperCase();
					if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) return filePath;
				} else if (isUnixExecutable(stats)) return filePath;
			}
			const originalFilePath = filePath;
			for (const extension$1 of extensions) {
				filePath = originalFilePath + extension$1;
				stats = void 0;
				try {
					stats = yield exports.stat(filePath);
				} catch (err) {
					if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
				}
				if (stats && stats.isFile()) {
					if (exports.IS_WINDOWS) {
						try {
							const directory = path$7.dirname(filePath);
							const upperName = path$7.basename(filePath).toUpperCase();
							for (const actualName of yield exports.readdir(directory)) if (upperName === actualName.toUpperCase()) {
								filePath = path$7.join(directory, actualName);
								break;
							}
						} catch (err) {
							console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
						}
						return filePath;
					} else if (isUnixExecutable(stats)) return filePath;
				}
			}
			return "";
		});
	}
	exports.tryGetExecutablePath = tryGetExecutablePath;
	function normalizeSeparators(p) {
		p = p || "";
		if (exports.IS_WINDOWS) {
			p = p.replace(/\//g, "\\");
			return p.replace(/\\\\+/g, "\\");
		}
		return p.replace(/\/\/+/g, "/");
	}
	function isUnixExecutable(stats) {
		return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
	}
	function getCmdPath() {
		var _a$2;
		return (_a$2 = process.env["COMSPEC"]) !== null && _a$2 !== void 0 ? _a$2 : `cmd.exe`;
	}
	exports.getCmdPath = getCmdPath;
}));

//#endregion
//#region node_modules/@actions/io/lib/io.js
var require_io = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$15 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		});
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$12 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$12 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$15(result, mod, k);
		}
		__setModuleDefault$12(result, mod);
		return result;
	};
	var __awaiter$5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
	const assert_1$1 = require("assert");
	const path$6 = __importStar$12(require("path"));
	const ioUtil$1 = __importStar$12(require_io_util());
	/**
	* Copies a file or folder.
	* Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
	*
	* @param     source    source path
	* @param     dest      destination path
	* @param     options   optional. See CopyOptions.
	*/
	function cp(source, dest, options = {}) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const { force, recursive, copySourceDirectory } = readCopyOptions(options);
			const destStat = (yield ioUtil$1.exists(dest)) ? yield ioUtil$1.stat(dest) : null;
			if (destStat && destStat.isFile() && !force) return;
			const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path$6.join(dest, path$6.basename(source)) : dest;
			if (!(yield ioUtil$1.exists(source))) throw new Error(`no such file or directory: ${source}`);
			if ((yield ioUtil$1.stat(source)).isDirectory()) if (!recursive) throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
			else yield cpDirRecursive(source, newDest, 0, force);
			else {
				if (path$6.relative(source, newDest) === "") throw new Error(`'${newDest}' and '${source}' are the same file`);
				yield copyFile(source, newDest, force);
			}
		});
	}
	exports.cp = cp;
	/**
	* Moves a path.
	*
	* @param     source    source path
	* @param     dest      destination path
	* @param     options   optional. See MoveOptions.
	*/
	function mv(source, dest, options = {}) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (yield ioUtil$1.exists(dest)) {
				let destExists = true;
				if (yield ioUtil$1.isDirectory(dest)) {
					dest = path$6.join(dest, path$6.basename(source));
					destExists = yield ioUtil$1.exists(dest);
				}
				if (destExists) if (options.force == null || options.force) yield rmRF(dest);
				else throw new Error("Destination already exists");
			}
			yield mkdirP(path$6.dirname(dest));
			yield ioUtil$1.rename(source, dest);
		});
	}
	exports.mv = mv;
	/**
	* Remove a path recursively with force
	*
	* @param inputPath path to remove
	*/
	function rmRF(inputPath) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (ioUtil$1.IS_WINDOWS) {
				if (/[*"<>|]/.test(inputPath)) throw new Error("File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows");
			}
			try {
				yield ioUtil$1.rm(inputPath, {
					force: true,
					maxRetries: 3,
					recursive: true,
					retryDelay: 300
				});
			} catch (err) {
				throw new Error(`File was unable to be removed ${err}`);
			}
		});
	}
	exports.rmRF = rmRF;
	/**
	* Make a directory.  Creates the full path with folders in between
	* Will throw if it fails
	*
	* @param   fsPath        path to create
	* @returns Promise<void>
	*/
	function mkdirP(fsPath) {
		return __awaiter$5(this, void 0, void 0, function* () {
			assert_1$1.ok(fsPath, "a path argument must be provided");
			yield ioUtil$1.mkdir(fsPath, { recursive: true });
		});
	}
	exports.mkdirP = mkdirP;
	/**
	* Returns path of a tool had the tool actually been invoked.  Resolves via paths.
	* If you check and the tool does not exist, it will throw.
	*
	* @param     tool              name of the tool
	* @param     check             whether to check if tool exists
	* @returns   Promise<string>   path to tool
	*/
	function which(tool, check) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			if (check) {
				const result = yield which(tool, false);
				if (!result) if (ioUtil$1.IS_WINDOWS) throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
				else throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
				return result;
			}
			const matches = yield findInPath(tool);
			if (matches && matches.length > 0) return matches[0];
			return "";
		});
	}
	exports.which = which;
	/**
	* Returns a list of all occurrences of the given tool on the system path.
	*
	* @returns   Promise<string[]>  the paths of the tool
	*/
	function findInPath(tool) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			const extensions = [];
			if (ioUtil$1.IS_WINDOWS && process.env["PATHEXT"]) {
				for (const extension$1 of process.env["PATHEXT"].split(path$6.delimiter)) if (extension$1) extensions.push(extension$1);
			}
			if (ioUtil$1.isRooted(tool)) {
				const filePath = yield ioUtil$1.tryGetExecutablePath(tool, extensions);
				if (filePath) return [filePath];
				return [];
			}
			if (tool.includes(path$6.sep)) return [];
			const directories = [];
			if (process.env.PATH) {
				for (const p of process.env.PATH.split(path$6.delimiter)) if (p) directories.push(p);
			}
			const matches = [];
			for (const directory of directories) {
				const filePath = yield ioUtil$1.tryGetExecutablePath(path$6.join(directory, tool), extensions);
				if (filePath) matches.push(filePath);
			}
			return matches;
		});
	}
	exports.findInPath = findInPath;
	function readCopyOptions(options) {
		return {
			force: options.force == null ? true : options.force,
			recursive: Boolean(options.recursive),
			copySourceDirectory: options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory)
		};
	}
	function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (currentDepth >= 255) return;
			currentDepth++;
			yield mkdirP(destDir);
			const files = yield ioUtil$1.readdir(sourceDir);
			for (const fileName of files) {
				const srcFile = `${sourceDir}/${fileName}`;
				const destFile = `${destDir}/${fileName}`;
				if ((yield ioUtil$1.lstat(srcFile)).isDirectory()) yield cpDirRecursive(srcFile, destFile, currentDepth, force);
				else yield copyFile(srcFile, destFile, force);
			}
			yield ioUtil$1.chmod(destDir, (yield ioUtil$1.stat(sourceDir)).mode);
		});
	}
	function copyFile(srcFile, destFile, force) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if ((yield ioUtil$1.lstat(srcFile)).isSymbolicLink()) {
				try {
					yield ioUtil$1.lstat(destFile);
					yield ioUtil$1.unlink(destFile);
				} catch (e$1) {
					if (e$1.code === "EPERM") {
						yield ioUtil$1.chmod(destFile, "0666");
						yield ioUtil$1.unlink(destFile);
					}
				}
				const symlinkFull = yield ioUtil$1.readlink(srcFile);
				yield ioUtil$1.symlink(symlinkFull, destFile, ioUtil$1.IS_WINDOWS ? "junction" : null);
			} else if (!(yield ioUtil$1.exists(destFile)) || force) yield ioUtil$1.copyFile(srcFile, destFile);
		});
	}
}));

//#endregion
//#region node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$14 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		});
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$11 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$11 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$14(result, mod, k);
		}
		__setModuleDefault$11(result, mod);
		return result;
	};
	var __awaiter$4 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.argStringToArray = exports.ToolRunner = void 0;
	const os$3 = __importStar$11(require("os"));
	const events = __importStar$11(require("events"));
	const child = __importStar$11(require("child_process"));
	const path$5 = __importStar$11(require("path"));
	const io = __importStar$11(require_io());
	const ioUtil = __importStar$11(require_io_util());
	const timers_1 = require("timers");
	const IS_WINDOWS = process.platform === "win32";
	var ToolRunner = class extends events.EventEmitter {
		constructor(toolPath, args, options) {
			super();
			if (!toolPath) throw new Error("Parameter 'toolPath' cannot be null or empty.");
			this.toolPath = toolPath;
			this.args = args || [];
			this.options = options || {};
		}
		_debug(message) {
			if (this.options.listeners && this.options.listeners.debug) this.options.listeners.debug(message);
		}
		_getCommandString(options, noPrefix) {
			const toolPath = this._getSpawnFileName();
			const args = this._getSpawnArgs(options);
			let cmd = noPrefix ? "" : "[command]";
			if (IS_WINDOWS) if (this._isCmdFile()) {
				cmd += toolPath;
				for (const a of args) cmd += ` ${a}`;
			} else if (options.windowsVerbatimArguments) {
				cmd += `"${toolPath}"`;
				for (const a of args) cmd += ` ${a}`;
			} else {
				cmd += this._windowsQuoteCmdArg(toolPath);
				for (const a of args) cmd += ` ${this._windowsQuoteCmdArg(a)}`;
			}
			else {
				cmd += toolPath;
				for (const a of args) cmd += ` ${a}`;
			}
			return cmd;
		}
		_processLineBuffer(data, strBuffer, onLine) {
			try {
				let s$2 = strBuffer + data.toString();
				let n = s$2.indexOf(os$3.EOL);
				while (n > -1) {
					onLine(s$2.substring(0, n));
					s$2 = s$2.substring(n + os$3.EOL.length);
					n = s$2.indexOf(os$3.EOL);
				}
				return s$2;
			} catch (err) {
				this._debug(`error processing line. Failed with error ${err}`);
				return "";
			}
		}
		_getSpawnFileName() {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) return process.env["COMSPEC"] || "cmd.exe";
			}
			return this.toolPath;
		}
		_getSpawnArgs(options) {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) {
					let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
					for (const a of this.args) {
						argline += " ";
						argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
					}
					argline += "\"";
					return [argline];
				}
			}
			return this.args;
		}
		_endsWith(str, end) {
			return str.endsWith(end);
		}
		_isCmdFile() {
			const upperToolPath = this.toolPath.toUpperCase();
			return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
		}
		_windowsQuoteCmdArg(arg) {
			if (!this._isCmdFile()) return this._uvQuoteCmdArg(arg);
			if (!arg) return "\"\"";
			const cmdSpecialChars = [
				" ",
				"	",
				"&",
				"(",
				")",
				"[",
				"]",
				"{",
				"}",
				"^",
				"=",
				";",
				"!",
				"'",
				"+",
				",",
				"`",
				"~",
				"|",
				"<",
				">",
				"\""
			];
			let needsQuotes = false;
			for (const char of arg) if (cmdSpecialChars.some((x$1) => x$1 === char)) {
				needsQuotes = true;
				break;
			}
			if (!needsQuotes) return arg;
			let reverse = "\"";
			let quoteHit = true;
			for (let i$2 = arg.length; i$2 > 0; i$2--) {
				reverse += arg[i$2 - 1];
				if (quoteHit && arg[i$2 - 1] === "\\") reverse += "\\";
				else if (arg[i$2 - 1] === "\"") {
					quoteHit = true;
					reverse += "\"";
				} else quoteHit = false;
			}
			reverse += "\"";
			return reverse.split("").reverse().join("");
		}
		_uvQuoteCmdArg(arg) {
			if (!arg) return "\"\"";
			if (!arg.includes(" ") && !arg.includes("	") && !arg.includes("\"")) return arg;
			if (!arg.includes("\"") && !arg.includes("\\")) return `"${arg}"`;
			let reverse = "\"";
			let quoteHit = true;
			for (let i$2 = arg.length; i$2 > 0; i$2--) {
				reverse += arg[i$2 - 1];
				if (quoteHit && arg[i$2 - 1] === "\\") reverse += "\\";
				else if (arg[i$2 - 1] === "\"") {
					quoteHit = true;
					reverse += "\\";
				} else quoteHit = false;
			}
			reverse += "\"";
			return reverse.split("").reverse().join("");
		}
		_cloneExecOptions(options) {
			options = options || {};
			const result = {
				cwd: options.cwd || process.cwd(),
				env: options.env || process.env,
				silent: options.silent || false,
				windowsVerbatimArguments: options.windowsVerbatimArguments || false,
				failOnStdErr: options.failOnStdErr || false,
				ignoreReturnCode: options.ignoreReturnCode || false,
				delay: options.delay || 1e4
			};
			result.outStream = options.outStream || process.stdout;
			result.errStream = options.errStream || process.stderr;
			return result;
		}
		_getSpawnOptions(options, toolPath) {
			options = options || {};
			const result = {};
			result.cwd = options.cwd;
			result.env = options.env;
			result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
			if (options.windowsVerbatimArguments) result.argv0 = `"${toolPath}"`;
			return result;
		}
		/**
		* Exec a tool.
		* Output will be streamed to the live console.
		* Returns promise with return code
		*
		* @param     tool     path to tool to exec
		* @param     options  optional exec options.  See ExecOptions
		* @returns   number
		*/
		exec() {
			return __awaiter$4(this, void 0, void 0, function* () {
				if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) this.toolPath = path$5.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
				this.toolPath = yield io.which(this.toolPath, true);
				return new Promise((resolve, reject) => __awaiter$4(this, void 0, void 0, function* () {
					this._debug(`exec tool: ${this.toolPath}`);
					this._debug("arguments:");
					for (const arg of this.args) this._debug(`   ${arg}`);
					const optionsNonNull = this._cloneExecOptions(this.options);
					if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os$3.EOL);
					const state = new ExecState(optionsNonNull, this.toolPath);
					state.on("debug", (message) => {
						this._debug(message);
					});
					if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) return reject(/* @__PURE__ */ new Error(`The cwd: ${this.options.cwd} does not exist!`));
					const fileName = this._getSpawnFileName();
					const cp$1 = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
					let stdbuffer = "";
					if (cp$1.stdout) cp$1.stdout.on("data", (data) => {
						if (this.options.listeners && this.options.listeners.stdout) this.options.listeners.stdout(data);
						if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(data);
						stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.stdline) this.options.listeners.stdline(line);
						});
					});
					let errbuffer = "";
					if (cp$1.stderr) cp$1.stderr.on("data", (data) => {
						state.processStderr = true;
						if (this.options.listeners && this.options.listeners.stderr) this.options.listeners.stderr(data);
						if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) (optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream).write(data);
						errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.errline) this.options.listeners.errline(line);
						});
					});
					cp$1.on("error", (err) => {
						state.processError = err.message;
						state.processExited = true;
						state.processClosed = true;
						state.CheckComplete();
					});
					cp$1.on("exit", (code$1) => {
						state.processExitCode = code$1;
						state.processExited = true;
						this._debug(`Exit code ${code$1} received from tool '${this.toolPath}'`);
						state.CheckComplete();
					});
					cp$1.on("close", (code$1) => {
						state.processExitCode = code$1;
						state.processExited = true;
						state.processClosed = true;
						this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
						state.CheckComplete();
					});
					state.on("done", (error$1, exitCode) => {
						if (stdbuffer.length > 0) this.emit("stdline", stdbuffer);
						if (errbuffer.length > 0) this.emit("errline", errbuffer);
						cp$1.removeAllListeners();
						if (error$1) reject(error$1);
						else resolve(exitCode);
					});
					if (this.options.input) {
						if (!cp$1.stdin) throw new Error("child process missing stdin");
						cp$1.stdin.end(this.options.input);
					}
				}));
			});
		}
	};
	exports.ToolRunner = ToolRunner;
	/**
	* Convert an arg string to an array of args. Handles escaping
	*
	* @param    argString   string of arguments
	* @returns  string[]    array of arguments
	*/
	function argStringToArray(argString) {
		const args = [];
		let inQuotes = false;
		let escaped = false;
		let arg = "";
		function append(c) {
			if (escaped && c !== "\"") arg += "\\";
			arg += c;
			escaped = false;
		}
		for (let i$2 = 0; i$2 < argString.length; i$2++) {
			const c = argString.charAt(i$2);
			if (c === "\"") {
				if (!escaped) inQuotes = !inQuotes;
				else append(c);
				continue;
			}
			if (c === "\\" && escaped) {
				append(c);
				continue;
			}
			if (c === "\\" && inQuotes) {
				escaped = true;
				continue;
			}
			if (c === " " && !inQuotes) {
				if (arg.length > 0) {
					args.push(arg);
					arg = "";
				}
				continue;
			}
			append(c);
		}
		if (arg.length > 0) args.push(arg.trim());
		return args;
	}
	exports.argStringToArray = argStringToArray;
	var ExecState = class ExecState extends events.EventEmitter {
		constructor(options, toolPath) {
			super();
			this.processClosed = false;
			this.processError = "";
			this.processExitCode = 0;
			this.processExited = false;
			this.processStderr = false;
			this.delay = 1e4;
			this.done = false;
			this.timeout = null;
			if (!toolPath) throw new Error("toolPath must not be empty");
			this.options = options;
			this.toolPath = toolPath;
			if (options.delay) this.delay = options.delay;
		}
		CheckComplete() {
			if (this.done) return;
			if (this.processClosed) this._setResult();
			else if (this.processExited) this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
		}
		_debug(message) {
			this.emit("debug", message);
		}
		_setResult() {
			let error$1;
			if (this.processExited) {
				if (this.processError) error$1 = /* @__PURE__ */ new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
				else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) error$1 = /* @__PURE__ */ new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
				else if (this.processStderr && this.options.failOnStdErr) error$1 = /* @__PURE__ */ new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
			}
			if (this.timeout) {
				clearTimeout(this.timeout);
				this.timeout = null;
			}
			this.done = true;
			this.emit("done", error$1, this.processExitCode);
		}
		static HandleTimeout(state) {
			if (state.done) return;
			if (!state.processClosed && state.processExited) {
				const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
				state._debug(message);
			}
			state._setResult();
		}
	};
}));

//#endregion
//#region node_modules/@actions/exec/lib/exec.js
var require_exec = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$13 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		});
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$10 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$10 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$13(result, mod, k);
		}
		__setModuleDefault$10(result, mod);
		return result;
	};
	var __awaiter$3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getExecOutput = exports.exec = void 0;
	const string_decoder_1 = require("string_decoder");
	const tr = __importStar$10(require_toolrunner());
	/**
	* Exec a command.
	* Output will be streamed to the live console.
	* Returns promise with return code
	*
	* @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
	* @param     args               optional arguments for tool. Escaping is handled by the lib.
	* @param     options            optional exec options.  See ExecOptions
	* @returns   Promise<number>    exit code
	*/
	function exec$1(commandLine, args, options) {
		return __awaiter$3(this, void 0, void 0, function* () {
			const commandArgs = tr.argStringToArray(commandLine);
			if (commandArgs.length === 0) throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
			const toolPath = commandArgs[0];
			args = commandArgs.slice(1).concat(args || []);
			return new tr.ToolRunner(toolPath, args, options).exec();
		});
	}
	exports.exec = exec$1;
	/**
	* Exec a command and get the output.
	* Output will be streamed to the live console.
	* Returns promise with the exit code and collected stdout and stderr
	*
	* @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
	* @param     args                  optional arguments for tool. Escaping is handled by the lib.
	* @param     options               optional exec options.  See ExecOptions
	* @returns   Promise<ExecOutput>   exit code, stdout, and stderr
	*/
	function getExecOutput(commandLine, args, options) {
		var _a$2, _b;
		return __awaiter$3(this, void 0, void 0, function* () {
			let stdout = "";
			let stderr = "";
			const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
			const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
			const originalStdoutListener = (_a$2 = options === null || options === void 0 ? void 0 : options.listeners) === null || _a$2 === void 0 ? void 0 : _a$2.stdout;
			const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
			const stdErrListener = (data) => {
				stderr += stderrDecoder.write(data);
				if (originalStdErrListener) originalStdErrListener(data);
			};
			const stdOutListener = (data) => {
				stdout += stdoutDecoder.write(data);
				if (originalStdoutListener) originalStdoutListener(data);
			};
			const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), {
				stdout: stdOutListener,
				stderr: stdErrListener
			});
			const exitCode = yield exec$1(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
			stdout += stdoutDecoder.end();
			stderr += stderrDecoder.end();
			return {
				exitCode,
				stdout,
				stderr
			};
		});
	}
	exports.getExecOutput = getExecOutput;
}));

//#endregion
//#region node_modules/@actions/core/lib/platform.js
var require_platform = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$12 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$9 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$9 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$12(result, mod, k);
		}
		__setModuleDefault$9(result, mod);
		return result;
	};
	var __awaiter$2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __importDefault$4 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
	const os_1$2 = __importDefault$4(require("os"));
	const exec = __importStar$9(require_exec());
	const getWindowsInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		const { stdout: version } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Version\"", void 0, { silent: true });
		const { stdout: name } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Caption\"", void 0, { silent: true });
		return {
			name: name.trim(),
			version: version.trim()
		};
	});
	const getMacOsInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		var _a$2, _b, _c, _d;
		const { stdout } = yield exec.getExecOutput("sw_vers", void 0, { silent: true });
		const version = (_b = (_a$2 = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a$2 === void 0 ? void 0 : _a$2[1]) !== null && _b !== void 0 ? _b : "";
		return {
			name: (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "",
			version
		};
	});
	const getLinuxInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		const { stdout } = yield exec.getExecOutput("lsb_release", [
			"-i",
			"-r",
			"-s"
		], { silent: true });
		const [name, version] = stdout.trim().split("\n");
		return {
			name,
			version
		};
	});
	exports.platform = os_1$2.default.platform();
	exports.arch = os_1$2.default.arch();
	exports.isWindows = exports.platform === "win32";
	exports.isMacOS = exports.platform === "darwin";
	exports.isLinux = exports.platform === "linux";
	function getDetails() {
		return __awaiter$2(this, void 0, void 0, function* () {
			return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
				platform: exports.platform,
				arch: exports.arch,
				isWindows: exports.isWindows,
				isMacOS: exports.isMacOS,
				isLinux: exports.isLinux
			});
		});
	}
	exports.getDetails = getDetails;
}));

//#endregion
//#region node_modules/@actions/core/lib/core.js
var require_core = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$11 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$8 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$8 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$11(result, mod, k);
		}
		__setModuleDefault$8(result, mod);
		return result;
	};
	var __awaiter$1 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
	const command_1 = require_command();
	const file_command_1 = require_file_command();
	const utils_1$1 = require_utils$3();
	const os$2 = __importStar$8(require("os"));
	const path$4 = __importStar$8(require("path"));
	const oidc_utils_1 = require_oidc_utils();
	/**
	* The code to exit an action
	*/
	var ExitCode;
	(function(ExitCode$1) {
		/**
		* A code indicating that the action was successful
		*/
		ExitCode$1[ExitCode$1["Success"] = 0] = "Success";
		/**
		* A code indicating that the action was a failure
		*/
		ExitCode$1[ExitCode$1["Failure"] = 1] = "Failure";
	})(ExitCode || (exports.ExitCode = ExitCode = {}));
	/**
	* Sets env variable for this action and future actions in the job
	* @param name the name of the variable to set
	* @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
	*/
	function exportVariable(name, val) {
		const convertedVal = (0, utils_1$1.toCommandValue)(val);
		process.env[name] = convertedVal;
		if (process.env["GITHUB_ENV"] || "") return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
		(0, command_1.issueCommand)("set-env", { name }, convertedVal);
	}
	exports.exportVariable = exportVariable;
	/**
	* Registers a secret which will get masked from logs
	* @param secret value of the secret
	*/
	function setSecret(secret) {
		(0, command_1.issueCommand)("add-mask", {}, secret);
	}
	exports.setSecret = setSecret;
	/**
	* Prepends inputPath to the PATH (for this action and future actions)
	* @param inputPath
	*/
	function addPath(inputPath) {
		if (process.env["GITHUB_PATH"] || "") (0, file_command_1.issueFileCommand)("PATH", inputPath);
		else (0, command_1.issueCommand)("add-path", {}, inputPath);
		process.env["PATH"] = `${inputPath}${path$4.delimiter}${process.env["PATH"]}`;
	}
	exports.addPath = addPath;
	/**
	* Gets the value of an input.
	* Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
	* Returns an empty string if the value is not defined.
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   string
	*/
	function getInput(name, options) {
		const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
		if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);
		if (options && options.trimWhitespace === false) return val;
		return val.trim();
	}
	exports.getInput = getInput;
	/**
	* Gets the values of an multiline input.  Each value is also trimmed.
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   string[]
	*
	*/
	function getMultilineInput(name, options) {
		const inputs = getInput(name, options).split("\n").filter((x$1) => x$1 !== "");
		if (options && options.trimWhitespace === false) return inputs;
		return inputs.map((input) => input.trim());
	}
	exports.getMultilineInput = getMultilineInput;
	/**
	* Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
	* Support boolean input list: `true | True | TRUE | false | False | FALSE` .
	* The return value is also in boolean type.
	* ref: https://yaml.org/spec/1.2/spec.html#id2804923
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   boolean
	*/
	function getBooleanInput(name, options) {
		const trueValue = [
			"true",
			"True",
			"TRUE"
		];
		const falseValue = [
			"false",
			"False",
			"FALSE"
		];
		const val = getInput(name, options);
		if (trueValue.includes(val)) return true;
		if (falseValue.includes(val)) return false;
		throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\nSupport boolean input list: \`true | True | TRUE | false | False | FALSE\``);
	}
	exports.getBooleanInput = getBooleanInput;
	/**
	* Sets the value of an output.
	*
	* @param     name     name of the output to set
	* @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
	*/
	function setOutput(name, value) {
		if (process.env["GITHUB_OUTPUT"] || "") return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
		process.stdout.write(os$2.EOL);
		(0, command_1.issueCommand)("set-output", { name }, (0, utils_1$1.toCommandValue)(value));
	}
	exports.setOutput = setOutput;
	/**
	* Enables or disables the echoing of commands into stdout for the rest of the step.
	* Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
	*
	*/
	function setCommandEcho(enabled) {
		(0, command_1.issue)("echo", enabled ? "on" : "off");
	}
	exports.setCommandEcho = setCommandEcho;
	/**
	* Sets the action status to failed.
	* When the action exits it will be with an exit code of 1
	* @param message add error issue message
	*/
	function setFailed(message) {
		process.exitCode = ExitCode.Failure;
		error(message);
	}
	exports.setFailed = setFailed;
	/**
	* Gets whether Actions Step Debug is on or not
	*/
	function isDebug() {
		return process.env["RUNNER_DEBUG"] === "1";
	}
	exports.isDebug = isDebug;
	/**
	* Writes debug message to user log
	* @param message debug message
	*/
	function debug$2(message) {
		(0, command_1.issueCommand)("debug", {}, message);
	}
	exports.debug = debug$2;
	/**
	* Adds an error issue
	* @param message error issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function error(message, properties = {}) {
		(0, command_1.issueCommand)("error", (0, utils_1$1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.error = error;
	/**
	* Adds a warning issue
	* @param message warning issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function warning(message, properties = {}) {
		(0, command_1.issueCommand)("warning", (0, utils_1$1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.warning = warning;
	/**
	* Adds a notice issue
	* @param message notice issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function notice(message, properties = {}) {
		(0, command_1.issueCommand)("notice", (0, utils_1$1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.notice = notice;
	/**
	* Writes info to log with console.log.
	* @param message info message
	*/
	function info(message) {
		process.stdout.write(message + os$2.EOL);
	}
	exports.info = info;
	/**
	* Begin an output group.
	*
	* Output until the next `groupEnd` will be foldable in this group
	*
	* @param name The name of the output group
	*/
	function startGroup(name) {
		(0, command_1.issue)("group", name);
	}
	exports.startGroup = startGroup;
	/**
	* End an output group.
	*/
	function endGroup() {
		(0, command_1.issue)("endgroup");
	}
	exports.endGroup = endGroup;
	/**
	* Wrap an asynchronous function call in a group.
	*
	* Returns the same type as the function itself.
	*
	* @param name The name of the group
	* @param fn The function to wrap in the group
	*/
	function group(name, fn) {
		return __awaiter$1(this, void 0, void 0, function* () {
			startGroup(name);
			let result;
			try {
				result = yield fn();
			} finally {
				endGroup();
			}
			return result;
		});
	}
	exports.group = group;
	/**
	* Saves state for current action, the state can only be retrieved by this action's post job execution.
	*
	* @param     name     name of the state to store
	* @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
	*/
	function saveState(name, value) {
		if (process.env["GITHUB_STATE"] || "") return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
		(0, command_1.issueCommand)("save-state", { name }, (0, utils_1$1.toCommandValue)(value));
	}
	exports.saveState = saveState;
	/**
	* Gets the value of an state set by this action's main execution.
	*
	* @param     name     name of the state to get
	* @returns   string
	*/
	function getState(name) {
		return process.env[`STATE_${name}`] || "";
	}
	exports.getState = getState;
	function getIDToken(aud) {
		return __awaiter$1(this, void 0, void 0, function* () {
			return yield oidc_utils_1.OidcClient.getIDToken(aud);
		});
	}
	exports.getIDToken = getIDToken;
	/**
	* Summary exports
	*/
	var summary_1 = require_summary();
	Object.defineProperty(exports, "summary", {
		enumerable: true,
		get: function() {
			return summary_1.summary;
		}
	});
	/**
	* @deprecated use core.summary
	*/
	var summary_2 = require_summary();
	Object.defineProperty(exports, "markdownSummary", {
		enumerable: true,
		get: function() {
			return summary_2.markdownSummary;
		}
	});
	/**
	* Path exports
	*/
	var path_utils_1 = require_path_utils();
	Object.defineProperty(exports, "toPosixPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPosixPath;
		}
	});
	Object.defineProperty(exports, "toWin32Path", {
		enumerable: true,
		get: function() {
			return path_utils_1.toWin32Path;
		}
	});
	Object.defineProperty(exports, "toPlatformPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPlatformPath;
		}
	});
	/**
	* Platform utilities exports
	*/
	exports.platform = __importStar$8(require_platform());
}));

//#endregion
//#region node_modules/@actions/github/lib/context.js
var require_context = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Context = void 0;
	const fs_1$1 = require("fs");
	const os_1$1 = require("os");
	var Context$2 = class {
		/**
		* Hydrate the context from the environment
		*/
		constructor() {
			var _a$2, _b, _c;
			this.payload = {};
			if (process.env.GITHUB_EVENT_PATH) if ((0, fs_1$1.existsSync)(process.env.GITHUB_EVENT_PATH)) this.payload = JSON.parse((0, fs_1$1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
			else {
				const path$9 = process.env.GITHUB_EVENT_PATH;
				process.stdout.write(`GITHUB_EVENT_PATH ${path$9} does not exist${os_1$1.EOL}`);
			}
			this.eventName = process.env.GITHUB_EVENT_NAME;
			this.sha = process.env.GITHUB_SHA;
			this.ref = process.env.GITHUB_REF;
			this.workflow = process.env.GITHUB_WORKFLOW;
			this.action = process.env.GITHUB_ACTION;
			this.actor = process.env.GITHUB_ACTOR;
			this.job = process.env.GITHUB_JOB;
			this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10);
			this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
			this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
			this.apiUrl = (_a$2 = process.env.GITHUB_API_URL) !== null && _a$2 !== void 0 ? _a$2 : `https://api.github.com`;
			this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
			this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
		}
		get issue() {
			const payload = this.payload;
			return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
		}
		get repo() {
			if (process.env.GITHUB_REPOSITORY) {
				const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
				return {
					owner,
					repo
				};
			}
			if (this.payload.repository) return {
				owner: this.payload.repository.owner.login,
				repo: this.payload.repository.name
			};
			throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
		}
	};
	exports.Context = Context$2;
}));

//#endregion
//#region node_modules/@actions/github/lib/internal/utils.js
var require_utils$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$10 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$7 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$7 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$10(result, mod, k);
		}
		__setModuleDefault$7(result, mod);
		return result;
	};
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$1) {
					reject(e$1);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getApiBaseUrl = exports.getProxyFetch = exports.getProxyAgentDispatcher = exports.getProxyAgent = exports.getAuthString = void 0;
	const httpClient = __importStar$7(require_lib());
	const undici_1 = require_undici();
	function getAuthString(token, options) {
		if (!token && !options.auth) throw new Error("Parameter token or opts.auth is required");
		else if (token && options.auth) throw new Error("Parameters token and opts.auth may not both be specified");
		return typeof options.auth === "string" ? options.auth : `token ${token}`;
	}
	exports.getAuthString = getAuthString;
	function getProxyAgent(destinationUrl) {
		return new httpClient.HttpClient().getAgent(destinationUrl);
	}
	exports.getProxyAgent = getProxyAgent;
	function getProxyAgentDispatcher(destinationUrl) {
		return new httpClient.HttpClient().getAgentDispatcher(destinationUrl);
	}
	exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
	function getProxyFetch(destinationUrl) {
		const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
		const proxyFetch = (url, opts) => __awaiter(this, void 0, void 0, function* () {
			return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
		});
		return proxyFetch;
	}
	exports.getProxyFetch = getProxyFetch;
	function getApiBaseUrl() {
		return process.env["GITHUB_API_URL"] || "https://api.github.com";
	}
	exports.getApiBaseUrl = getApiBaseUrl;
}));

//#endregion
//#region node_modules/universal-user-agent/dist-node/index.js
var require_dist_node$9 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function getUserAgent() {
		if (typeof navigator === "object" && "userAgent" in navigator) return navigator.userAgent;
		if (typeof process === "object" && process.version !== void 0) return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
		return "<environment undetectable>";
	}
	exports.getUserAgent = getUserAgent;
}));

//#endregion
//#region node_modules/before-after-hook/lib/register.js
var require_register = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = register$1;
	function register$1(state, name, method, options) {
		if (typeof method !== "function") throw new Error("method for before hook must be a function");
		if (!options) options = {};
		if (Array.isArray(name)) return name.reverse().reduce(function(callback, name$1) {
			return register$1.bind(null, state, name$1, callback, options);
		}, method)();
		return Promise.resolve().then(function() {
			if (!state.registry[name]) return method(options);
			return state.registry[name].reduce(function(method$1, registered) {
				return registered.hook.bind(null, method$1, options);
			}, method)();
		});
	}
}));

//#endregion
//#region node_modules/before-after-hook/lib/add.js
var require_add = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = addHook$1;
	function addHook$1(state, kind, name, hook$1) {
		var orig = hook$1;
		if (!state.registry[name]) state.registry[name] = [];
		if (kind === "before") hook$1 = function(method, options) {
			return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
		};
		if (kind === "after") hook$1 = function(method, options) {
			var result;
			return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
				result = result_;
				return orig(result, options);
			}).then(function() {
				return result;
			});
		};
		if (kind === "error") hook$1 = function(method, options) {
			return Promise.resolve().then(method.bind(null, options)).catch(function(error$1) {
				return orig(error$1, options);
			});
		};
		state.registry[name].push({
			hook: hook$1,
			orig
		});
	}
}));

//#endregion
//#region node_modules/before-after-hook/lib/remove.js
var require_remove = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = removeHook$1;
	function removeHook$1(state, name, method) {
		if (!state.registry[name]) return;
		var index = state.registry[name].map(function(registered) {
			return registered.orig;
		}).indexOf(method);
		if (index === -1) return;
		state.registry[name].splice(index, 1);
	}
}));

//#endregion
//#region node_modules/before-after-hook/index.js
var require_before_after_hook = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var register = require_register();
	var addHook = require_add();
	var removeHook = require_remove();
	var bind = Function.bind;
	var bindable = bind.bind(bind);
	function bindApi(hook$1, state, name) {
		var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
		hook$1.api = { remove: removeHookRef };
		hook$1.remove = removeHookRef;
		[
			"before",
			"error",
			"after",
			"wrap"
		].forEach(function(kind) {
			var args = name ? [
				state,
				kind,
				name
			] : [state, kind];
			hook$1[kind] = hook$1.api[kind] = bindable(addHook, null).apply(null, args);
		});
	}
	function HookSingular() {
		var singularHookName = "h";
		var singularHookState = { registry: {} };
		var singularHook = register.bind(null, singularHookState, singularHookName);
		bindApi(singularHook, singularHookState, singularHookName);
		return singularHook;
	}
	function HookCollection() {
		var state = { registry: {} };
		var hook$1 = register.bind(null, state);
		bindApi(hook$1, state);
		return hook$1;
	}
	var collectionHookDeprecationMessageDisplayed = false;
	function Hook() {
		if (!collectionHookDeprecationMessageDisplayed) {
			console.warn("[before-after-hook]: \"Hook()\" repurposing warning, use \"Hook.Collection()\". Read more: https://git.io/upgrade-before-after-hook-to-1.4");
			collectionHookDeprecationMessageDisplayed = true;
		}
		return HookCollection();
	}
	Hook.Singular = HookSingular.bind();
	Hook.Collection = HookCollection.bind();
	module.exports = Hook;
	module.exports.Hook = Hook;
	module.exports.Singular = Hook.Singular;
	module.exports.Collection = Hook.Collection;
}));

//#endregion
//#region node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node$8 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var __defProp$7 = Object.defineProperty;
	var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$7 = Object.getOwnPropertyNames;
	var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
	var __export$7 = (target, all) => {
		for (var name in all) __defProp$7(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$7 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$7(from)) if (!__hasOwnProp$7.call(to, key) && key !== except) __defProp$7(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$7(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$7 = (mod) => __copyProps$7(__defProp$7({}, "__esModule", { value: true }), mod);
	var dist_src_exports$5 = {};
	__export$7(dist_src_exports$5, { endpoint: () => endpoint });
	module.exports = __toCommonJS$7(dist_src_exports$5);
	var userAgent = `octokit-endpoint.js/9.0.6 ${(0, require_dist_node$9().getUserAgent)()}`;
	var DEFAULTS = {
		method: "GET",
		baseUrl: "https://api.github.com",
		headers: {
			accept: "application/vnd.github.v3+json",
			"user-agent": userAgent
		},
		mediaType: { format: "" }
	};
	function lowercaseKeys(object) {
		if (!object) return {};
		return Object.keys(object).reduce((newObj, key) => {
			newObj[key.toLowerCase()] = object[key];
			return newObj;
		}, {});
	}
	function isPlainObject$2(value) {
		if (typeof value !== "object" || value === null) return false;
		if (Object.prototype.toString.call(value) !== "[object Object]") return false;
		const proto = Object.getPrototypeOf(value);
		if (proto === null) return true;
		const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
	}
	function mergeDeep(defaults, options) {
		const result = Object.assign({}, defaults);
		Object.keys(options).forEach((key) => {
			if (isPlainObject$2(options[key])) if (!(key in defaults)) Object.assign(result, { [key]: options[key] });
			else result[key] = mergeDeep(defaults[key], options[key]);
			else Object.assign(result, { [key]: options[key] });
		});
		return result;
	}
	function removeUndefinedProperties(obj) {
		for (const key in obj) if (obj[key] === void 0) delete obj[key];
		return obj;
	}
	function merge(defaults, route, options) {
		if (typeof route === "string") {
			let [method, url] = route.split(" ");
			options = Object.assign(url ? {
				method,
				url
			} : { url: method }, options);
		} else options = Object.assign({}, route);
		options.headers = lowercaseKeys(options.headers);
		removeUndefinedProperties(options);
		removeUndefinedProperties(options.headers);
		const mergedOptions = mergeDeep(defaults || {}, options);
		if (options.url === "/graphql") {
			if (defaults && defaults.mediaType.previews?.length) mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
			mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
		}
		return mergedOptions;
	}
	function addQueryParameters(url, parameters) {
		const separator = /\?/.test(url) ? "&" : "?";
		const names = Object.keys(parameters);
		if (names.length === 0) return url;
		return url + separator + names.map((name) => {
			if (name === "q") return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
			return `${name}=${encodeURIComponent(parameters[name])}`;
		}).join("&");
	}
	var urlVariableRegex = /\{[^{}}]+\}/g;
	function removeNonChars(variableName) {
		return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
	}
	function extractUrlVariableNames(url) {
		const matches = url.match(urlVariableRegex);
		if (!matches) return [];
		return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
	}
	function omit$1(object, keysToOmit) {
		const result = { __proto__: null };
		for (const key of Object.keys(object)) if (keysToOmit.indexOf(key) === -1) result[key] = object[key];
		return result;
	}
	function encodeReserved(str) {
		return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
			if (!/%[0-9A-Fa-f]/.test(part)) part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
			return part;
		}).join("");
	}
	function encodeUnreserved(str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
			return "%" + c.charCodeAt(0).toString(16).toUpperCase();
		});
	}
	function encodeValue(operator, value, key) {
		value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
		if (key) return encodeUnreserved(key) + "=" + value;
		else return value;
	}
	function isDefined(value) {
		return value !== void 0 && value !== null;
	}
	function isKeyOperator(operator) {
		return operator === ";" || operator === "&" || operator === "?";
	}
	function getValues(context, operator, key, modifier) {
		var value = context[key], result = [];
		if (isDefined(value) && value !== "") if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
			value = value.toString();
			if (modifier && modifier !== "*") value = value.substring(0, parseInt(modifier, 10));
			result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
		} else if (modifier === "*") if (Array.isArray(value)) value.filter(isDefined).forEach(function(value2) {
			result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
		});
		else Object.keys(value).forEach(function(k) {
			if (isDefined(value[k])) result.push(encodeValue(operator, value[k], k));
		});
		else {
			const tmp = [];
			if (Array.isArray(value)) value.filter(isDefined).forEach(function(value2) {
				tmp.push(encodeValue(operator, value2));
			});
			else Object.keys(value).forEach(function(k) {
				if (isDefined(value[k])) {
					tmp.push(encodeUnreserved(k));
					tmp.push(encodeValue(operator, value[k].toString()));
				}
			});
			if (isKeyOperator(operator)) result.push(encodeUnreserved(key) + "=" + tmp.join(","));
			else if (tmp.length !== 0) result.push(tmp.join(","));
		}
		else if (operator === ";") {
			if (isDefined(value)) result.push(encodeUnreserved(key));
		} else if (value === "" && (operator === "&" || operator === "?")) result.push(encodeUnreserved(key) + "=");
		else if (value === "") result.push("");
		return result;
	}
	function parseUrl(template) {
		return { expand: expand.bind(null, template) };
	}
	function expand(template, context) {
		var operators = [
			"+",
			"#",
			".",
			"/",
			";",
			"?",
			"&"
		];
		template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
			if (expression) {
				let operator = "";
				const values = [];
				if (operators.indexOf(expression.charAt(0)) !== -1) {
					operator = expression.charAt(0);
					expression = expression.substr(1);
				}
				expression.split(/,/g).forEach(function(variable) {
					var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
					values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
				});
				if (operator && operator !== "+") {
					var separator = ",";
					if (operator === "?") separator = "&";
					else if (operator !== "#") separator = operator;
					return (values.length !== 0 ? operator : "") + values.join(separator);
				} else return values.join(",");
			} else return encodeReserved(literal);
		});
		if (template === "/") return template;
		else return template.replace(/\/$/, "");
	}
	function parse$4(options) {
		let method = options.method.toUpperCase();
		let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
		let headers = Object.assign({}, options.headers);
		let body;
		let parameters = omit$1(options, [
			"method",
			"baseUrl",
			"url",
			"headers",
			"request",
			"mediaType"
		]);
		const urlVariableNames = extractUrlVariableNames(url);
		url = parseUrl(url).expand(parameters);
		if (!/^http/.test(url)) url = options.baseUrl + url;
		const remainingParameters = omit$1(parameters, Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl"));
		if (!/application\/octet-stream/i.test(headers.accept)) {
			if (options.mediaType.format) headers.accept = headers.accept.split(/,/).map((format$2) => format$2.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
			if (url.endsWith("/graphql")) {
				if (options.mediaType.previews?.length) headers.accept = (headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || []).concat(options.mediaType.previews).map((preview) => {
					return `application/vnd.github.${preview}-preview${options.mediaType.format ? `.${options.mediaType.format}` : "+json"}`;
				}).join(",");
			}
		}
		if (["GET", "HEAD"].includes(method)) url = addQueryParameters(url, remainingParameters);
		else if ("data" in remainingParameters) body = remainingParameters.data;
		else if (Object.keys(remainingParameters).length) body = remainingParameters;
		if (!headers["content-type"] && typeof body !== "undefined") headers["content-type"] = "application/json; charset=utf-8";
		if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") body = "";
		return Object.assign({
			method,
			url,
			headers
		}, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
	}
	function endpointWithDefaults(defaults, route, options) {
		return parse$4(merge(defaults, route, options));
	}
	function withDefaults$2(oldDefaults, newDefaults) {
		const DEFAULTS2 = merge(oldDefaults, newDefaults);
		const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
		return Object.assign(endpoint2, {
			DEFAULTS: DEFAULTS2,
			defaults: withDefaults$2.bind(null, DEFAULTS2),
			merge: merge.bind(null, DEFAULTS2),
			parse: parse$4
		});
	}
	var endpoint = withDefaults$2(null, DEFAULTS);
}));

//#endregion
//#region node_modules/deprecation/dist-node/index.js
var require_dist_node$7 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Deprecation = class extends Error {
		constructor(message) {
			super(message);
			/* istanbul ignore next */
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
			this.name = "Deprecation";
		}
	};
	exports.Deprecation = Deprecation;
}));

//#endregion
//#region node_modules/wrappy/wrappy.js
var require_wrappy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = wrappy$1;
	function wrappy$1(fn, cb) {
		if (fn && cb) return wrappy$1(fn)(cb);
		if (typeof fn !== "function") throw new TypeError("need wrapper function");
		Object.keys(fn).forEach(function(k) {
			wrapper[k] = fn[k];
		});
		return wrapper;
		function wrapper() {
			var args = new Array(arguments.length);
			for (var i$2 = 0; i$2 < args.length; i$2++) args[i$2] = arguments[i$2];
			var ret = fn.apply(this, args);
			var cb$1 = args[args.length - 1];
			if (typeof ret === "function" && ret !== cb$1) Object.keys(cb$1).forEach(function(k) {
				ret[k] = cb$1[k];
			});
			return ret;
		}
	}
}));

//#endregion
//#region node_modules/once/once.js
var require_once = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var wrappy = require_wrappy();
	module.exports = wrappy(once);
	module.exports.strict = wrappy(onceStrict);
	once.proto = once(function() {
		Object.defineProperty(Function.prototype, "once", {
			value: function() {
				return once(this);
			},
			configurable: true
		});
		Object.defineProperty(Function.prototype, "onceStrict", {
			value: function() {
				return onceStrict(this);
			},
			configurable: true
		});
	});
	function once(fn) {
		var f$2 = function() {
			if (f$2.called) return f$2.value;
			f$2.called = true;
			return f$2.value = fn.apply(this, arguments);
		};
		f$2.called = false;
		return f$2;
	}
	function onceStrict(fn) {
		var f$2 = function() {
			if (f$2.called) throw new Error(f$2.onceError);
			f$2.called = true;
			return f$2.value = fn.apply(this, arguments);
		};
		f$2.onceError = (fn.name || "Function wrapped with `once`") + " shouldn't be called more than once";
		f$2.called = false;
		return f$2;
	}
}));

//#endregion
//#region node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node$6 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var __create = Object.create;
	var __defProp$6 = Object.defineProperty;
	var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$6 = Object.getOwnPropertyNames;
	var __getProtoOf = Object.getPrototypeOf;
	var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
	var __export$6 = (target, all) => {
		for (var name in all) __defProp$6(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$6 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$6(from)) if (!__hasOwnProp$6.call(to, key) && key !== except) __defProp$6(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$6(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps$6(isNodeMode || !mod || !mod.__esModule ? __defProp$6(target, "default", {
		value: mod,
		enumerable: true
	}) : target, mod));
	var __toCommonJS$6 = (mod) => __copyProps$6(__defProp$6({}, "__esModule", { value: true }), mod);
	var dist_src_exports$4 = {};
	__export$6(dist_src_exports$4, { RequestError: () => RequestError });
	module.exports = __toCommonJS$6(dist_src_exports$4);
	var import_deprecation = require_dist_node$7();
	var import_once = __toESM(require_once());
	var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
	var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
	var RequestError = class extends Error {
		constructor(message, statusCode, options) {
			super(message);
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
			this.name = "HttpError";
			this.status = statusCode;
			let headers;
			if ("headers" in options && typeof options.headers !== "undefined") headers = options.headers;
			if ("response" in options) {
				this.response = options.response;
				headers = options.response.headers;
			}
			const requestCopy = Object.assign({}, options.request);
			if (options.request.headers.authorization) requestCopy.headers = Object.assign({}, options.request.headers, { authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]") });
			requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
			this.request = requestCopy;
			Object.defineProperty(this, "code", { get() {
				logOnceCode(new import_deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
				return statusCode;
			} });
			Object.defineProperty(this, "headers", { get() {
				logOnceHeaders(new import_deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
				return headers || {};
			} });
		}
	};
}));

//#endregion
//#region node_modules/@octokit/request/dist-node/index.js
var require_dist_node$5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var __defProp$5 = Object.defineProperty;
	var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$5 = Object.getOwnPropertyNames;
	var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
	var __export$5 = (target, all) => {
		for (var name in all) __defProp$5(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$5 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$5(from)) if (!__hasOwnProp$5.call(to, key) && key !== except) __defProp$5(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$5(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$5 = (mod) => __copyProps$5(__defProp$5({}, "__esModule", { value: true }), mod);
	var dist_src_exports$3 = {};
	__export$5(dist_src_exports$3, { request: () => request$1 });
	module.exports = __toCommonJS$5(dist_src_exports$3);
	var import_endpoint = require_dist_node$8();
	var import_universal_user_agent$2 = require_dist_node$9();
	var VERSION$4 = "8.4.1";
	function isPlainObject$1(value) {
		if (typeof value !== "object" || value === null) return false;
		if (Object.prototype.toString.call(value) !== "[object Object]") return false;
		const proto = Object.getPrototypeOf(value);
		if (proto === null) return true;
		const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
	}
	var import_request_error = require_dist_node$6();
	function getBufferResponse(response) {
		return response.arrayBuffer();
	}
	function fetchWrapper(requestOptions) {
		var _a$2, _b, _c, _d;
		const log$3 = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
		const parseSuccessResponseBody = ((_a$2 = requestOptions.request) == null ? void 0 : _a$2.parseSuccessResponseBody) !== false;
		if (isPlainObject$1(requestOptions.body) || Array.isArray(requestOptions.body)) requestOptions.body = JSON.stringify(requestOptions.body);
		let headers = {};
		let status;
		let url;
		let { fetch: fetch$3 } = globalThis;
		if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) fetch$3 = requestOptions.request.fetch;
		if (!fetch$3) throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
		return fetch$3(requestOptions.url, {
			method: requestOptions.method,
			body: requestOptions.body,
			redirect: (_c = requestOptions.request) == null ? void 0 : _c.redirect,
			headers: requestOptions.headers,
			signal: (_d = requestOptions.request) == null ? void 0 : _d.signal,
			...requestOptions.body && { duplex: "half" }
		}).then(async (response) => {
			url = response.url;
			status = response.status;
			for (const keyAndValue of response.headers) headers[keyAndValue[0]] = keyAndValue[1];
			if ("deprecation" in headers) {
				const matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/);
				const deprecationLink = matches && matches.pop();
				log$3.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
			}
			if (status === 204 || status === 205) return;
			if (requestOptions.method === "HEAD") {
				if (status < 400) return;
				throw new import_request_error.RequestError(response.statusText, status, {
					response: {
						url,
						status,
						headers,
						data: void 0
					},
					request: requestOptions
				});
			}
			if (status === 304) throw new import_request_error.RequestError("Not modified", status, {
				response: {
					url,
					status,
					headers,
					data: await getResponseData(response)
				},
				request: requestOptions
			});
			if (status >= 400) {
				const data = await getResponseData(response);
				throw new import_request_error.RequestError(toErrorMessage(data), status, {
					response: {
						url,
						status,
						headers,
						data
					},
					request: requestOptions
				});
			}
			return parseSuccessResponseBody ? await getResponseData(response) : response.body;
		}).then((data) => {
			return {
				status,
				url,
				headers,
				data
			};
		}).catch((error$1) => {
			if (error$1 instanceof import_request_error.RequestError) throw error$1;
			else if (error$1.name === "AbortError") throw error$1;
			let message = error$1.message;
			if (error$1.name === "TypeError" && "cause" in error$1) {
				if (error$1.cause instanceof Error) message = error$1.cause.message;
				else if (typeof error$1.cause === "string") message = error$1.cause;
			}
			throw new import_request_error.RequestError(message, 500, { request: requestOptions });
		});
	}
	async function getResponseData(response) {
		const contentType = response.headers.get("content-type");
		if (/application\/json/.test(contentType)) return response.json().catch(() => response.text()).catch(() => "");
		if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) return response.text();
		return getBufferResponse(response);
	}
	function toErrorMessage(data) {
		if (typeof data === "string") return data;
		let suffix;
		if ("documentation_url" in data) suffix = ` - ${data.documentation_url}`;
		else suffix = "";
		if ("message" in data) {
			if (Array.isArray(data.errors)) return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
			return `${data.message}${suffix}`;
		}
		return `Unknown error: ${JSON.stringify(data)}`;
	}
	function withDefaults$1(oldEndpoint, newDefaults) {
		const endpoint2 = oldEndpoint.defaults(newDefaults);
		const newApi = function(route, parameters) {
			const endpointOptions = endpoint2.merge(route, parameters);
			if (!endpointOptions.request || !endpointOptions.request.hook) return fetchWrapper(endpoint2.parse(endpointOptions));
			const request2 = (route2, parameters2) => {
				return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
			};
			Object.assign(request2, {
				endpoint: endpoint2,
				defaults: withDefaults$1.bind(null, endpoint2)
			});
			return endpointOptions.request.hook(request2, endpointOptions);
		};
		return Object.assign(newApi, {
			endpoint: endpoint2,
			defaults: withDefaults$1.bind(null, endpoint2)
		});
	}
	var request$1 = withDefaults$1(import_endpoint.endpoint, { headers: { "user-agent": `octokit-request.js/${VERSION$4} ${(0, import_universal_user_agent$2.getUserAgent)()}` } });
}));

//#endregion
//#region node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var __defProp$4 = Object.defineProperty;
	var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$4 = Object.getOwnPropertyNames;
	var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
	var __export$4 = (target, all) => {
		for (var name in all) __defProp$4(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$4 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$4(from)) if (!__hasOwnProp$4.call(to, key) && key !== except) __defProp$4(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$4(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$4 = (mod) => __copyProps$4(__defProp$4({}, "__esModule", { value: true }), mod);
	var index_exports$1 = {};
	__export$4(index_exports$1, {
		GraphqlResponseError: () => GraphqlResponseError,
		graphql: () => graphql2,
		withCustomRequest: () => withCustomRequest
	});
	module.exports = __toCommonJS$4(index_exports$1);
	var import_request3 = require_dist_node$5();
	var import_universal_user_agent$1 = require_dist_node$9();
	var VERSION$3 = "7.1.1";
	require_dist_node$5();
	require_dist_node$5();
	function _buildMessageForResponseErrors(data) {
		return `Request failed due to following response errors:
` + data.errors.map((e$1) => ` - ${e$1.message}`).join("\n");
	}
	var GraphqlResponseError = class extends Error {
		constructor(request2, headers, response) {
			super(_buildMessageForResponseErrors(response));
			this.request = request2;
			this.headers = headers;
			this.response = response;
			this.name = "GraphqlResponseError";
			this.errors = response.errors;
			this.data = response.data;
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
		}
	};
	var NON_VARIABLE_OPTIONS = [
		"method",
		"baseUrl",
		"url",
		"headers",
		"request",
		"query",
		"mediaType"
	];
	var FORBIDDEN_VARIABLE_OPTIONS = [
		"query",
		"method",
		"url"
	];
	var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
	function graphql(request2, query, options) {
		if (options) {
			if (typeof query === "string" && "query" in options) return Promise.reject(/* @__PURE__ */ new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
			for (const key in options) {
				if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
				return Promise.reject(/* @__PURE__ */ new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
			}
		}
		const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
		const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
			if (NON_VARIABLE_OPTIONS.includes(key)) {
				result[key] = parsedOptions[key];
				return result;
			}
			if (!result.variables) result.variables = {};
			result.variables[key] = parsedOptions[key];
			return result;
		}, {});
		const baseUrl$1 = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
		if (GHES_V3_SUFFIX_REGEX.test(baseUrl$1)) requestOptions.url = baseUrl$1.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
		return request2(requestOptions).then((response) => {
			if (response.data.errors) {
				const headers = {};
				for (const key of Object.keys(response.headers)) headers[key] = response.headers[key];
				throw new GraphqlResponseError(requestOptions, headers, response.data);
			}
			return response.data.data;
		});
	}
	function withDefaults(request2, newDefaults) {
		const newRequest = request2.defaults(newDefaults);
		const newApi = (query, options) => {
			return graphql(newRequest, query, options);
		};
		return Object.assign(newApi, {
			defaults: withDefaults.bind(null, newRequest),
			endpoint: newRequest.endpoint
		});
	}
	var graphql2 = withDefaults(import_request3.request, {
		headers: { "user-agent": `octokit-graphql.js/${VERSION$3} ${(0, import_universal_user_agent$1.getUserAgent)()}` },
		method: "POST",
		url: "/graphql"
	});
	function withCustomRequest(customRequest) {
		return withDefaults(customRequest, {
			method: "POST",
			url: "/graphql"
		});
	}
}));

//#endregion
//#region node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var __defProp$3 = Object.defineProperty;
	var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$3 = Object.getOwnPropertyNames;
	var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
	var __export$3 = (target, all) => {
		for (var name in all) __defProp$3(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$3 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$3(from)) if (!__hasOwnProp$3.call(to, key) && key !== except) __defProp$3(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$3(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$3 = (mod) => __copyProps$3(__defProp$3({}, "__esModule", { value: true }), mod);
	var dist_src_exports$2 = {};
	__export$3(dist_src_exports$2, { createTokenAuth: () => createTokenAuth });
	module.exports = __toCommonJS$3(dist_src_exports$2);
	var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
	var REGEX_IS_INSTALLATION = /^ghs_/;
	var REGEX_IS_USER_TO_SERVER = /^ghu_/;
	async function auth$1(token) {
		const isApp = token.split(/\./).length === 3;
		const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
		const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
		return {
			type: "token",
			token,
			tokenType: isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth"
		};
	}
	function withAuthorizationPrefix(token) {
		if (token.split(/\./).length === 3) return `bearer ${token}`;
		return `token ${token}`;
	}
	async function hook(token, request$3, route, parameters) {
		const endpoint$1 = request$3.endpoint.merge(route, parameters);
		endpoint$1.headers.authorization = withAuthorizationPrefix(token);
		return request$3(endpoint$1);
	}
	var createTokenAuth = function createTokenAuth2(token) {
		if (!token) throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
		if (typeof token !== "string") throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
		token = token.replace(/^(token|bearer) +/i, "");
		return Object.assign(auth$1.bind(null, token), { hook: hook.bind(null, token) });
	};
}));

//#endregion
//#region node_modules/@octokit/core/dist-node/index.js
var require_dist_node$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var __defProp$2 = Object.defineProperty;
	var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$2 = Object.getOwnPropertyNames;
	var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
	var __export$2 = (target, all) => {
		for (var name in all) __defProp$2(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$2 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$2(from)) if (!__hasOwnProp$2.call(to, key) && key !== except) __defProp$2(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$2 = (mod) => __copyProps$2(__defProp$2({}, "__esModule", { value: true }), mod);
	var index_exports = {};
	__export$2(index_exports, { Octokit: () => Octokit });
	module.exports = __toCommonJS$2(index_exports);
	var import_universal_user_agent = require_dist_node$9();
	var import_before_after_hook = require_before_after_hook();
	var import_request = require_dist_node$5();
	var import_graphql = require_dist_node$4();
	var import_auth_token = require_dist_node$3();
	var VERSION$2 = "5.2.2";
	var noop$1 = () => {};
	var consoleWarn = console.warn.bind(console);
	var consoleError = console.error.bind(console);
	function createLogger(logger$1 = {}) {
		if (typeof logger$1.debug !== "function") logger$1.debug = noop$1;
		if (typeof logger$1.info !== "function") logger$1.info = noop$1;
		if (typeof logger$1.warn !== "function") logger$1.warn = consoleWarn;
		if (typeof logger$1.error !== "function") logger$1.error = consoleError;
		return logger$1;
	}
	var userAgentTrail = `octokit-core.js/${VERSION$2} ${(0, import_universal_user_agent.getUserAgent)()}`;
	var Octokit = class {
		static {
			this.VERSION = VERSION$2;
		}
		static defaults(defaults) {
			const OctokitWithDefaults = class extends this {
				constructor(...args) {
					const options = args[0] || {};
					if (typeof defaults === "function") {
						super(defaults(options));
						return;
					}
					super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? { userAgent: `${options.userAgent} ${defaults.userAgent}` } : null));
				}
			};
			return OctokitWithDefaults;
		}
		static {
			this.plugins = [];
		}
		/**
		* Attach a plugin (or many) to your Octokit instance.
		*
		* @example
		* const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
		*/
		static plugin(...newPlugins) {
			const currentPlugins = this.plugins;
			const NewOctokit = class extends this {
				static {
					this.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
				}
			};
			return NewOctokit;
		}
		constructor(options = {}) {
			const hook$1 = new import_before_after_hook.Collection();
			const requestDefaults = {
				baseUrl: import_request.request.endpoint.DEFAULTS.baseUrl,
				headers: {},
				request: Object.assign({}, options.request, { hook: hook$1.bind(null, "request") }),
				mediaType: {
					previews: [],
					format: ""
				}
			};
			requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
			if (options.baseUrl) requestDefaults.baseUrl = options.baseUrl;
			if (options.previews) requestDefaults.mediaType.previews = options.previews;
			if (options.timeZone) requestDefaults.headers["time-zone"] = options.timeZone;
			this.request = import_request.request.defaults(requestDefaults);
			this.graphql = (0, import_graphql.withCustomRequest)(this.request).defaults(requestDefaults);
			this.log = createLogger(options.log);
			this.hook = hook$1;
			if (!options.authStrategy) if (!options.auth) this.auth = async () => ({ type: "unauthenticated" });
			else {
				const auth$2 = (0, import_auth_token.createTokenAuth)(options.auth);
				hook$1.wrap("request", auth$2.hook);
				this.auth = auth$2;
			}
			else {
				const { authStrategy, ...otherOptions } = options;
				const auth$2 = authStrategy(Object.assign({
					request: this.request,
					log: this.log,
					octokit: this,
					octokitOptions: otherOptions
				}, options.auth));
				hook$1.wrap("request", auth$2.hook);
				this.auth = auth$2;
			}
			const classConstructor = this.constructor;
			for (let i$2 = 0; i$2 < classConstructor.plugins.length; ++i$2) Object.assign(this, classConstructor.plugins[i$2](this, options));
		}
	};
}));

//#endregion
//#region node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var __defProp$1 = Object.defineProperty;
	var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$1 = Object.getOwnPropertyNames;
	var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
	var __export$1 = (target, all) => {
		for (var name in all) __defProp$1(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$1 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$1(from)) if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$1 = (mod) => __copyProps$1(__defProp$1({}, "__esModule", { value: true }), mod);
	var dist_src_exports$1 = {};
	__export$1(dist_src_exports$1, {
		legacyRestEndpointMethods: () => legacyRestEndpointMethods,
		restEndpointMethods: () => restEndpointMethods
	});
	module.exports = __toCommonJS$1(dist_src_exports$1);
	var VERSION$1 = "10.4.1";
	var endpoints_default = {
		actions: {
			addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
			addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
			addSelectedRepoToOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
			approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
			cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
			createEnvironmentVariable: ["POST /repositories/{repository_id}/environments/{environment_name}/variables"],
			createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			createOrgVariable: ["POST /orgs/{org}/actions/variables"],
			createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
			createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
			createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
			createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
			createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
			createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
			deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
			deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
			deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
			deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			deleteEnvironmentVariable: ["DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
			deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			deleteRepoVariable: ["DELETE /repos/{owner}/{repo}/actions/variables/{name}"],
			deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
			deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
			deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
			deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
			disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
			disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
			downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
			downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
			downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
			downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
			enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
			enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
			forceCancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"],
			generateRunnerJitconfigForOrg: ["POST /orgs/{org}/actions/runners/generate-jitconfig"],
			generateRunnerJitconfigForRepo: ["POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"],
			getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
			getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
			getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
			getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
			getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
			getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
			getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
			getCustomOidcSubClaimForRepo: ["GET /repos/{owner}/{repo}/actions/oidc/customization/sub"],
			getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
			getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			getEnvironmentVariable: ["GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
			getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
			getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
			getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
			getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
			getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
			getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
			getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
			getRepoPermissions: [
				"GET /repos/{owner}/{repo}/actions/permissions",
				{},
				{ renamed: ["actions", "getGithubActionsPermissionsRepository"] }
			],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
			getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
			getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
			getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
			getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
			getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
			getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
			getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
			getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
			getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
			listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
			listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
			listEnvironmentVariables: ["GET /repositories/{repository_id}/environments/{environment_name}/variables"],
			listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
			listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
			listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
			listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
			listOrgVariables: ["GET /orgs/{org}/actions/variables"],
			listRepoOrganizationSecrets: ["GET /repos/{owner}/{repo}/actions/organization-secrets"],
			listRepoOrganizationVariables: ["GET /repos/{owner}/{repo}/actions/organization-variables"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
			listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
			listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
			listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
			listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
			listSelectedReposForOrgVariable: ["GET /orgs/{org}/actions/variables/{name}/repositories"],
			listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
			listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
			listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
			listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
			listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
			listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
			reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
			reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
			reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
			removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
			removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
			removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
			removeSelectedRepoFromOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
			reviewCustomGatesForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"],
			reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
			setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
			setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
			setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
			setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			setCustomOidcSubClaimForRepo: ["PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"],
			setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
			setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
			setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
			setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
			setSelectedReposForOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories"],
			setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
			setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"],
			updateEnvironmentVariable: ["PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
			updateRepoVariable: ["PATCH /repos/{owner}/{repo}/actions/variables/{name}"]
		},
		activity: {
			checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
			deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
			deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
			getFeeds: ["GET /feeds"],
			getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
			getThread: ["GET /notifications/threads/{thread_id}"],
			getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
			listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
			listNotificationsForAuthenticatedUser: ["GET /notifications"],
			listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
			listPublicEvents: ["GET /events"],
			listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
			listPublicEventsForUser: ["GET /users/{username}/events/public"],
			listPublicOrgEvents: ["GET /orgs/{org}/events"],
			listReceivedEventsForUser: ["GET /users/{username}/received_events"],
			listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
			listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
			listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
			listReposStarredByAuthenticatedUser: ["GET /user/starred"],
			listReposStarredByUser: ["GET /users/{username}/starred"],
			listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
			listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
			listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
			listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
			markNotificationsAsRead: ["PUT /notifications"],
			markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
			markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
			markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
			setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
			setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
			starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
			unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
		},
		apps: {
			addRepoToInstallation: [
				"PUT /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
			],
			addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
			checkToken: ["POST /applications/{client_id}/token"],
			createFromManifest: ["POST /app-manifests/{code}/conversions"],
			createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
			deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
			deleteInstallation: ["DELETE /app/installations/{installation_id}"],
			deleteToken: ["DELETE /applications/{client_id}/token"],
			getAuthenticated: ["GET /app"],
			getBySlug: ["GET /apps/{app_slug}"],
			getInstallation: ["GET /app/installations/{installation_id}"],
			getOrgInstallation: ["GET /orgs/{org}/installation"],
			getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
			getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
			getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
			getUserInstallation: ["GET /users/{username}/installation"],
			getWebhookConfigForApp: ["GET /app/hook/config"],
			getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
			listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
			listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
			listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
			listInstallationRequestsForAuthenticatedApp: ["GET /app/installation-requests"],
			listInstallations: ["GET /app/installations"],
			listInstallationsForAuthenticatedUser: ["GET /user/installations"],
			listPlans: ["GET /marketplace_listing/plans"],
			listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
			listReposAccessibleToInstallation: ["GET /installation/repositories"],
			listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
			listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
			listWebhookDeliveries: ["GET /app/hook/deliveries"],
			redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
			removeRepoFromInstallation: [
				"DELETE /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
			],
			removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
			resetToken: ["PATCH /applications/{client_id}/token"],
			revokeInstallationAccessToken: ["DELETE /installation/token"],
			scopeToken: ["POST /applications/{client_id}/token/scoped"],
			suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
			unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
			updateWebhookConfigForApp: ["PATCH /app/hook/config"]
		},
		billing: {
			getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
			getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
			getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
			getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
			getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
			getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
		},
		checks: {
			create: ["POST /repos/{owner}/{repo}/check-runs"],
			createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
			get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
			getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
			listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
			listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
			listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
			listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
			rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
			rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
			setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
			update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
		},
		codeScanning: {
			deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
			getAlert: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
				{},
				{ renamedParameters: { alert_id: "alert_number" } }
			],
			getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
			getCodeqlDatabase: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"],
			getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
			getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
			listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
			listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
			listAlertsInstances: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
				{},
				{ renamed: ["codeScanning", "listAlertInstances"] }
			],
			listCodeqlDatabases: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases"],
			listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
			updateDefaultSetup: ["PATCH /repos/{owner}/{repo}/code-scanning/default-setup"],
			uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
		},
		codesOfConduct: {
			getAllCodesOfConduct: ["GET /codes_of_conduct"],
			getConductCode: ["GET /codes_of_conduct/{key}"]
		},
		codespaces: {
			addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			checkPermissionsForDevcontainer: ["GET /repos/{owner}/{repo}/codespaces/permissions_check"],
			codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
			createForAuthenticatedUser: ["POST /user/codespaces"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
			createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
			createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
			deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
			deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
			exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
			getCodespacesForUserInOrg: ["GET /orgs/{org}/members/{username}/codespaces"],
			getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
			getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
			getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
			getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
			listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
			listForAuthenticatedUser: ["GET /user/codespaces"],
			listInOrganization: [
				"GET /orgs/{org}/codespaces",
				{},
				{ renamedParameters: { org_id: "org" } }
			],
			listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
			listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
			listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
			listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
			preFlightWithRepoForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/new"],
			publishForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/publish"],
			removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
			setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
			startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
			stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
			stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
			updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
		},
		copilot: {
			addCopilotSeatsForTeams: ["POST /orgs/{org}/copilot/billing/selected_teams"],
			addCopilotSeatsForUsers: ["POST /orgs/{org}/copilot/billing/selected_users"],
			cancelCopilotSeatAssignmentForTeams: ["DELETE /orgs/{org}/copilot/billing/selected_teams"],
			cancelCopilotSeatAssignmentForUsers: ["DELETE /orgs/{org}/copilot/billing/selected_users"],
			getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
			getCopilotSeatDetailsForUser: ["GET /orgs/{org}/members/{username}/copilot"],
			listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
		},
		dependabot: {
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
			getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			listAlertsForEnterprise: ["GET /enterprises/{enterprise}/dependabot/alerts"],
			listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
			listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"]
		},
		dependencyGraph: {
			createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
			diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"],
			exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
		},
		emojis: { get: ["GET /emojis"] },
		gists: {
			checkIsStarred: ["GET /gists/{gist_id}/star"],
			create: ["POST /gists"],
			createComment: ["POST /gists/{gist_id}/comments"],
			delete: ["DELETE /gists/{gist_id}"],
			deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
			fork: ["POST /gists/{gist_id}/forks"],
			get: ["GET /gists/{gist_id}"],
			getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
			getRevision: ["GET /gists/{gist_id}/{sha}"],
			list: ["GET /gists"],
			listComments: ["GET /gists/{gist_id}/comments"],
			listCommits: ["GET /gists/{gist_id}/commits"],
			listForUser: ["GET /users/{username}/gists"],
			listForks: ["GET /gists/{gist_id}/forks"],
			listPublic: ["GET /gists/public"],
			listStarred: ["GET /gists/starred"],
			star: ["PUT /gists/{gist_id}/star"],
			unstar: ["DELETE /gists/{gist_id}/star"],
			update: ["PATCH /gists/{gist_id}"],
			updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
		},
		git: {
			createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
			createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
			createRef: ["POST /repos/{owner}/{repo}/git/refs"],
			createTag: ["POST /repos/{owner}/{repo}/git/tags"],
			createTree: ["POST /repos/{owner}/{repo}/git/trees"],
			deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
			getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
			getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
			getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
			getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
			getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
			listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
			updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
		},
		gitignore: {
			getAllTemplates: ["GET /gitignore/templates"],
			getTemplate: ["GET /gitignore/templates/{name}"]
		},
		interactions: {
			getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
			getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
			getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
			getRestrictionsForYourPublicRepos: [
				"GET /user/interaction-limits",
				{},
				{ renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
			],
			removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
			removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
			removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
			removeRestrictionsForYourPublicRepos: [
				"DELETE /user/interaction-limits",
				{},
				{ renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
			],
			setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
			setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
			setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
			setRestrictionsForYourPublicRepos: [
				"PUT /user/interaction-limits",
				{},
				{ renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
			]
		},
		issues: {
			addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
			addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
			checkUserCanBeAssignedToIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"],
			create: ["POST /repos/{owner}/{repo}/issues"],
			createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
			createLabel: ["POST /repos/{owner}/{repo}/labels"],
			createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
			deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
			deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
			get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
			getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
			getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
			getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
			list: ["GET /issues"],
			listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
			listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
			listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
			listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
			listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
			listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
			listForAuthenticatedUser: ["GET /user/issues"],
			listForOrg: ["GET /orgs/{org}/issues"],
			listForRepo: ["GET /repos/{owner}/{repo}/issues"],
			listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
			listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
			listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
			lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
			removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
			setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
			updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
			updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
		},
		licenses: {
			get: ["GET /licenses/{license}"],
			getAllCommonlyUsed: ["GET /licenses"],
			getForRepo: ["GET /repos/{owner}/{repo}/license"]
		},
		markdown: {
			render: ["POST /markdown"],
			renderRaw: ["POST /markdown/raw", { headers: { "content-type": "text/plain; charset=utf-8" } }]
		},
		meta: {
			get: ["GET /meta"],
			getAllVersions: ["GET /versions"],
			getOctocat: ["GET /octocat"],
			getZen: ["GET /zen"],
			root: ["GET /"]
		},
		migrations: {
			cancelImport: [
				"DELETE /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import" }
			],
			deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
			deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
			downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
			getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
			getCommitAuthors: [
				"GET /repos/{owner}/{repo}/import/authors",
				{},
				{ deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors" }
			],
			getImportStatus: [
				"GET /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status" }
			],
			getLargeFiles: [
				"GET /repos/{owner}/{repo}/import/large_files",
				{},
				{ deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files" }
			],
			getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
			getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
			listForAuthenticatedUser: ["GET /user/migrations"],
			listForOrg: ["GET /orgs/{org}/migrations"],
			listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
			listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
			listReposForUser: [
				"GET /user/migrations/{migration_id}/repositories",
				{},
				{ renamed: ["migrations", "listReposForAuthenticatedUser"] }
			],
			mapCommitAuthor: [
				"PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
				{},
				{ deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author" }
			],
			setLfsPreference: [
				"PATCH /repos/{owner}/{repo}/import/lfs",
				{},
				{ deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference" }
			],
			startForAuthenticatedUser: ["POST /user/migrations"],
			startForOrg: ["POST /orgs/{org}/migrations"],
			startImport: [
				"PUT /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import" }
			],
			unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
			unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
			updateImport: [
				"PATCH /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import" }
			]
		},
		oidc: {
			getOidcCustomSubTemplateForOrg: ["GET /orgs/{org}/actions/oidc/customization/sub"],
			updateOidcCustomSubTemplateForOrg: ["PUT /orgs/{org}/actions/oidc/customization/sub"]
		},
		orgs: {
			addSecurityManagerTeam: ["PUT /orgs/{org}/security-managers/teams/{team_slug}"],
			assignTeamToOrgRole: ["PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
			assignUserToOrgRole: ["PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"],
			blockUser: ["PUT /orgs/{org}/blocks/{username}"],
			cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
			checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
			checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
			checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
			convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
			createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
			createInvitation: ["POST /orgs/{org}/invitations"],
			createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
			createOrUpdateCustomPropertiesValuesForRepos: ["PATCH /orgs/{org}/properties/values"],
			createOrUpdateCustomProperty: ["PUT /orgs/{org}/properties/schema/{custom_property_name}"],
			createWebhook: ["POST /orgs/{org}/hooks"],
			delete: ["DELETE /orgs/{org}"],
			deleteCustomOrganizationRole: ["DELETE /orgs/{org}/organization-roles/{role_id}"],
			deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
			enableOrDisableSecurityProductOnAllOrgRepos: ["POST /orgs/{org}/{security_product}/{enablement}"],
			get: ["GET /orgs/{org}"],
			getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
			getCustomProperty: ["GET /orgs/{org}/properties/schema/{custom_property_name}"],
			getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
			getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
			getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
			getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
			getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
			getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
			list: ["GET /organizations"],
			listAppInstallations: ["GET /orgs/{org}/installations"],
			listBlockedUsers: ["GET /orgs/{org}/blocks"],
			listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
			listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
			listForAuthenticatedUser: ["GET /user/orgs"],
			listForUser: ["GET /users/{username}/orgs"],
			listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
			listMembers: ["GET /orgs/{org}/members"],
			listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
			listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
			listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
			listOrgRoles: ["GET /orgs/{org}/organization-roles"],
			listOrganizationFineGrainedPermissions: ["GET /orgs/{org}/organization-fine-grained-permissions"],
			listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
			listPatGrantRepositories: ["GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"],
			listPatGrantRequestRepositories: ["GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"],
			listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
			listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
			listPendingInvitations: ["GET /orgs/{org}/invitations"],
			listPublicMembers: ["GET /orgs/{org}/public_members"],
			listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
			listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
			listWebhooks: ["GET /orgs/{org}/hooks"],
			patchCustomOrganizationRole: ["PATCH /orgs/{org}/organization-roles/{role_id}"],
			pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
			removeCustomProperty: ["DELETE /orgs/{org}/properties/schema/{custom_property_name}"],
			removeMember: ["DELETE /orgs/{org}/members/{username}"],
			removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
			removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
			removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
			removeSecurityManagerTeam: ["DELETE /orgs/{org}/security-managers/teams/{team_slug}"],
			reviewPatGrantRequest: ["POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"],
			reviewPatGrantRequestsInBulk: ["POST /orgs/{org}/personal-access-token-requests"],
			revokeAllOrgRolesTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}"],
			revokeAllOrgRolesUser: ["DELETE /orgs/{org}/organization-roles/users/{username}"],
			revokeOrgRoleTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
			revokeOrgRoleUser: ["DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"],
			setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
			setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
			unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
			update: ["PATCH /orgs/{org}"],
			updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
			updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
			updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
			updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
			updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
		},
		packages: {
			deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
			deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
			deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
			deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getAllPackageVersionsForAPackageOwnedByAnOrg: [
				"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
				{},
				{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
			],
			getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
				"GET /user/packages/{package_type}/{package_name}/versions",
				{},
				{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"] }
			],
			getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
			getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
			getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
			getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
			getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
			getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
			getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			listDockerMigrationConflictingPackagesForAuthenticatedUser: ["GET /user/docker/conflicts"],
			listDockerMigrationConflictingPackagesForOrganization: ["GET /orgs/{org}/docker/conflicts"],
			listDockerMigrationConflictingPackagesForUser: ["GET /users/{username}/docker/conflicts"],
			listPackagesForAuthenticatedUser: ["GET /user/packages"],
			listPackagesForOrganization: ["GET /orgs/{org}/packages"],
			listPackagesForUser: ["GET /users/{username}/packages"],
			restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
			restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
			restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
		},
		projects: {
			addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
			createCard: ["POST /projects/columns/{column_id}/cards"],
			createColumn: ["POST /projects/{project_id}/columns"],
			createForAuthenticatedUser: ["POST /user/projects"],
			createForOrg: ["POST /orgs/{org}/projects"],
			createForRepo: ["POST /repos/{owner}/{repo}/projects"],
			delete: ["DELETE /projects/{project_id}"],
			deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
			deleteColumn: ["DELETE /projects/columns/{column_id}"],
			get: ["GET /projects/{project_id}"],
			getCard: ["GET /projects/columns/cards/{card_id}"],
			getColumn: ["GET /projects/columns/{column_id}"],
			getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
			listCards: ["GET /projects/columns/{column_id}/cards"],
			listCollaborators: ["GET /projects/{project_id}/collaborators"],
			listColumns: ["GET /projects/{project_id}/columns"],
			listForOrg: ["GET /orgs/{org}/projects"],
			listForRepo: ["GET /repos/{owner}/{repo}/projects"],
			listForUser: ["GET /users/{username}/projects"],
			moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
			moveColumn: ["POST /projects/columns/{column_id}/moves"],
			removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
			update: ["PATCH /projects/{project_id}"],
			updateCard: ["PATCH /projects/columns/cards/{card_id}"],
			updateColumn: ["PATCH /projects/columns/{column_id}"]
		},
		pulls: {
			checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			create: ["POST /repos/{owner}/{repo}/pulls"],
			createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
			createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
			deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
			dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
			get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
			getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
			list: ["GET /repos/{owner}/{repo}/pulls"],
			listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
			listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
			listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
			listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
			listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
			listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
			update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
			updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
			updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
		},
		rateLimit: { get: ["GET /rate_limit"] },
		reactions: {
			createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
			createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
			createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
			createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
			createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
			createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
			createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
			deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
			deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
			deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
			deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],
			listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
			listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
			listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
			listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
			listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
			listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
			listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]
		},
		repos: {
			acceptInvitation: [
				"PATCH /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
			],
			acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
			addAppAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
			addStatusCheckContexts: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			addTeamAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			addUserAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			cancelPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"],
			checkAutomatedSecurityFixes: ["GET /repos/{owner}/{repo}/automated-security-fixes"],
			checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
			checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
			codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
			compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
			compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
			createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
			createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
			createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
			createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
			createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
			createDeploymentBranchPolicy: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
			createDeploymentProtectionRule: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
			createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
			createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
			createForAuthenticatedUser: ["POST /user/repos"],
			createFork: ["POST /repos/{owner}/{repo}/forks"],
			createInOrg: ["POST /orgs/{org}/repos"],
			createOrUpdateCustomPropertiesValues: ["PATCH /repos/{owner}/{repo}/properties/values"],
			createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
			createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
			createOrgRuleset: ["POST /orgs/{org}/rulesets"],
			createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
			createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
			createRelease: ["POST /repos/{owner}/{repo}/releases"],
			createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
			createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
			createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
			createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
			declineInvitation: [
				"DELETE /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
			],
			declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
			delete: ["DELETE /repos/{owner}/{repo}"],
			deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
			deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
			deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
			deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
			deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
			deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
			deleteDeploymentBranchPolicy: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
			deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
			deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
			deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
			deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
			deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			deleteTagProtection: ["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],
			deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
			disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
			disableDeploymentProtectionRule: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
			disablePrivateVulnerabilityReporting: ["DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"],
			disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
			downloadArchive: [
				"GET /repos/{owner}/{repo}/zipball/{ref}",
				{},
				{ renamed: ["repos", "downloadZipballArchive"] }
			],
			downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
			downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
			enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
			enablePrivateVulnerabilityReporting: ["PUT /repos/{owner}/{repo}/private-vulnerability-reporting"],
			enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
			generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
			get: ["GET /repos/{owner}/{repo}"],
			getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
			getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			getAllDeploymentProtectionRules: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
			getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
			getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
			getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
			getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
			getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
			getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
			getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
			getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
			getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
			getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
			getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
			getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
			getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
			getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
			getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
			getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
			getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
			getCustomDeploymentProtectionRule: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
			getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
			getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
			getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
			getDeploymentBranchPolicy: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
			getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
			getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
			getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
			getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
			getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
			getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
			getOrgRulesets: ["GET /orgs/{org}/rulesets"],
			getPages: ["GET /repos/{owner}/{repo}/pages"],
			getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
			getPagesDeployment: ["GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"],
			getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
			getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
			getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
			getReadme: ["GET /repos/{owner}/{repo}/readme"],
			getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
			getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
			getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
			getRepoRuleSuite: ["GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"],
			getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
			getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
			getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
			getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
			getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
			getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
			getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
			getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
			getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
			getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
			listActivities: ["GET /repos/{owner}/{repo}/activity"],
			listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
			listBranches: ["GET /repos/{owner}/{repo}/branches"],
			listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
			listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
			listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
			listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
			listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
			listCommits: ["GET /repos/{owner}/{repo}/commits"],
			listContributors: ["GET /repos/{owner}/{repo}/contributors"],
			listCustomDeploymentRuleIntegrations: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"],
			listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
			listDeploymentBranchPolicies: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
			listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
			listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
			listForAuthenticatedUser: ["GET /user/repos"],
			listForOrg: ["GET /orgs/{org}/repos"],
			listForUser: ["GET /users/{username}/repos"],
			listForks: ["GET /repos/{owner}/{repo}/forks"],
			listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
			listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
			listLanguages: ["GET /repos/{owner}/{repo}/languages"],
			listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
			listPublic: ["GET /repositories"],
			listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
			listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
			listReleases: ["GET /repos/{owner}/{repo}/releases"],
			listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
			listTags: ["GET /repos/{owner}/{repo}/tags"],
			listTeams: ["GET /repos/{owner}/{repo}/teams"],
			listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
			listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
			merge: ["POST /repos/{owner}/{repo}/merges"],
			mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
			pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
			removeAppAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
			removeStatusCheckContexts: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			removeTeamAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			removeUserAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
			replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
			requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
			setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			setAppAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			setStatusCheckContexts: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			setTeamAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			setUserAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
			transfer: ["POST /repos/{owner}/{repo}/transfer"],
			update: ["PATCH /repos/{owner}/{repo}"],
			updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
			updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
			updateDeploymentBranchPolicy: ["PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
			updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
			updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
			updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
			updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			updateStatusCheckPotection: [
				"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
				{},
				{ renamed: ["repos", "updateStatusCheckProtection"] }
			],
			updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
			updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
			uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", { baseUrl: "https://uploads.github.com" }]
		},
		search: {
			code: ["GET /search/code"],
			commits: ["GET /search/commits"],
			issuesAndPullRequests: ["GET /search/issues"],
			labels: ["GET /search/labels"],
			repos: ["GET /search/repositories"],
			topics: ["GET /search/topics"],
			users: ["GET /search/users"]
		},
		secretScanning: {
			getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
			listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
			listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
			listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
		},
		securityAdvisories: {
			createFork: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"],
			createPrivateVulnerabilityReport: ["POST /repos/{owner}/{repo}/security-advisories/reports"],
			createRepositoryAdvisory: ["POST /repos/{owner}/{repo}/security-advisories"],
			createRepositoryAdvisoryCveRequest: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"],
			getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
			getRepositoryAdvisory: ["GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],
			listGlobalAdvisories: ["GET /advisories"],
			listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
			listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
			updateRepositoryAdvisory: ["PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"]
		},
		teams: {
			addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			create: ["POST /orgs/{org}/teams"],
			createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
			createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
			deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
			getByName: ["GET /orgs/{org}/teams/{team_slug}"],
			getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			list: ["GET /orgs/{org}/teams"],
			listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
			listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
			listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
			listForAuthenticatedUser: ["GET /user/teams"],
			listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
			listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
			listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
			listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
			removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
		},
		users: {
			addEmailForAuthenticated: [
				"POST /user/emails",
				{},
				{ renamed: ["users", "addEmailForAuthenticatedUser"] }
			],
			addEmailForAuthenticatedUser: ["POST /user/emails"],
			addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
			block: ["PUT /user/blocks/{username}"],
			checkBlocked: ["GET /user/blocks/{username}"],
			checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
			checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
			createGpgKeyForAuthenticated: [
				"POST /user/gpg_keys",
				{},
				{ renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
			],
			createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
			createPublicSshKeyForAuthenticated: [
				"POST /user/keys",
				{},
				{ renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
			],
			createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
			createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
			deleteEmailForAuthenticated: [
				"DELETE /user/emails",
				{},
				{ renamed: ["users", "deleteEmailForAuthenticatedUser"] }
			],
			deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
			deleteGpgKeyForAuthenticated: [
				"DELETE /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
			],
			deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
			deletePublicSshKeyForAuthenticated: [
				"DELETE /user/keys/{key_id}",
				{},
				{ renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
			],
			deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
			deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
			deleteSshSigningKeyForAuthenticatedUser: ["DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"],
			follow: ["PUT /user/following/{username}"],
			getAuthenticated: ["GET /user"],
			getByUsername: ["GET /users/{username}"],
			getContextForUser: ["GET /users/{username}/hovercard"],
			getGpgKeyForAuthenticated: [
				"GET /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
			],
			getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
			getPublicSshKeyForAuthenticated: [
				"GET /user/keys/{key_id}",
				{},
				{ renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
			],
			getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
			getSshSigningKeyForAuthenticatedUser: ["GET /user/ssh_signing_keys/{ssh_signing_key_id}"],
			list: ["GET /users"],
			listBlockedByAuthenticated: [
				"GET /user/blocks",
				{},
				{ renamed: ["users", "listBlockedByAuthenticatedUser"] }
			],
			listBlockedByAuthenticatedUser: ["GET /user/blocks"],
			listEmailsForAuthenticated: [
				"GET /user/emails",
				{},
				{ renamed: ["users", "listEmailsForAuthenticatedUser"] }
			],
			listEmailsForAuthenticatedUser: ["GET /user/emails"],
			listFollowedByAuthenticated: [
				"GET /user/following",
				{},
				{ renamed: ["users", "listFollowedByAuthenticatedUser"] }
			],
			listFollowedByAuthenticatedUser: ["GET /user/following"],
			listFollowersForAuthenticatedUser: ["GET /user/followers"],
			listFollowersForUser: ["GET /users/{username}/followers"],
			listFollowingForUser: ["GET /users/{username}/following"],
			listGpgKeysForAuthenticated: [
				"GET /user/gpg_keys",
				{},
				{ renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
			],
			listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
			listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
			listPublicEmailsForAuthenticated: [
				"GET /user/public_emails",
				{},
				{ renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
			],
			listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
			listPublicKeysForUser: ["GET /users/{username}/keys"],
			listPublicSshKeysForAuthenticated: [
				"GET /user/keys",
				{},
				{ renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
			],
			listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
			listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
			listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
			listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
			listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
			setPrimaryEmailVisibilityForAuthenticated: [
				"PATCH /user/email/visibility",
				{},
				{ renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
			],
			setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
			unblock: ["DELETE /user/blocks/{username}"],
			unfollow: ["DELETE /user/following/{username}"],
			updateAuthenticated: ["PATCH /user"]
		}
	};
	var endpointMethodsMap = /* @__PURE__ */ new Map();
	for (const [scope, endpoints] of Object.entries(endpoints_default)) for (const [methodName, endpoint$1] of Object.entries(endpoints)) {
		const [route, defaults, decorations] = endpoint$1;
		const [method, url] = route.split(/ /);
		const endpointDefaults = Object.assign({
			method,
			url
		}, defaults);
		if (!endpointMethodsMap.has(scope)) endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
		endpointMethodsMap.get(scope).set(methodName, {
			scope,
			methodName,
			endpointDefaults,
			decorations
		});
	}
	var handler = {
		has({ scope }, methodName) {
			return endpointMethodsMap.get(scope).has(methodName);
		},
		getOwnPropertyDescriptor(target, methodName) {
			return {
				value: this.get(target, methodName),
				configurable: true,
				writable: true,
				enumerable: true
			};
		},
		defineProperty(target, methodName, descriptor) {
			Object.defineProperty(target.cache, methodName, descriptor);
			return true;
		},
		deleteProperty(target, methodName) {
			delete target.cache[methodName];
			return true;
		},
		ownKeys({ scope }) {
			return [...endpointMethodsMap.get(scope).keys()];
		},
		set(target, methodName, value) {
			return target.cache[methodName] = value;
		},
		get({ octokit, scope, cache }, methodName) {
			if (cache[methodName]) return cache[methodName];
			const method = endpointMethodsMap.get(scope).get(methodName);
			if (!method) return;
			const { endpointDefaults, decorations } = method;
			if (decorations) cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
			else cache[methodName] = octokit.request.defaults(endpointDefaults);
			return cache[methodName];
		}
	};
	function endpointsToMethods(octokit) {
		const newMethods = {};
		for (const scope of endpointMethodsMap.keys()) newMethods[scope] = new Proxy({
			octokit,
			scope,
			cache: {}
		}, handler);
		return newMethods;
	}
	function decorate(octokit, scope, methodName, defaults, decorations) {
		const requestWithDefaults = octokit.request.defaults(defaults);
		function withDecorations(...args) {
			let options = requestWithDefaults.endpoint.merge(...args);
			if (decorations.mapToData) {
				options = Object.assign({}, options, {
					data: options[decorations.mapToData],
					[decorations.mapToData]: void 0
				});
				return requestWithDefaults(options);
			}
			if (decorations.renamed) {
				const [newScope, newMethodName] = decorations.renamed;
				octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
			}
			if (decorations.deprecated) octokit.log.warn(decorations.deprecated);
			if (decorations.renamedParameters) {
				const options2 = requestWithDefaults.endpoint.merge(...args);
				for (const [name, alias] of Object.entries(decorations.renamedParameters)) if (name in options2) {
					octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
					if (!(alias in options2)) options2[alias] = options2[name];
					delete options2[name];
				}
				return requestWithDefaults(options2);
			}
			return requestWithDefaults(...args);
		}
		return Object.assign(withDecorations, requestWithDefaults);
	}
	function restEndpointMethods(octokit) {
		return { rest: endpointsToMethods(octokit) };
	}
	restEndpointMethods.VERSION = VERSION$1;
	function legacyRestEndpointMethods(octokit) {
		const api$1 = endpointsToMethods(octokit);
		return {
			...api$1,
			rest: api$1
		};
	}
	legacyRestEndpointMethods.VERSION = VERSION$1;
}));

//#endregion
//#region node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __export = (target, all) => {
		for (var name in all) __defProp(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
	var dist_src_exports = {};
	__export(dist_src_exports, {
		composePaginateRest: () => composePaginateRest,
		isPaginatingEndpoint: () => isPaginatingEndpoint,
		paginateRest: () => paginateRest,
		paginatingEndpoints: () => paginatingEndpoints
	});
	module.exports = __toCommonJS(dist_src_exports);
	var VERSION = "9.2.2";
	function normalizePaginatedListResponse(response) {
		if (!response.data) return {
			...response,
			data: []
		};
		if (!("total_count" in response.data && !("url" in response.data))) return response;
		const incompleteResults = response.data.incomplete_results;
		const repositorySelection = response.data.repository_selection;
		const totalCount = response.data.total_count;
		delete response.data.incomplete_results;
		delete response.data.repository_selection;
		delete response.data.total_count;
		const namespaceKey = Object.keys(response.data)[0];
		response.data = response.data[namespaceKey];
		if (typeof incompleteResults !== "undefined") response.data.incomplete_results = incompleteResults;
		if (typeof repositorySelection !== "undefined") response.data.repository_selection = repositorySelection;
		response.data.total_count = totalCount;
		return response;
	}
	function iterator(octokit, route, parameters) {
		const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
		const requestMethod = typeof route === "function" ? route : octokit.request;
		const method = options.method;
		const headers = options.headers;
		let url = options.url;
		return { [Symbol.asyncIterator]: () => ({ async next() {
			if (!url) return { done: true };
			try {
				const normalizedResponse = normalizePaginatedListResponse(await requestMethod({
					method,
					url,
					headers
				}));
				url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
				return { value: normalizedResponse };
			} catch (error$1) {
				if (error$1.status !== 409) throw error$1;
				url = "";
				return { value: {
					status: 200,
					headers: {},
					data: []
				} };
			}
		} }) };
	}
	function paginate(octokit, route, parameters, mapFn) {
		if (typeof parameters === "function") {
			mapFn = parameters;
			parameters = void 0;
		}
		return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
	}
	function gather(octokit, results, iterator2, mapFn) {
		return iterator2.next().then((result) => {
			if (result.done) return results;
			let earlyExit = false;
			function done() {
				earlyExit = true;
			}
			results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
			if (earlyExit) return results;
			return gather(octokit, results, iterator2, mapFn);
		});
	}
	var composePaginateRest = Object.assign(paginate, { iterator });
	var paginatingEndpoints = [
		"GET /advisories",
		"GET /app/hook/deliveries",
		"GET /app/installation-requests",
		"GET /app/installations",
		"GET /assignments/{assignment_id}/accepted_assignments",
		"GET /classrooms",
		"GET /classrooms/{classroom_id}/assignments",
		"GET /enterprises/{enterprise}/dependabot/alerts",
		"GET /enterprises/{enterprise}/secret-scanning/alerts",
		"GET /events",
		"GET /gists",
		"GET /gists/public",
		"GET /gists/starred",
		"GET /gists/{gist_id}/comments",
		"GET /gists/{gist_id}/commits",
		"GET /gists/{gist_id}/forks",
		"GET /installation/repositories",
		"GET /issues",
		"GET /licenses",
		"GET /marketplace_listing/plans",
		"GET /marketplace_listing/plans/{plan_id}/accounts",
		"GET /marketplace_listing/stubbed/plans",
		"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
		"GET /networks/{owner}/{repo}/events",
		"GET /notifications",
		"GET /organizations",
		"GET /orgs/{org}/actions/cache/usage-by-repository",
		"GET /orgs/{org}/actions/permissions/repositories",
		"GET /orgs/{org}/actions/runners",
		"GET /orgs/{org}/actions/secrets",
		"GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/actions/variables",
		"GET /orgs/{org}/actions/variables/{name}/repositories",
		"GET /orgs/{org}/blocks",
		"GET /orgs/{org}/code-scanning/alerts",
		"GET /orgs/{org}/codespaces",
		"GET /orgs/{org}/codespaces/secrets",
		"GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/copilot/billing/seats",
		"GET /orgs/{org}/dependabot/alerts",
		"GET /orgs/{org}/dependabot/secrets",
		"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/events",
		"GET /orgs/{org}/failed_invitations",
		"GET /orgs/{org}/hooks",
		"GET /orgs/{org}/hooks/{hook_id}/deliveries",
		"GET /orgs/{org}/installations",
		"GET /orgs/{org}/invitations",
		"GET /orgs/{org}/invitations/{invitation_id}/teams",
		"GET /orgs/{org}/issues",
		"GET /orgs/{org}/members",
		"GET /orgs/{org}/members/{username}/codespaces",
		"GET /orgs/{org}/migrations",
		"GET /orgs/{org}/migrations/{migration_id}/repositories",
		"GET /orgs/{org}/organization-roles/{role_id}/teams",
		"GET /orgs/{org}/organization-roles/{role_id}/users",
		"GET /orgs/{org}/outside_collaborators",
		"GET /orgs/{org}/packages",
		"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
		"GET /orgs/{org}/personal-access-token-requests",
		"GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
		"GET /orgs/{org}/personal-access-tokens",
		"GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
		"GET /orgs/{org}/projects",
		"GET /orgs/{org}/properties/values",
		"GET /orgs/{org}/public_members",
		"GET /orgs/{org}/repos",
		"GET /orgs/{org}/rulesets",
		"GET /orgs/{org}/rulesets/rule-suites",
		"GET /orgs/{org}/secret-scanning/alerts",
		"GET /orgs/{org}/security-advisories",
		"GET /orgs/{org}/teams",
		"GET /orgs/{org}/teams/{team_slug}/discussions",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
		"GET /orgs/{org}/teams/{team_slug}/invitations",
		"GET /orgs/{org}/teams/{team_slug}/members",
		"GET /orgs/{org}/teams/{team_slug}/projects",
		"GET /orgs/{org}/teams/{team_slug}/repos",
		"GET /orgs/{org}/teams/{team_slug}/teams",
		"GET /projects/columns/{column_id}/cards",
		"GET /projects/{project_id}/collaborators",
		"GET /projects/{project_id}/columns",
		"GET /repos/{owner}/{repo}/actions/artifacts",
		"GET /repos/{owner}/{repo}/actions/caches",
		"GET /repos/{owner}/{repo}/actions/organization-secrets",
		"GET /repos/{owner}/{repo}/actions/organization-variables",
		"GET /repos/{owner}/{repo}/actions/runners",
		"GET /repos/{owner}/{repo}/actions/runs",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
		"GET /repos/{owner}/{repo}/actions/secrets",
		"GET /repos/{owner}/{repo}/actions/variables",
		"GET /repos/{owner}/{repo}/actions/workflows",
		"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
		"GET /repos/{owner}/{repo}/activity",
		"GET /repos/{owner}/{repo}/assignees",
		"GET /repos/{owner}/{repo}/branches",
		"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
		"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
		"GET /repos/{owner}/{repo}/code-scanning/alerts",
		"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
		"GET /repos/{owner}/{repo}/code-scanning/analyses",
		"GET /repos/{owner}/{repo}/codespaces",
		"GET /repos/{owner}/{repo}/codespaces/devcontainers",
		"GET /repos/{owner}/{repo}/codespaces/secrets",
		"GET /repos/{owner}/{repo}/collaborators",
		"GET /repos/{owner}/{repo}/comments",
		"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/commits",
		"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
		"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
		"GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
		"GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
		"GET /repos/{owner}/{repo}/commits/{ref}/status",
		"GET /repos/{owner}/{repo}/commits/{ref}/statuses",
		"GET /repos/{owner}/{repo}/contributors",
		"GET /repos/{owner}/{repo}/dependabot/alerts",
		"GET /repos/{owner}/{repo}/dependabot/secrets",
		"GET /repos/{owner}/{repo}/deployments",
		"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
		"GET /repos/{owner}/{repo}/environments",
		"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
		"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
		"GET /repos/{owner}/{repo}/events",
		"GET /repos/{owner}/{repo}/forks",
		"GET /repos/{owner}/{repo}/hooks",
		"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
		"GET /repos/{owner}/{repo}/invitations",
		"GET /repos/{owner}/{repo}/issues",
		"GET /repos/{owner}/{repo}/issues/comments",
		"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/issues/events",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/events",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
		"GET /repos/{owner}/{repo}/keys",
		"GET /repos/{owner}/{repo}/labels",
		"GET /repos/{owner}/{repo}/milestones",
		"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
		"GET /repos/{owner}/{repo}/notifications",
		"GET /repos/{owner}/{repo}/pages/builds",
		"GET /repos/{owner}/{repo}/projects",
		"GET /repos/{owner}/{repo}/pulls",
		"GET /repos/{owner}/{repo}/pulls/comments",
		"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
		"GET /repos/{owner}/{repo}/releases",
		"GET /repos/{owner}/{repo}/releases/{release_id}/assets",
		"GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
		"GET /repos/{owner}/{repo}/rules/branches/{branch}",
		"GET /repos/{owner}/{repo}/rulesets",
		"GET /repos/{owner}/{repo}/rulesets/rule-suites",
		"GET /repos/{owner}/{repo}/secret-scanning/alerts",
		"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
		"GET /repos/{owner}/{repo}/security-advisories",
		"GET /repos/{owner}/{repo}/stargazers",
		"GET /repos/{owner}/{repo}/subscribers",
		"GET /repos/{owner}/{repo}/tags",
		"GET /repos/{owner}/{repo}/teams",
		"GET /repos/{owner}/{repo}/topics",
		"GET /repositories",
		"GET /repositories/{repository_id}/environments/{environment_name}/secrets",
		"GET /repositories/{repository_id}/environments/{environment_name}/variables",
		"GET /search/code",
		"GET /search/commits",
		"GET /search/issues",
		"GET /search/labels",
		"GET /search/repositories",
		"GET /search/topics",
		"GET /search/users",
		"GET /teams/{team_id}/discussions",
		"GET /teams/{team_id}/discussions/{discussion_number}/comments",
		"GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
		"GET /teams/{team_id}/discussions/{discussion_number}/reactions",
		"GET /teams/{team_id}/invitations",
		"GET /teams/{team_id}/members",
		"GET /teams/{team_id}/projects",
		"GET /teams/{team_id}/repos",
		"GET /teams/{team_id}/teams",
		"GET /user/blocks",
		"GET /user/codespaces",
		"GET /user/codespaces/secrets",
		"GET /user/emails",
		"GET /user/followers",
		"GET /user/following",
		"GET /user/gpg_keys",
		"GET /user/installations",
		"GET /user/installations/{installation_id}/repositories",
		"GET /user/issues",
		"GET /user/keys",
		"GET /user/marketplace_purchases",
		"GET /user/marketplace_purchases/stubbed",
		"GET /user/memberships/orgs",
		"GET /user/migrations",
		"GET /user/migrations/{migration_id}/repositories",
		"GET /user/orgs",
		"GET /user/packages",
		"GET /user/packages/{package_type}/{package_name}/versions",
		"GET /user/public_emails",
		"GET /user/repos",
		"GET /user/repository_invitations",
		"GET /user/social_accounts",
		"GET /user/ssh_signing_keys",
		"GET /user/starred",
		"GET /user/subscriptions",
		"GET /user/teams",
		"GET /users",
		"GET /users/{username}/events",
		"GET /users/{username}/events/orgs/{org}",
		"GET /users/{username}/events/public",
		"GET /users/{username}/followers",
		"GET /users/{username}/following",
		"GET /users/{username}/gists",
		"GET /users/{username}/gpg_keys",
		"GET /users/{username}/keys",
		"GET /users/{username}/orgs",
		"GET /users/{username}/packages",
		"GET /users/{username}/projects",
		"GET /users/{username}/received_events",
		"GET /users/{username}/received_events/public",
		"GET /users/{username}/repos",
		"GET /users/{username}/social_accounts",
		"GET /users/{username}/ssh_signing_keys",
		"GET /users/{username}/starred",
		"GET /users/{username}/subscriptions"
	];
	function isPaginatingEndpoint(arg) {
		if (typeof arg === "string") return paginatingEndpoints.includes(arg);
		else return false;
	}
	function paginateRest(octokit) {
		return { paginate: Object.assign(paginate.bind(null, octokit), { iterator: iterator.bind(null, octokit) }) };
	}
	paginateRest.VERSION = VERSION;
}));

//#endregion
//#region node_modules/@actions/github/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$9 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$6 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$6 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$9(result, mod, k);
		}
		__setModuleDefault$6(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
	const Context$1 = __importStar$6(require_context());
	const Utils = __importStar$6(require_utils$1());
	const core_1 = require_dist_node$2();
	const plugin_rest_endpoint_methods_1 = require_dist_node$1();
	const plugin_paginate_rest_1 = require_dist_node();
	exports.context = new Context$1.Context();
	const baseUrl = Utils.getApiBaseUrl();
	exports.defaults = {
		baseUrl,
		request: {
			agent: Utils.getProxyAgent(baseUrl),
			fetch: Utils.getProxyFetch(baseUrl)
		}
	};
	exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
	/**
	* Convience function to correctly format Octokit Options to pass into the constructor.
	*
	* @param     token    the repo PAT or GITHUB_TOKEN
	* @param     options  other options to set
	*/
	function getOctokitOptions(token, options) {
		const opts = Object.assign({}, options || {});
		const auth$2 = Utils.getAuthString(token, opts);
		if (auth$2) opts.auth = auth$2;
		return opts;
	}
	exports.getOctokitOptions = getOctokitOptions;
}));

//#endregion
//#region node_modules/@actions/github/lib/github.js
var require_github = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$8 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$5 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$5 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$8(result, mod, k);
		}
		__setModuleDefault$5(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOctokit = exports.context = void 0;
	const Context = __importStar$5(require_context());
	const utils_1 = require_utils();
	exports.context = new Context.Context();
	/**
	* Returns a hydrated octokit ready to use for GitHub Actions
	*
	* @param     token    the repo PAT or GITHUB_TOKEN
	* @param     options  other options to set
	*/
	function getOctokit$1(token, options, ...additionalPlugins) {
		return new (utils_1.GitHub.plugin(...additionalPlugins))((0, utils_1.getOctokitOptions)(token, options));
	}
	exports.getOctokit = getOctokit$1;
}));

//#endregion
//#region src/utils.js
var import_github = require_github();
var import_core$3 = /* @__PURE__ */ __toESM$1(require_core(), 1);
function getISOWeek(date) {
	const target = new Date(date.valueOf());
	const dayNr = (date.getUTCDay() + 6) % 7;
	target.setUTCDate(target.getUTCDate() - dayNr + 3);
	const firstThursday = target.valueOf();
	target.setUTCMonth(0, 1);
	if (target.getUTCDay() !== 4) target.setUTCMonth(0, 1 + (4 - target.getUTCDay() + 7) % 7);
	const weekNumber = 1 + Math.ceil((firstThursday - target) / 6048e5);
	return `${target.getUTCFullYear()}-W${String(weekNumber).padStart(2, "0")}`;
}
function getWeekStart(date) {
	const target = new Date(date.valueOf());
	const dayNr = (date.getUTCDay() + 6) % 7;
	target.setUTCDate(target.getUTCDate() - dayNr);
	target.setUTCHours(0, 0, 0, 0);
	return target.toISOString().split("T")[0];
}
function getWeekEnd(date) {
	const target = new Date(date.valueOf());
	const dayNr = (date.getUTCDay() + 6) % 7;
	target.setUTCDate(target.getUTCDate() - dayNr + 6);
	target.setUTCHours(23, 59, 59, 999);
	return target.toISOString().split("T")[0];
}

//#endregion
//#region src/github-utils.js
function getRepoInfo() {
	const [owner, repo] = (process.env.GITHUB_REPOSITORY || "").split("/");
	return {
		owner,
		repo
	};
}
function shouldIncludeFullPatch(file) {
	if (file.filename.includes("package-lock.json")) return false;
	if (file.filename.includes("yarn.lock")) return false;
	if (file.filename.includes("pnpm-lock.yaml")) return false;
	if (file.filename.includes("dist/")) return false;
	if (file.changes < 50) return true;
	return false;
}
function groupCommitsByWeek(commits) {
	const groups = /* @__PURE__ */ new Map();
	commits.forEach((commit) => {
		const date = new Date(commit.commit.author.date);
		const weekKey = getISOWeek(date);
		if (!groups.has(weekKey)) groups.set(weekKey, {
			weekStart: getWeekStart(date),
			weekEnd: getWeekEnd(date),
			commits: []
		});
		groups.get(weekKey).commits.push(commit);
	});
	return Array.from(groups.values());
}
async function getCommitsGroupedByWeek({ token, owner, repo, commitsCount = 10 }) {
	const octokit = (0, import_github.getOctokit)(token);
	try {
		const { data: commits } = await octokit.rest.repos.listCommits({
			owner,
			repo,
			per_page: commitsCount
		});
		const weekGroups = groupCommitsByWeek(commits);
		return await Promise.all(weekGroups.map(async (week) => {
			const enrichedCommits = await Promise.all(week.commits.map(async (commit) => {
				const { data: commitData } = await octokit.rest.repos.getCommit({
					owner,
					repo,
					ref: commit.sha
				});
				return {
					sha: commit.sha,
					message: commit.commit.message,
					author: commit.commit.author.name,
					date: commit.commit.author.date,
					files: commitData.files.map((file) => ({
						filename: file.filename,
						status: file.status,
						additions: file.additions,
						deletions: file.deletions,
						changes: file.changes,
						patch: shouldIncludeFullPatch(file) ? file.patch : null
					}))
				};
			}));
			return {
				...week,
				commits: enrichedCommits
			};
		}));
	} catch (error$1) {
		import_core$3.error(`Error getting last commits diff: ${error$1.message}`);
		throw error$1;
	}
}

//#endregion
//#region src/changelog-utils.js
var import_core$2 = /* @__PURE__ */ __toESM$1(require_core(), 1);
/**
* Read existing changelog file
* @param {string} changelogPath - Path to CHANGELOG.md
* @returns {string} - Content of changelog or empty string
*/
function readChangelog(changelogPath = "CHANGELOG.md") {
	try {
		if (fs.existsSync(changelogPath)) {
			const content = fs.readFileSync(changelogPath, "utf8");
			import_core$2.info(`Read existing changelog from ${changelogPath}`);
			return content;
		} else {
			import_core$2.info("No existing changelog found, will create new one");
			return "";
		}
	} catch (error$1) {
		import_core$2.warning(`Error reading changelog: ${error$1.message}`);
		return "";
	}
}

//#endregion
//#region node_modules/extend/index.js
var require_extend = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var defineProperty = Object.defineProperty;
	var gOPD = Object.getOwnPropertyDescriptor;
	var isArray = function isArray$1(arr) {
		if (typeof Array.isArray === "function") return Array.isArray(arr);
		return toStr.call(arr) === "[object Array]";
	};
	var isPlainObject = function isPlainObject$3(obj) {
		if (!obj || toStr.call(obj) !== "[object Object]") return false;
		var hasOwnConstructor = hasOwn.call(obj, "constructor");
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return false;
		var key;
		for (key in obj);
		return typeof key === "undefined" || hasOwn.call(obj, key);
	};
	var setProperty = function setProperty$1(target, options) {
		if (defineProperty && options.name === "__proto__") defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
		else target[options.name] = options.newValue;
	};
	var getProperty = function getProperty$1(obj, name) {
		if (name === "__proto__") {
			if (!hasOwn.call(obj, name)) return;
			else if (gOPD) return gOPD(obj, name).value;
		}
		return obj[name];
	};
	module.exports = function extend() {
		var options, name, src, copy, copyIsArray, clone$1;
		var target = arguments[0];
		var i$2 = 1;
		var length = arguments.length;
		var deep = false;
		if (typeof target === "boolean") {
			deep = target;
			target = arguments[1] || {};
			i$2 = 2;
		}
		if (target == null || typeof target !== "object" && typeof target !== "function") target = {};
		for (; i$2 < length; ++i$2) {
			options = arguments[i$2];
			if (options != null) for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);
				if (target !== copy) {
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone$1 = src && isArray(src) ? src : [];
						} else clone$1 = src && isPlainObject(src) ? src : {};
						setProperty(target, {
							name,
							newValue: extend(deep, clone$1, copy)
						});
					} else if (typeof copy !== "undefined") setProperty(target, {
						name,
						newValue: copy
					});
				}
			}
		}
		return target;
	};
}));

//#endregion
//#region node_modules/gaxios/package.json
var require_package$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"name": "gaxios",
		"version": "7.1.3",
		"description": "A simple common HTTP client specifically for Google APIs and services.",
		"main": "build/cjs/src/index.js",
		"types": "build/cjs/src/index.d.ts",
		"files": ["build/"],
		"exports": { ".": {
			"import": {
				"types": "./build/esm/src/index.d.ts",
				"default": "./build/esm/src/index.js"
			},
			"require": {
				"types": "./build/cjs/src/index.d.ts",
				"default": "./build/cjs/src/index.js"
			}
		} },
		"scripts": {
			"lint": "gts check --no-inline-config",
			"test": "c8 mocha build/esm/test",
			"presystem-test": "npm run compile",
			"system-test": "mocha build/esm/system-test --timeout 80000",
			"compile": "tsc -b ./tsconfig.json ./tsconfig.cjs.json && node utils/enable-esm.mjs",
			"fix": "gts fix",
			"prepare": "npm run compile",
			"pretest": "npm run compile",
			"webpack": "webpack",
			"prebrowser-test": "npm run compile",
			"browser-test": "node build/browser-test/browser-test-runner.js",
			"docs": "jsdoc -c .jsdoc.js",
			"docs-test": "linkinator docs",
			"predocs-test": "npm run docs",
			"samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
			"prelint": "cd samples; npm link ../; npm install",
			"clean": "gts clean"
		},
		"repository": {
			"type": "git",
			"directory": "packages/gaxios",
			"url": "https://github.com/googleapis/google-cloud-node-core.git"
		},
		"keywords": ["google"],
		"engines": { "node": ">=18" },
		"author": "Google, LLC",
		"license": "Apache-2.0",
		"devDependencies": {
			"@babel/plugin-proposal-private-methods": "^7.18.6",
			"@types/cors": "^2.8.6",
			"@types/express": "^5.0.0",
			"@types/extend": "^3.0.1",
			"@types/mocha": "^10.0.10",
			"@types/multiparty": "4.2.1",
			"@types/mv": "^2.1.0",
			"@types/ncp": "^2.0.1",
			"@types/node": "^22.0.0",
			"@types/sinon": "^17.0.0",
			"@types/tmp": "0.2.6",
			"assert": "^2.0.0",
			"browserify": "^17.0.0",
			"c8": "^10.0.0",
			"cors": "^2.8.5",
			"express": "^5.0.0",
			"gts": "^6.0.0",
			"is-docker": "^3.0.0",
			"jsdoc": "^4.0.0",
			"jsdoc-fresh": "^5.0.0",
			"jsdoc-region-tag": "^4.0.0",
			"karma": "^6.0.0",
			"karma-chrome-launcher": "^3.0.0",
			"karma-coverage": "^2.0.0",
			"karma-firefox-launcher": "^2.0.0",
			"karma-mocha": "^2.0.0",
			"karma-remap-coverage": "^0.1.5",
			"karma-sourcemap-loader": "^0.4.0",
			"karma-webpack": "^5.0.1",
			"linkinator": "^6.1.2",
			"mocha": "^11.1.0",
			"multiparty": "^4.2.1",
			"mv": "^2.1.1",
			"ncp": "^2.0.0",
			"nock": "^14.0.0-beta.13",
			"null-loader": "^4.0.0",
			"pack-n-play": "^4.0.0",
			"puppeteer": "^24.0.0",
			"sinon": "^21.0.0",
			"stream-browserify": "^3.0.0",
			"tmp": "0.2.5",
			"ts-loader": "^9.5.2",
			"typescript": "^5.8.3",
			"webpack": "^5.35.0",
			"webpack-cli": "^6.0.1"
		},
		"dependencies": {
			"extend": "^3.0.2",
			"https-proxy-agent": "^7.0.1",
			"node-fetch": "^3.3.2",
			"rimraf": "^5.0.1"
		},
		"homepage": "https://github.com/googleapis/google-cloud-node-core/tree/main/packages/gaxios"
	};
}));

//#endregion
//#region node_modules/gaxios/build/cjs/src/util.cjs
var require_util$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const pkg$2 = require_package$1();
	module.exports = { pkg: pkg$2 };
}));

//#endregion
//#region node_modules/gaxios/build/cjs/src/common.js
var require_common$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __importDefault$3 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GaxiosError = exports.GAXIOS_ERROR_SYMBOL = void 0;
	exports.defaultErrorRedactor = defaultErrorRedactor;
	const extend_1$1 = __importDefault$3(require_extend());
	const pkg$1 = __importDefault$3(require_util$1()).default.pkg;
	/**
	* Support `instanceof` operator for `GaxiosError`s in different versions of this library.
	*
	* @see {@link GaxiosError[Symbol.hasInstance]}
	*/
	exports.GAXIOS_ERROR_SYMBOL = Symbol.for(`${pkg$1.name}-gaxios-error`);
	var GaxiosError = class GaxiosError extends Error {
		config;
		response;
		/**
		* An error code.
		* Can be a system error code, DOMException error name, or any error's 'code' property where it is a `string`.
		*
		* It is only a `number` when the cause is sourced from an API-level error (AIP-193).
		*
		* @see {@link https://nodejs.org/api/errors.html#errorcode error.code}
		* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMException#error_names DOMException#error_names}
		* @see {@link https://google.aip.dev/193#http11json-representation AIP-193}
		*
		* @example
		* 'ECONNRESET'
		*
		* @example
		* 'TimeoutError'
		*
		* @example
		* 500
		*/
		code;
		/**
		* An HTTP Status code.
		* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Response/status Response#status}
		*
		* @example
		* 500
		*/
		status;
		/**
		* @deprecated use {@link GaxiosError.cause} instead.
		*
		* @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause Error#cause}
		*
		* @privateRemarks
		*
		* We will want to remove this property later as the modern `cause` property is better suited
		* for displaying and relaying nested errors. Keeping this here makes the resulting
		* error log larger than it needs to be.
		*
		*/
		error;
		/**
		* Support `instanceof` operator for `GaxiosError` across builds/duplicated files.
		*
		* @see {@link GAXIOS_ERROR_SYMBOL}
		* @see {@link GaxiosError[Symbol.hasInstance]}
		* @see {@link https://github.com/microsoft/TypeScript/issues/13965#issuecomment-278570200}
		* @see {@link https://stackoverflow.com/questions/46618852/require-and-instanceof}
		* @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/@@hasInstance#reverting_to_default_instanceof_behavior}
		*/
		[exports.GAXIOS_ERROR_SYMBOL] = pkg$1.version;
		/**
		* Support `instanceof` operator for `GaxiosError` across builds/duplicated files.
		*
		* @see {@link GAXIOS_ERROR_SYMBOL}
		* @see {@link GaxiosError[GAXIOS_ERROR_SYMBOL]}
		*/
		static [Symbol.hasInstance](instance$1) {
			if (instance$1 && typeof instance$1 === "object" && exports.GAXIOS_ERROR_SYMBOL in instance$1 && instance$1[exports.GAXIOS_ERROR_SYMBOL] === pkg$1.version) return true;
			return Function.prototype[Symbol.hasInstance].call(GaxiosError, instance$1);
		}
		constructor(message, config, response, cause) {
			super(message, { cause });
			this.config = config;
			this.response = response;
			this.error = cause instanceof Error ? cause : void 0;
			this.config = (0, extend_1$1.default)(true, {}, config);
			if (this.response) this.response.config = (0, extend_1$1.default)(true, {}, this.response.config);
			if (this.response) {
				try {
					this.response.data = translateData(this.config.responseType, this.response?.bodyUsed ? this.response?.data : void 0);
				} catch {}
				this.status = this.response.status;
			}
			if (cause instanceof DOMException) this.code = cause.name;
			else if (cause && typeof cause === "object" && "code" in cause && (typeof cause.code === "string" || typeof cause.code === "number")) this.code = cause.code;
		}
		/**
		* An AIP-193 conforming error extractor.
		*
		* @see {@link https://google.aip.dev/193#http11json-representation AIP-193}
		*
		* @internal
		* @expiremental
		*
		* @param res the response object
		* @returns the extracted error information
		*/
		static extractAPIErrorFromResponse(res, defaultErrorMessage = "The request failed") {
			let message = defaultErrorMessage;
			if (typeof res.data === "string") message = res.data;
			if (res.data && typeof res.data === "object" && "error" in res.data && res.data.error && !res.ok) {
				if (typeof res.data.error === "string") return {
					message: res.data.error,
					code: res.status,
					status: res.statusText
				};
				if (typeof res.data.error === "object") {
					message = "message" in res.data.error && typeof res.data.error.message === "string" ? res.data.error.message : message;
					const status = "status" in res.data.error && typeof res.data.error.status === "string" ? res.data.error.status : res.statusText;
					const code$1 = "code" in res.data.error && typeof res.data.error.code === "number" ? res.data.error.code : res.status;
					if ("errors" in res.data.error && Array.isArray(res.data.error.errors)) {
						const errorMessages = [];
						for (const e$1 of res.data.error.errors) if (typeof e$1 === "object" && "message" in e$1 && typeof e$1.message === "string") errorMessages.push(e$1.message);
						return Object.assign({
							message: errorMessages.join("\n") || message,
							code: code$1,
							status
						}, res.data.error);
					}
					return Object.assign({
						message,
						code: code$1,
						status
					}, res.data.error);
				}
			}
			return {
				message,
				code: res.status,
				status: res.statusText
			};
		}
	};
	exports.GaxiosError = GaxiosError;
	function translateData(responseType, data) {
		switch (responseType) {
			case "stream": return data;
			case "json": return JSON.parse(JSON.stringify(data));
			case "arraybuffer": return JSON.parse(Buffer.from(data).toString("utf8"));
			case "blob": return JSON.parse(data.text());
			default: return data;
		}
	}
	/**
	* An experimental error redactor.
	*
	* @param config Config to potentially redact properties of
	* @param response Config to potentially redact properties of
	*
	* @experimental
	*/
	function defaultErrorRedactor(data) {
		const REDACT = "<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.";
		function redactHeaders(headers) {
			if (!headers) return;
			headers.forEach((_, key) => {
				if (/^authentication$/i.test(key) || /^authorization$/i.test(key) || /secret/i.test(key)) headers.set(key, REDACT);
			});
		}
		function redactString(obj, key) {
			if (typeof obj === "object" && obj !== null && typeof obj[key] === "string") {
				const text = obj[key];
				if (/grant_type=/i.test(text) || /assertion=/i.test(text) || /secret/i.test(text)) obj[key] = REDACT;
			}
		}
		function redactObject(obj) {
			if (!obj || typeof obj !== "object") return;
			else if (obj instanceof FormData || obj instanceof URLSearchParams || "forEach" in obj && "set" in obj) obj.forEach((_, key) => {
				if (["grant_type", "assertion"].includes(key) || /secret/.test(key)) obj.set(key, REDACT);
			});
			else {
				if ("grant_type" in obj) obj["grant_type"] = REDACT;
				if ("assertion" in obj) obj["assertion"] = REDACT;
				if ("client_secret" in obj) obj["client_secret"] = REDACT;
			}
		}
		if (data.config) {
			redactHeaders(data.config.headers);
			redactString(data.config, "data");
			redactObject(data.config.data);
			redactString(data.config, "body");
			redactObject(data.config.body);
			if (data.config.url.searchParams.has("token")) data.config.url.searchParams.set("token", REDACT);
			if (data.config.url.searchParams.has("client_secret")) data.config.url.searchParams.set("client_secret", REDACT);
		}
		if (data.response) {
			defaultErrorRedactor({ config: data.response.config });
			redactHeaders(data.response.headers);
			if (data.response.bodyUsed) {
				redactString(data.response, "data");
				redactObject(data.response.data);
			}
		}
		return data;
	}
}));

//#endregion
//#region node_modules/gaxios/build/cjs/src/retry.js
var require_retry = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRetryConfig = getRetryConfig;
	async function getRetryConfig(err) {
		let config = getConfig(err);
		if (!err || !err.config || !config && !err.config.retry) return { shouldRetry: false };
		config = config || {};
		config.currentRetryAttempt = config.currentRetryAttempt || 0;
		config.retry = config.retry === void 0 || config.retry === null ? 3 : config.retry;
		config.httpMethodsToRetry = config.httpMethodsToRetry || [
			"GET",
			"HEAD",
			"PUT",
			"OPTIONS",
			"DELETE"
		];
		config.noResponseRetries = config.noResponseRetries === void 0 || config.noResponseRetries === null ? 2 : config.noResponseRetries;
		config.retryDelayMultiplier = config.retryDelayMultiplier ? config.retryDelayMultiplier : 2;
		config.timeOfFirstRequest = config.timeOfFirstRequest ? config.timeOfFirstRequest : Date.now();
		config.totalTimeout = config.totalTimeout ? config.totalTimeout : Number.MAX_SAFE_INTEGER;
		config.maxRetryDelay = config.maxRetryDelay ? config.maxRetryDelay : Number.MAX_SAFE_INTEGER;
		config.statusCodesToRetry = config.statusCodesToRetry || [
			[100, 199],
			[408, 408],
			[429, 429],
			[500, 599]
		];
		err.config.retryConfig = config;
		if (!await (config.shouldRetry || shouldRetryRequest)(err)) return {
			shouldRetry: false,
			config: err.config
		};
		const delay = getNextRetryDelay(config);
		err.config.retryConfig.currentRetryAttempt += 1;
		const backoff = config.retryBackoff ? config.retryBackoff(err, delay) : new Promise((resolve) => {
			setTimeout(resolve, delay);
		});
		if (config.onRetryAttempt) await config.onRetryAttempt(err);
		await backoff;
		return {
			shouldRetry: true,
			config: err.config
		};
	}
	/**
	* Determine based on config if we should retry the request.
	* @param err The GaxiosError passed to the interceptor.
	*/
	function shouldRetryRequest(err) {
		const config = getConfig(err);
		if (err.config.signal?.aborted && err.code !== "TimeoutError" || err.code === "AbortError") return false;
		if (!config || config.retry === 0) return false;
		if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) return false;
		if (!config.httpMethodsToRetry || !config.httpMethodsToRetry.includes(err.config.method?.toUpperCase() || "GET")) return false;
		if (err.response && err.response.status) {
			let isInRange = false;
			for (const [min, max] of config.statusCodesToRetry) {
				const status = err.response.status;
				if (status >= min && status <= max) {
					isInRange = true;
					break;
				}
			}
			if (!isInRange) return false;
		}
		config.currentRetryAttempt = config.currentRetryAttempt || 0;
		if (config.currentRetryAttempt >= config.retry) return false;
		return true;
	}
	/**
	* Acquire the raxConfig object from an GaxiosError if available.
	* @param err The Gaxios error with a config object.
	*/
	function getConfig(err) {
		if (err && err.config && err.config.retryConfig) return err.config.retryConfig;
	}
	/**
	* Gets the delay to wait before the next retry.
	*
	* @param {RetryConfig} config The current set of retry options
	* @returns {number} the amount of ms to wait before the next retry attempt.
	*/
	function getNextRetryDelay(config) {
		const calculatedDelay = (config.currentRetryAttempt ? 0 : config.retryDelay ?? 100) + (Math.pow(config.retryDelayMultiplier, config.currentRetryAttempt) - 1) / 2 * 1e3;
		const maxAllowableDelay = config.totalTimeout - (Date.now() - config.timeOfFirstRequest);
		return Math.min(calculatedDelay, maxAllowableDelay, config.maxRetryDelay);
	}
}));

//#endregion
//#region node_modules/gaxios/build/cjs/src/interceptor.js
var require_interceptor = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GaxiosInterceptorManager = void 0;
	/**
	* Class to manage collections of GaxiosInterceptors for both requests and responses.
	*/
	var GaxiosInterceptorManager = class extends Set {};
	exports.GaxiosInterceptorManager = GaxiosInterceptorManager;
}));

//#endregion
//#region node_modules/ms/index.js
var require_ms = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Helpers.
	*/
	var s$1 = 1e3;
	var m$1 = s$1 * 60;
	var h$1 = m$1 * 60;
	var d = h$1 * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$3(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$3(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h$1;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m$1;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s$1;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return Math.round(ms / d) + "d";
		if (msAbs >= h$1) return Math.round(ms / h$1) + "h";
		if (msAbs >= m$1) return Math.round(ms / m$1) + "m";
		if (msAbs >= s$1) return Math.round(ms / s$1) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return plural(ms, msAbs, d, "day");
		if (msAbs >= h$1) return plural(ms, msAbs, h$1, "hour");
		if (msAbs >= m$1) return plural(ms, msAbs, m$1, "minute");
		if (msAbs >= s$1) return plural(ms, msAbs, s$1, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
	}
}));

//#endregion
//#region node_modules/debug/src/common.js
var require_common = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		createDebug.destroy = destroy$1;
		Object.keys(env).forEach((key) => {
			createDebug[key] = env[key];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug.names = [];
		createDebug.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;
			for (let i$2 = 0; i$2 < namespace.length; i$2++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i$2);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$4(...args) {
				if (!debug$4.enabled) return;
				const self$1 = debug$4;
				const curr = Number(/* @__PURE__ */ new Date());
				self$1.diff = curr - (prevTime || curr);
				self$1.prev = prevTime;
				self$1.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format$2) => {
					if (match === "%%") return "%";
					index++;
					const formatter = createDebug.formatters[format$2];
					if (typeof formatter === "function") {
						const val = args[index];
						match = formatter.call(self$1, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug.formatArgs.call(self$1, args);
				(self$1.log || createDebug.log).apply(self$1, args);
			}
			debug$4.namespace = namespace;
			debug$4.useColors = createDebug.useColors();
			debug$4.color = createDebug.selectColor(namespace);
			debug$4.extend = extend;
			debug$4.destroy = createDebug.destroy;
			Object.defineProperty(debug$4, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug$4);
			return debug$4;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy$1() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
}));

//#endregion
//#region node_modules/debug/src/browser.js
var require_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*/
	exports.formatArgs = formatArgs$1;
	exports.save = save$1;
	exports.load = load$1;
	exports.useColors = useColors$1;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
			}
		};
	})();
	/**
	* Colors.
	*/
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors$1() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		let m$2;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$2[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs$1(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match) => {
			if (match === "%%") return;
			index++;
			if (match === "%c") lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.debug()` when available.
	* No-op when `console.debug` is not a "function".
	* If `console.debug` is not available, falls back
	* to `console.log`.
	*
	* @api public
	*/
	exports.log = console.debug || console.log || (() => {});
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save$1(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error$1) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load$1() {
		let r$1;
		try {
			r$1 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
		} catch (error$1) {}
		if (!r$1 && typeof process !== "undefined" && "env" in process) r$1 = process.env.DEBUG;
		return r$1;
	}
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return localStorage;
		} catch (error$1) {}
	}
	module.exports = require_common()(exports);
	const { formatters: formatters$1 } = module.exports;
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	formatters$1.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error$1) {
			return "[UnexpectedJSONParseError]: " + error$1.message;
		}
	};
}));

//#endregion
//#region node_modules/debug/src/node.js
var require_node = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	const tty = require("tty");
	const util$5 = require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*/
	exports.init = init;
	exports.log = log$2;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.destroy = util$5.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		const supportsColor = require("supports-color");
		if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	} catch (error$1) {}
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter((key) => {
		return /^debug_/i.test(key);
	}).reduce((obj, key) => {
		const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});
		let val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
	}
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		const { namespace: name, useColors: useColors$2 } = this;
		if (useColors$2) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name + " " + args[0];
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) return "";
		return (/* @__PURE__ */ new Date()).toISOString() + " ";
	}
	/**
	* Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	*/
	function log$2(...args) {
		return process.stderr.write(util$5.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (namespaces) process.env.DEBUG = namespaces;
		else delete process.env.DEBUG;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug$4) {
		debug$4.inspectOpts = {};
		const keys = Object.keys(exports.inspectOpts);
		for (let i$2 = 0; i$2 < keys.length; i$2++) debug$4.inspectOpts[keys[i$2]] = exports.inspectOpts[keys[i$2]];
	}
	module.exports = require_common()(exports);
	const { formatters } = module.exports;
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$5.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	};
	/**
	* Map %O to `util.inspect()`, allowing multiple lines if needed.
	*/
	formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$5.inspect(v, this.inspectOpts);
	};
}));

//#endregion
//#region node_modules/debug/src/index.js
var require_src$5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Detect Electron renderer / nwjs process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) module.exports = require_browser();
	else module.exports = require_node();
}));

//#endregion
//#region node_modules/agent-base/dist/helpers.js
var require_helpers = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$7 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$4 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$4 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$7(result, mod, k);
		}
		__setModuleDefault$4(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.req = exports.json = exports.toBuffer = void 0;
	const http$5 = __importStar$4(require("http"));
	const https$3 = __importStar$4(require("https"));
	async function toBuffer$4(stream$6) {
		let length = 0;
		const chunks = [];
		for await (const chunk of stream$6) {
			length += chunk.length;
			chunks.push(chunk);
		}
		return Buffer.concat(chunks, length);
	}
	exports.toBuffer = toBuffer$4;
	async function json(stream$6) {
		const str = (await toBuffer$4(stream$6)).toString("utf8");
		try {
			return JSON.parse(str);
		} catch (_err) {
			const err = _err;
			err.message += ` (input: ${str})`;
			throw err;
		}
	}
	exports.json = json;
	function req(url, opts = {}) {
		const req$1 = ((typeof url === "string" ? url : url.href).startsWith("https:") ? https$3 : http$5).request(url, opts);
		const promise = new Promise((resolve, reject) => {
			req$1.once("response", resolve).once("error", reject).end();
		});
		req$1.then = promise.then.bind(promise);
		return req$1;
	}
	exports.req = req;
}));

//#endregion
//#region node_modules/agent-base/dist/index.js
var require_dist$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$6 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$3 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$3 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$6(result, mod, k);
		}
		__setModuleDefault$3(result, mod);
		return result;
	};
	var __exportStar$4 = exports && exports.__exportStar || function(m$2, exports$1) {
		for (var p in m$2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$6(exports$1, m$2, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Agent = void 0;
	const net$2 = __importStar$3(require("net"));
	const http$4 = __importStar$3(require("http"));
	const https_1$1 = require("https");
	__exportStar$4(require_helpers(), exports);
	const INTERNAL = Symbol("AgentBaseInternalState");
	var Agent = class extends http$4.Agent {
		constructor(opts) {
			super(opts);
			this[INTERNAL] = {};
		}
		/**
		* Determine whether this is an `http` or `https` request.
		*/
		isSecureEndpoint(options) {
			if (options) {
				if (typeof options.secureEndpoint === "boolean") return options.secureEndpoint;
				if (typeof options.protocol === "string") return options.protocol === "https:";
			}
			const { stack } = /* @__PURE__ */ new Error();
			if (typeof stack !== "string") return false;
			return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
		}
		incrementSockets(name) {
			if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) return null;
			if (!this.sockets[name]) this.sockets[name] = [];
			const fakeSocket = new net$2.Socket({ writable: false });
			this.sockets[name].push(fakeSocket);
			this.totalSocketCount++;
			return fakeSocket;
		}
		decrementSockets(name, socket) {
			if (!this.sockets[name] || socket === null) return;
			const sockets = this.sockets[name];
			const index = sockets.indexOf(socket);
			if (index !== -1) {
				sockets.splice(index, 1);
				this.totalSocketCount--;
				if (sockets.length === 0) delete this.sockets[name];
			}
		}
		getName(options) {
			if (this.isSecureEndpoint(options)) return https_1$1.Agent.prototype.getName.call(this, options);
			return super.getName(options);
		}
		createSocket(req$1, options, cb) {
			const connectOpts = {
				...options,
				secureEndpoint: this.isSecureEndpoint(options)
			};
			const name = this.getName(connectOpts);
			const fakeSocket = this.incrementSockets(name);
			Promise.resolve().then(() => this.connect(req$1, connectOpts)).then((socket) => {
				this.decrementSockets(name, fakeSocket);
				if (socket instanceof http$4.Agent) try {
					return socket.addRequest(req$1, connectOpts);
				} catch (err) {
					return cb(err);
				}
				this[INTERNAL].currentSocket = socket;
				super.createSocket(req$1, options, cb);
			}, (err) => {
				this.decrementSockets(name, fakeSocket);
				cb(err);
			});
		}
		createConnection() {
			const socket = this[INTERNAL].currentSocket;
			this[INTERNAL].currentSocket = void 0;
			if (!socket) throw new Error("No socket was returned in the `connect()` function");
			return socket;
		}
		get defaultPort() {
			return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
		}
		set defaultPort(v) {
			if (this[INTERNAL]) this[INTERNAL].defaultPort = v;
		}
		get protocol() {
			return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
		}
		set protocol(v) {
			if (this[INTERNAL]) this[INTERNAL].protocol = v;
		}
	};
	exports.Agent = Agent;
}));

//#endregion
//#region node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __importDefault$2 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseProxyResponse = void 0;
	const debug$1 = (0, __importDefault$2(require_src$5()).default)("https-proxy-agent:parse-proxy-response");
	function parseProxyResponse(socket) {
		return new Promise((resolve, reject) => {
			let buffersLength = 0;
			const buffers = [];
			function read() {
				const b = socket.read();
				if (b) ondata(b);
				else socket.once("readable", read);
			}
			function cleanup() {
				socket.removeListener("end", onend);
				socket.removeListener("error", onerror);
				socket.removeListener("readable", read);
			}
			function onend() {
				cleanup();
				debug$1("onend");
				reject(/* @__PURE__ */ new Error("Proxy connection ended before receiving CONNECT response"));
			}
			function onerror(err) {
				cleanup();
				debug$1("onerror %o", err);
				reject(err);
			}
			function ondata(b) {
				buffers.push(b);
				buffersLength += b.length;
				const buffered = Buffer.concat(buffers, buffersLength);
				const endOfHeaders = buffered.indexOf("\r\n\r\n");
				if (endOfHeaders === -1) {
					debug$1("have not received end of HTTP headers yet...");
					read();
					return;
				}
				const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
				const firstLine = headerParts.shift();
				if (!firstLine) {
					socket.destroy();
					return reject(/* @__PURE__ */ new Error("No header received from proxy CONNECT response"));
				}
				const firstLineParts = firstLine.split(" ");
				const statusCode = +firstLineParts[1];
				const statusText = firstLineParts.slice(2).join(" ");
				const headers = {};
				for (const header of headerParts) {
					if (!header) continue;
					const firstColon = header.indexOf(":");
					if (firstColon === -1) {
						socket.destroy();
						return reject(/* @__PURE__ */ new Error(`Invalid header from proxy CONNECT response: "${header}"`));
					}
					const key = header.slice(0, firstColon).toLowerCase();
					const value = header.slice(firstColon + 1).trimStart();
					const current = headers[key];
					if (typeof current === "string") headers[key] = [current, value];
					else if (Array.isArray(current)) current.push(value);
					else headers[key] = value;
				}
				debug$1("got proxy server response: %o %o", firstLine, headers);
				cleanup();
				resolve({
					connect: {
						statusCode,
						statusText,
						headers
					},
					buffered
				});
			}
			socket.on("error", onerror);
			socket.on("end", onend);
			read();
		});
	}
	exports.parseProxyResponse = parseProxyResponse;
}));

//#endregion
//#region node_modules/https-proxy-agent/dist/index.js
var require_dist = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$5 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$2 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$2 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$5(result, mod, k);
		}
		__setModuleDefault$2(result, mod);
		return result;
	};
	var __importDefault$1 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpsProxyAgent = void 0;
	const net$1 = __importStar$2(require("net"));
	const tls$1 = __importStar$2(require("tls"));
	const assert_1 = __importDefault$1(require("assert"));
	const debug_1 = __importDefault$1(require_src$5());
	const agent_base_1 = require_dist$1();
	const url_1 = require("url");
	const parse_proxy_response_1 = require_parse_proxy_response();
	const debug = (0, debug_1.default)("https-proxy-agent");
	const setServernameFromNonIpHost = (options) => {
		if (options.servername === void 0 && options.host && !net$1.isIP(options.host)) return {
			...options,
			servername: options.host
		};
		return options;
	};
	/**
	* The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
	* the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
	*
	* Outgoing HTTP requests are first tunneled through the proxy server using the
	* `CONNECT` HTTP request method to establish a connection to the proxy server,
	* and then the proxy server connects to the destination target and issues the
	* HTTP request from the proxy server.
	*
	* `https:` requests have their socket connection upgraded to TLS once
	* the connection to the proxy server has been established.
	*/
	var HttpsProxyAgent = class extends agent_base_1.Agent {
		constructor(proxy, opts) {
			super(opts);
			this.options = { path: void 0 };
			this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
			this.proxyHeaders = opts?.headers ?? {};
			debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
			const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
			const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
			this.connectOpts = {
				ALPNProtocols: ["http/1.1"],
				...opts ? omit(opts, "headers") : null,
				host,
				port
			};
		}
		/**
		* Called when the node-core HTTP client library is creating a
		* new HTTP request.
		*/
		async connect(req$1, opts) {
			const { proxy } = this;
			if (!opts.host) throw new TypeError("No \"host\" provided");
			let socket;
			if (proxy.protocol === "https:") {
				debug("Creating `tls.Socket`: %o", this.connectOpts);
				socket = tls$1.connect(setServernameFromNonIpHost(this.connectOpts));
			} else {
				debug("Creating `net.Socket`: %o", this.connectOpts);
				socket = net$1.connect(this.connectOpts);
			}
			const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
			const host = net$1.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
			let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
			if (proxy.username || proxy.password) {
				const auth$2 = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
				headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth$2).toString("base64")}`;
			}
			headers.Host = `${host}:${opts.port}`;
			if (!headers["Proxy-Connection"]) headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
			for (const name of Object.keys(headers)) payload += `${name}: ${headers[name]}\r\n`;
			const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
			socket.write(`${payload}\r\n`);
			const { connect: connect$2, buffered } = await proxyResponsePromise;
			req$1.emit("proxyConnect", connect$2);
			this.emit("proxyConnect", connect$2, req$1);
			if (connect$2.statusCode === 200) {
				req$1.once("socket", resume$1);
				if (opts.secureEndpoint) {
					debug("Upgrading socket connection to TLS");
					return tls$1.connect({
						...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
						socket
					});
				}
				return socket;
			}
			socket.destroy();
			const fakeSocket = new net$1.Socket({ writable: false });
			fakeSocket.readable = true;
			req$1.once("socket", (s$2) => {
				debug("Replaying proxy buffer for failed request");
				(0, assert_1.default)(s$2.listenerCount("data") > 0);
				s$2.push(buffered);
				s$2.push(null);
			});
			return fakeSocket;
		}
	};
	HttpsProxyAgent.protocols = ["http", "https"];
	exports.HttpsProxyAgent = HttpsProxyAgent;
	function resume$1(socket) {
		socket.resume();
	}
	function omit(obj, ...keys) {
		const ret = {};
		let key;
		for (key in obj) if (!keys.includes(key)) ret[key] = obj[key];
		return ret;
	}
}));

//#endregion
//#region node_modules/data-uri-to-buffer/dist/index.js
/**
* Returns a `Buffer` instance from the given data URI `uri`.
*
* @param {String} uri Data URI to turn into a Buffer instance
* @returns {Buffer} Buffer instance from Data URI
* @api public
*/
function dataUriToBuffer(uri) {
	if (!/^data:/i.test(uri)) throw new TypeError("`uri` does not appear to be a Data URI (must begin with \"data:\")");
	uri = uri.replace(/\r?\n/g, "");
	const firstComma = uri.indexOf(",");
	if (firstComma === -1 || firstComma <= 4) throw new TypeError("malformed data: URI");
	const meta = uri.substring(5, firstComma).split(";");
	let charset = "";
	let base64 = false;
	const type = meta[0] || "text/plain";
	let typeFull = type;
	for (let i$2 = 1; i$2 < meta.length; i$2++) if (meta[i$2] === "base64") base64 = true;
	else if (meta[i$2]) {
		typeFull += `;${meta[i$2]}`;
		if (meta[i$2].indexOf("charset=") === 0) charset = meta[i$2].substring(8);
	}
	if (!meta[0] && !charset.length) {
		typeFull += ";charset=US-ASCII";
		charset = "US-ASCII";
	}
	const encoding = base64 ? "base64" : "ascii";
	const data = unescape(uri.substring(firstComma + 1));
	const buffer$1 = Buffer.from(data, encoding);
	buffer$1.type = type;
	buffer$1.typeFull = typeFull;
	buffer$1.charset = charset;
	return buffer$1;
}
var dist_default;
var init_dist = __esmMin((() => {
	dist_default = dataUriToBuffer;
}));

//#endregion
//#region node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* @license
	* web-streams-polyfill v3.3.3
	* Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
	* This code is released under the MIT license.
	* SPDX-License-Identifier: MIT
	*/
	(function(global$1, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global$1 = typeof globalThis !== "undefined" ? globalThis : global$1 || self, factory(global$1.WebStreamsPolyfill = {}));
	})(exports, (function(exports$1) {
		"use strict";
		function noop$3() {}
		function typeIsObject(x$1) {
			return typeof x$1 === "object" && x$1 !== null || typeof x$1 === "function";
		}
		const rethrowAssertionErrorRejection = noop$3;
		function setFunctionName(fn, name) {
			try {
				Object.defineProperty(fn, "name", {
					value: name,
					configurable: true
				});
			} catch (_a$3) {}
		}
		const originalPromise = Promise;
		const originalPromiseThen = Promise.prototype.then;
		const originalPromiseReject = Promise.reject.bind(originalPromise);
		function newPromise(executor) {
			return new originalPromise(executor);
		}
		function promiseResolvedWith(value) {
			return newPromise((resolve) => resolve(value));
		}
		function promiseRejectedWith(reason) {
			return originalPromiseReject(reason);
		}
		function PerformPromiseThen(promise, onFulfilled, onRejected) {
			return originalPromiseThen.call(promise, onFulfilled, onRejected);
		}
		function uponPromise(promise, onFulfilled, onRejected) {
			PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
		}
		function uponFulfillment(promise, onFulfilled) {
			uponPromise(promise, onFulfilled);
		}
		function uponRejection(promise, onRejected) {
			uponPromise(promise, void 0, onRejected);
		}
		function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
			return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
		}
		function setPromiseIsHandledToTrue(promise) {
			PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
		}
		let _queueMicrotask = (callback) => {
			if (typeof queueMicrotask === "function") _queueMicrotask = queueMicrotask;
			else {
				const resolvedPromise = promiseResolvedWith(void 0);
				_queueMicrotask = (cb) => PerformPromiseThen(resolvedPromise, cb);
			}
			return _queueMicrotask(callback);
		};
		function reflectCall(F$1, V, args) {
			if (typeof F$1 !== "function") throw new TypeError("Argument is not a function");
			return Function.prototype.apply.call(F$1, V, args);
		}
		function promiseCall(F$1, V, args) {
			try {
				return promiseResolvedWith(reflectCall(F$1, V, args));
			} catch (value) {
				return promiseRejectedWith(value);
			}
		}
		const QUEUE_MAX_ARRAY_SIZE = 16384;
		/**
		* Simple queue structure.
		*
		* Avoids scalability issues with using a packed array directly by using
		* multiple arrays in a linked list and keeping the array size bounded.
		*/
		class SimpleQueue {
			constructor() {
				this._cursor = 0;
				this._size = 0;
				this._front = {
					_elements: [],
					_next: void 0
				};
				this._back = this._front;
				this._cursor = 0;
				this._size = 0;
			}
			get length() {
				return this._size;
			}
			push(element) {
				const oldBack = this._back;
				let newBack = oldBack;
				if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) newBack = {
					_elements: [],
					_next: void 0
				};
				oldBack._elements.push(element);
				if (newBack !== oldBack) {
					this._back = newBack;
					oldBack._next = newBack;
				}
				++this._size;
			}
			shift() {
				const oldFront = this._front;
				let newFront = oldFront;
				const oldCursor = this._cursor;
				let newCursor = oldCursor + 1;
				const elements = oldFront._elements;
				const element = elements[oldCursor];
				if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
					newFront = oldFront._next;
					newCursor = 0;
				}
				--this._size;
				this._cursor = newCursor;
				if (oldFront !== newFront) this._front = newFront;
				elements[oldCursor] = void 0;
				return element;
			}
			forEach(callback) {
				let i$2 = this._cursor;
				let node = this._front;
				let elements = node._elements;
				while (i$2 !== elements.length || node._next !== void 0) {
					if (i$2 === elements.length) {
						node = node._next;
						elements = node._elements;
						i$2 = 0;
						if (elements.length === 0) break;
					}
					callback(elements[i$2]);
					++i$2;
				}
			}
			peek() {
				const front = this._front;
				const cursor = this._cursor;
				return front._elements[cursor];
			}
		}
		const AbortSteps = Symbol("[[AbortSteps]]");
		const ErrorSteps = Symbol("[[ErrorSteps]]");
		const CancelSteps = Symbol("[[CancelSteps]]");
		const PullSteps = Symbol("[[PullSteps]]");
		const ReleaseSteps = Symbol("[[ReleaseSteps]]");
		function ReadableStreamReaderGenericInitialize(reader, stream$6) {
			reader._ownerReadableStream = stream$6;
			stream$6._reader = reader;
			if (stream$6._state === "readable") defaultReaderClosedPromiseInitialize(reader);
			else if (stream$6._state === "closed") defaultReaderClosedPromiseInitializeAsResolved(reader);
			else defaultReaderClosedPromiseInitializeAsRejected(reader, stream$6._storedError);
		}
		function ReadableStreamReaderGenericCancel(reader, reason) {
			const stream$6 = reader._ownerReadableStream;
			return ReadableStreamCancel(stream$6, reason);
		}
		function ReadableStreamReaderGenericRelease(reader) {
			const stream$6 = reader._ownerReadableStream;
			if (stream$6._state === "readable") defaultReaderClosedPromiseReject(reader, /* @__PURE__ */ new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
			else defaultReaderClosedPromiseResetToRejected(reader, /* @__PURE__ */ new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
			stream$6._readableStreamController[ReleaseSteps]();
			stream$6._reader = void 0;
			reader._ownerReadableStream = void 0;
		}
		function readerLockException(name) {
			return /* @__PURE__ */ new TypeError("Cannot " + name + " a stream using a released reader");
		}
		function defaultReaderClosedPromiseInitialize(reader) {
			reader._closedPromise = newPromise((resolve, reject) => {
				reader._closedPromise_resolve = resolve;
				reader._closedPromise_reject = reject;
			});
		}
		function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
			defaultReaderClosedPromiseInitialize(reader);
			defaultReaderClosedPromiseReject(reader, reason);
		}
		function defaultReaderClosedPromiseInitializeAsResolved(reader) {
			defaultReaderClosedPromiseInitialize(reader);
			defaultReaderClosedPromiseResolve(reader);
		}
		function defaultReaderClosedPromiseReject(reader, reason) {
			if (reader._closedPromise_reject === void 0) return;
			setPromiseIsHandledToTrue(reader._closedPromise);
			reader._closedPromise_reject(reason);
			reader._closedPromise_resolve = void 0;
			reader._closedPromise_reject = void 0;
		}
		function defaultReaderClosedPromiseResetToRejected(reader, reason) {
			defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
		}
		function defaultReaderClosedPromiseResolve(reader) {
			if (reader._closedPromise_resolve === void 0) return;
			reader._closedPromise_resolve(void 0);
			reader._closedPromise_resolve = void 0;
			reader._closedPromise_reject = void 0;
		}
		const NumberIsFinite = Number.isFinite || function(x$1) {
			return typeof x$1 === "number" && isFinite(x$1);
		};
		const MathTrunc = Math.trunc || function(v) {
			return v < 0 ? Math.ceil(v) : Math.floor(v);
		};
		function isDictionary(x$1) {
			return typeof x$1 === "object" || typeof x$1 === "function";
		}
		function assertDictionary(obj, context) {
			if (obj !== void 0 && !isDictionary(obj)) throw new TypeError(`${context} is not an object.`);
		}
		function assertFunction(x$1, context) {
			if (typeof x$1 !== "function") throw new TypeError(`${context} is not a function.`);
		}
		function isObject$1(x$1) {
			return typeof x$1 === "object" && x$1 !== null || typeof x$1 === "function";
		}
		function assertObject(x$1, context) {
			if (!isObject$1(x$1)) throw new TypeError(`${context} is not an object.`);
		}
		function assertRequiredArgument(x$1, position, context) {
			if (x$1 === void 0) throw new TypeError(`Parameter ${position} is required in '${context}'.`);
		}
		function assertRequiredField(x$1, field, context) {
			if (x$1 === void 0) throw new TypeError(`${field} is required in '${context}'.`);
		}
		function convertUnrestrictedDouble(value) {
			return Number(value);
		}
		function censorNegativeZero(x$1) {
			return x$1 === 0 ? 0 : x$1;
		}
		function integerPart(x$1) {
			return censorNegativeZero(MathTrunc(x$1));
		}
		function convertUnsignedLongLongWithEnforceRange(value, context) {
			const lowerBound = 0;
			const upperBound = Number.MAX_SAFE_INTEGER;
			let x$1 = Number(value);
			x$1 = censorNegativeZero(x$1);
			if (!NumberIsFinite(x$1)) throw new TypeError(`${context} is not a finite number`);
			x$1 = integerPart(x$1);
			if (x$1 < lowerBound || x$1 > upperBound) throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
			if (!NumberIsFinite(x$1) || x$1 === 0) return 0;
			return x$1;
		}
		function assertReadableStream(x$1, context) {
			if (!IsReadableStream(x$1)) throw new TypeError(`${context} is not a ReadableStream.`);
		}
		function AcquireReadableStreamDefaultReader(stream$6) {
			return new ReadableStreamDefaultReader(stream$6);
		}
		function ReadableStreamAddReadRequest(stream$6, readRequest) {
			stream$6._reader._readRequests.push(readRequest);
		}
		function ReadableStreamFulfillReadRequest(stream$6, chunk, done) {
			const readRequest = stream$6._reader._readRequests.shift();
			if (done) readRequest._closeSteps();
			else readRequest._chunkSteps(chunk);
		}
		function ReadableStreamGetNumReadRequests(stream$6) {
			return stream$6._reader._readRequests.length;
		}
		function ReadableStreamHasDefaultReader(stream$6) {
			const reader = stream$6._reader;
			if (reader === void 0) return false;
			if (!IsReadableStreamDefaultReader(reader)) return false;
			return true;
		}
		/**
		* A default reader vended by a {@link ReadableStream}.
		*
		* @public
		*/
		class ReadableStreamDefaultReader {
			constructor(stream$6) {
				assertRequiredArgument(stream$6, 1, "ReadableStreamDefaultReader");
				assertReadableStream(stream$6, "First parameter");
				if (IsReadableStreamLocked(stream$6)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
				ReadableStreamReaderGenericInitialize(this, stream$6);
				this._readRequests = new SimpleQueue();
			}
			/**
			* Returns a promise that will be fulfilled when the stream becomes closed,
			* or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
			*/
			get closed() {
				if (!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
				return this._closedPromise;
			}
			/**
			* If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
			*/
			cancel(reason = void 0) {
				if (!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
				if (this._ownerReadableStream === void 0) return promiseRejectedWith(readerLockException("cancel"));
				return ReadableStreamReaderGenericCancel(this, reason);
			}
			/**
			* Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
			*
			* If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
			*/
			read() {
				if (!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException("read"));
				if (this._ownerReadableStream === void 0) return promiseRejectedWith(readerLockException("read from"));
				let resolvePromise;
				let rejectPromise;
				const promise = newPromise((resolve, reject) => {
					resolvePromise = resolve;
					rejectPromise = reject;
				});
				ReadableStreamDefaultReaderRead(this, {
					_chunkSteps: (chunk) => resolvePromise({
						value: chunk,
						done: false
					}),
					_closeSteps: () => resolvePromise({
						value: void 0,
						done: true
					}),
					_errorSteps: (e$1) => rejectPromise(e$1)
				});
				return promise;
			}
			/**
			* Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
			* If the associated stream is errored when the lock is released, the reader will appear errored in the same way
			* from now on; otherwise, the reader will appear closed.
			*
			* A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
			* the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
			* do so will throw a `TypeError` and leave the reader locked to the stream.
			*/
			releaseLock() {
				if (!IsReadableStreamDefaultReader(this)) throw defaultReaderBrandCheckException("releaseLock");
				if (this._ownerReadableStream === void 0) return;
				ReadableStreamDefaultReaderRelease(this);
			}
		}
		Object.defineProperties(ReadableStreamDefaultReader.prototype, {
			cancel: { enumerable: true },
			read: { enumerable: true },
			releaseLock: { enumerable: true },
			closed: { enumerable: true }
		});
		setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
		setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
		setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock");
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
			value: "ReadableStreamDefaultReader",
			configurable: true
		});
		function IsReadableStreamDefaultReader(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_readRequests")) return false;
			return x$1 instanceof ReadableStreamDefaultReader;
		}
		function ReadableStreamDefaultReaderRead(reader, readRequest) {
			const stream$6 = reader._ownerReadableStream;
			stream$6._disturbed = true;
			if (stream$6._state === "closed") readRequest._closeSteps();
			else if (stream$6._state === "errored") readRequest._errorSteps(stream$6._storedError);
			else stream$6._readableStreamController[PullSteps](readRequest);
		}
		function ReadableStreamDefaultReaderRelease(reader) {
			ReadableStreamReaderGenericRelease(reader);
			ReadableStreamDefaultReaderErrorReadRequests(reader, /* @__PURE__ */ new TypeError("Reader was released"));
		}
		function ReadableStreamDefaultReaderErrorReadRequests(reader, e$1) {
			const readRequests = reader._readRequests;
			reader._readRequests = new SimpleQueue();
			readRequests.forEach((readRequest) => {
				readRequest._errorSteps(e$1);
			});
		}
		function defaultReaderBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
		}
		const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);
		class ReadableStreamAsyncIteratorImpl {
			constructor(reader, preventCancel) {
				this._ongoingPromise = void 0;
				this._isFinished = false;
				this._reader = reader;
				this._preventCancel = preventCancel;
			}
			next() {
				const nextSteps = () => this._nextSteps();
				this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
				return this._ongoingPromise;
			}
			return(value) {
				const returnSteps = () => this._returnSteps(value);
				return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
			}
			_nextSteps() {
				if (this._isFinished) return Promise.resolve({
					value: void 0,
					done: true
				});
				const reader = this._reader;
				let resolvePromise;
				let rejectPromise;
				const promise = newPromise((resolve, reject) => {
					resolvePromise = resolve;
					rejectPromise = reject;
				});
				ReadableStreamDefaultReaderRead(reader, {
					_chunkSteps: (chunk) => {
						this._ongoingPromise = void 0;
						_queueMicrotask(() => resolvePromise({
							value: chunk,
							done: false
						}));
					},
					_closeSteps: () => {
						this._ongoingPromise = void 0;
						this._isFinished = true;
						ReadableStreamReaderGenericRelease(reader);
						resolvePromise({
							value: void 0,
							done: true
						});
					},
					_errorSteps: (reason) => {
						this._ongoingPromise = void 0;
						this._isFinished = true;
						ReadableStreamReaderGenericRelease(reader);
						rejectPromise(reason);
					}
				});
				return promise;
			}
			_returnSteps(value) {
				if (this._isFinished) return Promise.resolve({
					value,
					done: true
				});
				this._isFinished = true;
				const reader = this._reader;
				if (!this._preventCancel) {
					const result = ReadableStreamReaderGenericCancel(reader, value);
					ReadableStreamReaderGenericRelease(reader);
					return transformPromiseWith(result, () => ({
						value,
						done: true
					}));
				}
				ReadableStreamReaderGenericRelease(reader);
				return promiseResolvedWith({
					value,
					done: true
				});
			}
		}
		const ReadableStreamAsyncIteratorPrototype = {
			next() {
				if (!IsReadableStreamAsyncIterator(this)) return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
				return this._asyncIteratorImpl.next();
			},
			return(value) {
				if (!IsReadableStreamAsyncIterator(this)) return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
				return this._asyncIteratorImpl.return(value);
			}
		};
		Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
		function AcquireReadableStreamAsyncIterator(stream$6, preventCancel) {
			const impl = new ReadableStreamAsyncIteratorImpl(AcquireReadableStreamDefaultReader(stream$6), preventCancel);
			const iterator$1 = Object.create(ReadableStreamAsyncIteratorPrototype);
			iterator$1._asyncIteratorImpl = impl;
			return iterator$1;
		}
		function IsReadableStreamAsyncIterator(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_asyncIteratorImpl")) return false;
			try {
				return x$1._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
			} catch (_a$3) {
				return false;
			}
		}
		function streamAsyncIteratorBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
		}
		const NumberIsNaN = Number.isNaN || function(x$1) {
			return x$1 !== x$1;
		};
		var _a$2, _b, _c;
		function CreateArrayFromList(elements) {
			return elements.slice();
		}
		function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
			new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
		}
		let TransferArrayBuffer = (O) => {
			if (typeof O.transfer === "function") TransferArrayBuffer = (buffer$1) => buffer$1.transfer();
			else if (typeof structuredClone === "function") TransferArrayBuffer = (buffer$1) => structuredClone(buffer$1, { transfer: [buffer$1] });
			else TransferArrayBuffer = (buffer$1) => buffer$1;
			return TransferArrayBuffer(O);
		};
		let IsDetachedBuffer = (O) => {
			if (typeof O.detached === "boolean") IsDetachedBuffer = (buffer$1) => buffer$1.detached;
			else IsDetachedBuffer = (buffer$1) => buffer$1.byteLength === 0;
			return IsDetachedBuffer(O);
		};
		function ArrayBufferSlice(buffer$1, begin, end) {
			if (buffer$1.slice) return buffer$1.slice(begin, end);
			const length = end - begin;
			const slice = new ArrayBuffer(length);
			CopyDataBlockBytes(slice, 0, buffer$1, begin, length);
			return slice;
		}
		function GetMethod(receiver, prop) {
			const func = receiver[prop];
			if (func === void 0 || func === null) return;
			if (typeof func !== "function") throw new TypeError(`${String(prop)} is not a function`);
			return func;
		}
		function CreateAsyncFromSyncIterator(syncIteratorRecord) {
			const syncIterable = { [Symbol.iterator]: () => syncIteratorRecord.iterator };
			const asyncIterator = async function* () {
				return yield* syncIterable;
			}();
			return {
				iterator: asyncIterator,
				nextMethod: asyncIterator.next,
				done: false
			};
		}
		const SymbolAsyncIterator = (_c = (_a$2 = Symbol.asyncIterator) !== null && _a$2 !== void 0 ? _a$2 : (_b = Symbol.for) === null || _b === void 0 ? void 0 : _b.call(Symbol, "Symbol.asyncIterator")) !== null && _c !== void 0 ? _c : "@@asyncIterator";
		function GetIterator(obj, hint = "sync", method) {
			if (method === void 0) if (hint === "async") {
				method = GetMethod(obj, SymbolAsyncIterator);
				if (method === void 0) return CreateAsyncFromSyncIterator(GetIterator(obj, "sync", GetMethod(obj, Symbol.iterator)));
			} else method = GetMethod(obj, Symbol.iterator);
			if (method === void 0) throw new TypeError("The object is not iterable");
			const iterator$1 = reflectCall(method, obj, []);
			if (!typeIsObject(iterator$1)) throw new TypeError("The iterator method must return an object");
			return {
				iterator: iterator$1,
				nextMethod: iterator$1.next,
				done: false
			};
		}
		function IteratorNext(iteratorRecord) {
			const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
			if (!typeIsObject(result)) throw new TypeError("The iterator.next() method must return an object");
			return result;
		}
		function IteratorComplete(iterResult) {
			return Boolean(iterResult.done);
		}
		function IteratorValue(iterResult) {
			return iterResult.value;
		}
		function IsNonNegativeNumber(v) {
			if (typeof v !== "number") return false;
			if (NumberIsNaN(v)) return false;
			if (v < 0) return false;
			return true;
		}
		function CloneAsUint8Array(O) {
			const buffer$1 = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
			return new Uint8Array(buffer$1);
		}
		function DequeueValue(container) {
			const pair = container._queue.shift();
			container._queueTotalSize -= pair.size;
			if (container._queueTotalSize < 0) container._queueTotalSize = 0;
			return pair.value;
		}
		function EnqueueValueWithSize(container, value, size) {
			if (!IsNonNegativeNumber(size) || size === Infinity) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
			container._queue.push({
				value,
				size
			});
			container._queueTotalSize += size;
		}
		function PeekQueueValue(container) {
			return container._queue.peek().value;
		}
		function ResetQueue(container) {
			container._queue = new SimpleQueue();
			container._queueTotalSize = 0;
		}
		function isDataViewConstructor(ctor) {
			return ctor === DataView;
		}
		function isDataView(view) {
			return isDataViewConstructor(view.constructor);
		}
		function arrayBufferViewElementSize(ctor) {
			if (isDataViewConstructor(ctor)) return 1;
			return ctor.BYTES_PER_ELEMENT;
		}
		/**
		* A pull-into request in a {@link ReadableByteStreamController}.
		*
		* @public
		*/
		class ReadableStreamBYOBRequest {
			constructor() {
				throw new TypeError("Illegal constructor");
			}
			/**
			* Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
			*/
			get view() {
				if (!IsReadableStreamBYOBRequest(this)) throw byobRequestBrandCheckException("view");
				return this._view;
			}
			respond(bytesWritten) {
				if (!IsReadableStreamBYOBRequest(this)) throw byobRequestBrandCheckException("respond");
				assertRequiredArgument(bytesWritten, 1, "respond");
				bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
				if (this._associatedReadableByteStreamController === void 0) throw new TypeError("This BYOB request has been invalidated");
				if (IsDetachedBuffer(this._view.buffer)) throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
				ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
			}
			respondWithNewView(view) {
				if (!IsReadableStreamBYOBRequest(this)) throw byobRequestBrandCheckException("respondWithNewView");
				assertRequiredArgument(view, 1, "respondWithNewView");
				if (!ArrayBuffer.isView(view)) throw new TypeError("You can only respond with array buffer views");
				if (this._associatedReadableByteStreamController === void 0) throw new TypeError("This BYOB request has been invalidated");
				if (IsDetachedBuffer(view.buffer)) throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
				ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
			}
		}
		Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
			respond: { enumerable: true },
			respondWithNewView: { enumerable: true },
			view: { enumerable: true }
		});
		setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
		setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView");
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
			value: "ReadableStreamBYOBRequest",
			configurable: true
		});
		/**
		* Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
		*
		* @public
		*/
		class ReadableByteStreamController {
			constructor() {
				throw new TypeError("Illegal constructor");
			}
			/**
			* Returns the current BYOB pull request, or `null` if there isn't one.
			*/
			get byobRequest() {
				if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("byobRequest");
				return ReadableByteStreamControllerGetBYOBRequest(this);
			}
			/**
			* Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
			* over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
			*/
			get desiredSize() {
				if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("desiredSize");
				return ReadableByteStreamControllerGetDesiredSize(this);
			}
			/**
			* Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
			* the stream, but once those are read, the stream will become closed.
			*/
			close() {
				if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("close");
				if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
				const state = this._controlledReadableByteStream._state;
				if (state !== "readable") throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
				ReadableByteStreamControllerClose(this);
			}
			enqueue(chunk) {
				if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("enqueue");
				assertRequiredArgument(chunk, 1, "enqueue");
				if (!ArrayBuffer.isView(chunk)) throw new TypeError("chunk must be an array buffer view");
				if (chunk.byteLength === 0) throw new TypeError("chunk must have non-zero byteLength");
				if (chunk.buffer.byteLength === 0) throw new TypeError(`chunk's buffer must have non-zero byteLength`);
				if (this._closeRequested) throw new TypeError("stream is closed or draining");
				const state = this._controlledReadableByteStream._state;
				if (state !== "readable") throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
				ReadableByteStreamControllerEnqueue(this, chunk);
			}
			/**
			* Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
			*/
			error(e$1 = void 0) {
				if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("error");
				ReadableByteStreamControllerError(this, e$1);
			}
			/** @internal */
			[CancelSteps](reason) {
				ReadableByteStreamControllerClearPendingPullIntos(this);
				ResetQueue(this);
				const result = this._cancelAlgorithm(reason);
				ReadableByteStreamControllerClearAlgorithms(this);
				return result;
			}
			/** @internal */
			[PullSteps](readRequest) {
				const stream$6 = this._controlledReadableByteStream;
				if (this._queueTotalSize > 0) {
					ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
					return;
				}
				const autoAllocateChunkSize = this._autoAllocateChunkSize;
				if (autoAllocateChunkSize !== void 0) {
					let buffer$1;
					try {
						buffer$1 = new ArrayBuffer(autoAllocateChunkSize);
					} catch (bufferE) {
						readRequest._errorSteps(bufferE);
						return;
					}
					const pullIntoDescriptor = {
						buffer: buffer$1,
						bufferByteLength: autoAllocateChunkSize,
						byteOffset: 0,
						byteLength: autoAllocateChunkSize,
						bytesFilled: 0,
						minimumFill: 1,
						elementSize: 1,
						viewConstructor: Uint8Array,
						readerType: "default"
					};
					this._pendingPullIntos.push(pullIntoDescriptor);
				}
				ReadableStreamAddReadRequest(stream$6, readRequest);
				ReadableByteStreamControllerCallPullIfNeeded(this);
			}
			/** @internal */
			[ReleaseSteps]() {
				if (this._pendingPullIntos.length > 0) {
					const firstPullInto = this._pendingPullIntos.peek();
					firstPullInto.readerType = "none";
					this._pendingPullIntos = new SimpleQueue();
					this._pendingPullIntos.push(firstPullInto);
				}
			}
		}
		Object.defineProperties(ReadableByteStreamController.prototype, {
			close: { enumerable: true },
			enqueue: { enumerable: true },
			error: { enumerable: true },
			byobRequest: { enumerable: true },
			desiredSize: { enumerable: true }
		});
		setFunctionName(ReadableByteStreamController.prototype.close, "close");
		setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue");
		setFunctionName(ReadableByteStreamController.prototype.error, "error");
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
			value: "ReadableByteStreamController",
			configurable: true
		});
		function IsReadableByteStreamController(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_controlledReadableByteStream")) return false;
			return x$1 instanceof ReadableByteStreamController;
		}
		function IsReadableStreamBYOBRequest(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_associatedReadableByteStreamController")) return false;
			return x$1 instanceof ReadableStreamBYOBRequest;
		}
		function ReadableByteStreamControllerCallPullIfNeeded(controller) {
			if (!ReadableByteStreamControllerShouldCallPull(controller)) return;
			if (controller._pulling) {
				controller._pullAgain = true;
				return;
			}
			controller._pulling = true;
			uponPromise(controller._pullAlgorithm(), () => {
				controller._pulling = false;
				if (controller._pullAgain) {
					controller._pullAgain = false;
					ReadableByteStreamControllerCallPullIfNeeded(controller);
				}
				return null;
			}, (e$1) => {
				ReadableByteStreamControllerError(controller, e$1);
				return null;
			});
		}
		function ReadableByteStreamControllerClearPendingPullIntos(controller) {
			ReadableByteStreamControllerInvalidateBYOBRequest(controller);
			controller._pendingPullIntos = new SimpleQueue();
		}
		function ReadableByteStreamControllerCommitPullIntoDescriptor(stream$6, pullIntoDescriptor) {
			let done = false;
			if (stream$6._state === "closed") done = true;
			const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
			if (pullIntoDescriptor.readerType === "default") ReadableStreamFulfillReadRequest(stream$6, filledView, done);
			else ReadableStreamFulfillReadIntoRequest(stream$6, filledView, done);
		}
		function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
			const bytesFilled = pullIntoDescriptor.bytesFilled;
			const elementSize = pullIntoDescriptor.elementSize;
			return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
		}
		function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer$1, byteOffset, byteLength$1) {
			controller._queue.push({
				buffer: buffer$1,
				byteOffset,
				byteLength: byteLength$1
			});
			controller._queueTotalSize += byteLength$1;
		}
		function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer$1, byteOffset, byteLength$1) {
			let clonedChunk;
			try {
				clonedChunk = ArrayBufferSlice(buffer$1, byteOffset, byteOffset + byteLength$1);
			} catch (cloneE) {
				ReadableByteStreamControllerError(controller, cloneE);
				throw cloneE;
			}
			ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength$1);
		}
		function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
			if (firstDescriptor.bytesFilled > 0) ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
			ReadableByteStreamControllerShiftPendingPullInto(controller);
		}
		function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
			const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
			const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
			let totalBytesToCopyRemaining = maxBytesToCopy;
			let ready = false;
			const maxAlignedBytes = maxBytesFilled - maxBytesFilled % pullIntoDescriptor.elementSize;
			if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
				totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
				ready = true;
			}
			const queue = controller._queue;
			while (totalBytesToCopyRemaining > 0) {
				const headOfQueue = queue.peek();
				const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
				const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
				CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
				if (headOfQueue.byteLength === bytesToCopy) queue.shift();
				else {
					headOfQueue.byteOffset += bytesToCopy;
					headOfQueue.byteLength -= bytesToCopy;
				}
				controller._queueTotalSize -= bytesToCopy;
				ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
				totalBytesToCopyRemaining -= bytesToCopy;
			}
			return ready;
		}
		function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
			pullIntoDescriptor.bytesFilled += size;
		}
		function ReadableByteStreamControllerHandleQueueDrain(controller) {
			if (controller._queueTotalSize === 0 && controller._closeRequested) {
				ReadableByteStreamControllerClearAlgorithms(controller);
				ReadableStreamClose(controller._controlledReadableByteStream);
			} else ReadableByteStreamControllerCallPullIfNeeded(controller);
		}
		function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
			if (controller._byobRequest === null) return;
			controller._byobRequest._associatedReadableByteStreamController = void 0;
			controller._byobRequest._view = null;
			controller._byobRequest = null;
		}
		function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
			while (controller._pendingPullIntos.length > 0) {
				if (controller._queueTotalSize === 0) return;
				const pullIntoDescriptor = controller._pendingPullIntos.peek();
				if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
					ReadableByteStreamControllerShiftPendingPullInto(controller);
					ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
				}
			}
		}
		function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
			const reader = controller._controlledReadableByteStream._reader;
			while (reader._readRequests.length > 0) {
				if (controller._queueTotalSize === 0) return;
				ReadableByteStreamControllerFillReadRequestFromQueue(controller, reader._readRequests.shift());
			}
		}
		function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
			const stream$6 = controller._controlledReadableByteStream;
			const ctor = view.constructor;
			const elementSize = arrayBufferViewElementSize(ctor);
			const { byteOffset, byteLength: byteLength$1 } = view;
			const minimumFill = min * elementSize;
			let buffer$1;
			try {
				buffer$1 = TransferArrayBuffer(view.buffer);
			} catch (e$1) {
				readIntoRequest._errorSteps(e$1);
				return;
			}
			const pullIntoDescriptor = {
				buffer: buffer$1,
				bufferByteLength: buffer$1.byteLength,
				byteOffset,
				byteLength: byteLength$1,
				bytesFilled: 0,
				minimumFill,
				elementSize,
				viewConstructor: ctor,
				readerType: "byob"
			};
			if (controller._pendingPullIntos.length > 0) {
				controller._pendingPullIntos.push(pullIntoDescriptor);
				ReadableStreamAddReadIntoRequest(stream$6, readIntoRequest);
				return;
			}
			if (stream$6._state === "closed") {
				const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
				readIntoRequest._closeSteps(emptyView);
				return;
			}
			if (controller._queueTotalSize > 0) {
				if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
					const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
					ReadableByteStreamControllerHandleQueueDrain(controller);
					readIntoRequest._chunkSteps(filledView);
					return;
				}
				if (controller._closeRequested) {
					const e$1 = /* @__PURE__ */ new TypeError("Insufficient bytes to fill elements in the given buffer");
					ReadableByteStreamControllerError(controller, e$1);
					readIntoRequest._errorSteps(e$1);
					return;
				}
			}
			controller._pendingPullIntos.push(pullIntoDescriptor);
			ReadableStreamAddReadIntoRequest(stream$6, readIntoRequest);
			ReadableByteStreamControllerCallPullIfNeeded(controller);
		}
		function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
			if (firstDescriptor.readerType === "none") ReadableByteStreamControllerShiftPendingPullInto(controller);
			const stream$6 = controller._controlledReadableByteStream;
			if (ReadableStreamHasBYOBReader(stream$6)) while (ReadableStreamGetNumReadIntoRequests(stream$6) > 0) ReadableByteStreamControllerCommitPullIntoDescriptor(stream$6, ReadableByteStreamControllerShiftPendingPullInto(controller));
		}
		function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
			ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
			if (pullIntoDescriptor.readerType === "none") {
				ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
				ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
				return;
			}
			if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) return;
			ReadableByteStreamControllerShiftPendingPullInto(controller);
			const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
			if (remainderSize > 0) {
				const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
				ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
			}
			pullIntoDescriptor.bytesFilled -= remainderSize;
			ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
			ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
		}
		function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
			const firstDescriptor = controller._pendingPullIntos.peek();
			ReadableByteStreamControllerInvalidateBYOBRequest(controller);
			if (controller._controlledReadableByteStream._state === "closed") ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
			else ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
			ReadableByteStreamControllerCallPullIfNeeded(controller);
		}
		function ReadableByteStreamControllerShiftPendingPullInto(controller) {
			return controller._pendingPullIntos.shift();
		}
		function ReadableByteStreamControllerShouldCallPull(controller) {
			const stream$6 = controller._controlledReadableByteStream;
			if (stream$6._state !== "readable") return false;
			if (controller._closeRequested) return false;
			if (!controller._started) return false;
			if (ReadableStreamHasDefaultReader(stream$6) && ReadableStreamGetNumReadRequests(stream$6) > 0) return true;
			if (ReadableStreamHasBYOBReader(stream$6) && ReadableStreamGetNumReadIntoRequests(stream$6) > 0) return true;
			if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) return true;
			return false;
		}
		function ReadableByteStreamControllerClearAlgorithms(controller) {
			controller._pullAlgorithm = void 0;
			controller._cancelAlgorithm = void 0;
		}
		function ReadableByteStreamControllerClose(controller) {
			const stream$6 = controller._controlledReadableByteStream;
			if (controller._closeRequested || stream$6._state !== "readable") return;
			if (controller._queueTotalSize > 0) {
				controller._closeRequested = true;
				return;
			}
			if (controller._pendingPullIntos.length > 0) {
				const firstPendingPullInto = controller._pendingPullIntos.peek();
				if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
					const e$1 = /* @__PURE__ */ new TypeError("Insufficient bytes to fill elements in the given buffer");
					ReadableByteStreamControllerError(controller, e$1);
					throw e$1;
				}
			}
			ReadableByteStreamControllerClearAlgorithms(controller);
			ReadableStreamClose(stream$6);
		}
		function ReadableByteStreamControllerEnqueue(controller, chunk) {
			const stream$6 = controller._controlledReadableByteStream;
			if (controller._closeRequested || stream$6._state !== "readable") return;
			const { buffer: buffer$1, byteOffset, byteLength: byteLength$1 } = chunk;
			if (IsDetachedBuffer(buffer$1)) throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
			const transferredBuffer = TransferArrayBuffer(buffer$1);
			if (controller._pendingPullIntos.length > 0) {
				const firstPendingPullInto = controller._pendingPullIntos.peek();
				if (IsDetachedBuffer(firstPendingPullInto.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
				ReadableByteStreamControllerInvalidateBYOBRequest(controller);
				firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
				if (firstPendingPullInto.readerType === "none") ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
			}
			if (ReadableStreamHasDefaultReader(stream$6)) {
				ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
				if (ReadableStreamGetNumReadRequests(stream$6) === 0) ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength$1);
				else {
					if (controller._pendingPullIntos.length > 0) ReadableByteStreamControllerShiftPendingPullInto(controller);
					ReadableStreamFulfillReadRequest(stream$6, new Uint8Array(transferredBuffer, byteOffset, byteLength$1), false);
				}
			} else if (ReadableStreamHasBYOBReader(stream$6)) {
				ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength$1);
				ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
			} else ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength$1);
			ReadableByteStreamControllerCallPullIfNeeded(controller);
		}
		function ReadableByteStreamControllerError(controller, e$1) {
			const stream$6 = controller._controlledReadableByteStream;
			if (stream$6._state !== "readable") return;
			ReadableByteStreamControllerClearPendingPullIntos(controller);
			ResetQueue(controller);
			ReadableByteStreamControllerClearAlgorithms(controller);
			ReadableStreamError(stream$6, e$1);
		}
		function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
			const entry = controller._queue.shift();
			controller._queueTotalSize -= entry.byteLength;
			ReadableByteStreamControllerHandleQueueDrain(controller);
			const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
			readRequest._chunkSteps(view);
		}
		function ReadableByteStreamControllerGetBYOBRequest(controller) {
			if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
				const firstDescriptor = controller._pendingPullIntos.peek();
				const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
				const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
				SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
				controller._byobRequest = byobRequest;
			}
			return controller._byobRequest;
		}
		function ReadableByteStreamControllerGetDesiredSize(controller) {
			const state = controller._controlledReadableByteStream._state;
			if (state === "errored") return null;
			if (state === "closed") return 0;
			return controller._strategyHWM - controller._queueTotalSize;
		}
		function ReadableByteStreamControllerRespond(controller, bytesWritten) {
			const firstDescriptor = controller._pendingPullIntos.peek();
			if (controller._controlledReadableByteStream._state === "closed") {
				if (bytesWritten !== 0) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
			} else {
				if (bytesWritten === 0) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
				if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) throw new RangeError("bytesWritten out of range");
			}
			firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
			ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
		}
		function ReadableByteStreamControllerRespondWithNewView(controller, view) {
			const firstDescriptor = controller._pendingPullIntos.peek();
			if (controller._controlledReadableByteStream._state === "closed") {
				if (view.byteLength !== 0) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
			} else if (view.byteLength === 0) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
			if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
			if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
			if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
			const viewByteLength = view.byteLength;
			firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
			ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
		}
		function SetUpReadableByteStreamController(stream$6, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
			controller._controlledReadableByteStream = stream$6;
			controller._pullAgain = false;
			controller._pulling = false;
			controller._byobRequest = null;
			controller._queue = controller._queueTotalSize = void 0;
			ResetQueue(controller);
			controller._closeRequested = false;
			controller._started = false;
			controller._strategyHWM = highWaterMark;
			controller._pullAlgorithm = pullAlgorithm;
			controller._cancelAlgorithm = cancelAlgorithm;
			controller._autoAllocateChunkSize = autoAllocateChunkSize;
			controller._pendingPullIntos = new SimpleQueue();
			stream$6._readableStreamController = controller;
			uponPromise(promiseResolvedWith(startAlgorithm()), () => {
				controller._started = true;
				ReadableByteStreamControllerCallPullIfNeeded(controller);
				return null;
			}, (r$1) => {
				ReadableByteStreamControllerError(controller, r$1);
				return null;
			});
		}
		function SetUpReadableByteStreamControllerFromUnderlyingSource(stream$6, underlyingByteSource, highWaterMark) {
			const controller = Object.create(ReadableByteStreamController.prototype);
			let startAlgorithm;
			let pullAlgorithm;
			let cancelAlgorithm;
			if (underlyingByteSource.start !== void 0) startAlgorithm = () => underlyingByteSource.start(controller);
			else startAlgorithm = () => void 0;
			if (underlyingByteSource.pull !== void 0) pullAlgorithm = () => underlyingByteSource.pull(controller);
			else pullAlgorithm = () => promiseResolvedWith(void 0);
			if (underlyingByteSource.cancel !== void 0) cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
			else cancelAlgorithm = () => promiseResolvedWith(void 0);
			const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
			if (autoAllocateChunkSize === 0) throw new TypeError("autoAllocateChunkSize must be greater than 0");
			SetUpReadableByteStreamController(stream$6, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
		}
		function SetUpReadableStreamBYOBRequest(request$3, controller, view) {
			request$3._associatedReadableByteStreamController = controller;
			request$3._view = view;
		}
		function byobRequestBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
		}
		function byteStreamControllerBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
		}
		function convertReaderOptions(options, context) {
			assertDictionary(options, context);
			const mode = options === null || options === void 0 ? void 0 : options.mode;
			return { mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`) };
		}
		function convertReadableStreamReaderMode(mode, context) {
			mode = `${mode}`;
			if (mode !== "byob") throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
			return mode;
		}
		function convertByobReadOptions(options, context) {
			var _a$3;
			assertDictionary(options, context);
			return { min: convertUnsignedLongLongWithEnforceRange((_a$3 = options === null || options === void 0 ? void 0 : options.min) !== null && _a$3 !== void 0 ? _a$3 : 1, `${context} has member 'min' that`) };
		}
		function AcquireReadableStreamBYOBReader(stream$6) {
			return new ReadableStreamBYOBReader(stream$6);
		}
		function ReadableStreamAddReadIntoRequest(stream$6, readIntoRequest) {
			stream$6._reader._readIntoRequests.push(readIntoRequest);
		}
		function ReadableStreamFulfillReadIntoRequest(stream$6, chunk, done) {
			const readIntoRequest = stream$6._reader._readIntoRequests.shift();
			if (done) readIntoRequest._closeSteps(chunk);
			else readIntoRequest._chunkSteps(chunk);
		}
		function ReadableStreamGetNumReadIntoRequests(stream$6) {
			return stream$6._reader._readIntoRequests.length;
		}
		function ReadableStreamHasBYOBReader(stream$6) {
			const reader = stream$6._reader;
			if (reader === void 0) return false;
			if (!IsReadableStreamBYOBReader(reader)) return false;
			return true;
		}
		/**
		* A BYOB reader vended by a {@link ReadableStream}.
		*
		* @public
		*/
		class ReadableStreamBYOBReader {
			constructor(stream$6) {
				assertRequiredArgument(stream$6, 1, "ReadableStreamBYOBReader");
				assertReadableStream(stream$6, "First parameter");
				if (IsReadableStreamLocked(stream$6)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
				if (!IsReadableByteStreamController(stream$6._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
				ReadableStreamReaderGenericInitialize(this, stream$6);
				this._readIntoRequests = new SimpleQueue();
			}
			/**
			* Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
			* the reader's lock is released before the stream finishes closing.
			*/
			get closed() {
				if (!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException("closed"));
				return this._closedPromise;
			}
			/**
			* If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
			*/
			cancel(reason = void 0) {
				if (!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
				if (this._ownerReadableStream === void 0) return promiseRejectedWith(readerLockException("cancel"));
				return ReadableStreamReaderGenericCancel(this, reason);
			}
			read(view, rawOptions = {}) {
				if (!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException("read"));
				if (!ArrayBuffer.isView(view)) return promiseRejectedWith(/* @__PURE__ */ new TypeError("view must be an array buffer view"));
				if (view.byteLength === 0) return promiseRejectedWith(/* @__PURE__ */ new TypeError("view must have non-zero byteLength"));
				if (view.buffer.byteLength === 0) return promiseRejectedWith(/* @__PURE__ */ new TypeError(`view's buffer must have non-zero byteLength`));
				if (IsDetachedBuffer(view.buffer)) return promiseRejectedWith(/* @__PURE__ */ new TypeError("view's buffer has been detached"));
				let options;
				try {
					options = convertByobReadOptions(rawOptions, "options");
				} catch (e$1) {
					return promiseRejectedWith(e$1);
				}
				const min = options.min;
				if (min === 0) return promiseRejectedWith(/* @__PURE__ */ new TypeError("options.min must be greater than 0"));
				if (!isDataView(view)) {
					if (min > view.length) return promiseRejectedWith(/* @__PURE__ */ new RangeError("options.min must be less than or equal to view's length"));
				} else if (min > view.byteLength) return promiseRejectedWith(/* @__PURE__ */ new RangeError("options.min must be less than or equal to view's byteLength"));
				if (this._ownerReadableStream === void 0) return promiseRejectedWith(readerLockException("read from"));
				let resolvePromise;
				let rejectPromise;
				const promise = newPromise((resolve, reject) => {
					resolvePromise = resolve;
					rejectPromise = reject;
				});
				ReadableStreamBYOBReaderRead(this, view, min, {
					_chunkSteps: (chunk) => resolvePromise({
						value: chunk,
						done: false
					}),
					_closeSteps: (chunk) => resolvePromise({
						value: chunk,
						done: true
					}),
					_errorSteps: (e$1) => rejectPromise(e$1)
				});
				return promise;
			}
			/**
			* Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
			* If the associated stream is errored when the lock is released, the reader will appear errored in the same way
			* from now on; otherwise, the reader will appear closed.
			*
			* A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
			* the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
			* do so will throw a `TypeError` and leave the reader locked to the stream.
			*/
			releaseLock() {
				if (!IsReadableStreamBYOBReader(this)) throw byobReaderBrandCheckException("releaseLock");
				if (this._ownerReadableStream === void 0) return;
				ReadableStreamBYOBReaderRelease(this);
			}
		}
		Object.defineProperties(ReadableStreamBYOBReader.prototype, {
			cancel: { enumerable: true },
			read: { enumerable: true },
			releaseLock: { enumerable: true },
			closed: { enumerable: true }
		});
		setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
		setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
		setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock");
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
			value: "ReadableStreamBYOBReader",
			configurable: true
		});
		function IsReadableStreamBYOBReader(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_readIntoRequests")) return false;
			return x$1 instanceof ReadableStreamBYOBReader;
		}
		function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
			const stream$6 = reader._ownerReadableStream;
			stream$6._disturbed = true;
			if (stream$6._state === "errored") readIntoRequest._errorSteps(stream$6._storedError);
			else ReadableByteStreamControllerPullInto(stream$6._readableStreamController, view, min, readIntoRequest);
		}
		function ReadableStreamBYOBReaderRelease(reader) {
			ReadableStreamReaderGenericRelease(reader);
			ReadableStreamBYOBReaderErrorReadIntoRequests(reader, /* @__PURE__ */ new TypeError("Reader was released"));
		}
		function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e$1) {
			const readIntoRequests = reader._readIntoRequests;
			reader._readIntoRequests = new SimpleQueue();
			readIntoRequests.forEach((readIntoRequest) => {
				readIntoRequest._errorSteps(e$1);
			});
		}
		function byobReaderBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
		}
		function ExtractHighWaterMark(strategy, defaultHWM) {
			const { highWaterMark } = strategy;
			if (highWaterMark === void 0) return defaultHWM;
			if (NumberIsNaN(highWaterMark) || highWaterMark < 0) throw new RangeError("Invalid highWaterMark");
			return highWaterMark;
		}
		function ExtractSizeAlgorithm(strategy) {
			const { size } = strategy;
			if (!size) return () => 1;
			return size;
		}
		function convertQueuingStrategy(init$1, context) {
			assertDictionary(init$1, context);
			const highWaterMark = init$1 === null || init$1 === void 0 ? void 0 : init$1.highWaterMark;
			const size = init$1 === null || init$1 === void 0 ? void 0 : init$1.size;
			return {
				highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
				size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
			};
		}
		function convertQueuingStrategySize(fn, context) {
			assertFunction(fn, context);
			return (chunk) => convertUnrestrictedDouble(fn(chunk));
		}
		function convertUnderlyingSink(original, context) {
			assertDictionary(original, context);
			const abort$1 = original === null || original === void 0 ? void 0 : original.abort;
			const close = original === null || original === void 0 ? void 0 : original.close;
			const start = original === null || original === void 0 ? void 0 : original.start;
			const type = original === null || original === void 0 ? void 0 : original.type;
			const write$1 = original === null || original === void 0 ? void 0 : original.write;
			return {
				abort: abort$1 === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort$1, original, `${context} has member 'abort' that`),
				close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
				start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
				write: write$1 === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write$1, original, `${context} has member 'write' that`),
				type
			};
		}
		function convertUnderlyingSinkAbortCallback(fn, original, context) {
			assertFunction(fn, context);
			return (reason) => promiseCall(fn, original, [reason]);
		}
		function convertUnderlyingSinkCloseCallback(fn, original, context) {
			assertFunction(fn, context);
			return () => promiseCall(fn, original, []);
		}
		function convertUnderlyingSinkStartCallback(fn, original, context) {
			assertFunction(fn, context);
			return (controller) => reflectCall(fn, original, [controller]);
		}
		function convertUnderlyingSinkWriteCallback(fn, original, context) {
			assertFunction(fn, context);
			return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
		}
		function assertWritableStream(x$1, context) {
			if (!IsWritableStream(x$1)) throw new TypeError(`${context} is not a WritableStream.`);
		}
		function isAbortSignal$1(value) {
			if (typeof value !== "object" || value === null) return false;
			try {
				return typeof value.aborted === "boolean";
			} catch (_a$3) {
				return false;
			}
		}
		const supportsAbortController = typeof AbortController === "function";
		/**
		* Construct a new AbortController, if supported by the platform.
		*
		* @internal
		*/
		function createAbortController() {
			if (supportsAbortController) return new AbortController();
		}
		/**
		* A writable stream represents a destination for data, into which you can write.
		*
		* @public
		*/
		class WritableStream$2 {
			constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
				if (rawUnderlyingSink === void 0) rawUnderlyingSink = null;
				else assertObject(rawUnderlyingSink, "First parameter");
				const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
				const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
				InitializeWritableStream(this);
				if (underlyingSink.type !== void 0) throw new RangeError("Invalid type is specified");
				const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
				const highWaterMark = ExtractHighWaterMark(strategy, 1);
				SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
			}
			/**
			* Returns whether or not the writable stream is locked to a writer.
			*/
			get locked() {
				if (!IsWritableStream(this)) throw streamBrandCheckException$2("locked");
				return IsWritableStreamLocked(this);
			}
			/**
			* Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
			* immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
			* mechanism of the underlying sink.
			*
			* The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
			* that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
			* the stream) if the stream is currently locked.
			*/
			abort(reason = void 0) {
				if (!IsWritableStream(this)) return promiseRejectedWith(streamBrandCheckException$2("abort"));
				if (IsWritableStreamLocked(this)) return promiseRejectedWith(/* @__PURE__ */ new TypeError("Cannot abort a stream that already has a writer"));
				return WritableStreamAbort(this, reason);
			}
			/**
			* Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
			* close behavior. During this time any further attempts to write will fail (without erroring the stream).
			*
			* The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
			* successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
			* a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
			*/
			close() {
				if (!IsWritableStream(this)) return promiseRejectedWith(streamBrandCheckException$2("close"));
				if (IsWritableStreamLocked(this)) return promiseRejectedWith(/* @__PURE__ */ new TypeError("Cannot close a stream that already has a writer"));
				if (WritableStreamCloseQueuedOrInFlight(this)) return promiseRejectedWith(/* @__PURE__ */ new TypeError("Cannot close an already-closing stream"));
				return WritableStreamClose(this);
			}
			/**
			* Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
			* is locked, no other writer can be acquired until this one is released.
			*
			* This functionality is especially useful for creating abstractions that desire the ability to write to a stream
			* without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
			* the same time, which would cause the resulting written data to be unpredictable and probably useless.
			*/
			getWriter() {
				if (!IsWritableStream(this)) throw streamBrandCheckException$2("getWriter");
				return AcquireWritableStreamDefaultWriter(this);
			}
		}
		Object.defineProperties(WritableStream$2.prototype, {
			abort: { enumerable: true },
			close: { enumerable: true },
			getWriter: { enumerable: true },
			locked: { enumerable: true }
		});
		setFunctionName(WritableStream$2.prototype.abort, "abort");
		setFunctionName(WritableStream$2.prototype.close, "close");
		setFunctionName(WritableStream$2.prototype.getWriter, "getWriter");
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(WritableStream$2.prototype, Symbol.toStringTag, {
			value: "WritableStream",
			configurable: true
		});
		function AcquireWritableStreamDefaultWriter(stream$6) {
			return new WritableStreamDefaultWriter(stream$6);
		}
		function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
			const stream$6 = Object.create(WritableStream$2.prototype);
			InitializeWritableStream(stream$6);
			SetUpWritableStreamDefaultController(stream$6, Object.create(WritableStreamDefaultController.prototype), startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
			return stream$6;
		}
		function InitializeWritableStream(stream$6) {
			stream$6._state = "writable";
			stream$6._storedError = void 0;
			stream$6._writer = void 0;
			stream$6._writableStreamController = void 0;
			stream$6._writeRequests = new SimpleQueue();
			stream$6._inFlightWriteRequest = void 0;
			stream$6._closeRequest = void 0;
			stream$6._inFlightCloseRequest = void 0;
			stream$6._pendingAbortRequest = void 0;
			stream$6._backpressure = false;
		}
		function IsWritableStream(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_writableStreamController")) return false;
			return x$1 instanceof WritableStream$2;
		}
		function IsWritableStreamLocked(stream$6) {
			if (stream$6._writer === void 0) return false;
			return true;
		}
		function WritableStreamAbort(stream$6, reason) {
			var _a$3;
			if (stream$6._state === "closed" || stream$6._state === "errored") return promiseResolvedWith(void 0);
			stream$6._writableStreamController._abortReason = reason;
			(_a$3 = stream$6._writableStreamController._abortController) === null || _a$3 === void 0 || _a$3.abort(reason);
			const state = stream$6._state;
			if (state === "closed" || state === "errored") return promiseResolvedWith(void 0);
			if (stream$6._pendingAbortRequest !== void 0) return stream$6._pendingAbortRequest._promise;
			let wasAlreadyErroring = false;
			if (state === "erroring") {
				wasAlreadyErroring = true;
				reason = void 0;
			}
			const promise = newPromise((resolve, reject) => {
				stream$6._pendingAbortRequest = {
					_promise: void 0,
					_resolve: resolve,
					_reject: reject,
					_reason: reason,
					_wasAlreadyErroring: wasAlreadyErroring
				};
			});
			stream$6._pendingAbortRequest._promise = promise;
			if (!wasAlreadyErroring) WritableStreamStartErroring(stream$6, reason);
			return promise;
		}
		function WritableStreamClose(stream$6) {
			const state = stream$6._state;
			if (state === "closed" || state === "errored") return promiseRejectedWith(/* @__PURE__ */ new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
			const promise = newPromise((resolve, reject) => {
				stream$6._closeRequest = {
					_resolve: resolve,
					_reject: reject
				};
			});
			const writer = stream$6._writer;
			if (writer !== void 0 && stream$6._backpressure && state === "writable") defaultWriterReadyPromiseResolve(writer);
			WritableStreamDefaultControllerClose(stream$6._writableStreamController);
			return promise;
		}
		function WritableStreamAddWriteRequest(stream$6) {
			return newPromise((resolve, reject) => {
				const writeRequest = {
					_resolve: resolve,
					_reject: reject
				};
				stream$6._writeRequests.push(writeRequest);
			});
		}
		function WritableStreamDealWithRejection(stream$6, error$1) {
			if (stream$6._state === "writable") {
				WritableStreamStartErroring(stream$6, error$1);
				return;
			}
			WritableStreamFinishErroring(stream$6);
		}
		function WritableStreamStartErroring(stream$6, reason) {
			const controller = stream$6._writableStreamController;
			stream$6._state = "erroring";
			stream$6._storedError = reason;
			const writer = stream$6._writer;
			if (writer !== void 0) WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
			if (!WritableStreamHasOperationMarkedInFlight(stream$6) && controller._started) WritableStreamFinishErroring(stream$6);
		}
		function WritableStreamFinishErroring(stream$6) {
			stream$6._state = "errored";
			stream$6._writableStreamController[ErrorSteps]();
			const storedError = stream$6._storedError;
			stream$6._writeRequests.forEach((writeRequest) => {
				writeRequest._reject(storedError);
			});
			stream$6._writeRequests = new SimpleQueue();
			if (stream$6._pendingAbortRequest === void 0) {
				WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream$6);
				return;
			}
			const abortRequest = stream$6._pendingAbortRequest;
			stream$6._pendingAbortRequest = void 0;
			if (abortRequest._wasAlreadyErroring) {
				abortRequest._reject(storedError);
				WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream$6);
				return;
			}
			uponPromise(stream$6._writableStreamController[AbortSteps](abortRequest._reason), () => {
				abortRequest._resolve();
				WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream$6);
				return null;
			}, (reason) => {
				abortRequest._reject(reason);
				WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream$6);
				return null;
			});
		}
		function WritableStreamFinishInFlightWrite(stream$6) {
			stream$6._inFlightWriteRequest._resolve(void 0);
			stream$6._inFlightWriteRequest = void 0;
		}
		function WritableStreamFinishInFlightWriteWithError(stream$6, error$1) {
			stream$6._inFlightWriteRequest._reject(error$1);
			stream$6._inFlightWriteRequest = void 0;
			WritableStreamDealWithRejection(stream$6, error$1);
		}
		function WritableStreamFinishInFlightClose(stream$6) {
			stream$6._inFlightCloseRequest._resolve(void 0);
			stream$6._inFlightCloseRequest = void 0;
			if (stream$6._state === "erroring") {
				stream$6._storedError = void 0;
				if (stream$6._pendingAbortRequest !== void 0) {
					stream$6._pendingAbortRequest._resolve();
					stream$6._pendingAbortRequest = void 0;
				}
			}
			stream$6._state = "closed";
			const writer = stream$6._writer;
			if (writer !== void 0) defaultWriterClosedPromiseResolve(writer);
		}
		function WritableStreamFinishInFlightCloseWithError(stream$6, error$1) {
			stream$6._inFlightCloseRequest._reject(error$1);
			stream$6._inFlightCloseRequest = void 0;
			if (stream$6._pendingAbortRequest !== void 0) {
				stream$6._pendingAbortRequest._reject(error$1);
				stream$6._pendingAbortRequest = void 0;
			}
			WritableStreamDealWithRejection(stream$6, error$1);
		}
		function WritableStreamCloseQueuedOrInFlight(stream$6) {
			if (stream$6._closeRequest === void 0 && stream$6._inFlightCloseRequest === void 0) return false;
			return true;
		}
		function WritableStreamHasOperationMarkedInFlight(stream$6) {
			if (stream$6._inFlightWriteRequest === void 0 && stream$6._inFlightCloseRequest === void 0) return false;
			return true;
		}
		function WritableStreamMarkCloseRequestInFlight(stream$6) {
			stream$6._inFlightCloseRequest = stream$6._closeRequest;
			stream$6._closeRequest = void 0;
		}
		function WritableStreamMarkFirstWriteRequestInFlight(stream$6) {
			stream$6._inFlightWriteRequest = stream$6._writeRequests.shift();
		}
		function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream$6) {
			if (stream$6._closeRequest !== void 0) {
				stream$6._closeRequest._reject(stream$6._storedError);
				stream$6._closeRequest = void 0;
			}
			const writer = stream$6._writer;
			if (writer !== void 0) defaultWriterClosedPromiseReject(writer, stream$6._storedError);
		}
		function WritableStreamUpdateBackpressure(stream$6, backpressure) {
			const writer = stream$6._writer;
			if (writer !== void 0 && backpressure !== stream$6._backpressure) if (backpressure) defaultWriterReadyPromiseReset(writer);
			else defaultWriterReadyPromiseResolve(writer);
			stream$6._backpressure = backpressure;
		}
		/**
		* A default writer vended by a {@link WritableStream}.
		*
		* @public
		*/
		class WritableStreamDefaultWriter {
			constructor(stream$6) {
				assertRequiredArgument(stream$6, 1, "WritableStreamDefaultWriter");
				assertWritableStream(stream$6, "First parameter");
				if (IsWritableStreamLocked(stream$6)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
				this._ownerWritableStream = stream$6;
				stream$6._writer = this;
				const state = stream$6._state;
				if (state === "writable") {
					if (!WritableStreamCloseQueuedOrInFlight(stream$6) && stream$6._backpressure) defaultWriterReadyPromiseInitialize(this);
					else defaultWriterReadyPromiseInitializeAsResolved(this);
					defaultWriterClosedPromiseInitialize(this);
				} else if (state === "erroring") {
					defaultWriterReadyPromiseInitializeAsRejected(this, stream$6._storedError);
					defaultWriterClosedPromiseInitialize(this);
				} else if (state === "closed") {
					defaultWriterReadyPromiseInitializeAsResolved(this);
					defaultWriterClosedPromiseInitializeAsResolved(this);
				} else {
					const storedError = stream$6._storedError;
					defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
					defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
				}
			}
			/**
			* Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
			* the writers lock is released before the stream finishes closing.
			*/
			get closed() {
				if (!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
				return this._closedPromise;
			}
			/**
			* Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
			* A producer can use this information to determine the right amount of data to write.
			*
			* It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
			* queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
			* the writers lock is released.
			*/
			get desiredSize() {
				if (!IsWritableStreamDefaultWriter(this)) throw defaultWriterBrandCheckException("desiredSize");
				if (this._ownerWritableStream === void 0) throw defaultWriterLockException("desiredSize");
				return WritableStreamDefaultWriterGetDesiredSize(this);
			}
			/**
			* Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
			* from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
			* back to zero or below, the getter will return a new promise that stays pending until the next transition.
			*
			* If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
			* rejected.
			*/
			get ready() {
				if (!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
				return this._readyPromise;
			}
			/**
			* If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
			*/
			abort(reason = void 0) {
				if (!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
				if (this._ownerWritableStream === void 0) return promiseRejectedWith(defaultWriterLockException("abort"));
				return WritableStreamDefaultWriterAbort(this, reason);
			}
			/**
			* If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
			*/
			close() {
				if (!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException("close"));
				const stream$6 = this._ownerWritableStream;
				if (stream$6 === void 0) return promiseRejectedWith(defaultWriterLockException("close"));
				if (WritableStreamCloseQueuedOrInFlight(stream$6)) return promiseRejectedWith(/* @__PURE__ */ new TypeError("Cannot close an already-closing stream"));
				return WritableStreamDefaultWriterClose(this);
			}
			/**
			* Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
			* If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
			* now on; otherwise, the writer will appear closed.
			*
			* Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
			* promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
			* Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
			* other producers from writing in an interleaved manner.
			*/
			releaseLock() {
				if (!IsWritableStreamDefaultWriter(this)) throw defaultWriterBrandCheckException("releaseLock");
				if (this._ownerWritableStream === void 0) return;
				WritableStreamDefaultWriterRelease(this);
			}
			write(chunk = void 0) {
				if (!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException("write"));
				if (this._ownerWritableStream === void 0) return promiseRejectedWith(defaultWriterLockException("write to"));
				return WritableStreamDefaultWriterWrite(this, chunk);
			}
		}
		Object.defineProperties(WritableStreamDefaultWriter.prototype, {
			abort: { enumerable: true },
			close: { enumerable: true },
			releaseLock: { enumerable: true },
			write: { enumerable: true },
			closed: { enumerable: true },
			desiredSize: { enumerable: true },
			ready: { enumerable: true }
		});
		setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
		setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
		setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock");
		setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
			value: "WritableStreamDefaultWriter",
			configurable: true
		});
		function IsWritableStreamDefaultWriter(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_ownerWritableStream")) return false;
			return x$1 instanceof WritableStreamDefaultWriter;
		}
		function WritableStreamDefaultWriterAbort(writer, reason) {
			const stream$6 = writer._ownerWritableStream;
			return WritableStreamAbort(stream$6, reason);
		}
		function WritableStreamDefaultWriterClose(writer) {
			const stream$6 = writer._ownerWritableStream;
			return WritableStreamClose(stream$6);
		}
		function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
			const stream$6 = writer._ownerWritableStream;
			const state = stream$6._state;
			if (WritableStreamCloseQueuedOrInFlight(stream$6) || state === "closed") return promiseResolvedWith(void 0);
			if (state === "errored") return promiseRejectedWith(stream$6._storedError);
			return WritableStreamDefaultWriterClose(writer);
		}
		function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error$1) {
			if (writer._closedPromiseState === "pending") defaultWriterClosedPromiseReject(writer, error$1);
			else defaultWriterClosedPromiseResetToRejected(writer, error$1);
		}
		function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error$1) {
			if (writer._readyPromiseState === "pending") defaultWriterReadyPromiseReject(writer, error$1);
			else defaultWriterReadyPromiseResetToRejected(writer, error$1);
		}
		function WritableStreamDefaultWriterGetDesiredSize(writer) {
			const stream$6 = writer._ownerWritableStream;
			const state = stream$6._state;
			if (state === "errored" || state === "erroring") return null;
			if (state === "closed") return 0;
			return WritableStreamDefaultControllerGetDesiredSize(stream$6._writableStreamController);
		}
		function WritableStreamDefaultWriterRelease(writer) {
			const stream$6 = writer._ownerWritableStream;
			const releasedError = /* @__PURE__ */ new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
			WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
			WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
			stream$6._writer = void 0;
			writer._ownerWritableStream = void 0;
		}
		function WritableStreamDefaultWriterWrite(writer, chunk) {
			const stream$6 = writer._ownerWritableStream;
			const controller = stream$6._writableStreamController;
			const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
			if (stream$6 !== writer._ownerWritableStream) return promiseRejectedWith(defaultWriterLockException("write to"));
			const state = stream$6._state;
			if (state === "errored") return promiseRejectedWith(stream$6._storedError);
			if (WritableStreamCloseQueuedOrInFlight(stream$6) || state === "closed") return promiseRejectedWith(/* @__PURE__ */ new TypeError("The stream is closing or closed and cannot be written to"));
			if (state === "erroring") return promiseRejectedWith(stream$6._storedError);
			const promise = WritableStreamAddWriteRequest(stream$6);
			WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
			return promise;
		}
		const closeSentinel = {};
		/**
		* Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
		*
		* @public
		*/
		class WritableStreamDefaultController {
			constructor() {
				throw new TypeError("Illegal constructor");
			}
			/**
			* The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
			*
			* @deprecated
			*  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
			*  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
			*/
			get abortReason() {
				if (!IsWritableStreamDefaultController(this)) throw defaultControllerBrandCheckException$2("abortReason");
				return this._abortReason;
			}
			/**
			* An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
			*/
			get signal() {
				if (!IsWritableStreamDefaultController(this)) throw defaultControllerBrandCheckException$2("signal");
				if (this._abortController === void 0) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
				return this._abortController.signal;
			}
			/**
			* Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
			*
			* This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
			* sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
			* normal lifecycle of interactions with the underlying sink.
			*/
			error(e$1 = void 0) {
				if (!IsWritableStreamDefaultController(this)) throw defaultControllerBrandCheckException$2("error");
				if (this._controlledWritableStream._state !== "writable") return;
				WritableStreamDefaultControllerError(this, e$1);
			}
			/** @internal */
			[AbortSteps](reason) {
				const result = this._abortAlgorithm(reason);
				WritableStreamDefaultControllerClearAlgorithms(this);
				return result;
			}
			/** @internal */
			[ErrorSteps]() {
				ResetQueue(this);
			}
		}
		Object.defineProperties(WritableStreamDefaultController.prototype, {
			abortReason: { enumerable: true },
			signal: { enumerable: true },
			error: { enumerable: true }
		});
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
			value: "WritableStreamDefaultController",
			configurable: true
		});
		function IsWritableStreamDefaultController(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_controlledWritableStream")) return false;
			return x$1 instanceof WritableStreamDefaultController;
		}
		function SetUpWritableStreamDefaultController(stream$6, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
			controller._controlledWritableStream = stream$6;
			stream$6._writableStreamController = controller;
			controller._queue = void 0;
			controller._queueTotalSize = void 0;
			ResetQueue(controller);
			controller._abortReason = void 0;
			controller._abortController = createAbortController();
			controller._started = false;
			controller._strategySizeAlgorithm = sizeAlgorithm;
			controller._strategyHWM = highWaterMark;
			controller._writeAlgorithm = writeAlgorithm;
			controller._closeAlgorithm = closeAlgorithm;
			controller._abortAlgorithm = abortAlgorithm;
			WritableStreamUpdateBackpressure(stream$6, WritableStreamDefaultControllerGetBackpressure(controller));
			uponPromise(promiseResolvedWith(startAlgorithm()), () => {
				controller._started = true;
				WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
				return null;
			}, (r$1) => {
				controller._started = true;
				WritableStreamDealWithRejection(stream$6, r$1);
				return null;
			});
		}
		function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream$6, underlyingSink, highWaterMark, sizeAlgorithm) {
			const controller = Object.create(WritableStreamDefaultController.prototype);
			let startAlgorithm;
			let writeAlgorithm;
			let closeAlgorithm;
			let abortAlgorithm;
			if (underlyingSink.start !== void 0) startAlgorithm = () => underlyingSink.start(controller);
			else startAlgorithm = () => void 0;
			if (underlyingSink.write !== void 0) writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
			else writeAlgorithm = () => promiseResolvedWith(void 0);
			if (underlyingSink.close !== void 0) closeAlgorithm = () => underlyingSink.close();
			else closeAlgorithm = () => promiseResolvedWith(void 0);
			if (underlyingSink.abort !== void 0) abortAlgorithm = (reason) => underlyingSink.abort(reason);
			else abortAlgorithm = () => promiseResolvedWith(void 0);
			SetUpWritableStreamDefaultController(stream$6, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
		}
		function WritableStreamDefaultControllerClearAlgorithms(controller) {
			controller._writeAlgorithm = void 0;
			controller._closeAlgorithm = void 0;
			controller._abortAlgorithm = void 0;
			controller._strategySizeAlgorithm = void 0;
		}
		function WritableStreamDefaultControllerClose(controller) {
			EnqueueValueWithSize(controller, closeSentinel, 0);
			WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
		}
		function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
			try {
				return controller._strategySizeAlgorithm(chunk);
			} catch (chunkSizeE) {
				WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
				return 1;
			}
		}
		function WritableStreamDefaultControllerGetDesiredSize(controller) {
			return controller._strategyHWM - controller._queueTotalSize;
		}
		function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
			try {
				EnqueueValueWithSize(controller, chunk, chunkSize);
			} catch (enqueueE) {
				WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
				return;
			}
			const stream$6 = controller._controlledWritableStream;
			if (!WritableStreamCloseQueuedOrInFlight(stream$6) && stream$6._state === "writable") WritableStreamUpdateBackpressure(stream$6, WritableStreamDefaultControllerGetBackpressure(controller));
			WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
		}
		function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
			const stream$6 = controller._controlledWritableStream;
			if (!controller._started) return;
			if (stream$6._inFlightWriteRequest !== void 0) return;
			if (stream$6._state === "erroring") {
				WritableStreamFinishErroring(stream$6);
				return;
			}
			if (controller._queue.length === 0) return;
			const value = PeekQueueValue(controller);
			if (value === closeSentinel) WritableStreamDefaultControllerProcessClose(controller);
			else WritableStreamDefaultControllerProcessWrite(controller, value);
		}
		function WritableStreamDefaultControllerErrorIfNeeded(controller, error$1) {
			if (controller._controlledWritableStream._state === "writable") WritableStreamDefaultControllerError(controller, error$1);
		}
		function WritableStreamDefaultControllerProcessClose(controller) {
			const stream$6 = controller._controlledWritableStream;
			WritableStreamMarkCloseRequestInFlight(stream$6);
			DequeueValue(controller);
			const sinkClosePromise = controller._closeAlgorithm();
			WritableStreamDefaultControllerClearAlgorithms(controller);
			uponPromise(sinkClosePromise, () => {
				WritableStreamFinishInFlightClose(stream$6);
				return null;
			}, (reason) => {
				WritableStreamFinishInFlightCloseWithError(stream$6, reason);
				return null;
			});
		}
		function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
			const stream$6 = controller._controlledWritableStream;
			WritableStreamMarkFirstWriteRequestInFlight(stream$6);
			uponPromise(controller._writeAlgorithm(chunk), () => {
				WritableStreamFinishInFlightWrite(stream$6);
				const state = stream$6._state;
				DequeueValue(controller);
				if (!WritableStreamCloseQueuedOrInFlight(stream$6) && state === "writable") WritableStreamUpdateBackpressure(stream$6, WritableStreamDefaultControllerGetBackpressure(controller));
				WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
				return null;
			}, (reason) => {
				if (stream$6._state === "writable") WritableStreamDefaultControllerClearAlgorithms(controller);
				WritableStreamFinishInFlightWriteWithError(stream$6, reason);
				return null;
			});
		}
		function WritableStreamDefaultControllerGetBackpressure(controller) {
			return WritableStreamDefaultControllerGetDesiredSize(controller) <= 0;
		}
		function WritableStreamDefaultControllerError(controller, error$1) {
			const stream$6 = controller._controlledWritableStream;
			WritableStreamDefaultControllerClearAlgorithms(controller);
			WritableStreamStartErroring(stream$6, error$1);
		}
		function streamBrandCheckException$2(name) {
			return /* @__PURE__ */ new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
		}
		function defaultControllerBrandCheckException$2(name) {
			return /* @__PURE__ */ new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
		}
		function defaultWriterBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
		}
		function defaultWriterLockException(name) {
			return /* @__PURE__ */ new TypeError("Cannot " + name + " a stream using a released writer");
		}
		function defaultWriterClosedPromiseInitialize(writer) {
			writer._closedPromise = newPromise((resolve, reject) => {
				writer._closedPromise_resolve = resolve;
				writer._closedPromise_reject = reject;
				writer._closedPromiseState = "pending";
			});
		}
		function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
			defaultWriterClosedPromiseInitialize(writer);
			defaultWriterClosedPromiseReject(writer, reason);
		}
		function defaultWriterClosedPromiseInitializeAsResolved(writer) {
			defaultWriterClosedPromiseInitialize(writer);
			defaultWriterClosedPromiseResolve(writer);
		}
		function defaultWriterClosedPromiseReject(writer, reason) {
			if (writer._closedPromise_reject === void 0) return;
			setPromiseIsHandledToTrue(writer._closedPromise);
			writer._closedPromise_reject(reason);
			writer._closedPromise_resolve = void 0;
			writer._closedPromise_reject = void 0;
			writer._closedPromiseState = "rejected";
		}
		function defaultWriterClosedPromiseResetToRejected(writer, reason) {
			defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
		}
		function defaultWriterClosedPromiseResolve(writer) {
			if (writer._closedPromise_resolve === void 0) return;
			writer._closedPromise_resolve(void 0);
			writer._closedPromise_resolve = void 0;
			writer._closedPromise_reject = void 0;
			writer._closedPromiseState = "resolved";
		}
		function defaultWriterReadyPromiseInitialize(writer) {
			writer._readyPromise = newPromise((resolve, reject) => {
				writer._readyPromise_resolve = resolve;
				writer._readyPromise_reject = reject;
			});
			writer._readyPromiseState = "pending";
		}
		function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
			defaultWriterReadyPromiseInitialize(writer);
			defaultWriterReadyPromiseReject(writer, reason);
		}
		function defaultWriterReadyPromiseInitializeAsResolved(writer) {
			defaultWriterReadyPromiseInitialize(writer);
			defaultWriterReadyPromiseResolve(writer);
		}
		function defaultWriterReadyPromiseReject(writer, reason) {
			if (writer._readyPromise_reject === void 0) return;
			setPromiseIsHandledToTrue(writer._readyPromise);
			writer._readyPromise_reject(reason);
			writer._readyPromise_resolve = void 0;
			writer._readyPromise_reject = void 0;
			writer._readyPromiseState = "rejected";
		}
		function defaultWriterReadyPromiseReset(writer) {
			defaultWriterReadyPromiseInitialize(writer);
		}
		function defaultWriterReadyPromiseResetToRejected(writer, reason) {
			defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
		}
		function defaultWriterReadyPromiseResolve(writer) {
			if (writer._readyPromise_resolve === void 0) return;
			writer._readyPromise_resolve(void 0);
			writer._readyPromise_resolve = void 0;
			writer._readyPromise_reject = void 0;
			writer._readyPromiseState = "fulfilled";
		}
		function getGlobals() {
			if (typeof globalThis !== "undefined") return globalThis;
			else if (typeof self !== "undefined") return self;
			else if (typeof global !== "undefined") return global;
		}
		const globals = getGlobals();
		function isDOMExceptionConstructor(ctor) {
			if (!(typeof ctor === "function" || typeof ctor === "object")) return false;
			if (ctor.name !== "DOMException") return false;
			try {
				new ctor();
				return true;
			} catch (_a$3) {
				return false;
			}
		}
		/**
		* Support:
		* - Web browsers
		* - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)
		*/
		function getFromGlobal() {
			const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
			return isDOMExceptionConstructor(ctor) ? ctor : void 0;
		}
		/**
		* Support:
		* - All platforms
		*/
		function createPolyfill() {
			const ctor = function DOMException$9(message, name) {
				this.message = message || "";
				this.name = name || "Error";
				if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
			};
			setFunctionName(ctor, "DOMException");
			ctor.prototype = Object.create(Error.prototype);
			Object.defineProperty(ctor.prototype, "constructor", {
				value: ctor,
				writable: true,
				configurable: true
			});
			return ctor;
		}
		const DOMException$8 = getFromGlobal() || createPolyfill();
		function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
			const reader = AcquireReadableStreamDefaultReader(source);
			const writer = AcquireWritableStreamDefaultWriter(dest);
			source._disturbed = true;
			let shuttingDown = false;
			let currentWrite = promiseResolvedWith(void 0);
			return newPromise((resolve, reject) => {
				let abortAlgorithm;
				if (signal !== void 0) {
					abortAlgorithm = () => {
						const error$1 = signal.reason !== void 0 ? signal.reason : new DOMException$8("Aborted", "AbortError");
						const actions = [];
						if (!preventAbort) actions.push(() => {
							if (dest._state === "writable") return WritableStreamAbort(dest, error$1);
							return promiseResolvedWith(void 0);
						});
						if (!preventCancel) actions.push(() => {
							if (source._state === "readable") return ReadableStreamCancel(source, error$1);
							return promiseResolvedWith(void 0);
						});
						shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error$1);
					};
					if (signal.aborted) {
						abortAlgorithm();
						return;
					}
					signal.addEventListener("abort", abortAlgorithm);
				}
				function pipeLoop() {
					return newPromise((resolveLoop, rejectLoop) => {
						function next(done) {
							if (done) resolveLoop();
							else PerformPromiseThen(pipeStep(), next, rejectLoop);
						}
						next(false);
					});
				}
				function pipeStep() {
					if (shuttingDown) return promiseResolvedWith(true);
					return PerformPromiseThen(writer._readyPromise, () => {
						return newPromise((resolveRead, rejectRead) => {
							ReadableStreamDefaultReaderRead(reader, {
								_chunkSteps: (chunk) => {
									currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop$3);
									resolveRead(false);
								},
								_closeSteps: () => resolveRead(true),
								_errorSteps: rejectRead
							});
						});
					});
				}
				isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
					if (!preventAbort) shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
					else shutdown(true, storedError);
					return null;
				});
				isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
					if (!preventCancel) shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
					else shutdown(true, storedError);
					return null;
				});
				isOrBecomesClosed(source, reader._closedPromise, () => {
					if (!preventClose) shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
					else shutdown();
					return null;
				});
				if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
					const destClosed = /* @__PURE__ */ new TypeError("the destination writable stream closed before all data could be piped to it");
					if (!preventCancel) shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
					else shutdown(true, destClosed);
				}
				setPromiseIsHandledToTrue(pipeLoop());
				function waitForWritesToFinish() {
					const oldCurrentWrite = currentWrite;
					return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
				}
				function isOrBecomesErrored(stream$6, promise, action) {
					if (stream$6._state === "errored") action(stream$6._storedError);
					else uponRejection(promise, action);
				}
				function isOrBecomesClosed(stream$6, promise, action) {
					if (stream$6._state === "closed") action();
					else uponFulfillment(promise, action);
				}
				function shutdownWithAction(action, originalIsError, originalError) {
					if (shuttingDown) return;
					shuttingDown = true;
					if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) uponFulfillment(waitForWritesToFinish(), doTheRest);
					else doTheRest();
					function doTheRest() {
						uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
						return null;
					}
				}
				function shutdown(isError, error$1) {
					if (shuttingDown) return;
					shuttingDown = true;
					if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error$1));
					else finalize(isError, error$1);
				}
				function finalize(isError, error$1) {
					WritableStreamDefaultWriterRelease(writer);
					ReadableStreamReaderGenericRelease(reader);
					if (signal !== void 0) signal.removeEventListener("abort", abortAlgorithm);
					if (isError) reject(error$1);
					else resolve(void 0);
					return null;
				}
			});
		}
		/**
		* Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
		*
		* @public
		*/
		class ReadableStreamDefaultController {
			constructor() {
				throw new TypeError("Illegal constructor");
			}
			/**
			* Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
			* over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
			*/
			get desiredSize() {
				if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("desiredSize");
				return ReadableStreamDefaultControllerGetDesiredSize(this);
			}
			/**
			* Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
			* the stream, but once those are read, the stream will become closed.
			*/
			close() {
				if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("close");
				if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) throw new TypeError("The stream is not in a state that permits close");
				ReadableStreamDefaultControllerClose(this);
			}
			enqueue(chunk = void 0) {
				if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("enqueue");
				if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) throw new TypeError("The stream is not in a state that permits enqueue");
				return ReadableStreamDefaultControllerEnqueue(this, chunk);
			}
			/**
			* Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
			*/
			error(e$1 = void 0) {
				if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("error");
				ReadableStreamDefaultControllerError(this, e$1);
			}
			/** @internal */
			[CancelSteps](reason) {
				ResetQueue(this);
				const result = this._cancelAlgorithm(reason);
				ReadableStreamDefaultControllerClearAlgorithms(this);
				return result;
			}
			/** @internal */
			[PullSteps](readRequest) {
				const stream$6 = this._controlledReadableStream;
				if (this._queue.length > 0) {
					const chunk = DequeueValue(this);
					if (this._closeRequested && this._queue.length === 0) {
						ReadableStreamDefaultControllerClearAlgorithms(this);
						ReadableStreamClose(stream$6);
					} else ReadableStreamDefaultControllerCallPullIfNeeded(this);
					readRequest._chunkSteps(chunk);
				} else {
					ReadableStreamAddReadRequest(stream$6, readRequest);
					ReadableStreamDefaultControllerCallPullIfNeeded(this);
				}
			}
			/** @internal */
			[ReleaseSteps]() {}
		}
		Object.defineProperties(ReadableStreamDefaultController.prototype, {
			close: { enumerable: true },
			enqueue: { enumerable: true },
			error: { enumerable: true },
			desiredSize: { enumerable: true }
		});
		setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
		setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue");
		setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
			value: "ReadableStreamDefaultController",
			configurable: true
		});
		function IsReadableStreamDefaultController(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_controlledReadableStream")) return false;
			return x$1 instanceof ReadableStreamDefaultController;
		}
		function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
			if (!ReadableStreamDefaultControllerShouldCallPull(controller)) return;
			if (controller._pulling) {
				controller._pullAgain = true;
				return;
			}
			controller._pulling = true;
			uponPromise(controller._pullAlgorithm(), () => {
				controller._pulling = false;
				if (controller._pullAgain) {
					controller._pullAgain = false;
					ReadableStreamDefaultControllerCallPullIfNeeded(controller);
				}
				return null;
			}, (e$1) => {
				ReadableStreamDefaultControllerError(controller, e$1);
				return null;
			});
		}
		function ReadableStreamDefaultControllerShouldCallPull(controller) {
			const stream$6 = controller._controlledReadableStream;
			if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) return false;
			if (!controller._started) return false;
			if (IsReadableStreamLocked(stream$6) && ReadableStreamGetNumReadRequests(stream$6) > 0) return true;
			if (ReadableStreamDefaultControllerGetDesiredSize(controller) > 0) return true;
			return false;
		}
		function ReadableStreamDefaultControllerClearAlgorithms(controller) {
			controller._pullAlgorithm = void 0;
			controller._cancelAlgorithm = void 0;
			controller._strategySizeAlgorithm = void 0;
		}
		function ReadableStreamDefaultControllerClose(controller) {
			if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) return;
			const stream$6 = controller._controlledReadableStream;
			controller._closeRequested = true;
			if (controller._queue.length === 0) {
				ReadableStreamDefaultControllerClearAlgorithms(controller);
				ReadableStreamClose(stream$6);
			}
		}
		function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
			if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) return;
			const stream$6 = controller._controlledReadableStream;
			if (IsReadableStreamLocked(stream$6) && ReadableStreamGetNumReadRequests(stream$6) > 0) ReadableStreamFulfillReadRequest(stream$6, chunk, false);
			else {
				let chunkSize;
				try {
					chunkSize = controller._strategySizeAlgorithm(chunk);
				} catch (chunkSizeE) {
					ReadableStreamDefaultControllerError(controller, chunkSizeE);
					throw chunkSizeE;
				}
				try {
					EnqueueValueWithSize(controller, chunk, chunkSize);
				} catch (enqueueE) {
					ReadableStreamDefaultControllerError(controller, enqueueE);
					throw enqueueE;
				}
			}
			ReadableStreamDefaultControllerCallPullIfNeeded(controller);
		}
		function ReadableStreamDefaultControllerError(controller, e$1) {
			const stream$6 = controller._controlledReadableStream;
			if (stream$6._state !== "readable") return;
			ResetQueue(controller);
			ReadableStreamDefaultControllerClearAlgorithms(controller);
			ReadableStreamError(stream$6, e$1);
		}
		function ReadableStreamDefaultControllerGetDesiredSize(controller) {
			const state = controller._controlledReadableStream._state;
			if (state === "errored") return null;
			if (state === "closed") return 0;
			return controller._strategyHWM - controller._queueTotalSize;
		}
		function ReadableStreamDefaultControllerHasBackpressure(controller) {
			if (ReadableStreamDefaultControllerShouldCallPull(controller)) return false;
			return true;
		}
		function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
			const state = controller._controlledReadableStream._state;
			if (!controller._closeRequested && state === "readable") return true;
			return false;
		}
		function SetUpReadableStreamDefaultController(stream$6, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
			controller._controlledReadableStream = stream$6;
			controller._queue = void 0;
			controller._queueTotalSize = void 0;
			ResetQueue(controller);
			controller._started = false;
			controller._closeRequested = false;
			controller._pullAgain = false;
			controller._pulling = false;
			controller._strategySizeAlgorithm = sizeAlgorithm;
			controller._strategyHWM = highWaterMark;
			controller._pullAlgorithm = pullAlgorithm;
			controller._cancelAlgorithm = cancelAlgorithm;
			stream$6._readableStreamController = controller;
			uponPromise(promiseResolvedWith(startAlgorithm()), () => {
				controller._started = true;
				ReadableStreamDefaultControllerCallPullIfNeeded(controller);
				return null;
			}, (r$1) => {
				ReadableStreamDefaultControllerError(controller, r$1);
				return null;
			});
		}
		function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream$6, underlyingSource, highWaterMark, sizeAlgorithm) {
			const controller = Object.create(ReadableStreamDefaultController.prototype);
			let startAlgorithm;
			let pullAlgorithm;
			let cancelAlgorithm;
			if (underlyingSource.start !== void 0) startAlgorithm = () => underlyingSource.start(controller);
			else startAlgorithm = () => void 0;
			if (underlyingSource.pull !== void 0) pullAlgorithm = () => underlyingSource.pull(controller);
			else pullAlgorithm = () => promiseResolvedWith(void 0);
			if (underlyingSource.cancel !== void 0) cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
			else cancelAlgorithm = () => promiseResolvedWith(void 0);
			SetUpReadableStreamDefaultController(stream$6, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
		}
		function defaultControllerBrandCheckException$1(name) {
			return /* @__PURE__ */ new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
		}
		function ReadableStreamTee(stream$6, cloneForBranch2) {
			if (IsReadableByteStreamController(stream$6._readableStreamController)) return ReadableByteStreamTee(stream$6);
			return ReadableStreamDefaultTee(stream$6);
		}
		function ReadableStreamDefaultTee(stream$6, cloneForBranch2) {
			const reader = AcquireReadableStreamDefaultReader(stream$6);
			let reading = false;
			let readAgain = false;
			let canceled1 = false;
			let canceled2 = false;
			let reason1;
			let reason2;
			let branch1;
			let branch2;
			let resolveCancelPromise;
			const cancelPromise = newPromise((resolve) => {
				resolveCancelPromise = resolve;
			});
			function pullAlgorithm() {
				if (reading) {
					readAgain = true;
					return promiseResolvedWith(void 0);
				}
				reading = true;
				ReadableStreamDefaultReaderRead(reader, {
					_chunkSteps: (chunk) => {
						_queueMicrotask(() => {
							readAgain = false;
							const chunk1 = chunk;
							const chunk2 = chunk;
							if (!canceled1) ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
							if (!canceled2) ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
							reading = false;
							if (readAgain) pullAlgorithm();
						});
					},
					_closeSteps: () => {
						reading = false;
						if (!canceled1) ReadableStreamDefaultControllerClose(branch1._readableStreamController);
						if (!canceled2) ReadableStreamDefaultControllerClose(branch2._readableStreamController);
						if (!canceled1 || !canceled2) resolveCancelPromise(void 0);
					},
					_errorSteps: () => {
						reading = false;
					}
				});
				return promiseResolvedWith(void 0);
			}
			function cancel1Algorithm(reason) {
				canceled1 = true;
				reason1 = reason;
				if (canceled2) {
					const cancelResult = ReadableStreamCancel(stream$6, CreateArrayFromList([reason1, reason2]));
					resolveCancelPromise(cancelResult);
				}
				return cancelPromise;
			}
			function cancel2Algorithm(reason) {
				canceled2 = true;
				reason2 = reason;
				if (canceled1) {
					const cancelResult = ReadableStreamCancel(stream$6, CreateArrayFromList([reason1, reason2]));
					resolveCancelPromise(cancelResult);
				}
				return cancelPromise;
			}
			function startAlgorithm() {}
			branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
			branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
			uponRejection(reader._closedPromise, (r$1) => {
				ReadableStreamDefaultControllerError(branch1._readableStreamController, r$1);
				ReadableStreamDefaultControllerError(branch2._readableStreamController, r$1);
				if (!canceled1 || !canceled2) resolveCancelPromise(void 0);
				return null;
			});
			return [branch1, branch2];
		}
		function ReadableByteStreamTee(stream$6) {
			let reader = AcquireReadableStreamDefaultReader(stream$6);
			let reading = false;
			let readAgainForBranch1 = false;
			let readAgainForBranch2 = false;
			let canceled1 = false;
			let canceled2 = false;
			let reason1;
			let reason2;
			let branch1;
			let branch2;
			let resolveCancelPromise;
			const cancelPromise = newPromise((resolve) => {
				resolveCancelPromise = resolve;
			});
			function forwardReaderError(thisReader) {
				uponRejection(thisReader._closedPromise, (r$1) => {
					if (thisReader !== reader) return null;
					ReadableByteStreamControllerError(branch1._readableStreamController, r$1);
					ReadableByteStreamControllerError(branch2._readableStreamController, r$1);
					if (!canceled1 || !canceled2) resolveCancelPromise(void 0);
					return null;
				});
			}
			function pullWithDefaultReader() {
				if (IsReadableStreamBYOBReader(reader)) {
					ReadableStreamReaderGenericRelease(reader);
					reader = AcquireReadableStreamDefaultReader(stream$6);
					forwardReaderError(reader);
				}
				ReadableStreamDefaultReaderRead(reader, {
					_chunkSteps: (chunk) => {
						_queueMicrotask(() => {
							readAgainForBranch1 = false;
							readAgainForBranch2 = false;
							const chunk1 = chunk;
							let chunk2 = chunk;
							if (!canceled1 && !canceled2) try {
								chunk2 = CloneAsUint8Array(chunk);
							} catch (cloneE) {
								ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
								ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
								resolveCancelPromise(ReadableStreamCancel(stream$6, cloneE));
								return;
							}
							if (!canceled1) ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
							if (!canceled2) ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
							reading = false;
							if (readAgainForBranch1) pull1Algorithm();
							else if (readAgainForBranch2) pull2Algorithm();
						});
					},
					_closeSteps: () => {
						reading = false;
						if (!canceled1) ReadableByteStreamControllerClose(branch1._readableStreamController);
						if (!canceled2) ReadableByteStreamControllerClose(branch2._readableStreamController);
						if (branch1._readableStreamController._pendingPullIntos.length > 0) ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
						if (branch2._readableStreamController._pendingPullIntos.length > 0) ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
						if (!canceled1 || !canceled2) resolveCancelPromise(void 0);
					},
					_errorSteps: () => {
						reading = false;
					}
				});
			}
			function pullWithBYOBReader(view, forBranch2) {
				if (IsReadableStreamDefaultReader(reader)) {
					ReadableStreamReaderGenericRelease(reader);
					reader = AcquireReadableStreamBYOBReader(stream$6);
					forwardReaderError(reader);
				}
				const byobBranch = forBranch2 ? branch2 : branch1;
				const otherBranch = forBranch2 ? branch1 : branch2;
				ReadableStreamBYOBReaderRead(reader, view, 1, {
					_chunkSteps: (chunk) => {
						_queueMicrotask(() => {
							readAgainForBranch1 = false;
							readAgainForBranch2 = false;
							const byobCanceled = forBranch2 ? canceled2 : canceled1;
							if (!(forBranch2 ? canceled1 : canceled2)) {
								let clonedChunk;
								try {
									clonedChunk = CloneAsUint8Array(chunk);
								} catch (cloneE) {
									ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
									ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
									resolveCancelPromise(ReadableStreamCancel(stream$6, cloneE));
									return;
								}
								if (!byobCanceled) ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
								ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
							} else if (!byobCanceled) ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
							reading = false;
							if (readAgainForBranch1) pull1Algorithm();
							else if (readAgainForBranch2) pull2Algorithm();
						});
					},
					_closeSteps: (chunk) => {
						reading = false;
						const byobCanceled = forBranch2 ? canceled2 : canceled1;
						const otherCanceled = forBranch2 ? canceled1 : canceled2;
						if (!byobCanceled) ReadableByteStreamControllerClose(byobBranch._readableStreamController);
						if (!otherCanceled) ReadableByteStreamControllerClose(otherBranch._readableStreamController);
						if (chunk !== void 0) {
							if (!byobCanceled) ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
							if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
						}
						if (!byobCanceled || !otherCanceled) resolveCancelPromise(void 0);
					},
					_errorSteps: () => {
						reading = false;
					}
				});
			}
			function pull1Algorithm() {
				if (reading) {
					readAgainForBranch1 = true;
					return promiseResolvedWith(void 0);
				}
				reading = true;
				const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
				if (byobRequest === null) pullWithDefaultReader();
				else pullWithBYOBReader(byobRequest._view, false);
				return promiseResolvedWith(void 0);
			}
			function pull2Algorithm() {
				if (reading) {
					readAgainForBranch2 = true;
					return promiseResolvedWith(void 0);
				}
				reading = true;
				const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
				if (byobRequest === null) pullWithDefaultReader();
				else pullWithBYOBReader(byobRequest._view, true);
				return promiseResolvedWith(void 0);
			}
			function cancel1Algorithm(reason) {
				canceled1 = true;
				reason1 = reason;
				if (canceled2) {
					const cancelResult = ReadableStreamCancel(stream$6, CreateArrayFromList([reason1, reason2]));
					resolveCancelPromise(cancelResult);
				}
				return cancelPromise;
			}
			function cancel2Algorithm(reason) {
				canceled2 = true;
				reason2 = reason;
				if (canceled1) {
					const cancelResult = ReadableStreamCancel(stream$6, CreateArrayFromList([reason1, reason2]));
					resolveCancelPromise(cancelResult);
				}
				return cancelPromise;
			}
			function startAlgorithm() {}
			branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
			branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
			forwardReaderError(reader);
			return [branch1, branch2];
		}
		function isReadableStreamLike$2(stream$6) {
			return typeIsObject(stream$6) && typeof stream$6.getReader !== "undefined";
		}
		function ReadableStreamFrom$4(source) {
			if (isReadableStreamLike$2(source)) return ReadableStreamFromDefaultReader(source.getReader());
			return ReadableStreamFromIterable(source);
		}
		function ReadableStreamFromIterable(asyncIterable) {
			let stream$6;
			const iteratorRecord = GetIterator(asyncIterable, "async");
			const startAlgorithm = noop$3;
			function pullAlgorithm() {
				let nextResult;
				try {
					nextResult = IteratorNext(iteratorRecord);
				} catch (e$1) {
					return promiseRejectedWith(e$1);
				}
				return transformPromiseWith(promiseResolvedWith(nextResult), (iterResult) => {
					if (!typeIsObject(iterResult)) throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
					if (IteratorComplete(iterResult)) ReadableStreamDefaultControllerClose(stream$6._readableStreamController);
					else {
						const value = IteratorValue(iterResult);
						ReadableStreamDefaultControllerEnqueue(stream$6._readableStreamController, value);
					}
				});
			}
			function cancelAlgorithm(reason) {
				const iterator$1 = iteratorRecord.iterator;
				let returnMethod;
				try {
					returnMethod = GetMethod(iterator$1, "return");
				} catch (e$1) {
					return promiseRejectedWith(e$1);
				}
				if (returnMethod === void 0) return promiseResolvedWith(void 0);
				let returnResult;
				try {
					returnResult = reflectCall(returnMethod, iterator$1, [reason]);
				} catch (e$1) {
					return promiseRejectedWith(e$1);
				}
				return transformPromiseWith(promiseResolvedWith(returnResult), (iterResult) => {
					if (!typeIsObject(iterResult)) throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
				});
			}
			stream$6 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
			return stream$6;
		}
		function ReadableStreamFromDefaultReader(reader) {
			let stream$6;
			const startAlgorithm = noop$3;
			function pullAlgorithm() {
				let readPromise;
				try {
					readPromise = reader.read();
				} catch (e$1) {
					return promiseRejectedWith(e$1);
				}
				return transformPromiseWith(readPromise, (readResult) => {
					if (!typeIsObject(readResult)) throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
					if (readResult.done) ReadableStreamDefaultControllerClose(stream$6._readableStreamController);
					else {
						const value = readResult.value;
						ReadableStreamDefaultControllerEnqueue(stream$6._readableStreamController, value);
					}
				});
			}
			function cancelAlgorithm(reason) {
				try {
					return promiseResolvedWith(reader.cancel(reason));
				} catch (e$1) {
					return promiseRejectedWith(e$1);
				}
			}
			stream$6 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
			return stream$6;
		}
		function convertUnderlyingDefaultOrByteSource(source, context) {
			assertDictionary(source, context);
			const original = source;
			const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
			const cancel = original === null || original === void 0 ? void 0 : original.cancel;
			const pull = original === null || original === void 0 ? void 0 : original.pull;
			const start = original === null || original === void 0 ? void 0 : original.start;
			const type = original === null || original === void 0 ? void 0 : original.type;
			return {
				autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
				cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
				pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
				start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
				type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
			};
		}
		function convertUnderlyingSourceCancelCallback(fn, original, context) {
			assertFunction(fn, context);
			return (reason) => promiseCall(fn, original, [reason]);
		}
		function convertUnderlyingSourcePullCallback(fn, original, context) {
			assertFunction(fn, context);
			return (controller) => promiseCall(fn, original, [controller]);
		}
		function convertUnderlyingSourceStartCallback(fn, original, context) {
			assertFunction(fn, context);
			return (controller) => reflectCall(fn, original, [controller]);
		}
		function convertReadableStreamType(type, context) {
			type = `${type}`;
			if (type !== "bytes") throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
			return type;
		}
		function convertIteratorOptions(options, context) {
			assertDictionary(options, context);
			const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
			return { preventCancel: Boolean(preventCancel) };
		}
		function convertPipeOptions(options, context) {
			assertDictionary(options, context);
			const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
			const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
			const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
			const signal = options === null || options === void 0 ? void 0 : options.signal;
			if (signal !== void 0) assertAbortSignal(signal, `${context} has member 'signal' that`);
			return {
				preventAbort: Boolean(preventAbort),
				preventCancel: Boolean(preventCancel),
				preventClose: Boolean(preventClose),
				signal
			};
		}
		function assertAbortSignal(signal, context) {
			if (!isAbortSignal$1(signal)) throw new TypeError(`${context} is not an AbortSignal.`);
		}
		function convertReadableWritablePair(pair, context) {
			assertDictionary(pair, context);
			const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
			assertRequiredField(readable, "readable", "ReadableWritablePair");
			assertReadableStream(readable, `${context} has member 'readable' that`);
			const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
			assertRequiredField(writable, "writable", "ReadableWritablePair");
			assertWritableStream(writable, `${context} has member 'writable' that`);
			return {
				readable,
				writable
			};
		}
		/**
		* A readable stream represents a source of data, from which you can read.
		*
		* @public
		*/
		class ReadableStream$7 {
			constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
				if (rawUnderlyingSource === void 0) rawUnderlyingSource = null;
				else assertObject(rawUnderlyingSource, "First parameter");
				const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
				const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
				InitializeReadableStream(this);
				if (underlyingSource.type === "bytes") {
					if (strategy.size !== void 0) throw new RangeError("The strategy for a byte stream cannot have a size function");
					const highWaterMark = ExtractHighWaterMark(strategy, 0);
					SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
				} else {
					const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
					const highWaterMark = ExtractHighWaterMark(strategy, 1);
					SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
				}
			}
			/**
			* Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
			*/
			get locked() {
				if (!IsReadableStream(this)) throw streamBrandCheckException$1("locked");
				return IsReadableStreamLocked(this);
			}
			/**
			* Cancels the stream, signaling a loss of interest in the stream by a consumer.
			*
			* The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
			* method, which might or might not use it.
			*/
			cancel(reason = void 0) {
				if (!IsReadableStream(this)) return promiseRejectedWith(streamBrandCheckException$1("cancel"));
				if (IsReadableStreamLocked(this)) return promiseRejectedWith(/* @__PURE__ */ new TypeError("Cannot cancel a stream that already has a reader"));
				return ReadableStreamCancel(this, reason);
			}
			getReader(rawOptions = void 0) {
				if (!IsReadableStream(this)) throw streamBrandCheckException$1("getReader");
				if (convertReaderOptions(rawOptions, "First parameter").mode === void 0) return AcquireReadableStreamDefaultReader(this);
				return AcquireReadableStreamBYOBReader(this);
			}
			pipeThrough(rawTransform, rawOptions = {}) {
				if (!IsReadableStream(this)) throw streamBrandCheckException$1("pipeThrough");
				assertRequiredArgument(rawTransform, 1, "pipeThrough");
				const transform = convertReadableWritablePair(rawTransform, "First parameter");
				const options = convertPipeOptions(rawOptions, "Second parameter");
				if (IsReadableStreamLocked(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
				if (IsWritableStreamLocked(transform.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
				setPromiseIsHandledToTrue(ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal));
				return transform.readable;
			}
			pipeTo(destination, rawOptions = {}) {
				if (!IsReadableStream(this)) return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
				if (destination === void 0) return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
				if (!IsWritableStream(destination)) return promiseRejectedWith(/* @__PURE__ */ new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
				let options;
				try {
					options = convertPipeOptions(rawOptions, "Second parameter");
				} catch (e$1) {
					return promiseRejectedWith(e$1);
				}
				if (IsReadableStreamLocked(this)) return promiseRejectedWith(/* @__PURE__ */ new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
				if (IsWritableStreamLocked(destination)) return promiseRejectedWith(/* @__PURE__ */ new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
				return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
			}
			/**
			* Tees this readable stream, returning a two-element array containing the two resulting branches as
			* new {@link ReadableStream} instances.
			*
			* Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
			* To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
			* propagated to the stream's underlying source.
			*
			* Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
			* this could allow interference between the two branches.
			*/
			tee() {
				if (!IsReadableStream(this)) throw streamBrandCheckException$1("tee");
				return CreateArrayFromList(ReadableStreamTee(this));
			}
			values(rawOptions = void 0) {
				if (!IsReadableStream(this)) throw streamBrandCheckException$1("values");
				const options = convertIteratorOptions(rawOptions, "First parameter");
				return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
			}
			[SymbolAsyncIterator](options) {
				return this.values(options);
			}
			/**
			* Creates a new ReadableStream wrapping the provided iterable or async iterable.
			*
			* This can be used to adapt various kinds of objects into a readable stream,
			* such as an array, an async generator, or a Node.js readable stream.
			*/
			static from(asyncIterable) {
				return ReadableStreamFrom$4(asyncIterable);
			}
		}
		Object.defineProperties(ReadableStream$7, { from: { enumerable: true } });
		Object.defineProperties(ReadableStream$7.prototype, {
			cancel: { enumerable: true },
			getReader: { enumerable: true },
			pipeThrough: { enumerable: true },
			pipeTo: { enumerable: true },
			tee: { enumerable: true },
			values: { enumerable: true },
			locked: { enumerable: true }
		});
		setFunctionName(ReadableStream$7.from, "from");
		setFunctionName(ReadableStream$7.prototype.cancel, "cancel");
		setFunctionName(ReadableStream$7.prototype.getReader, "getReader");
		setFunctionName(ReadableStream$7.prototype.pipeThrough, "pipeThrough");
		setFunctionName(ReadableStream$7.prototype.pipeTo, "pipeTo");
		setFunctionName(ReadableStream$7.prototype.tee, "tee");
		setFunctionName(ReadableStream$7.prototype.values, "values");
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(ReadableStream$7.prototype, Symbol.toStringTag, {
			value: "ReadableStream",
			configurable: true
		});
		Object.defineProperty(ReadableStream$7.prototype, SymbolAsyncIterator, {
			value: ReadableStream$7.prototype.values,
			writable: true,
			configurable: true
		});
		function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
			const stream$6 = Object.create(ReadableStream$7.prototype);
			InitializeReadableStream(stream$6);
			SetUpReadableStreamDefaultController(stream$6, Object.create(ReadableStreamDefaultController.prototype), startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
			return stream$6;
		}
		function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
			const stream$6 = Object.create(ReadableStream$7.prototype);
			InitializeReadableStream(stream$6);
			SetUpReadableByteStreamController(stream$6, Object.create(ReadableByteStreamController.prototype), startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
			return stream$6;
		}
		function InitializeReadableStream(stream$6) {
			stream$6._state = "readable";
			stream$6._reader = void 0;
			stream$6._storedError = void 0;
			stream$6._disturbed = false;
		}
		function IsReadableStream(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_readableStreamController")) return false;
			return x$1 instanceof ReadableStream$7;
		}
		function IsReadableStreamLocked(stream$6) {
			if (stream$6._reader === void 0) return false;
			return true;
		}
		function ReadableStreamCancel(stream$6, reason) {
			stream$6._disturbed = true;
			if (stream$6._state === "closed") return promiseResolvedWith(void 0);
			if (stream$6._state === "errored") return promiseRejectedWith(stream$6._storedError);
			ReadableStreamClose(stream$6);
			const reader = stream$6._reader;
			if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
				const readIntoRequests = reader._readIntoRequests;
				reader._readIntoRequests = new SimpleQueue();
				readIntoRequests.forEach((readIntoRequest) => {
					readIntoRequest._closeSteps(void 0);
				});
			}
			return transformPromiseWith(stream$6._readableStreamController[CancelSteps](reason), noop$3);
		}
		function ReadableStreamClose(stream$6) {
			stream$6._state = "closed";
			const reader = stream$6._reader;
			if (reader === void 0) return;
			defaultReaderClosedPromiseResolve(reader);
			if (IsReadableStreamDefaultReader(reader)) {
				const readRequests = reader._readRequests;
				reader._readRequests = new SimpleQueue();
				readRequests.forEach((readRequest) => {
					readRequest._closeSteps();
				});
			}
		}
		function ReadableStreamError(stream$6, e$1) {
			stream$6._state = "errored";
			stream$6._storedError = e$1;
			const reader = stream$6._reader;
			if (reader === void 0) return;
			defaultReaderClosedPromiseReject(reader, e$1);
			if (IsReadableStreamDefaultReader(reader)) ReadableStreamDefaultReaderErrorReadRequests(reader, e$1);
			else ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e$1);
		}
		function streamBrandCheckException$1(name) {
			return /* @__PURE__ */ new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
		}
		function convertQueuingStrategyInit(init$1, context) {
			assertDictionary(init$1, context);
			const highWaterMark = init$1 === null || init$1 === void 0 ? void 0 : init$1.highWaterMark;
			assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
			return { highWaterMark: convertUnrestrictedDouble(highWaterMark) };
		}
		const byteLengthSizeFunction = (chunk) => {
			return chunk.byteLength;
		};
		setFunctionName(byteLengthSizeFunction, "size");
		/**
		* A queuing strategy that counts the number of bytes in each chunk.
		*
		* @public
		*/
		class ByteLengthQueuingStrategy {
			constructor(options) {
				assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
				options = convertQueuingStrategyInit(options, "First parameter");
				this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
			}
			/**
			* Returns the high water mark provided to the constructor.
			*/
			get highWaterMark() {
				if (!IsByteLengthQueuingStrategy(this)) throw byteLengthBrandCheckException("highWaterMark");
				return this._byteLengthQueuingStrategyHighWaterMark;
			}
			/**
			* Measures the size of `chunk` by returning the value of its `byteLength` property.
			*/
			get size() {
				if (!IsByteLengthQueuingStrategy(this)) throw byteLengthBrandCheckException("size");
				return byteLengthSizeFunction;
			}
		}
		Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
			highWaterMark: { enumerable: true },
			size: { enumerable: true }
		});
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
			value: "ByteLengthQueuingStrategy",
			configurable: true
		});
		function byteLengthBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
		}
		function IsByteLengthQueuingStrategy(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_byteLengthQueuingStrategyHighWaterMark")) return false;
			return x$1 instanceof ByteLengthQueuingStrategy;
		}
		const countSizeFunction = () => {
			return 1;
		};
		setFunctionName(countSizeFunction, "size");
		/**
		* A queuing strategy that counts the number of chunks.
		*
		* @public
		*/
		class CountQueuingStrategy {
			constructor(options) {
				assertRequiredArgument(options, 1, "CountQueuingStrategy");
				options = convertQueuingStrategyInit(options, "First parameter");
				this._countQueuingStrategyHighWaterMark = options.highWaterMark;
			}
			/**
			* Returns the high water mark provided to the constructor.
			*/
			get highWaterMark() {
				if (!IsCountQueuingStrategy(this)) throw countBrandCheckException("highWaterMark");
				return this._countQueuingStrategyHighWaterMark;
			}
			/**
			* Measures the size of `chunk` by always returning 1.
			* This ensures that the total queue size is a count of the number of chunks in the queue.
			*/
			get size() {
				if (!IsCountQueuingStrategy(this)) throw countBrandCheckException("size");
				return countSizeFunction;
			}
		}
		Object.defineProperties(CountQueuingStrategy.prototype, {
			highWaterMark: { enumerable: true },
			size: { enumerable: true }
		});
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
			value: "CountQueuingStrategy",
			configurable: true
		});
		function countBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
		}
		function IsCountQueuingStrategy(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_countQueuingStrategyHighWaterMark")) return false;
			return x$1 instanceof CountQueuingStrategy;
		}
		function convertTransformer(original, context) {
			assertDictionary(original, context);
			const cancel = original === null || original === void 0 ? void 0 : original.cancel;
			const flush = original === null || original === void 0 ? void 0 : original.flush;
			const readableType = original === null || original === void 0 ? void 0 : original.readableType;
			const start = original === null || original === void 0 ? void 0 : original.start;
			const transform = original === null || original === void 0 ? void 0 : original.transform;
			const writableType = original === null || original === void 0 ? void 0 : original.writableType;
			return {
				cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
				flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
				readableType,
				start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
				transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
				writableType
			};
		}
		function convertTransformerFlushCallback(fn, original, context) {
			assertFunction(fn, context);
			return (controller) => promiseCall(fn, original, [controller]);
		}
		function convertTransformerStartCallback(fn, original, context) {
			assertFunction(fn, context);
			return (controller) => reflectCall(fn, original, [controller]);
		}
		function convertTransformerTransformCallback(fn, original, context) {
			assertFunction(fn, context);
			return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
		}
		function convertTransformerCancelCallback(fn, original, context) {
			assertFunction(fn, context);
			return (reason) => promiseCall(fn, original, [reason]);
		}
		/**
		* A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
		* known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
		* In a manner specific to the transform stream in question, writes to the writable side result in new data being
		* made available for reading from the readable side.
		*
		* @public
		*/
		class TransformStream$2 {
			constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
				if (rawTransformer === void 0) rawTransformer = null;
				const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
				const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
				const transformer = convertTransformer(rawTransformer, "First parameter");
				if (transformer.readableType !== void 0) throw new RangeError("Invalid readableType specified");
				if (transformer.writableType !== void 0) throw new RangeError("Invalid writableType specified");
				const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
				const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
				const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
				const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
				let startPromise_resolve;
				const startPromise = newPromise((resolve) => {
					startPromise_resolve = resolve;
				});
				InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
				SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
				if (transformer.start !== void 0) startPromise_resolve(transformer.start(this._transformStreamController));
				else startPromise_resolve(void 0);
			}
			/**
			* The readable side of the transform stream.
			*/
			get readable() {
				if (!IsTransformStream(this)) throw streamBrandCheckException("readable");
				return this._readable;
			}
			/**
			* The writable side of the transform stream.
			*/
			get writable() {
				if (!IsTransformStream(this)) throw streamBrandCheckException("writable");
				return this._writable;
			}
		}
		Object.defineProperties(TransformStream$2.prototype, {
			readable: { enumerable: true },
			writable: { enumerable: true }
		});
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(TransformStream$2.prototype, Symbol.toStringTag, {
			value: "TransformStream",
			configurable: true
		});
		function InitializeTransformStream(stream$6, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
			function startAlgorithm() {
				return startPromise;
			}
			function writeAlgorithm(chunk) {
				return TransformStreamDefaultSinkWriteAlgorithm(stream$6, chunk);
			}
			function abortAlgorithm(reason) {
				return TransformStreamDefaultSinkAbortAlgorithm(stream$6, reason);
			}
			function closeAlgorithm() {
				return TransformStreamDefaultSinkCloseAlgorithm(stream$6);
			}
			stream$6._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
			function pullAlgorithm() {
				return TransformStreamDefaultSourcePullAlgorithm(stream$6);
			}
			function cancelAlgorithm(reason) {
				return TransformStreamDefaultSourceCancelAlgorithm(stream$6, reason);
			}
			stream$6._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
			stream$6._backpressure = void 0;
			stream$6._backpressureChangePromise = void 0;
			stream$6._backpressureChangePromise_resolve = void 0;
			TransformStreamSetBackpressure(stream$6, true);
			stream$6._transformStreamController = void 0;
		}
		function IsTransformStream(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_transformStreamController")) return false;
			return x$1 instanceof TransformStream$2;
		}
		function TransformStreamError(stream$6, e$1) {
			ReadableStreamDefaultControllerError(stream$6._readable._readableStreamController, e$1);
			TransformStreamErrorWritableAndUnblockWrite(stream$6, e$1);
		}
		function TransformStreamErrorWritableAndUnblockWrite(stream$6, e$1) {
			TransformStreamDefaultControllerClearAlgorithms(stream$6._transformStreamController);
			WritableStreamDefaultControllerErrorIfNeeded(stream$6._writable._writableStreamController, e$1);
			TransformStreamUnblockWrite(stream$6);
		}
		function TransformStreamUnblockWrite(stream$6) {
			if (stream$6._backpressure) TransformStreamSetBackpressure(stream$6, false);
		}
		function TransformStreamSetBackpressure(stream$6, backpressure) {
			if (stream$6._backpressureChangePromise !== void 0) stream$6._backpressureChangePromise_resolve();
			stream$6._backpressureChangePromise = newPromise((resolve) => {
				stream$6._backpressureChangePromise_resolve = resolve;
			});
			stream$6._backpressure = backpressure;
		}
		/**
		* Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
		*
		* @public
		*/
		class TransformStreamDefaultController {
			constructor() {
				throw new TypeError("Illegal constructor");
			}
			/**
			* Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
			*/
			get desiredSize() {
				if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("desiredSize");
				const readableController = this._controlledTransformStream._readable._readableStreamController;
				return ReadableStreamDefaultControllerGetDesiredSize(readableController);
			}
			enqueue(chunk = void 0) {
				if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("enqueue");
				TransformStreamDefaultControllerEnqueue(this, chunk);
			}
			/**
			* Errors both the readable side and the writable side of the controlled transform stream, making all future
			* interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
			*/
			error(reason = void 0) {
				if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("error");
				TransformStreamDefaultControllerError(this, reason);
			}
			/**
			* Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
			* transformer only needs to consume a portion of the chunks written to the writable side.
			*/
			terminate() {
				if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("terminate");
				TransformStreamDefaultControllerTerminate(this);
			}
		}
		Object.defineProperties(TransformStreamDefaultController.prototype, {
			enqueue: { enumerable: true },
			error: { enumerable: true },
			terminate: { enumerable: true },
			desiredSize: { enumerable: true }
		});
		setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue");
		setFunctionName(TransformStreamDefaultController.prototype.error, "error");
		setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate");
		if (typeof Symbol.toStringTag === "symbol") Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
			value: "TransformStreamDefaultController",
			configurable: true
		});
		function IsTransformStreamDefaultController(x$1) {
			if (!typeIsObject(x$1)) return false;
			if (!Object.prototype.hasOwnProperty.call(x$1, "_controlledTransformStream")) return false;
			return x$1 instanceof TransformStreamDefaultController;
		}
		function SetUpTransformStreamDefaultController(stream$6, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
			controller._controlledTransformStream = stream$6;
			stream$6._transformStreamController = controller;
			controller._transformAlgorithm = transformAlgorithm;
			controller._flushAlgorithm = flushAlgorithm;
			controller._cancelAlgorithm = cancelAlgorithm;
			controller._finishPromise = void 0;
			controller._finishPromise_resolve = void 0;
			controller._finishPromise_reject = void 0;
		}
		function SetUpTransformStreamDefaultControllerFromTransformer(stream$6, transformer) {
			const controller = Object.create(TransformStreamDefaultController.prototype);
			let transformAlgorithm;
			let flushAlgorithm;
			let cancelAlgorithm;
			if (transformer.transform !== void 0) transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
			else transformAlgorithm = (chunk) => {
				try {
					TransformStreamDefaultControllerEnqueue(controller, chunk);
					return promiseResolvedWith(void 0);
				} catch (transformResultE) {
					return promiseRejectedWith(transformResultE);
				}
			};
			if (transformer.flush !== void 0) flushAlgorithm = () => transformer.flush(controller);
			else flushAlgorithm = () => promiseResolvedWith(void 0);
			if (transformer.cancel !== void 0) cancelAlgorithm = (reason) => transformer.cancel(reason);
			else cancelAlgorithm = () => promiseResolvedWith(void 0);
			SetUpTransformStreamDefaultController(stream$6, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
		}
		function TransformStreamDefaultControllerClearAlgorithms(controller) {
			controller._transformAlgorithm = void 0;
			controller._flushAlgorithm = void 0;
			controller._cancelAlgorithm = void 0;
		}
		function TransformStreamDefaultControllerEnqueue(controller, chunk) {
			const stream$6 = controller._controlledTransformStream;
			const readableController = stream$6._readable._readableStreamController;
			if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) throw new TypeError("Readable side is not in a state that permits enqueue");
			try {
				ReadableStreamDefaultControllerEnqueue(readableController, chunk);
			} catch (e$1) {
				TransformStreamErrorWritableAndUnblockWrite(stream$6, e$1);
				throw stream$6._readable._storedError;
			}
			if (ReadableStreamDefaultControllerHasBackpressure(readableController) !== stream$6._backpressure) TransformStreamSetBackpressure(stream$6, true);
		}
		function TransformStreamDefaultControllerError(controller, e$1) {
			TransformStreamError(controller._controlledTransformStream, e$1);
		}
		function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
			return transformPromiseWith(controller._transformAlgorithm(chunk), void 0, (r$1) => {
				TransformStreamError(controller._controlledTransformStream, r$1);
				throw r$1;
			});
		}
		function TransformStreamDefaultControllerTerminate(controller) {
			const stream$6 = controller._controlledTransformStream;
			const readableController = stream$6._readable._readableStreamController;
			ReadableStreamDefaultControllerClose(readableController);
			TransformStreamErrorWritableAndUnblockWrite(stream$6, /* @__PURE__ */ new TypeError("TransformStream terminated"));
		}
		function TransformStreamDefaultSinkWriteAlgorithm(stream$6, chunk) {
			const controller = stream$6._transformStreamController;
			if (stream$6._backpressure) {
				const backpressureChangePromise = stream$6._backpressureChangePromise;
				return transformPromiseWith(backpressureChangePromise, () => {
					const writable = stream$6._writable;
					if (writable._state === "erroring") throw writable._storedError;
					return TransformStreamDefaultControllerPerformTransform(controller, chunk);
				});
			}
			return TransformStreamDefaultControllerPerformTransform(controller, chunk);
		}
		function TransformStreamDefaultSinkAbortAlgorithm(stream$6, reason) {
			const controller = stream$6._transformStreamController;
			if (controller._finishPromise !== void 0) return controller._finishPromise;
			const readable = stream$6._readable;
			controller._finishPromise = newPromise((resolve, reject) => {
				controller._finishPromise_resolve = resolve;
				controller._finishPromise_reject = reject;
			});
			const cancelPromise = controller._cancelAlgorithm(reason);
			TransformStreamDefaultControllerClearAlgorithms(controller);
			uponPromise(cancelPromise, () => {
				if (readable._state === "errored") defaultControllerFinishPromiseReject(controller, readable._storedError);
				else {
					ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
					defaultControllerFinishPromiseResolve(controller);
				}
				return null;
			}, (r$1) => {
				ReadableStreamDefaultControllerError(readable._readableStreamController, r$1);
				defaultControllerFinishPromiseReject(controller, r$1);
				return null;
			});
			return controller._finishPromise;
		}
		function TransformStreamDefaultSinkCloseAlgorithm(stream$6) {
			const controller = stream$6._transformStreamController;
			if (controller._finishPromise !== void 0) return controller._finishPromise;
			const readable = stream$6._readable;
			controller._finishPromise = newPromise((resolve, reject) => {
				controller._finishPromise_resolve = resolve;
				controller._finishPromise_reject = reject;
			});
			const flushPromise = controller._flushAlgorithm();
			TransformStreamDefaultControllerClearAlgorithms(controller);
			uponPromise(flushPromise, () => {
				if (readable._state === "errored") defaultControllerFinishPromiseReject(controller, readable._storedError);
				else {
					ReadableStreamDefaultControllerClose(readable._readableStreamController);
					defaultControllerFinishPromiseResolve(controller);
				}
				return null;
			}, (r$1) => {
				ReadableStreamDefaultControllerError(readable._readableStreamController, r$1);
				defaultControllerFinishPromiseReject(controller, r$1);
				return null;
			});
			return controller._finishPromise;
		}
		function TransformStreamDefaultSourcePullAlgorithm(stream$6) {
			TransformStreamSetBackpressure(stream$6, false);
			return stream$6._backpressureChangePromise;
		}
		function TransformStreamDefaultSourceCancelAlgorithm(stream$6, reason) {
			const controller = stream$6._transformStreamController;
			if (controller._finishPromise !== void 0) return controller._finishPromise;
			const writable = stream$6._writable;
			controller._finishPromise = newPromise((resolve, reject) => {
				controller._finishPromise_resolve = resolve;
				controller._finishPromise_reject = reject;
			});
			const cancelPromise = controller._cancelAlgorithm(reason);
			TransformStreamDefaultControllerClearAlgorithms(controller);
			uponPromise(cancelPromise, () => {
				if (writable._state === "errored") defaultControllerFinishPromiseReject(controller, writable._storedError);
				else {
					WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
					TransformStreamUnblockWrite(stream$6);
					defaultControllerFinishPromiseResolve(controller);
				}
				return null;
			}, (r$1) => {
				WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r$1);
				TransformStreamUnblockWrite(stream$6);
				defaultControllerFinishPromiseReject(controller, r$1);
				return null;
			});
			return controller._finishPromise;
		}
		function defaultControllerBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
		}
		function defaultControllerFinishPromiseResolve(controller) {
			if (controller._finishPromise_resolve === void 0) return;
			controller._finishPromise_resolve();
			controller._finishPromise_resolve = void 0;
			controller._finishPromise_reject = void 0;
		}
		function defaultControllerFinishPromiseReject(controller, reason) {
			if (controller._finishPromise_reject === void 0) return;
			setPromiseIsHandledToTrue(controller._finishPromise);
			controller._finishPromise_reject(reason);
			controller._finishPromise_resolve = void 0;
			controller._finishPromise_reject = void 0;
		}
		function streamBrandCheckException(name) {
			return /* @__PURE__ */ new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
		}
		exports$1.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
		exports$1.CountQueuingStrategy = CountQueuingStrategy;
		exports$1.ReadableByteStreamController = ReadableByteStreamController;
		exports$1.ReadableStream = ReadableStream$7;
		exports$1.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
		exports$1.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
		exports$1.ReadableStreamDefaultController = ReadableStreamDefaultController;
		exports$1.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
		exports$1.TransformStream = TransformStream$2;
		exports$1.TransformStreamDefaultController = TransformStreamDefaultController;
		exports$1.WritableStream = WritableStream$2;
		exports$1.WritableStreamDefaultController = WritableStreamDefaultController;
		exports$1.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
	}));
}));

//#endregion
//#region node_modules/fetch-blob/streams.cjs
var require_streams = /* @__PURE__ */ __commonJSMin((() => {
	/* c8 ignore start */
	const POOL_SIZE$1 = 65536;
	if (!globalThis.ReadableStream) try {
		const process$2 = require("node:process");
		const { emitWarning } = process$2;
		try {
			process$2.emitWarning = () => {};
			Object.assign(globalThis, require("node:stream/web"));
			process$2.emitWarning = emitWarning;
		} catch (error$1) {
			process$2.emitWarning = emitWarning;
			throw error$1;
		}
	} catch (error$1) {
		Object.assign(globalThis, require_ponyfill_es2018());
	}
	try {
		const { Blob: Blob$7 } = require("buffer");
		if (Blob$7 && !Blob$7.prototype.stream) Blob$7.prototype.stream = function name(params) {
			let position = 0;
			const blob = this;
			return new ReadableStream({
				type: "bytes",
				async pull(ctrl) {
					const buffer$1 = await blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1)).arrayBuffer();
					position += buffer$1.byteLength;
					ctrl.enqueue(new Uint8Array(buffer$1));
					if (position === blob.size) ctrl.close();
				}
			});
		};
	} catch (error$1) {}
}));
/* c8 ignore end */

//#endregion
//#region node_modules/fetch-blob/index.js
/** @param {(Blob | Uint8Array)[]} parts */
async function* toIterator(parts, clone$1 = true) {
	for (const part of parts) if ("stream" in part) yield* part.stream();
	else if (ArrayBuffer.isView(part)) if (clone$1) {
		let position = part.byteOffset;
		const end = part.byteOffset + part.byteLength;
		while (position !== end) {
			const size = Math.min(end - position, POOL_SIZE);
			const chunk = part.buffer.slice(position, position + size);
			position += chunk.byteLength;
			yield new Uint8Array(chunk);
		}
	} else yield part;
	else {
		let position = 0, b = part;
		while (position !== b.size) {
			const buffer$1 = await b.slice(position, Math.min(b.size, position + POOL_SIZE)).arrayBuffer();
			position += buffer$1.byteLength;
			yield new Uint8Array(buffer$1);
		}
	}
}
var import_streams, POOL_SIZE, _Blob, Blob$1, fetch_blob_default;
var init_fetch_blob = __esmMin((() => {
	import_streams = require_streams();
	POOL_SIZE = 65536;
	_Blob = class Blob$7 {
		/** @type {Array.<(Blob|Uint8Array)>} */
		#parts = [];
		#type = "";
		#size = 0;
		#endings = "transparent";
		/**
		* The Blob() constructor returns a new Blob object. The content
		* of the blob consists of the concatenation of the values given
		* in the parameter array.
		*
		* @param {*} blobParts
		* @param {{ type?: string, endings?: string }} [options]
		*/
		constructor(blobParts = [], options = {}) {
			if (typeof blobParts !== "object" || blobParts === null) throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
			if (typeof blobParts[Symbol.iterator] !== "function") throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
			if (typeof options !== "object" && typeof options !== "function") throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
			if (options === null) options = {};
			const encoder$2 = new TextEncoder();
			for (const element of blobParts) {
				let part;
				if (ArrayBuffer.isView(element)) part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
				else if (element instanceof ArrayBuffer) part = new Uint8Array(element.slice(0));
				else if (element instanceof Blob$7) part = element;
				else part = encoder$2.encode(`${element}`);
				this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
				this.#parts.push(part);
			}
			this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
			const type = options.type === void 0 ? "" : String(options.type);
			this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
		}
		/**
		* The Blob interface's size property returns the
		* size of the Blob in bytes.
		*/
		get size() {
			return this.#size;
		}
		/**
		* The type property of a Blob object returns the MIME type of the file.
		*/
		get type() {
			return this.#type;
		}
		/**
		* The text() method in the Blob interface returns a Promise
		* that resolves with a string containing the contents of
		* the blob, interpreted as UTF-8.
		*
		* @return {Promise<string>}
		*/
		async text() {
			const decoder = new TextDecoder();
			let str = "";
			for await (const part of toIterator(this.#parts, false)) str += decoder.decode(part, { stream: true });
			str += decoder.decode();
			return str;
		}
		/**
		* The arrayBuffer() method in the Blob interface returns a
		* Promise that resolves with the contents of the blob as
		* binary data contained in an ArrayBuffer.
		*
		* @return {Promise<ArrayBuffer>}
		*/
		async arrayBuffer() {
			const data = new Uint8Array(this.size);
			let offset = 0;
			for await (const chunk of toIterator(this.#parts, false)) {
				data.set(chunk, offset);
				offset += chunk.length;
			}
			return data.buffer;
		}
		stream() {
			const it = toIterator(this.#parts, true);
			return new globalThis.ReadableStream({
				type: "bytes",
				async pull(ctrl) {
					const chunk = await it.next();
					chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
				},
				async cancel() {
					await it.return();
				}
			});
		}
		/**
		* The Blob interface's slice() method creates and returns a
		* new Blob object which contains data from a subset of the
		* blob on which it's called.
		*
		* @param {number} [start]
		* @param {number} [end]
		* @param {string} [type]
		*/
		slice(start = 0, end = this.size, type = "") {
			const { size } = this;
			let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
			let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
			const span = Math.max(relativeEnd - relativeStart, 0);
			const parts = this.#parts;
			const blobParts = [];
			let added = 0;
			for (const part of parts) {
				if (added >= span) break;
				const size$1 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
				if (relativeStart && size$1 <= relativeStart) {
					relativeStart -= size$1;
					relativeEnd -= size$1;
				} else {
					let chunk;
					if (ArrayBuffer.isView(part)) {
						chunk = part.subarray(relativeStart, Math.min(size$1, relativeEnd));
						added += chunk.byteLength;
					} else {
						chunk = part.slice(relativeStart, Math.min(size$1, relativeEnd));
						added += chunk.size;
					}
					relativeEnd -= size$1;
					blobParts.push(chunk);
					relativeStart = 0;
				}
			}
			const blob = new Blob$7([], { type: String(type).toLowerCase() });
			blob.#size = span;
			blob.#parts = blobParts;
			return blob;
		}
		get [Symbol.toStringTag]() {
			return "Blob";
		}
		static [Symbol.hasInstance](object) {
			return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
		}
	};
	Object.defineProperties(_Blob.prototype, {
		size: { enumerable: true },
		type: { enumerable: true },
		slice: { enumerable: true }
	});
	Blob$1 = _Blob;
	fetch_blob_default = Blob$1;
}));

//#endregion
//#region node_modules/fetch-blob/file.js
var _File, File$1, file_default;
var init_file = __esmMin((() => {
	init_fetch_blob();
	_File = class File$5 extends fetch_blob_default {
		#lastModified = 0;
		#name = "";
		/**
		* @param {*[]} fileBits
		* @param {string} fileName
		* @param {{lastModified?: number, type?: string}} options
		*/ constructor(fileBits, fileName, options = {}) {
			if (arguments.length < 2) throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
			super(fileBits, options);
			if (options === null) options = {};
			const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
			if (!Number.isNaN(lastModified)) this.#lastModified = lastModified;
			this.#name = String(fileName);
		}
		get name() {
			return this.#name;
		}
		get lastModified() {
			return this.#lastModified;
		}
		get [Symbol.toStringTag]() {
			return "File";
		}
		static [Symbol.hasInstance](object) {
			return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
		}
	};
	File$1 = _File;
	file_default = File$1;
}));

//#endregion
//#region node_modules/formdata-polyfill/esm.min.js
/** @param {FormData} F */
function formDataToBlob(F$1, B = fetch_blob_default) {
	var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r\nContent-Disposition: form-data; name="`;
	F$1.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r\n`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type || "application/octet-stream"}\r\n\r\n`, v, "\r\n"));
	c.push(`--${b}--`);
	return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i$1, h, r, m, f$1, e, x, FormData$1;
var init_esm_min = __esmMin((() => {
	init_fetch_blob();
	init_file();
	({toStringTag: t, iterator: i$1, hasInstance: h} = Symbol), r = Math.random, m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","), f$1 = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]), e = (c, f$2) => (f$2 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), x = (n, a, e$1) => {
		if (a.length < e$1) throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e$1} arguments required, but only ${a.length} present.`);
	};
	FormData$1 = class FormData$5 {
		#d = [];
		constructor(...a) {
			if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
		}
		get [t]() {
			return "FormData";
		}
		[i$1]() {
			return this.entries();
		}
		static [h](o) {
			return o && typeof o === "object" && o[t] === "FormData" && !m.some((m$2) => typeof o[m$2] != "function");
		}
		append(...a) {
			x("append", arguments, 2);
			this.#d.push(f$1(...a));
		}
		delete(a) {
			x("delete", arguments, 1);
			a += "";
			this.#d = this.#d.filter(([b]) => b !== a);
		}
		get(a) {
			x("get", arguments, 1);
			a += "";
			for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
			return null;
		}
		getAll(a, b) {
			x("getAll", arguments, 1);
			b = [];
			a += "";
			this.#d.forEach((c) => c[0] === a && b.push(c[1]));
			return b;
		}
		has(a) {
			x("has", arguments, 1);
			a += "";
			return this.#d.some((b) => b[0] === a);
		}
		forEach(a, b) {
			x("forEach", arguments, 1);
			for (var [c, d$1] of this) a.call(b, d$1, c, this);
		}
		set(...a) {
			x("set", arguments, 2);
			var b = [], c = !0;
			a = f$1(...a);
			this.#d.forEach((d$1) => {
				d$1[0] === a[0] ? c && (c = !b.push(a)) : b.push(d$1);
			});
			c && b.push(a);
			this.#d = b;
		}
		*entries() {
			yield* this.#d;
		}
		*keys() {
			for (var [a] of this) yield a;
		}
		*values() {
			for (var [, a] of this) yield a;
		}
	};
}));

//#endregion
//#region node_modules/node-fetch/src/errors/base.js
var FetchBaseError;
var init_base = __esmMin((() => {
	FetchBaseError = class extends Error {
		constructor(message, type) {
			super(message);
			Error.captureStackTrace(this, this.constructor);
			this.type = type;
		}
		get name() {
			return this.constructor.name;
		}
		get [Symbol.toStringTag]() {
			return this.constructor.name;
		}
	};
}));

//#endregion
//#region node_modules/node-fetch/src/errors/fetch-error.js
var FetchError;
var init_fetch_error = __esmMin((() => {
	init_base();
	FetchError = class extends FetchBaseError {
		/**
		* @param  {string} message -      Error message for human
		* @param  {string} [type] -        Error type for machine
		* @param  {SystemError} [systemError] - For Node.js system error
		*/
		constructor(message, type, systemError) {
			super(message, type);
			if (systemError) {
				this.code = this.errno = systemError.code;
				this.erroredSysCall = systemError.syscall;
			}
		}
	};
}));

//#endregion
//#region node_modules/node-fetch/src/utils/is.js
var NAME, isURLSearchParameters, isBlob$3, isAbortSignal, isDomainOrSubdomain, isSameProtocol;
var init_is = __esmMin((() => {
	NAME = Symbol.toStringTag;
	isURLSearchParameters = (object) => {
		return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
	};
	isBlob$3 = (object) => {
		return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
	};
	isAbortSignal = (object) => {
		return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
	};
	isDomainOrSubdomain = (destination, original) => {
		const orig = new URL(original).hostname;
		const dest = new URL(destination).hostname;
		return orig === dest || orig.endsWith(`.${dest}`);
	};
	isSameProtocol = (destination, original) => {
		return new URL(original).protocol === new URL(destination).protocol;
	};
}));

//#endregion
//#region node_modules/node-domexception/index.js
var require_node_domexception = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
	if (!globalThis.DOMException) try {
		const { MessageChannel: MessageChannel$1 } = require("worker_threads"), port = new MessageChannel$1().port1, ab = /* @__PURE__ */ new ArrayBuffer();
		port.postMessage(ab, [ab, ab]);
	} catch (err) {
		err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
	}
	module.exports = globalThis.DOMException;
}));

//#endregion
//#region node_modules/fetch-blob/from.js
var import_node_domexception, stat, blobFromSync, blobFrom, fileFrom, fileFromSync, fromBlob, fromFile, BlobDataItem;
var init_from = __esmMin((() => {
	import_node_domexception = /* @__PURE__ */ __toESM$1(require_node_domexception(), 1);
	init_file();
	init_fetch_blob();
	({stat} = node_fs.promises);
	blobFromSync = (path$9, type) => fromBlob((0, node_fs.statSync)(path$9), path$9, type);
	blobFrom = (path$9, type) => stat(path$9).then((stat$1) => fromBlob(stat$1, path$9, type));
	fileFrom = (path$9, type) => stat(path$9).then((stat$1) => fromFile(stat$1, path$9, type));
	fileFromSync = (path$9, type) => fromFile((0, node_fs.statSync)(path$9), path$9, type);
	fromBlob = (stat$1, path$9, type = "") => new fetch_blob_default([new BlobDataItem({
		path: path$9,
		size: stat$1.size,
		lastModified: stat$1.mtimeMs,
		start: 0
	})], { type });
	fromFile = (stat$1, path$9, type = "") => new file_default([new BlobDataItem({
		path: path$9,
		size: stat$1.size,
		lastModified: stat$1.mtimeMs,
		start: 0
	})], (0, node_path.basename)(path$9), {
		type,
		lastModified: stat$1.mtimeMs
	});
	BlobDataItem = class BlobDataItem {
		#path;
		#start;
		constructor(options) {
			this.#path = options.path;
			this.#start = options.start;
			this.size = options.size;
			this.lastModified = options.lastModified;
		}
		/**
		* Slicing arguments is first validated and formatted
		* to not be out of range by Blob.prototype.slice
		*/
		slice(start, end) {
			return new BlobDataItem({
				path: this.#path,
				lastModified: this.lastModified,
				size: end - start,
				start: this.#start + start
			});
		}
		async *stream() {
			const { mtimeMs } = await stat(this.#path);
			if (mtimeMs > this.lastModified) throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
			yield* (0, node_fs.createReadStream)(this.#path, {
				start: this.#start,
				end: this.#start + this.size - 1
			});
		}
		get [Symbol.toStringTag]() {
			return "Blob";
		}
	};
}));

//#endregion
//#region node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = /* @__PURE__ */ __export$8({ toFormData: () => toFormData });
function _fileName(headerValue) {
	const m$2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
	if (!m$2) return;
	const match = m$2[2] || m$2[3] || "";
	let filename = match.slice(match.lastIndexOf("\\") + 1);
	filename = filename.replace(/%22/g, "\"");
	filename = filename.replace(/&#(\d{4});/g, (m$3, code$1) => {
		return String.fromCharCode(code$1);
	});
	return filename;
}
async function toFormData(Body$1, ct) {
	if (!/multipart/i.test(ct)) throw new TypeError("Failed to fetch");
	const m$2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
	if (!m$2) throw new TypeError("no or bad content-type header, no multipart boundary");
	const parser = new MultipartParser(m$2[1] || m$2[2]);
	let headerField;
	let headerValue;
	let entryValue;
	let entryName;
	let contentType;
	let filename;
	const entryChunks = [];
	const formData = new FormData$1();
	const onPartData = (ui8a) => {
		entryValue += decoder.decode(ui8a, { stream: true });
	};
	const appendToFile = (ui8a) => {
		entryChunks.push(ui8a);
	};
	const appendFileToFormData = () => {
		const file = new file_default(entryChunks, filename, { type: contentType });
		formData.append(entryName, file);
	};
	const appendEntryToFormData = () => {
		formData.append(entryName, entryValue);
	};
	const decoder = new TextDecoder("utf-8");
	decoder.decode();
	parser.onPartBegin = function() {
		parser.onPartData = onPartData;
		parser.onPartEnd = appendEntryToFormData;
		headerField = "";
		headerValue = "";
		entryValue = "";
		entryName = "";
		contentType = "";
		filename = null;
		entryChunks.length = 0;
	};
	parser.onHeaderField = function(ui8a) {
		headerField += decoder.decode(ui8a, { stream: true });
	};
	parser.onHeaderValue = function(ui8a) {
		headerValue += decoder.decode(ui8a, { stream: true });
	};
	parser.onHeaderEnd = function() {
		headerValue += decoder.decode();
		headerField = headerField.toLowerCase();
		if (headerField === "content-disposition") {
			const m$3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
			if (m$3) entryName = m$3[2] || m$3[3] || "";
			filename = _fileName(headerValue);
			if (filename) {
				parser.onPartData = appendToFile;
				parser.onPartEnd = appendFileToFormData;
			}
		} else if (headerField === "content-type") contentType = headerValue;
		headerValue = "";
		headerField = "";
	};
	for await (const chunk of Body$1) parser.write(chunk);
	parser.end();
	return formData;
}
var s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esmMin((() => {
	init_from();
	init_esm_min();
	s = 0;
	S = {
		START_BOUNDARY: s++,
		HEADER_FIELD_START: s++,
		HEADER_FIELD: s++,
		HEADER_VALUE_START: s++,
		HEADER_VALUE: s++,
		HEADER_VALUE_ALMOST_DONE: s++,
		HEADERS_ALMOST_DONE: s++,
		PART_DATA_START: s++,
		PART_DATA: s++,
		END: s++
	};
	f = 1;
	F = {
		PART_BOUNDARY: f,
		LAST_BOUNDARY: f *= 2
	};
	LF = 10;
	CR = 13;
	SPACE = 32;
	HYPHEN = 45;
	COLON = 58;
	A = 97;
	Z = 122;
	lower = (c) => c | 32;
	noop = () => {};
	MultipartParser = class {
		/**
		* @param {string} boundary
		*/
		constructor(boundary) {
			this.index = 0;
			this.flags = 0;
			this.onHeaderEnd = noop;
			this.onHeaderField = noop;
			this.onHeadersEnd = noop;
			this.onHeaderValue = noop;
			this.onPartBegin = noop;
			this.onPartData = noop;
			this.onPartEnd = noop;
			this.boundaryChars = {};
			boundary = "\r\n--" + boundary;
			const ui8a = new Uint8Array(boundary.length);
			for (let i$2 = 0; i$2 < boundary.length; i$2++) {
				ui8a[i$2] = boundary.charCodeAt(i$2);
				this.boundaryChars[ui8a[i$2]] = true;
			}
			this.boundary = ui8a;
			this.lookbehind = new Uint8Array(this.boundary.length + 8);
			this.state = S.START_BOUNDARY;
		}
		/**
		* @param {Uint8Array} data
		*/
		write(data) {
			let i$2 = 0;
			const length_ = data.length;
			let previousIndex = this.index;
			let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
			const boundaryLength = this.boundary.length;
			const boundaryEnd = boundaryLength - 1;
			const bufferLength = data.length;
			let c;
			let cl;
			const mark = (name) => {
				this[name + "Mark"] = i$2;
			};
			const clear$1 = (name) => {
				delete this[name + "Mark"];
			};
			const callback = (callbackSymbol, start, end, ui8a) => {
				if (start === void 0 || start !== end) this[callbackSymbol](ui8a && ui8a.subarray(start, end));
			};
			const dataCallback = (name, clear$2) => {
				const markSymbol = name + "Mark";
				if (!(markSymbol in this)) return;
				if (clear$2) {
					callback(name, this[markSymbol], i$2, data);
					delete this[markSymbol];
				} else {
					callback(name, this[markSymbol], data.length, data);
					this[markSymbol] = 0;
				}
			};
			for (i$2 = 0; i$2 < length_; i$2++) {
				c = data[i$2];
				switch (state) {
					case S.START_BOUNDARY:
						if (index === boundary.length - 2) {
							if (c === HYPHEN) flags |= F.LAST_BOUNDARY;
							else if (c !== CR) return;
							index++;
							break;
						} else if (index - 1 === boundary.length - 2) {
							if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
								state = S.END;
								flags = 0;
							} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
								index = 0;
								callback("onPartBegin");
								state = S.HEADER_FIELD_START;
							} else return;
							break;
						}
						if (c !== boundary[index + 2]) index = -2;
						if (c === boundary[index + 2]) index++;
						break;
					case S.HEADER_FIELD_START:
						state = S.HEADER_FIELD;
						mark("onHeaderField");
						index = 0;
					case S.HEADER_FIELD:
						if (c === CR) {
							clear$1("onHeaderField");
							state = S.HEADERS_ALMOST_DONE;
							break;
						}
						index++;
						if (c === HYPHEN) break;
						if (c === COLON) {
							if (index === 1) return;
							dataCallback("onHeaderField", true);
							state = S.HEADER_VALUE_START;
							break;
						}
						cl = lower(c);
						if (cl < A || cl > Z) return;
						break;
					case S.HEADER_VALUE_START:
						if (c === SPACE) break;
						mark("onHeaderValue");
						state = S.HEADER_VALUE;
					case S.HEADER_VALUE:
						if (c === CR) {
							dataCallback("onHeaderValue", true);
							callback("onHeaderEnd");
							state = S.HEADER_VALUE_ALMOST_DONE;
						}
						break;
					case S.HEADER_VALUE_ALMOST_DONE:
						if (c !== LF) return;
						state = S.HEADER_FIELD_START;
						break;
					case S.HEADERS_ALMOST_DONE:
						if (c !== LF) return;
						callback("onHeadersEnd");
						state = S.PART_DATA_START;
						break;
					case S.PART_DATA_START:
						state = S.PART_DATA;
						mark("onPartData");
					case S.PART_DATA:
						previousIndex = index;
						if (index === 0) {
							i$2 += boundaryEnd;
							while (i$2 < bufferLength && !(data[i$2] in boundaryChars)) i$2 += boundaryLength;
							i$2 -= boundaryEnd;
							c = data[i$2];
						}
						if (index < boundary.length) if (boundary[index] === c) {
							if (index === 0) dataCallback("onPartData", true);
							index++;
						} else index = 0;
						else if (index === boundary.length) {
							index++;
							if (c === CR) flags |= F.PART_BOUNDARY;
							else if (c === HYPHEN) flags |= F.LAST_BOUNDARY;
							else index = 0;
						} else if (index - 1 === boundary.length) if (flags & F.PART_BOUNDARY) {
							index = 0;
							if (c === LF) {
								flags &= ~F.PART_BOUNDARY;
								callback("onPartEnd");
								callback("onPartBegin");
								state = S.HEADER_FIELD_START;
								break;
							}
						} else if (flags & F.LAST_BOUNDARY) if (c === HYPHEN) {
							callback("onPartEnd");
							state = S.END;
							flags = 0;
						} else index = 0;
						else index = 0;
						if (index > 0) lookbehind[index - 1] = c;
						else if (previousIndex > 0) {
							const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
							callback("onPartData", 0, previousIndex, _lookbehind);
							previousIndex = 0;
							mark("onPartData");
							i$2--;
						}
						break;
					case S.END: break;
					default: throw new Error(`Unexpected state entered: ${state}`);
				}
			}
			dataCallback("onHeaderField");
			dataCallback("onHeaderValue");
			dataCallback("onPartData");
			this.index = index;
			this.state = state;
			this.flags = flags;
		}
		end() {
			if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) this.onPartEnd();
			else if (this.state !== S.END) throw new Error("MultipartParser.end(): stream ended unexpectedly");
		}
	};
}));

//#endregion
//#region node_modules/node-fetch/src/body.js
/**
* Body.js
*
* Body interface provides common methods for Request and Response
*/
/**
* Consume and convert an entire Body to a Buffer.
*
* Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
*
* @return Promise
*/
async function consumeBody(data) {
	if (data[INTERNALS$2].disturbed) throw new TypeError(`body used already for: ${data.url}`);
	data[INTERNALS$2].disturbed = true;
	if (data[INTERNALS$2].error) throw data[INTERNALS$2].error;
	const { body } = data;
	if (body === null) return node_buffer.Buffer.alloc(0);
	/* c8 ignore next 3 */
	if (!(body instanceof node_stream.default)) return node_buffer.Buffer.alloc(0);
	const accum = [];
	let accumBytes = 0;
	try {
		for await (const chunk of body) {
			if (data.size > 0 && accumBytes + chunk.length > data.size) {
				const error$1 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
				body.destroy(error$1);
				throw error$1;
			}
			accumBytes += chunk.length;
			accum.push(chunk);
		}
	} catch (error$1) {
		throw error$1 instanceof FetchBaseError ? error$1 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error$1.message}`, "system", error$1);
	}
	if (body.readableEnded === true || body._readableState.ended === true) try {
		if (accum.every((c) => typeof c === "string")) return node_buffer.Buffer.from(accum.join(""));
		return node_buffer.Buffer.concat(accum, accumBytes);
	} catch (error$1) {
		throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error$1.message}`, "system", error$1);
	}
	else throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
}
var pipeline, INTERNALS$2, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream;
var init_body = __esmMin((() => {
	init_fetch_blob();
	init_esm_min();
	init_fetch_error();
	init_base();
	init_is();
	pipeline = (0, node_util.promisify)(node_stream.default.pipeline);
	INTERNALS$2 = Symbol("Body internals");
	Body = class {
		constructor(body, { size = 0 } = {}) {
			let boundary = null;
			if (body === null) body = null;
			else if (isURLSearchParameters(body)) body = node_buffer.Buffer.from(body.toString());
			else if (isBlob$3(body)) {} else if (node_buffer.Buffer.isBuffer(body)) {} else if (node_util.types.isAnyArrayBuffer(body)) body = node_buffer.Buffer.from(body);
			else if (ArrayBuffer.isView(body)) body = node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
			else if (body instanceof node_stream.default) {} else if (body instanceof FormData$1) {
				body = formDataToBlob(body);
				boundary = body.type.split("=")[1];
			} else body = node_buffer.Buffer.from(String(body));
			let stream$6 = body;
			if (node_buffer.Buffer.isBuffer(body)) stream$6 = node_stream.default.Readable.from(body);
			else if (isBlob$3(body)) stream$6 = node_stream.default.Readable.from(body.stream());
			this[INTERNALS$2] = {
				body,
				stream: stream$6,
				boundary,
				disturbed: false,
				error: null
			};
			this.size = size;
			if (body instanceof node_stream.default) body.on("error", (error_) => {
				const error$1 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
				this[INTERNALS$2].error = error$1;
			});
		}
		get body() {
			return this[INTERNALS$2].stream;
		}
		get bodyUsed() {
			return this[INTERNALS$2].disturbed;
		}
		/**
		* Decode response as ArrayBuffer
		*
		* @return  Promise
		*/
		async arrayBuffer() {
			const { buffer: buffer$1, byteOffset, byteLength: byteLength$1 } = await consumeBody(this);
			return buffer$1.slice(byteOffset, byteOffset + byteLength$1);
		}
		async formData() {
			const ct = this.headers.get("content-type");
			if (ct.startsWith("application/x-www-form-urlencoded")) {
				const formData = new FormData$1();
				const parameters = new URLSearchParams(await this.text());
				for (const [name, value] of parameters) formData.append(name, value);
				return formData;
			}
			const { toFormData: toFormData$1 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
			return toFormData$1(this.body, ct);
		}
		/**
		* Return raw response as Blob
		*
		* @return Promise
		*/
		async blob() {
			const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
			return new fetch_blob_default([await this.arrayBuffer()], { type: ct });
		}
		/**
		* Decode response as json
		*
		* @return  Promise
		*/
		async json() {
			const text = await this.text();
			return JSON.parse(text);
		}
		/**
		* Decode response as text
		*
		* @return  Promise
		*/
		async text() {
			const buffer$1 = await consumeBody(this);
			return new TextDecoder().decode(buffer$1);
		}
		/**
		* Decode response as buffer (non-spec api)
		*
		* @return  Promise
		*/
		buffer() {
			return consumeBody(this);
		}
	};
	Body.prototype.buffer = (0, node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
	Object.defineProperties(Body.prototype, {
		body: { enumerable: true },
		bodyUsed: { enumerable: true },
		arrayBuffer: { enumerable: true },
		blob: { enumerable: true },
		json: { enumerable: true },
		text: { enumerable: true },
		data: { get: (0, node_util.deprecate)(() => {}, "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)") }
	});
	clone = (instance$1, highWaterMark) => {
		let p1;
		let p2;
		let { body } = instance$1[INTERNALS$2];
		if (instance$1.bodyUsed) throw new Error("cannot clone body after it is used");
		if (body instanceof node_stream.default && typeof body.getBoundary !== "function") {
			p1 = new node_stream.PassThrough({ highWaterMark });
			p2 = new node_stream.PassThrough({ highWaterMark });
			body.pipe(p1);
			body.pipe(p2);
			instance$1[INTERNALS$2].stream = p1;
			body = p2;
		}
		return body;
	};
	getNonSpecFormDataBoundary = (0, node_util.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
	extractContentType = (body, request$3) => {
		if (body === null) return null;
		if (typeof body === "string") return "text/plain;charset=UTF-8";
		if (isURLSearchParameters(body)) return "application/x-www-form-urlencoded;charset=UTF-8";
		if (isBlob$3(body)) return body.type || null;
		if (node_buffer.Buffer.isBuffer(body) || node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) return null;
		if (body instanceof FormData$1) return `multipart/form-data; boundary=${request$3[INTERNALS$2].boundary}`;
		if (body && typeof body.getBoundary === "function") return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
		if (body instanceof node_stream.default) return null;
		return "text/plain;charset=UTF-8";
	};
	getTotalBytes = (request$3) => {
		const { body } = request$3[INTERNALS$2];
		if (body === null) return 0;
		if (isBlob$3(body)) return body.size;
		if (node_buffer.Buffer.isBuffer(body)) return body.length;
		if (body && typeof body.getLengthSync === "function") return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
		return null;
	};
	writeToStream = async (dest, { body }) => {
		if (body === null) dest.end();
		else await pipeline(body, dest);
	};
}));

//#endregion
//#region node_modules/node-fetch/src/headers.js
/**
* Headers.js
*
* Headers class offers convenient helpers
*/
/**
* Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
* not conform to HTTP grammar productions.
* @param {import('http').IncomingMessage['rawHeaders']} headers
*/
function fromRawHeaders(headers = []) {
	return new Headers$1(headers.reduce((result, value, index, array) => {
		if (index % 2 === 0) result.push(array.slice(index, index + 2));
		return result;
	}, []).filter(([name, value]) => {
		try {
			validateHeaderName(name);
			validateHeaderValue(name, String(value));
			return true;
		} catch {
			return false;
		}
	}));
}
var validateHeaderName, validateHeaderValue, Headers$1;
var init_headers = __esmMin((() => {
	validateHeaderName = typeof node_http.default.validateHeaderName === "function" ? node_http.default.validateHeaderName : (name) => {
		if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
			const error$1 = /* @__PURE__ */ new TypeError(`Header name must be a valid HTTP token [${name}]`);
			Object.defineProperty(error$1, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
			throw error$1;
		}
	};
	validateHeaderValue = typeof node_http.default.validateHeaderValue === "function" ? node_http.default.validateHeaderValue : (name, value) => {
		if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
			const error$1 = /* @__PURE__ */ new TypeError(`Invalid character in header content ["${name}"]`);
			Object.defineProperty(error$1, "code", { value: "ERR_INVALID_CHAR" });
			throw error$1;
		}
	};
	Headers$1 = class Headers$1 extends URLSearchParams {
		/**
		* Headers class
		*
		* @constructor
		* @param {HeadersInit} [init] - Response headers
		*/
		constructor(init$1) {
			/** @type {string[][]} */
			let result = [];
			if (init$1 instanceof Headers$1) {
				const raw = init$1.raw();
				for (const [name, values] of Object.entries(raw)) result.push(...values.map((value) => [name, value]));
			} else if (init$1 == null) {} else if (typeof init$1 === "object" && !node_util.types.isBoxedPrimitive(init$1)) {
				const method = init$1[Symbol.iterator];
				if (method == null) result.push(...Object.entries(init$1));
				else {
					if (typeof method !== "function") throw new TypeError("Header pairs must be iterable");
					result = [...init$1].map((pair) => {
						if (typeof pair !== "object" || node_util.types.isBoxedPrimitive(pair)) throw new TypeError("Each header pair must be an iterable object");
						return [...pair];
					}).map((pair) => {
						if (pair.length !== 2) throw new TypeError("Each header pair must be a name/value tuple");
						return [...pair];
					});
				}
			} else throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
			result = result.length > 0 ? result.map(([name, value]) => {
				validateHeaderName(name);
				validateHeaderValue(name, String(value));
				return [String(name).toLowerCase(), String(value)];
			}) : void 0;
			super(result);
			return new Proxy(this, { get(target, p, receiver) {
				switch (p) {
					case "append":
					case "set": return (name, value) => {
						validateHeaderName(name);
						validateHeaderValue(name, String(value));
						return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
					};
					case "delete":
					case "has":
					case "getAll": return (name) => {
						validateHeaderName(name);
						return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
					};
					case "keys": return () => {
						target.sort();
						return new Set(URLSearchParams.prototype.keys.call(target)).keys();
					};
					default: return Reflect.get(target, p, receiver);
				}
			} });
			/* c8 ignore next */
		}
		get [Symbol.toStringTag]() {
			return this.constructor.name;
		}
		toString() {
			return Object.prototype.toString.call(this);
		}
		get(name) {
			const values = this.getAll(name);
			if (values.length === 0) return null;
			let value = values.join(", ");
			if (/^content-encoding$/i.test(name)) value = value.toLowerCase();
			return value;
		}
		forEach(callback, thisArg = void 0) {
			for (const name of this.keys()) Reflect.apply(callback, thisArg, [
				this.get(name),
				name,
				this
			]);
		}
		*values() {
			for (const name of this.keys()) yield this.get(name);
		}
		/**
		* @type {() => IterableIterator<[string, string]>}
		*/
		*entries() {
			for (const name of this.keys()) yield [name, this.get(name)];
		}
		[Symbol.iterator]() {
			return this.entries();
		}
		/**
		* Node-fetch non-spec method
		* returning all headers and their values as array
		* @returns {Record<string, string[]>}
		*/
		raw() {
			return [...this.keys()].reduce((result, key) => {
				result[key] = this.getAll(key);
				return result;
			}, {});
		}
		/**
		* For better console.log(headers) and also to convert Headers into Node.js Request compatible format
		*/
		[Symbol.for("nodejs.util.inspect.custom")]() {
			return [...this.keys()].reduce((result, key) => {
				const values = this.getAll(key);
				if (key === "host") result[key] = values[0];
				else result[key] = values.length > 1 ? values : values[0];
				return result;
			}, {});
		}
	};
	/**
	* Re-shaping object for Web IDL tests
	* Only need to do it for overridden methods
	*/
	Object.defineProperties(Headers$1.prototype, [
		"get",
		"entries",
		"forEach",
		"values"
	].reduce((result, property) => {
		result[property] = { enumerable: true };
		return result;
	}, {}));
}));

//#endregion
//#region node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus, isRedirect;
var init_is_redirect = __esmMin((() => {
	redirectStatus = new Set([
		301,
		302,
		303,
		307,
		308
	]);
	isRedirect = (code$1) => {
		return redirectStatus.has(code$1);
	};
}));

//#endregion
//#region node_modules/node-fetch/src/response.js
var INTERNALS$1, Response$1;
var init_response = __esmMin((() => {
	init_headers();
	init_body();
	init_is_redirect();
	INTERNALS$1 = Symbol("Response internals");
	Response$1 = class Response$1 extends Body {
		constructor(body = null, options = {}) {
			super(body, options);
			const status = options.status != null ? options.status : 200;
			const headers = new Headers$1(options.headers);
			if (body !== null && !headers.has("Content-Type")) {
				const contentType = extractContentType(body, this);
				if (contentType) headers.append("Content-Type", contentType);
			}
			this[INTERNALS$1] = {
				type: "default",
				url: options.url,
				status,
				statusText: options.statusText || "",
				headers,
				counter: options.counter,
				highWaterMark: options.highWaterMark
			};
		}
		get type() {
			return this[INTERNALS$1].type;
		}
		get url() {
			return this[INTERNALS$1].url || "";
		}
		get status() {
			return this[INTERNALS$1].status;
		}
		/**
		* Convenience property representing if the request ended normally
		*/
		get ok() {
			return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
		}
		get redirected() {
			return this[INTERNALS$1].counter > 0;
		}
		get statusText() {
			return this[INTERNALS$1].statusText;
		}
		get headers() {
			return this[INTERNALS$1].headers;
		}
		get highWaterMark() {
			return this[INTERNALS$1].highWaterMark;
		}
		/**
		* Clone this response
		*
		* @return  Response
		*/
		clone() {
			return new Response$1(clone(this, this.highWaterMark), {
				type: this.type,
				url: this.url,
				status: this.status,
				statusText: this.statusText,
				headers: this.headers,
				ok: this.ok,
				redirected: this.redirected,
				size: this.size,
				highWaterMark: this.highWaterMark
			});
		}
		/**
		* @param {string} url    The URL that the new response is to originate from.
		* @param {number} status An optional status code for the response (e.g., 302.)
		* @returns {Response}    A Response object.
		*/
		static redirect(url, status = 302) {
			if (!isRedirect(status)) throw new RangeError("Failed to execute \"redirect\" on \"response\": Invalid status code");
			return new Response$1(null, {
				headers: { location: new URL(url).toString() },
				status
			});
		}
		static error() {
			const response = new Response$1(null, {
				status: 0,
				statusText: ""
			});
			response[INTERNALS$1].type = "error";
			return response;
		}
		static json(data = void 0, init$1 = {}) {
			const body = JSON.stringify(data);
			if (body === void 0) throw new TypeError("data is not JSON serializable");
			const headers = new Headers$1(init$1 && init$1.headers);
			if (!headers.has("content-type")) headers.set("content-type", "application/json");
			return new Response$1(body, {
				...init$1,
				headers
			});
		}
		get [Symbol.toStringTag]() {
			return "Response";
		}
	};
	Object.defineProperties(Response$1.prototype, {
		type: { enumerable: true },
		url: { enumerable: true },
		status: { enumerable: true },
		ok: { enumerable: true },
		redirected: { enumerable: true },
		statusText: { enumerable: true },
		headers: { enumerable: true },
		clone: { enumerable: true }
	});
}));

//#endregion
//#region node_modules/node-fetch/src/utils/get-search.js
var getSearch;
var init_get_search = __esmMin((() => {
	getSearch = (parsedURL) => {
		if (parsedURL.search) return parsedURL.search;
		const lastOffset = parsedURL.href.length - 1;
		const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
		return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
	};
}));

//#endregion
//#region node_modules/node-fetch/src/utils/referrer.js
/**
* @external URL
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}
*/
/**
* @module utils/referrer
* @private
*/
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy 8.4. Strip url for use as a referrer}
* @param {string} URL
* @param {boolean} [originOnly=false]
*/
function stripURLForUseAsAReferrer(url, originOnly = false) {
	if (url == null) return "no-referrer";
	url = new URL(url);
	if (/^(about|blob|data):$/.test(url.protocol)) return "no-referrer";
	url.username = "";
	url.password = "";
	url.hash = "";
	if (originOnly) {
		url.pathname = "";
		url.search = "";
	}
	return url;
}
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy 3. Referrer Policies}
* @param {string} referrerPolicy
* @returns {string} referrerPolicy
*/
function validateReferrerPolicy(referrerPolicy$2) {
	if (!ReferrerPolicy.has(referrerPolicy$2)) throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy$2}`);
	return referrerPolicy$2;
}
/**
* @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy 3.2. Is origin potentially trustworthy?}
* @param {external:URL} url
* @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
*/
function isOriginPotentiallyTrustworthy(url) {
	if (/^(http|ws)s:$/.test(url.protocol)) return true;
	const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
	const hostIPVersion = (0, node_net.isIP)(hostIp);
	if (hostIPVersion === 4 && /^127\./.test(hostIp)) return true;
	if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) return true;
	if (url.host === "localhost" || url.host.endsWith(".localhost")) return false;
	if (url.protocol === "file:") return true;
	return false;
}
/**
* @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy 3.3. Is url potentially trustworthy?}
* @param {external:URL} url
* @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
*/
function isUrlPotentiallyTrustworthy(url) {
	if (/^about:(blank|srcdoc)$/.test(url)) return true;
	if (url.protocol === "data:") return true;
	if (/^(blob|filesystem):$/.test(url.protocol)) return true;
	return isOriginPotentiallyTrustworthy(url);
}
/**
* Modifies the referrerURL to enforce any extra security policy considerations.
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7
* @callback module:utils/referrer~referrerURLCallback
* @param {external:URL} referrerURL
* @returns {external:URL} modified referrerURL
*/
/**
* Modifies the referrerOrigin to enforce any extra security policy considerations.
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7
* @callback module:utils/referrer~referrerOriginCallback
* @param {external:URL} referrerOrigin
* @returns {external:URL} modified referrerOrigin
*/
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}
* @param {Request} request
* @param {object} o
* @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback
* @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback
* @returns {external:URL} Request's referrer
*/
function determineRequestsReferrer(request$3, { referrerURLCallback, referrerOriginCallback } = {}) {
	if (request$3.referrer === "no-referrer" || request$3.referrerPolicy === "") return null;
	const policy = request$3.referrerPolicy;
	if (request$3.referrer === "about:client") return "no-referrer";
	const referrerSource = request$3.referrer;
	let referrerURL = stripURLForUseAsAReferrer(referrerSource);
	let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
	if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
	if (referrerURLCallback) referrerURL = referrerURLCallback(referrerURL);
	if (referrerOriginCallback) referrerOrigin = referrerOriginCallback(referrerOrigin);
	const currentURL = new URL(request$3.url);
	switch (policy) {
		case "no-referrer": return "no-referrer";
		case "origin": return referrerOrigin;
		case "unsafe-url": return referrerURL;
		case "strict-origin":
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) return "no-referrer";
			return referrerOrigin.toString();
		case "strict-origin-when-cross-origin":
			if (referrerURL.origin === currentURL.origin) return referrerURL;
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) return "no-referrer";
			return referrerOrigin;
		case "same-origin":
			if (referrerURL.origin === currentURL.origin) return referrerURL;
			return "no-referrer";
		case "origin-when-cross-origin":
			if (referrerURL.origin === currentURL.origin) return referrerURL;
			return referrerOrigin;
		case "no-referrer-when-downgrade":
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) return "no-referrer";
			return referrerURL;
		default: throw new TypeError(`Invalid referrerPolicy: ${policy}`);
	}
}
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy 8.1. Parse a referrer policy from a Referrer-Policy header}
* @param {Headers} headers Response headers
* @returns {string} policy
*/
function parseReferrerPolicyFromHeader(headers) {
	const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
	let policy = "";
	for (const token of policyTokens) if (token && ReferrerPolicy.has(token)) policy = token;
	return policy;
}
var ReferrerPolicy, DEFAULT_REFERRER_POLICY;
var init_referrer = __esmMin((() => {
	ReferrerPolicy = new Set([
		"",
		"no-referrer",
		"no-referrer-when-downgrade",
		"same-origin",
		"origin",
		"strict-origin",
		"origin-when-cross-origin",
		"strict-origin-when-cross-origin",
		"unsafe-url"
	]);
	DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
}));

//#endregion
//#region node_modules/node-fetch/src/request.js
/**
* Request.js
*
* Request class contains server only options
*
* All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
*/
var INTERNALS, isRequest, doBadDataWarn, Request, getNodeRequestOptions;
var init_request = __esmMin((() => {
	init_headers();
	init_body();
	init_is();
	init_get_search();
	init_referrer();
	INTERNALS = Symbol("Request internals");
	isRequest = (object) => {
		return typeof object === "object" && typeof object[INTERNALS] === "object";
	};
	doBadDataWarn = (0, node_util.deprecate)(() => {}, ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");
	Request = class Request extends Body {
		constructor(input, init$1 = {}) {
			let parsedURL;
			if (isRequest(input)) parsedURL = new URL(input.url);
			else {
				parsedURL = new URL(input);
				input = {};
			}
			if (parsedURL.username !== "" || parsedURL.password !== "") throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
			let method = init$1.method || input.method || "GET";
			if (/^(delete|get|head|options|post|put)$/i.test(method)) method = method.toUpperCase();
			if (!isRequest(init$1) && "data" in init$1) doBadDataWarn();
			if ((init$1.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body");
			const inputBody = init$1.body ? init$1.body : isRequest(input) && input.body !== null ? clone(input) : null;
			super(inputBody, { size: init$1.size || input.size || 0 });
			const headers = new Headers$1(init$1.headers || input.headers || {});
			if (inputBody !== null && !headers.has("Content-Type")) {
				const contentType = extractContentType(inputBody, this);
				if (contentType) headers.set("Content-Type", contentType);
			}
			let signal = isRequest(input) ? input.signal : null;
			if ("signal" in init$1) signal = init$1.signal;
			if (signal != null && !isAbortSignal(signal)) throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
			let referrer = init$1.referrer == null ? input.referrer : init$1.referrer;
			if (referrer === "") referrer = "no-referrer";
			else if (referrer) {
				const parsedReferrer = new URL(referrer);
				referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
			} else referrer = void 0;
			this[INTERNALS] = {
				method,
				redirect: init$1.redirect || input.redirect || "follow",
				headers,
				parsedURL,
				signal,
				referrer
			};
			this.follow = init$1.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init$1.follow;
			this.compress = init$1.compress === void 0 ? input.compress === void 0 ? true : input.compress : init$1.compress;
			this.counter = init$1.counter || input.counter || 0;
			this.agent = init$1.agent || input.agent;
			this.highWaterMark = init$1.highWaterMark || input.highWaterMark || 16384;
			this.insecureHTTPParser = init$1.insecureHTTPParser || input.insecureHTTPParser || false;
			this.referrerPolicy = init$1.referrerPolicy || input.referrerPolicy || "";
		}
		/** @returns {string} */
		get method() {
			return this[INTERNALS].method;
		}
		/** @returns {string} */
		get url() {
			return (0, node_url.format)(this[INTERNALS].parsedURL);
		}
		/** @returns {Headers} */
		get headers() {
			return this[INTERNALS].headers;
		}
		get redirect() {
			return this[INTERNALS].redirect;
		}
		/** @returns {AbortSignal} */
		get signal() {
			return this[INTERNALS].signal;
		}
		get referrer() {
			if (this[INTERNALS].referrer === "no-referrer") return "";
			if (this[INTERNALS].referrer === "client") return "about:client";
			if (this[INTERNALS].referrer) return this[INTERNALS].referrer.toString();
		}
		get referrerPolicy() {
			return this[INTERNALS].referrerPolicy;
		}
		set referrerPolicy(referrerPolicy$2) {
			this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy$2);
		}
		/**
		* Clone this request
		*
		* @return  Request
		*/
		clone() {
			return new Request(this);
		}
		get [Symbol.toStringTag]() {
			return "Request";
		}
	};
	Object.defineProperties(Request.prototype, {
		method: { enumerable: true },
		url: { enumerable: true },
		headers: { enumerable: true },
		redirect: { enumerable: true },
		clone: { enumerable: true },
		signal: { enumerable: true },
		referrer: { enumerable: true },
		referrerPolicy: { enumerable: true }
	});
	getNodeRequestOptions = (request$3) => {
		const { parsedURL } = request$3[INTERNALS];
		const headers = new Headers$1(request$3[INTERNALS].headers);
		if (!headers.has("Accept")) headers.set("Accept", "*/*");
		let contentLengthValue = null;
		if (request$3.body === null && /^(post|put)$/i.test(request$3.method)) contentLengthValue = "0";
		if (request$3.body !== null) {
			const totalBytes = getTotalBytes(request$3);
			if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) contentLengthValue = String(totalBytes);
		}
		if (contentLengthValue) headers.set("Content-Length", contentLengthValue);
		if (request$3.referrerPolicy === "") request$3.referrerPolicy = DEFAULT_REFERRER_POLICY;
		if (request$3.referrer && request$3.referrer !== "no-referrer") request$3[INTERNALS].referrer = determineRequestsReferrer(request$3);
		else request$3[INTERNALS].referrer = "no-referrer";
		if (request$3[INTERNALS].referrer instanceof URL) headers.set("Referer", request$3.referrer);
		if (!headers.has("User-Agent")) headers.set("User-Agent", "node-fetch");
		if (request$3.compress && !headers.has("Accept-Encoding")) headers.set("Accept-Encoding", "gzip, deflate, br");
		let { agent } = request$3;
		if (typeof agent === "function") agent = agent(parsedURL);
		const search = getSearch(parsedURL);
		return {
			parsedURL,
			options: {
				path: parsedURL.pathname + search,
				method: request$3.method,
				headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
				insecureHTTPParser: request$3.insecureHTTPParser,
				agent
			}
		};
	};
}));

//#endregion
//#region node_modules/node-fetch/src/errors/abort-error.js
var AbortError;
var init_abort_error = __esmMin((() => {
	init_base();
	AbortError = class extends FetchBaseError {
		constructor(message, type = "aborted") {
			super(message, type);
		}
	};
}));

//#endregion
//#region node_modules/node-fetch/src/index.js
/**
* Index.js
*
* a request API compatible with window.fetch
*
* All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
*/
var src_exports = /* @__PURE__ */ __export$8({
	AbortError: () => AbortError,
	Blob: () => fetch_blob_default,
	FetchError: () => FetchError,
	File: () => file_default,
	FormData: () => FormData$1,
	Headers: () => Headers$1,
	Request: () => Request,
	Response: () => Response$1,
	blobFrom: () => blobFrom,
	blobFromSync: () => blobFromSync,
	default: () => fetch$1,
	fileFrom: () => fileFrom,
	fileFromSync: () => fileFromSync,
	isRedirect: () => isRedirect
});
/**
* Fetch function
*
* @param   {string | URL | import('./request').default} url - Absolute url or Request instance
* @param   {*} [options_] - Fetch options
* @return  {Promise<import('./response').default>}
*/
async function fetch$1(url, options_) {
	return new Promise((resolve, reject) => {
		const request$3 = new Request(url, options_);
		const { parsedURL, options } = getNodeRequestOptions(request$3);
		if (!supportedSchemas.has(parsedURL.protocol)) throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
		if (parsedURL.protocol === "data:") {
			const data = dist_default(request$3.url);
			resolve(new Response$1(data, { headers: { "Content-Type": data.typeFull } }));
			return;
		}
		const send = (parsedURL.protocol === "https:" ? node_https.default : node_http.default).request;
		const { signal } = request$3;
		let response = null;
		const abort$1 = () => {
			const error$1 = new AbortError("The operation was aborted.");
			reject(error$1);
			if (request$3.body && request$3.body instanceof node_stream.default.Readable) request$3.body.destroy(error$1);
			if (!response || !response.body) return;
			response.body.emit("error", error$1);
		};
		if (signal && signal.aborted) {
			abort$1();
			return;
		}
		const abortAndFinalize = () => {
			abort$1();
			finalize();
		};
		const request_ = send(parsedURL.toString(), options);
		if (signal) signal.addEventListener("abort", abortAndFinalize);
		const finalize = () => {
			request_.abort();
			if (signal) signal.removeEventListener("abort", abortAndFinalize);
		};
		request_.on("error", (error$1) => {
			reject(new FetchError(`request to ${request$3.url} failed, reason: ${error$1.message}`, "system", error$1));
			finalize();
		});
		fixResponseChunkedTransferBadEnding(request_, (error$1) => {
			if (response && response.body) response.body.destroy(error$1);
		});
		/* c8 ignore next 18 */
		if (process.version < "v14") request_.on("socket", (s$2) => {
			let endedWithEventsCount;
			s$2.prependListener("end", () => {
				endedWithEventsCount = s$2._eventsCount;
			});
			s$2.prependListener("close", (hadError) => {
				if (response && endedWithEventsCount < s$2._eventsCount && !hadError) {
					const error$1 = /* @__PURE__ */ new Error("Premature close");
					error$1.code = "ERR_STREAM_PREMATURE_CLOSE";
					response.body.emit("error", error$1);
				}
			});
		});
		request_.on("response", (response_) => {
			request_.setTimeout(0);
			const headers = fromRawHeaders(response_.rawHeaders);
			if (isRedirect(response_.statusCode)) {
				const location = headers.get("Location");
				let locationURL = null;
				try {
					locationURL = location === null ? null : new URL(location, request$3.url);
				} catch {
					if (request$3.redirect !== "manual") {
						reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
						finalize();
						return;
					}
				}
				switch (request$3.redirect) {
					case "error":
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request$3.url}`, "no-redirect"));
						finalize();
						return;
					case "manual": break;
					case "follow": {
						if (locationURL === null) break;
						if (request$3.counter >= request$3.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request$3.url}`, "max-redirect"));
							finalize();
							return;
						}
						const requestOptions = {
							headers: new Headers$1(request$3.headers),
							follow: request$3.follow,
							counter: request$3.counter + 1,
							agent: request$3.agent,
							compress: request$3.compress,
							method: request$3.method,
							body: clone(request$3),
							signal: request$3.signal,
							size: request$3.size,
							referrer: request$3.referrer,
							referrerPolicy: request$3.referrerPolicy
						};
						if (!isDomainOrSubdomain(request$3.url, locationURL) || !isSameProtocol(request$3.url, locationURL)) for (const name of [
							"authorization",
							"www-authenticate",
							"cookie",
							"cookie2"
						]) requestOptions.headers.delete(name);
						if (response_.statusCode !== 303 && request$3.body && options_.body instanceof node_stream.default.Readable) {
							reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
							finalize();
							return;
						}
						if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request$3.method === "POST") {
							requestOptions.method = "GET";
							requestOptions.body = void 0;
							requestOptions.headers.delete("content-length");
						}
						const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
						if (responseReferrerPolicy) requestOptions.referrerPolicy = responseReferrerPolicy;
						resolve(fetch$1(new Request(locationURL, requestOptions)));
						finalize();
						return;
					}
					default: return reject(/* @__PURE__ */ new TypeError(`Redirect option '${request$3.redirect}' is not a valid value of RequestRedirect`));
				}
			}
			if (signal) response_.once("end", () => {
				signal.removeEventListener("abort", abortAndFinalize);
			});
			let body = (0, node_stream.pipeline)(response_, new node_stream.PassThrough(), (error$1) => {
				if (error$1) reject(error$1);
			});
			/* c8 ignore next 3 */
			if (process.version < "v12.10") response_.on("aborted", abortAndFinalize);
			const responseOptions = {
				url: request$3.url,
				status: response_.statusCode,
				statusText: response_.statusMessage,
				headers,
				size: request$3.size,
				counter: request$3.counter,
				highWaterMark: request$3.highWaterMark
			};
			const codings = headers.get("Content-Encoding");
			if (!request$3.compress || request$3.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
				response = new Response$1(body, responseOptions);
				resolve(response);
				return;
			}
			const zlibOptions = {
				flush: node_zlib.default.Z_SYNC_FLUSH,
				finishFlush: node_zlib.default.Z_SYNC_FLUSH
			};
			if (codings === "gzip" || codings === "x-gzip") {
				body = (0, node_stream.pipeline)(body, node_zlib.default.createGunzip(zlibOptions), (error$1) => {
					if (error$1) reject(error$1);
				});
				response = new Response$1(body, responseOptions);
				resolve(response);
				return;
			}
			if (codings === "deflate" || codings === "x-deflate") {
				const raw = (0, node_stream.pipeline)(response_, new node_stream.PassThrough(), (error$1) => {
					if (error$1) reject(error$1);
				});
				raw.once("data", (chunk) => {
					if ((chunk[0] & 15) === 8) body = (0, node_stream.pipeline)(body, node_zlib.default.createInflate(), (error$1) => {
						if (error$1) reject(error$1);
					});
					else body = (0, node_stream.pipeline)(body, node_zlib.default.createInflateRaw(), (error$1) => {
						if (error$1) reject(error$1);
					});
					response = new Response$1(body, responseOptions);
					resolve(response);
				});
				raw.once("end", () => {
					if (!response) {
						response = new Response$1(body, responseOptions);
						resolve(response);
					}
				});
				return;
			}
			if (codings === "br") {
				body = (0, node_stream.pipeline)(body, node_zlib.default.createBrotliDecompress(), (error$1) => {
					if (error$1) reject(error$1);
				});
				response = new Response$1(body, responseOptions);
				resolve(response);
				return;
			}
			response = new Response$1(body, responseOptions);
			resolve(response);
		});
		writeToStream(request_, request$3).catch(reject);
	});
}
function fixResponseChunkedTransferBadEnding(request$3, errorCallback) {
	const LAST_CHUNK = node_buffer.Buffer.from("0\r\n\r\n");
	let isChunkedTransfer = false;
	let properLastChunkReceived = false;
	let previousChunk;
	request$3.on("response", (response) => {
		const { headers } = response;
		isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
	});
	request$3.on("socket", (socket) => {
		const onSocketClose$2 = () => {
			if (isChunkedTransfer && !properLastChunkReceived) {
				const error$1 = /* @__PURE__ */ new Error("Premature close");
				error$1.code = "ERR_STREAM_PREMATURE_CLOSE";
				errorCallback(error$1);
			}
		};
		const onData = (buf) => {
			properLastChunkReceived = node_buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
			if (!properLastChunkReceived && previousChunk) properLastChunkReceived = node_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && node_buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
			previousChunk = buf;
		};
		socket.prependListener("close", onSocketClose$2);
		socket.on("data", onData);
		request$3.on("close", () => {
			socket.removeListener("close", onSocketClose$2);
			socket.removeListener("data", onData);
		});
	});
}
var supportedSchemas;
var init_src = __esmMin((() => {
	init_dist();
	init_body();
	init_response();
	init_headers();
	init_request();
	init_fetch_error();
	init_abort_error();
	init_is_redirect();
	init_esm_min();
	init_is();
	init_referrer();
	init_from();
	supportedSchemas = new Set([
		"data:",
		"http:",
		"https:"
	]);
}));

//#endregion
//#region node_modules/gaxios/build/cjs/src/gaxios.js
var require_gaxios = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	var _a;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Gaxios = void 0;
	const extend_1 = __importDefault(require_extend());
	const https_1 = require("https");
	const common_js_1$1 = require_common$1();
	const retry_js_1 = require_retry();
	const stream_1 = require("stream");
	const interceptor_js_1 = require_interceptor();
	const randomUUID = async () => globalThis.crypto?.randomUUID() || (await import("crypto")).randomUUID();
	const HTTP_STATUS_NO_CONTENT = 204;
	var Gaxios = class {
		agentCache = /* @__PURE__ */ new Map();
		/**
		* Default HTTP options that will be used for every HTTP request.
		*/
		defaults;
		/**
		* Interceptors
		*/
		interceptors;
		/**
		* The Gaxios class is responsible for making HTTP requests.
		* @param defaults The default set of options to be used for this instance.
		*/
		constructor(defaults) {
			this.defaults = defaults || {};
			this.interceptors = {
				request: new interceptor_js_1.GaxiosInterceptorManager(),
				response: new interceptor_js_1.GaxiosInterceptorManager()
			};
		}
		/**
		* A {@link fetch `fetch`} compliant API for {@link Gaxios}.
		*
		* @remarks
		*
		* This is useful as a drop-in replacement for `fetch` API usage.
		*
		* @example
		*
		* ```ts
		* const gaxios = new Gaxios();
		* const myFetch: typeof fetch = (...args) => gaxios.fetch(...args);
		* await myFetch('https://example.com');
		* ```
		*
		* @param args `fetch` API or `Gaxios#request` parameters
		* @returns the {@link Response} with Gaxios-added properties
		*/
		fetch(...args) {
			const input = args[0];
			const init$1 = args[1];
			let url = void 0;
			const headers = new Headers();
			if (typeof input === "string") url = new URL(input);
			else if (input instanceof URL) url = input;
			else if (input && input.url) url = new URL(input.url);
			if (input && typeof input === "object" && "headers" in input) _a.mergeHeaders(headers, input.headers);
			if (init$1) _a.mergeHeaders(headers, new Headers(init$1.headers));
			if (typeof input === "object" && !(input instanceof URL)) return this.request({
				...init$1,
				...input,
				headers,
				url
			});
			else return this.request({
				...init$1,
				headers,
				url
			});
		}
		/**
		* Perform an HTTP request with the given options.
		* @param opts Set of HTTP options that will be used for this HTTP request.
		*/
		async request(opts = {}) {
			let prepared = await this.#prepareRequest(opts);
			prepared = await this.#applyRequestInterceptors(prepared);
			return this.#applyResponseInterceptors(this._request(prepared));
		}
		async _defaultAdapter(config) {
			const fetchImpl = config.fetchImplementation || this.defaults.fetchImplementation || await _a.#getFetch();
			const preparedOpts = { ...config };
			delete preparedOpts.data;
			const res = await fetchImpl(config.url, preparedOpts);
			const data = await this.getResponseData(config, res);
			if (!Object.getOwnPropertyDescriptor(res, "data")?.configurable) Object.defineProperties(res, { data: {
				configurable: true,
				writable: true,
				enumerable: true,
				value: data
			} });
			return Object.assign(res, {
				config,
				data
			});
		}
		/**
		* Internal, retryable version of the `request` method.
		* @param opts Set of HTTP options that will be used for this HTTP request.
		*/
		async _request(opts) {
			try {
				let translatedResponse;
				if (opts.adapter) translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));
				else translatedResponse = await this._defaultAdapter(opts);
				if (!opts.validateStatus(translatedResponse.status)) {
					if (opts.responseType === "stream") {
						const response = [];
						for await (const chunk of translatedResponse.data) response.push(chunk);
						translatedResponse.data = response.toString();
					}
					const errorInfo = common_js_1$1.GaxiosError.extractAPIErrorFromResponse(translatedResponse, `Request failed with status code ${translatedResponse.status}`);
					throw new common_js_1$1.GaxiosError(errorInfo?.message, opts, translatedResponse, errorInfo);
				}
				return translatedResponse;
			} catch (e$1) {
				let err;
				if (e$1 instanceof common_js_1$1.GaxiosError) err = e$1;
				else if (e$1 instanceof Error) err = new common_js_1$1.GaxiosError(e$1.message, opts, void 0, e$1);
				else err = new common_js_1$1.GaxiosError("Unexpected Gaxios Error", opts, void 0, e$1);
				const { shouldRetry, config } = await (0, retry_js_1.getRetryConfig)(err);
				if (shouldRetry && config) {
					err.config.retryConfig.currentRetryAttempt = config.retryConfig.currentRetryAttempt;
					opts.retryConfig = err.config?.retryConfig;
					this.#appendTimeoutToSignal(opts);
					return this._request(opts);
				}
				if (opts.errorRedactor) opts.errorRedactor(err);
				throw err;
			}
		}
		async getResponseData(opts, res) {
			if (res.status === HTTP_STATUS_NO_CONTENT) return "";
			if (opts.maxContentLength && res.headers.has("content-length") && opts.maxContentLength < Number.parseInt(res.headers?.get("content-length") || "")) throw new common_js_1$1.GaxiosError("Response's `Content-Length` is over the limit.", opts, Object.assign(res, { config: opts }));
			switch (opts.responseType) {
				case "stream": return res.body;
				case "json": {
					const data = await res.text();
					try {
						return JSON.parse(data);
					} catch {
						return data;
					}
				}
				case "arraybuffer": return res.arrayBuffer();
				case "blob": return res.blob();
				case "text": return res.text();
				default: return this.getResponseDataFromContentType(res);
			}
		}
		#urlMayUseProxy(url, noProxy = []) {
			const candidate = new URL(url);
			const noProxyList = [...noProxy];
			const noProxyEnvList = (process.env.NO_PROXY ?? process.env.no_proxy)?.split(",") || [];
			for (const rule of noProxyEnvList) noProxyList.push(rule.trim());
			for (const rule of noProxyList) if (rule instanceof RegExp) {
				if (rule.test(candidate.toString())) return false;
			} else if (rule instanceof URL) {
				if (rule.origin === candidate.origin) return false;
			} else if (rule.startsWith("*.") || rule.startsWith(".")) {
				const cleanedRule = rule.replace(/^\*\./, ".");
				if (candidate.hostname.endsWith(cleanedRule)) return false;
			} else if (rule === candidate.origin || rule === candidate.hostname || rule === candidate.href) return false;
			return true;
		}
		/**
		* Applies the request interceptors. The request interceptors are applied after the
		* call to prepareRequest is completed.
		*
		* @param {GaxiosOptionsPrepared} options The current set of options.
		*
		* @returns {Promise<GaxiosOptionsPrepared>} Promise that resolves to the set of options or response after interceptors are applied.
		*/
		async #applyRequestInterceptors(options) {
			let promiseChain = Promise.resolve(options);
			for (const interceptor of this.interceptors.request.values()) if (interceptor) promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
			return promiseChain;
		}
		/**
		* Applies the response interceptors. The response interceptors are applied after the
		* call to request is made.
		*
		* @param {GaxiosOptionsPrepared} options The current set of options.
		*
		* @returns {Promise<GaxiosOptionsPrepared>} Promise that resolves to the set of options or response after interceptors are applied.
		*/
		async #applyResponseInterceptors(response) {
			let promiseChain = Promise.resolve(response);
			for (const interceptor of this.interceptors.response.values()) if (interceptor) promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
			return promiseChain;
		}
		/**
		* Validates the options, merges them with defaults, and prepare request.
		*
		* @param options The original options passed from the client.
		* @returns Prepared options, ready to make a request
		*/
		async #prepareRequest(options) {
			const preparedHeaders = new Headers(this.defaults.headers);
			_a.mergeHeaders(preparedHeaders, options.headers);
			const opts = (0, extend_1.default)(true, {}, this.defaults, options);
			if (!opts.url) throw new Error("URL is required.");
			if (opts.baseURL) opts.url = new URL(opts.url, opts.baseURL);
			opts.url = new URL(opts.url);
			if (opts.params) if (opts.paramsSerializer) {
				let additionalQueryParams = opts.paramsSerializer(opts.params);
				if (additionalQueryParams.startsWith("?")) additionalQueryParams = additionalQueryParams.slice(1);
				const prefix = opts.url.toString().includes("?") ? "&" : "?";
				opts.url = opts.url + prefix + additionalQueryParams;
			} else {
				const url = opts.url instanceof URL ? opts.url : new URL(opts.url);
				for (const [key, value] of new URLSearchParams(opts.params)) url.searchParams.append(key, value);
				opts.url = url;
			}
			if (typeof options.maxContentLength === "number") opts.size = options.maxContentLength;
			if (typeof options.maxRedirects === "number") opts.follow = options.maxRedirects;
			const shouldDirectlyPassData = typeof opts.data === "string" || opts.data instanceof ArrayBuffer || opts.data instanceof Blob || globalThis.File && opts.data instanceof File || opts.data instanceof FormData || opts.data instanceof stream_1.Readable || opts.data instanceof ReadableStream || opts.data instanceof String || opts.data instanceof URLSearchParams || ArrayBuffer.isView(opts.data) || [
				"Blob",
				"File",
				"FormData"
			].includes(opts.data?.constructor?.name || "");
			if (opts.multipart?.length) {
				const boundary = await randomUUID();
				preparedHeaders.set("content-type", `multipart/related; boundary=${boundary}`);
				opts.body = stream_1.Readable.from(this.getMultipartRequest(opts.multipart, boundary));
			} else if (shouldDirectlyPassData) opts.body = opts.data;
			else if (typeof opts.data === "object") if (preparedHeaders.get("Content-Type") === "application/x-www-form-urlencoded") opts.body = opts.paramsSerializer ? opts.paramsSerializer(opts.data) : new URLSearchParams(opts.data);
			else {
				if (!preparedHeaders.has("content-type")) preparedHeaders.set("content-type", "application/json");
				opts.body = JSON.stringify(opts.data);
			}
			else if (opts.data) opts.body = opts.data;
			opts.validateStatus = opts.validateStatus || this.validateStatus;
			opts.responseType = opts.responseType || "unknown";
			if (!preparedHeaders.has("accept") && opts.responseType === "json") preparedHeaders.set("accept", "application/json");
			const proxy = opts.proxy || process?.env?.HTTPS_PROXY || process?.env?.https_proxy || process?.env?.HTTP_PROXY || process?.env?.http_proxy;
			if (opts.agent) {} else if (proxy && this.#urlMayUseProxy(opts.url, opts.noProxy)) {
				const HttpsProxyAgent$1 = await _a.#getProxyAgent();
				if (this.agentCache.has(proxy)) opts.agent = this.agentCache.get(proxy);
				else {
					opts.agent = new HttpsProxyAgent$1(proxy, {
						cert: opts.cert,
						key: opts.key
					});
					this.agentCache.set(proxy, opts.agent);
				}
			} else if (opts.cert && opts.key) if (this.agentCache.has(opts.key)) opts.agent = this.agentCache.get(opts.key);
			else {
				opts.agent = new https_1.Agent({
					cert: opts.cert,
					key: opts.key
				});
				this.agentCache.set(opts.key, opts.agent);
			}
			if (typeof opts.errorRedactor !== "function" && opts.errorRedactor !== false) opts.errorRedactor = common_js_1$1.defaultErrorRedactor;
			if (opts.body && !("duplex" in opts))
 /**
			* required for Node.js and the type isn't available today
			* @link https://github.com/nodejs/node/issues/46221
			* @link https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1483
			*/
			opts.duplex = "half";
			this.#appendTimeoutToSignal(opts);
			return Object.assign(opts, {
				headers: preparedHeaders,
				url: opts.url instanceof URL ? opts.url : new URL(opts.url)
			});
		}
		#appendTimeoutToSignal(opts) {
			if (opts.timeout) {
				const timeoutSignal = AbortSignal.timeout(opts.timeout);
				if (opts.signal && !opts.signal.aborted) opts.signal = AbortSignal.any([opts.signal, timeoutSignal]);
				else opts.signal = timeoutSignal;
			}
		}
		/**
		* By default, throw for any non-2xx status code
		* @param status status code from the HTTP response
		*/
		validateStatus(status) {
			return status >= 200 && status < 300;
		}
		/**
		* Attempts to parse a response by looking at the Content-Type header.
		* @param {Response} response the HTTP response.
		* @returns a promise that resolves to the response data.
		*/
		async getResponseDataFromContentType(response) {
			let contentType = response.headers.get("Content-Type");
			if (contentType === null) return response.text();
			contentType = contentType.toLowerCase();
			if (contentType.includes("application/json")) {
				let data = await response.text();
				try {
					data = JSON.parse(data);
				} catch {}
				return data;
			} else if (contentType.match(/^text\//)) return response.text();
			else return response.blob();
		}
		/**
		* Creates an async generator that yields the pieces of a multipart/related request body.
		* This implementation follows the spec: https://www.ietf.org/rfc/rfc2387.txt. However, recursive
		* multipart/related requests are not currently supported.
		*
		* @param {GaxiosMultipartOptions[]} multipartOptions the pieces to turn into a multipart/related body.
		* @param {string} boundary the boundary string to be placed between each part.
		*/
		async *getMultipartRequest(multipartOptions, boundary) {
			const finale = `--${boundary}--`;
			for (const currentPart of multipartOptions) {
				yield `--${boundary}\r\nContent-Type: ${currentPart.headers.get("Content-Type") || "application/octet-stream"}\r\n\r\n`;
				if (typeof currentPart.content === "string") yield currentPart.content;
				else yield* currentPart.content;
				yield "\r\n";
			}
			yield finale;
		}
		/**
		* A cache for the lazily-loaded proxy agent.
		*
		* Should use {@link Gaxios[#getProxyAgent]} to retrieve.
		*/
		static #proxyAgent;
		/**
		* A cache for the lazily-loaded fetch library.
		*
		* Should use {@link Gaxios[#getFetch]} to retrieve.
		*/
		static #fetch;
		/**
		* Imports, caches, and returns a proxy agent - if not already imported
		*
		* @returns A proxy agent
		*/
		static async #getProxyAgent() {
			this.#proxyAgent ||= (await Promise.resolve().then(() => /* @__PURE__ */ __toESM$1(require_dist()))).HttpsProxyAgent;
			return this.#proxyAgent;
		}
		static async #getFetch() {
			const hasWindow = typeof window !== "undefined" && !!window;
			this.#fetch ||= hasWindow ? window.fetch : (await Promise.resolve().then(() => (init_src(), src_exports))).default;
			return this.#fetch;
		}
		/**
		* Merges headers.
		* If the base headers do not exist a new `Headers` object will be returned.
		*
		* @remarks
		*
		* Using this utility can be helpful when the headers are not known to exist:
		* - if they exist as `Headers`, that instance will be used
		*   - it improves performance and allows users to use their existing references to their `Headers`
		* - if they exist in another form (`HeadersInit`), they will be used to create a new `Headers` object
		* - if the base headers do not exist a new `Headers` object will be created
		*
		* @param base headers to append/overwrite to
		* @param append headers to append/overwrite with
		* @returns the base headers instance with merged `Headers`
		*/
		static mergeHeaders(base, ...append) {
			base = base instanceof Headers ? base : new Headers(base);
			for (const headers of append) (headers instanceof Headers ? headers : new Headers(headers)).forEach((value, key) => {
				key === "set-cookie" ? base.append(key, value) : base.set(key, value);
			});
			return base;
		}
	};
	exports.Gaxios = Gaxios;
	_a = Gaxios;
}));

//#endregion
//#region node_modules/gaxios/build/cjs/src/index.js
var require_src$4 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$4 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __exportStar$3 = exports && exports.__exportStar || function(m$2, exports$1) {
		for (var p in m$2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$4(exports$1, m$2, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.instance = exports.Gaxios = exports.GaxiosError = void 0;
	exports.request = request;
	const gaxios_js_1 = require_gaxios();
	Object.defineProperty(exports, "Gaxios", {
		enumerable: true,
		get: function() {
			return gaxios_js_1.Gaxios;
		}
	});
	var common_js_1 = require_common$1();
	Object.defineProperty(exports, "GaxiosError", {
		enumerable: true,
		get: function() {
			return common_js_1.GaxiosError;
		}
	});
	__exportStar$3(require_interceptor(), exports);
	/**
	* The default instance used when the `request` method is directly
	* invoked.
	*/
	exports.instance = new gaxios_js_1.Gaxios();
	/**
	* Make an HTTP request using the given options.
	* @param opts Options for the request
	*/
	async function request(opts) {
		return exports.instance.request(opts);
	}
}));

//#endregion
//#region node_modules/bignumber.js/bignumber.js
var require_bignumber = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(globalObject) {
		"use strict";
		var BigNumber$2, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 0x5af3107a4000, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [
			1,
			10,
			100,
			1e3,
			1e4,
			1e5,
			1e6,
			1e7,
			1e8,
			1e9,
			1e10,
			1e11,
			0xe8d4a51000,
			0x9184e72a000
		], SQRT_BASE = 1e7, MAX = 1e9;
		function clone$1(configObject) {
			var div, convertBase, parseNumeric, P = BigNumber$3.prototype = {
				constructor: BigNumber$3,
				toString: null,
				valueOf: null
			}, ONE = new BigNumber$3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
				prefix: "",
				groupSize: 3,
				secondaryGroupSize: 0,
				groupSeparator: ",",
				decimalSeparator: ".",
				fractionGroupSize: 0,
				fractionGroupSeparator: "\xA0",
				suffix: ""
			}, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
			function BigNumber$3(v, b) {
				var alphabet, c, caseChanged, e$1, i$2, isNum, len$1, str, x$1 = this;
				if (!(x$1 instanceof BigNumber$3)) return new BigNumber$3(v, b);
				if (b == null) {
					if (v && v._isBigNumber === true) {
						x$1.s = v.s;
						if (!v.c || v.e > MAX_EXP) x$1.c = x$1.e = null;
						else if (v.e < MIN_EXP) x$1.c = [x$1.e = 0];
						else {
							x$1.e = v.e;
							x$1.c = v.c.slice();
						}
						return;
					}
					if ((isNum = typeof v == "number") && v * 0 == 0) {
						x$1.s = 1 / v < 0 ? (v = -v, -1) : 1;
						if (v === ~~v) {
							for (e$1 = 0, i$2 = v; i$2 >= 10; i$2 /= 10, e$1++);
							if (e$1 > MAX_EXP) x$1.c = x$1.e = null;
							else {
								x$1.e = e$1;
								x$1.c = [v];
							}
							return;
						}
						str = String(v);
					} else {
						if (!isNumeric.test(str = String(v))) return parseNumeric(x$1, str, isNum);
						x$1.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
					}
					if ((e$1 = str.indexOf(".")) > -1) str = str.replace(".", "");
					if ((i$2 = str.search(/e/i)) > 0) {
						if (e$1 < 0) e$1 = i$2;
						e$1 += +str.slice(i$2 + 1);
						str = str.substring(0, i$2);
					} else if (e$1 < 0) e$1 = str.length;
				} else {
					intCheck(b, 2, ALPHABET.length, "Base");
					if (b == 10 && alphabetHasNormalDecimalDigits) {
						x$1 = new BigNumber$3(v);
						return round(x$1, DECIMAL_PLACES + x$1.e + 1, ROUNDING_MODE);
					}
					str = String(v);
					if (isNum = typeof v == "number") {
						if (v * 0 != 0) return parseNumeric(x$1, str, isNum, b);
						x$1.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
						if (BigNumber$3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) throw Error(tooManyDigits + v);
					} else x$1.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
					alphabet = ALPHABET.slice(0, b);
					e$1 = i$2 = 0;
					for (len$1 = str.length; i$2 < len$1; i$2++) if (alphabet.indexOf(c = str.charAt(i$2)) < 0) {
						if (c == ".") {
							if (i$2 > e$1) {
								e$1 = len$1;
								continue;
							}
						} else if (!caseChanged) {
							if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
								caseChanged = true;
								i$2 = -1;
								e$1 = 0;
								continue;
							}
						}
						return parseNumeric(x$1, String(v), isNum, b);
					}
					isNum = false;
					str = convertBase(str, b, 10, x$1.s);
					if ((e$1 = str.indexOf(".")) > -1) str = str.replace(".", "");
					else e$1 = str.length;
				}
				for (i$2 = 0; str.charCodeAt(i$2) === 48; i$2++);
				for (len$1 = str.length; str.charCodeAt(--len$1) === 48;);
				if (str = str.slice(i$2, ++len$1)) {
					len$1 -= i$2;
					if (isNum && BigNumber$3.DEBUG && len$1 > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) throw Error(tooManyDigits + x$1.s * v);
					if ((e$1 = e$1 - i$2 - 1) > MAX_EXP) x$1.c = x$1.e = null;
					else if (e$1 < MIN_EXP) x$1.c = [x$1.e = 0];
					else {
						x$1.e = e$1;
						x$1.c = [];
						i$2 = (e$1 + 1) % LOG_BASE;
						if (e$1 < 0) i$2 += LOG_BASE;
						if (i$2 < len$1) {
							if (i$2) x$1.c.push(+str.slice(0, i$2));
							for (len$1 -= LOG_BASE; i$2 < len$1;) x$1.c.push(+str.slice(i$2, i$2 += LOG_BASE));
							i$2 = LOG_BASE - (str = str.slice(i$2)).length;
						} else i$2 -= len$1;
						for (; i$2--; str += "0");
						x$1.c.push(+str);
					}
				} else x$1.c = [x$1.e = 0];
			}
			BigNumber$3.clone = clone$1;
			BigNumber$3.ROUND_UP = 0;
			BigNumber$3.ROUND_DOWN = 1;
			BigNumber$3.ROUND_CEIL = 2;
			BigNumber$3.ROUND_FLOOR = 3;
			BigNumber$3.ROUND_HALF_UP = 4;
			BigNumber$3.ROUND_HALF_DOWN = 5;
			BigNumber$3.ROUND_HALF_EVEN = 6;
			BigNumber$3.ROUND_HALF_CEIL = 7;
			BigNumber$3.ROUND_HALF_FLOOR = 8;
			BigNumber$3.EUCLID = 9;
			BigNumber$3.config = BigNumber$3.set = function(obj) {
				var p, v;
				if (obj != null) if (typeof obj == "object") {
					if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
						v = obj[p];
						intCheck(v, 0, MAX, p);
						DECIMAL_PLACES = v;
					}
					if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
						v = obj[p];
						intCheck(v, 0, 8, p);
						ROUNDING_MODE = v;
					}
					if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
						v = obj[p];
						if (v && v.pop) {
							intCheck(v[0], -MAX, 0, p);
							intCheck(v[1], 0, MAX, p);
							TO_EXP_NEG = v[0];
							TO_EXP_POS = v[1];
						} else {
							intCheck(v, -MAX, MAX, p);
							TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
						}
					}
					if (obj.hasOwnProperty(p = "RANGE")) {
						v = obj[p];
						if (v && v.pop) {
							intCheck(v[0], -MAX, -1, p);
							intCheck(v[1], 1, MAX, p);
							MIN_EXP = v[0];
							MAX_EXP = v[1];
						} else {
							intCheck(v, -MAX, MAX, p);
							if (v) MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
							else throw Error(bignumberError + p + " cannot be zero: " + v);
						}
					}
					if (obj.hasOwnProperty(p = "CRYPTO")) {
						v = obj[p];
						if (v === !!v) if (v) if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) CRYPTO = v;
						else {
							CRYPTO = !v;
							throw Error(bignumberError + "crypto unavailable");
						}
						else CRYPTO = v;
						else throw Error(bignumberError + p + " not true or false: " + v);
					}
					if (obj.hasOwnProperty(p = "MODULO_MODE")) {
						v = obj[p];
						intCheck(v, 0, 9, p);
						MODULO_MODE = v;
					}
					if (obj.hasOwnProperty(p = "POW_PRECISION")) {
						v = obj[p];
						intCheck(v, 0, MAX, p);
						POW_PRECISION = v;
					}
					if (obj.hasOwnProperty(p = "FORMAT")) {
						v = obj[p];
						if (typeof v == "object") FORMAT = v;
						else throw Error(bignumberError + p + " not an object: " + v);
					}
					if (obj.hasOwnProperty(p = "ALPHABET")) {
						v = obj[p];
						if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
							alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
							ALPHABET = v;
						} else throw Error(bignumberError + p + " invalid: " + v);
					}
				} else throw Error(bignumberError + "Object expected: " + obj);
				return {
					DECIMAL_PLACES,
					ROUNDING_MODE,
					EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
					RANGE: [MIN_EXP, MAX_EXP],
					CRYPTO,
					MODULO_MODE,
					POW_PRECISION,
					FORMAT,
					ALPHABET
				};
			};
			BigNumber$3.isBigNumber = function(v) {
				if (!v || v._isBigNumber !== true) return false;
				if (!BigNumber$3.DEBUG) return true;
				var i$2, n, c = v.c, e$1 = v.e, s$2 = v.s;
				out: if ({}.toString.call(c) == "[object Array]") {
					if ((s$2 === 1 || s$2 === -1) && e$1 >= -MAX && e$1 <= MAX && e$1 === mathfloor(e$1)) {
						if (c[0] === 0) {
							if (e$1 === 0 && c.length === 1) return true;
							break out;
						}
						i$2 = (e$1 + 1) % LOG_BASE;
						if (i$2 < 1) i$2 += LOG_BASE;
						if (String(c[0]).length == i$2) {
							for (i$2 = 0; i$2 < c.length; i$2++) {
								n = c[i$2];
								if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
							}
							if (n !== 0) return true;
						}
					}
				} else if (c === null && e$1 === null && (s$2 === null || s$2 === 1 || s$2 === -1)) return true;
				throw Error(bignumberError + "Invalid BigNumber: " + v);
			};
			BigNumber$3.maximum = BigNumber$3.max = function() {
				return maxOrMin(arguments, -1);
			};
			BigNumber$3.minimum = BigNumber$3.min = function() {
				return maxOrMin(arguments, 1);
			};
			BigNumber$3.random = (function() {
				var pow2_53 = 9007199254740992;
				var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
					return mathfloor(Math.random() * pow2_53);
				} : function() {
					return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
				};
				return function(dp) {
					var a, b, e$1, k, v, i$2 = 0, c = [], rand = new BigNumber$3(ONE);
					if (dp == null) dp = DECIMAL_PLACES;
					else intCheck(dp, 0, MAX);
					k = mathceil(dp / LOG_BASE);
					if (CRYPTO) if (crypto.getRandomValues) {
						a = crypto.getRandomValues(new Uint32Array(k *= 2));
						for (; i$2 < k;) {
							v = a[i$2] * 131072 + (a[i$2 + 1] >>> 11);
							if (v >= 9e15) {
								b = crypto.getRandomValues(new Uint32Array(2));
								a[i$2] = b[0];
								a[i$2 + 1] = b[1];
							} else {
								c.push(v % 0x5af3107a4000);
								i$2 += 2;
							}
						}
						i$2 = k / 2;
					} else if (crypto.randomBytes) {
						a = crypto.randomBytes(k *= 7);
						for (; i$2 < k;) {
							v = (a[i$2] & 31) * 281474976710656 + a[i$2 + 1] * 1099511627776 + a[i$2 + 2] * 4294967296 + a[i$2 + 3] * 16777216 + (a[i$2 + 4] << 16) + (a[i$2 + 5] << 8) + a[i$2 + 6];
							if (v >= 9e15) crypto.randomBytes(7).copy(a, i$2);
							else {
								c.push(v % 0x5af3107a4000);
								i$2 += 7;
							}
						}
						i$2 = k / 7;
					} else {
						CRYPTO = false;
						throw Error(bignumberError + "crypto unavailable");
					}
					if (!CRYPTO) for (; i$2 < k;) {
						v = random53bitInt();
						if (v < 9e15) c[i$2++] = v % 0x5af3107a4000;
					}
					k = c[--i$2];
					dp %= LOG_BASE;
					if (k && dp) {
						v = POWS_TEN[LOG_BASE - dp];
						c[i$2] = mathfloor(k / v) * v;
					}
					for (; c[i$2] === 0; c.pop(), i$2--);
					if (i$2 < 0) c = [e$1 = 0];
					else {
						for (e$1 = -1; c[0] === 0; c.splice(0, 1), e$1 -= LOG_BASE);
						for (i$2 = 1, v = c[0]; v >= 10; v /= 10, i$2++);
						if (i$2 < LOG_BASE) e$1 -= LOG_BASE - i$2;
					}
					rand.e = e$1;
					rand.c = c;
					return rand;
				};
			})();
			BigNumber$3.sum = function() {
				var i$2 = 1, args = arguments, sum = new BigNumber$3(args[0]);
				for (; i$2 < args.length;) sum = sum.plus(args[i$2++]);
				return sum;
			};
			convertBase = (function() {
				var decimal = "0123456789";
				function toBaseOut(str, baseIn, baseOut, alphabet) {
					var j, arr = [0], arrL, i$2 = 0, len$1 = str.length;
					for (; i$2 < len$1;) {
						for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);
						arr[0] += alphabet.indexOf(str.charAt(i$2++));
						for (j = 0; j < arr.length; j++) if (arr[j] > baseOut - 1) {
							if (arr[j + 1] == null) arr[j + 1] = 0;
							arr[j + 1] += arr[j] / baseOut | 0;
							arr[j] %= baseOut;
						}
					}
					return arr.reverse();
				}
				return function(str, baseIn, baseOut, sign$1, callerIsToString) {
					var alphabet, d$1, e$1, k, r$1, x$1, xc, y$1, i$2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
					if (i$2 >= 0) {
						k = POW_PRECISION;
						POW_PRECISION = 0;
						str = str.replace(".", "");
						y$1 = new BigNumber$3(baseIn);
						x$1 = y$1.pow(str.length - i$2);
						POW_PRECISION = k;
						y$1.c = toBaseOut(toFixedPoint(coeffToString(x$1.c), x$1.e, "0"), 10, baseOut, decimal);
						y$1.e = y$1.c.length;
					}
					xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
					e$1 = k = xc.length;
					for (; xc[--k] == 0; xc.pop());
					if (!xc[0]) return alphabet.charAt(0);
					if (i$2 < 0) --e$1;
					else {
						x$1.c = xc;
						x$1.e = e$1;
						x$1.s = sign$1;
						x$1 = div(x$1, y$1, dp, rm, baseOut);
						xc = x$1.c;
						r$1 = x$1.r;
						e$1 = x$1.e;
					}
					d$1 = e$1 + dp + 1;
					i$2 = xc[d$1];
					k = baseOut / 2;
					r$1 = r$1 || d$1 < 0 || xc[d$1 + 1] != null;
					r$1 = rm < 4 ? (i$2 != null || r$1) && (rm == 0 || rm == (x$1.s < 0 ? 3 : 2)) : i$2 > k || i$2 == k && (rm == 4 || r$1 || rm == 6 && xc[d$1 - 1] & 1 || rm == (x$1.s < 0 ? 8 : 7));
					if (d$1 < 1 || !xc[0]) str = r$1 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
					else {
						xc.length = d$1;
						if (r$1) for (--baseOut; ++xc[--d$1] > baseOut;) {
							xc[d$1] = 0;
							if (!d$1) {
								++e$1;
								xc = [1].concat(xc);
							}
						}
						for (k = xc.length; !xc[--k];);
						for (i$2 = 0, str = ""; i$2 <= k; str += alphabet.charAt(xc[i$2++]));
						str = toFixedPoint(str, e$1, alphabet.charAt(0));
					}
					return str;
				};
			})();
			div = (function() {
				function multiply(x$1, k, base) {
					var m$2, temp, xlo, xhi, carry = 0, i$2 = x$1.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
					for (x$1 = x$1.slice(); i$2--;) {
						xlo = x$1[i$2] % SQRT_BASE;
						xhi = x$1[i$2] / SQRT_BASE | 0;
						m$2 = khi * xlo + xhi * klo;
						temp = klo * xlo + m$2 % SQRT_BASE * SQRT_BASE + carry;
						carry = (temp / base | 0) + (m$2 / SQRT_BASE | 0) + khi * xhi;
						x$1[i$2] = temp % base;
					}
					if (carry) x$1 = [carry].concat(x$1);
					return x$1;
				}
				function compare$1(a, b, aL, bL) {
					var i$2, cmp;
					if (aL != bL) cmp = aL > bL ? 1 : -1;
					else for (i$2 = cmp = 0; i$2 < aL; i$2++) if (a[i$2] != b[i$2]) {
						cmp = a[i$2] > b[i$2] ? 1 : -1;
						break;
					}
					return cmp;
				}
				function subtract(a, b, aL, base) {
					var i$2 = 0;
					for (; aL--;) {
						a[aL] -= i$2;
						i$2 = a[aL] < b[aL] ? 1 : 0;
						a[aL] = i$2 * base + a[aL] - b[aL];
					}
					for (; !a[0] && a.length > 1; a.splice(0, 1));
				}
				return function(x$1, y$1, dp, rm, base) {
					var cmp, e$1, i$2, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s$2 = x$1.s == y$1.s ? 1 : -1, xc = x$1.c, yc = y$1.c;
					if (!xc || !xc[0] || !yc || !yc[0]) return new BigNumber$3(!x$1.s || !y$1.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s$2 * 0 : s$2 / 0);
					q = new BigNumber$3(s$2);
					qc = q.c = [];
					e$1 = x$1.e - y$1.e;
					s$2 = dp + e$1 + 1;
					if (!base) {
						base = BASE;
						e$1 = bitFloor(x$1.e / LOG_BASE) - bitFloor(y$1.e / LOG_BASE);
						s$2 = s$2 / LOG_BASE | 0;
					}
					for (i$2 = 0; yc[i$2] == (xc[i$2] || 0); i$2++);
					if (yc[i$2] > (xc[i$2] || 0)) e$1--;
					if (s$2 < 0) {
						qc.push(1);
						more = true;
					} else {
						xL = xc.length;
						yL = yc.length;
						i$2 = 0;
						s$2 += 2;
						n = mathfloor(base / (yc[0] + 1));
						if (n > 1) {
							yc = multiply(yc, n, base);
							xc = multiply(xc, n, base);
							yL = yc.length;
							xL = xc.length;
						}
						xi = yL;
						rem = xc.slice(0, yL);
						remL = rem.length;
						for (; remL < yL; rem[remL++] = 0);
						yz = yc.slice();
						yz = [0].concat(yz);
						yc0 = yc[0];
						if (yc[1] >= base / 2) yc0++;
						do {
							n = 0;
							cmp = compare$1(yc, rem, yL, remL);
							if (cmp < 0) {
								rem0 = rem[0];
								if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
								n = mathfloor(rem0 / yc0);
								if (n > 1) {
									if (n >= base) n = base - 1;
									prod = multiply(yc, n, base);
									prodL = prod.length;
									remL = rem.length;
									while (compare$1(prod, rem, prodL, remL) == 1) {
										n--;
										subtract(prod, yL < prodL ? yz : yc, prodL, base);
										prodL = prod.length;
										cmp = 1;
									}
								} else {
									if (n == 0) cmp = n = 1;
									prod = yc.slice();
									prodL = prod.length;
								}
								if (prodL < remL) prod = [0].concat(prod);
								subtract(rem, prod, remL, base);
								remL = rem.length;
								if (cmp == -1) while (compare$1(yc, rem, yL, remL) < 1) {
									n++;
									subtract(rem, yL < remL ? yz : yc, remL, base);
									remL = rem.length;
								}
							} else if (cmp === 0) {
								n++;
								rem = [0];
							}
							qc[i$2++] = n;
							if (rem[0]) rem[remL++] = xc[xi] || 0;
							else {
								rem = [xc[xi]];
								remL = 1;
							}
						} while ((xi++ < xL || rem[0] != null) && s$2--);
						more = rem[0] != null;
						if (!qc[0]) qc.splice(0, 1);
					}
					if (base == BASE) {
						for (i$2 = 1, s$2 = qc[0]; s$2 >= 10; s$2 /= 10, i$2++);
						round(q, dp + (q.e = i$2 + e$1 * LOG_BASE - 1) + 1, rm, more);
					} else {
						q.e = e$1;
						q.r = +more;
					}
					return q;
				};
			})();
			function format$2(n, i$2, rm, id) {
				var c0, e$1, ne, len$1, str;
				if (rm == null) rm = ROUNDING_MODE;
				else intCheck(rm, 0, 8);
				if (!n.c) return n.toString();
				c0 = n.c[0];
				ne = n.e;
				if (i$2 == null) {
					str = coeffToString(n.c);
					str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
				} else {
					n = round(new BigNumber$3(n), i$2, rm);
					e$1 = n.e;
					str = coeffToString(n.c);
					len$1 = str.length;
					if (id == 1 || id == 2 && (i$2 <= e$1 || e$1 <= TO_EXP_NEG)) {
						for (; len$1 < i$2; str += "0", len$1++);
						str = toExponential(str, e$1);
					} else {
						i$2 -= ne + (id === 2 && e$1 > ne);
						str = toFixedPoint(str, e$1, "0");
						if (e$1 + 1 > len$1) {
							if (--i$2 > 0) for (str += "."; i$2--; str += "0");
						} else {
							i$2 += e$1 - len$1;
							if (i$2 > 0) {
								if (e$1 + 1 == len$1) str += ".";
								for (; i$2--; str += "0");
							}
						}
					}
				}
				return n.s < 0 && c0 ? "-" + str : str;
			}
			function maxOrMin(args, n) {
				var k, y$1, i$2 = 1, x$1 = new BigNumber$3(args[0]);
				for (; i$2 < args.length; i$2++) {
					y$1 = new BigNumber$3(args[i$2]);
					if (!y$1.s || (k = compare(x$1, y$1)) === n || k === 0 && x$1.s === n) x$1 = y$1;
				}
				return x$1;
			}
			function normalise(n, c, e$1) {
				var i$2 = 1, j = c.length;
				for (; !c[--j]; c.pop());
				for (j = c[0]; j >= 10; j /= 10, i$2++);
				if ((e$1 = i$2 + e$1 * LOG_BASE - 1) > MAX_EXP) n.c = n.e = null;
				else if (e$1 < MIN_EXP) n.c = [n.e = 0];
				else {
					n.e = e$1;
					n.c = c;
				}
				return n;
			}
			parseNumeric = (function() {
				var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
				return function(x$1, str, isNum, b) {
					var base, s$2 = isNum ? str : str.replace(whitespaceOrPlus, "");
					if (isInfinityOrNaN.test(s$2)) x$1.s = isNaN(s$2) ? null : s$2 < 0 ? -1 : 1;
					else {
						if (!isNum) {
							s$2 = s$2.replace(basePrefix, function(m$2, p1, p2) {
								base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
								return !b || b == base ? p1 : m$2;
							});
							if (b) {
								base = b;
								s$2 = s$2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
							}
							if (str != s$2) return new BigNumber$3(s$2, base);
						}
						if (BigNumber$3.DEBUG) throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
						x$1.s = null;
					}
					x$1.c = x$1.e = null;
				};
			})();
			function round(x$1, sd, rm, r$1) {
				var d$1, i$2, j, k, n, ni, rd, xc = x$1.c, pows10 = POWS_TEN;
				if (xc) {
					out: {
						for (d$1 = 1, k = xc[0]; k >= 10; k /= 10, d$1++);
						i$2 = sd - d$1;
						if (i$2 < 0) {
							i$2 += LOG_BASE;
							j = sd;
							n = xc[ni = 0];
							rd = mathfloor(n / pows10[d$1 - j - 1] % 10);
						} else {
							ni = mathceil((i$2 + 1) / LOG_BASE);
							if (ni >= xc.length) if (r$1) {
								for (; xc.length <= ni; xc.push(0));
								n = rd = 0;
								d$1 = 1;
								i$2 %= LOG_BASE;
								j = i$2 - LOG_BASE + 1;
							} else break out;
							else {
								n = k = xc[ni];
								for (d$1 = 1; k >= 10; k /= 10, d$1++);
								i$2 %= LOG_BASE;
								j = i$2 - LOG_BASE + d$1;
								rd = j < 0 ? 0 : mathfloor(n / pows10[d$1 - j - 1] % 10);
							}
						}
						r$1 = r$1 || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d$1 - j - 1]);
						r$1 = rm < 4 ? (rd || r$1) && (rm == 0 || rm == (x$1.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r$1 || rm == 6 && (i$2 > 0 ? j > 0 ? n / pows10[d$1 - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x$1.s < 0 ? 8 : 7));
						if (sd < 1 || !xc[0]) {
							xc.length = 0;
							if (r$1) {
								sd -= x$1.e + 1;
								xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
								x$1.e = -sd || 0;
							} else xc[0] = x$1.e = 0;
							return x$1;
						}
						if (i$2 == 0) {
							xc.length = ni;
							k = 1;
							ni--;
						} else {
							xc.length = ni + 1;
							k = pows10[LOG_BASE - i$2];
							xc[ni] = j > 0 ? mathfloor(n / pows10[d$1 - j] % pows10[j]) * k : 0;
						}
						if (r$1) for (;;) if (ni == 0) {
							for (i$2 = 1, j = xc[0]; j >= 10; j /= 10, i$2++);
							j = xc[0] += k;
							for (k = 1; j >= 10; j /= 10, k++);
							if (i$2 != k) {
								x$1.e++;
								if (xc[0] == BASE) xc[0] = 1;
							}
							break;
						} else {
							xc[ni] += k;
							if (xc[ni] != BASE) break;
							xc[ni--] = 0;
							k = 1;
						}
						for (i$2 = xc.length; xc[--i$2] === 0; xc.pop());
					}
					if (x$1.e > MAX_EXP) x$1.c = x$1.e = null;
					else if (x$1.e < MIN_EXP) x$1.c = [x$1.e = 0];
				}
				return x$1;
			}
			function valueOf(n) {
				var str, e$1 = n.e;
				if (e$1 === null) return n.toString();
				str = coeffToString(n.c);
				str = e$1 <= TO_EXP_NEG || e$1 >= TO_EXP_POS ? toExponential(str, e$1) : toFixedPoint(str, e$1, "0");
				return n.s < 0 ? "-" + str : str;
			}
			P.absoluteValue = P.abs = function() {
				var x$1 = new BigNumber$3(this);
				if (x$1.s < 0) x$1.s = 1;
				return x$1;
			};
			P.comparedTo = function(y$1, b) {
				return compare(this, new BigNumber$3(y$1, b));
			};
			P.decimalPlaces = P.dp = function(dp, rm) {
				var c, n, v, x$1 = this;
				if (dp != null) {
					intCheck(dp, 0, MAX);
					if (rm == null) rm = ROUNDING_MODE;
					else intCheck(rm, 0, 8);
					return round(new BigNumber$3(x$1), dp + x$1.e + 1, rm);
				}
				if (!(c = x$1.c)) return null;
				n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
				if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
				if (n < 0) n = 0;
				return n;
			};
			P.dividedBy = P.div = function(y$1, b) {
				return div(this, new BigNumber$3(y$1, b), DECIMAL_PLACES, ROUNDING_MODE);
			};
			P.dividedToIntegerBy = P.idiv = function(y$1, b) {
				return div(this, new BigNumber$3(y$1, b), 0, 1);
			};
			P.exponentiatedBy = P.pow = function(n, m$2) {
				var half, isModExp, i$2, k, more, nIsBig, nIsNeg, nIsOdd, y$1, x$1 = this;
				n = new BigNumber$3(n);
				if (n.c && !n.isInteger()) throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
				if (m$2 != null) m$2 = new BigNumber$3(m$2);
				nIsBig = n.e > 14;
				if (!x$1.c || !x$1.c[0] || x$1.c[0] == 1 && !x$1.e && x$1.c.length == 1 || !n.c || !n.c[0]) {
					y$1 = new BigNumber$3(Math.pow(+valueOf(x$1), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
					return m$2 ? y$1.mod(m$2) : y$1;
				}
				nIsNeg = n.s < 0;
				if (m$2) {
					if (m$2.c ? !m$2.c[0] : !m$2.s) return new BigNumber$3(NaN);
					isModExp = !nIsNeg && x$1.isInteger() && m$2.isInteger();
					if (isModExp) x$1 = x$1.mod(m$2);
				} else if (n.e > 9 && (x$1.e > 0 || x$1.e < -1 || (x$1.e == 0 ? x$1.c[0] > 1 || nIsBig && x$1.c[1] >= 24e7 : x$1.c[0] < 8e13 || nIsBig && x$1.c[0] <= 9999975e7))) {
					k = x$1.s < 0 && isOdd(n) ? -0 : 0;
					if (x$1.e > -1) k = 1 / k;
					return new BigNumber$3(nIsNeg ? 1 / k : k);
				} else if (POW_PRECISION) k = mathceil(POW_PRECISION / LOG_BASE + 2);
				if (nIsBig) {
					half = new BigNumber$3(.5);
					if (nIsNeg) n.s = 1;
					nIsOdd = isOdd(n);
				} else {
					i$2 = Math.abs(+valueOf(n));
					nIsOdd = i$2 % 2;
				}
				y$1 = new BigNumber$3(ONE);
				for (;;) {
					if (nIsOdd) {
						y$1 = y$1.times(x$1);
						if (!y$1.c) break;
						if (k) {
							if (y$1.c.length > k) y$1.c.length = k;
						} else if (isModExp) y$1 = y$1.mod(m$2);
					}
					if (i$2) {
						i$2 = mathfloor(i$2 / 2);
						if (i$2 === 0) break;
						nIsOdd = i$2 % 2;
					} else {
						n = n.times(half);
						round(n, n.e + 1, 1);
						if (n.e > 14) nIsOdd = isOdd(n);
						else {
							i$2 = +valueOf(n);
							if (i$2 === 0) break;
							nIsOdd = i$2 % 2;
						}
					}
					x$1 = x$1.times(x$1);
					if (k) {
						if (x$1.c && x$1.c.length > k) x$1.c.length = k;
					} else if (isModExp) x$1 = x$1.mod(m$2);
				}
				if (isModExp) return y$1;
				if (nIsNeg) y$1 = ONE.div(y$1);
				return m$2 ? y$1.mod(m$2) : k ? round(y$1, POW_PRECISION, ROUNDING_MODE, more) : y$1;
			};
			P.integerValue = function(rm) {
				var n = new BigNumber$3(this);
				if (rm == null) rm = ROUNDING_MODE;
				else intCheck(rm, 0, 8);
				return round(n, n.e + 1, rm);
			};
			P.isEqualTo = P.eq = function(y$1, b) {
				return compare(this, new BigNumber$3(y$1, b)) === 0;
			};
			P.isFinite = function() {
				return !!this.c;
			};
			P.isGreaterThan = P.gt = function(y$1, b) {
				return compare(this, new BigNumber$3(y$1, b)) > 0;
			};
			P.isGreaterThanOrEqualTo = P.gte = function(y$1, b) {
				return (b = compare(this, new BigNumber$3(y$1, b))) === 1 || b === 0;
			};
			P.isInteger = function() {
				return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
			};
			P.isLessThan = P.lt = function(y$1, b) {
				return compare(this, new BigNumber$3(y$1, b)) < 0;
			};
			P.isLessThanOrEqualTo = P.lte = function(y$1, b) {
				return (b = compare(this, new BigNumber$3(y$1, b))) === -1 || b === 0;
			};
			P.isNaN = function() {
				return !this.s;
			};
			P.isNegative = function() {
				return this.s < 0;
			};
			P.isPositive = function() {
				return this.s > 0;
			};
			P.isZero = function() {
				return !!this.c && this.c[0] == 0;
			};
			P.minus = function(y$1, b) {
				var i$2, j, t$1, xLTy, x$1 = this, a = x$1.s;
				y$1 = new BigNumber$3(y$1, b);
				b = y$1.s;
				if (!a || !b) return new BigNumber$3(NaN);
				if (a != b) {
					y$1.s = -b;
					return x$1.plus(y$1);
				}
				var xe = x$1.e / LOG_BASE, ye = y$1.e / LOG_BASE, xc = x$1.c, yc = y$1.c;
				if (!xe || !ye) {
					if (!xc || !yc) return xc ? (y$1.s = -b, y$1) : new BigNumber$3(yc ? x$1 : NaN);
					if (!xc[0] || !yc[0]) return yc[0] ? (y$1.s = -b, y$1) : new BigNumber$3(xc[0] ? x$1 : ROUNDING_MODE == 3 ? -0 : 0);
				}
				xe = bitFloor(xe);
				ye = bitFloor(ye);
				xc = xc.slice();
				if (a = xe - ye) {
					if (xLTy = a < 0) {
						a = -a;
						t$1 = xc;
					} else {
						ye = xe;
						t$1 = yc;
					}
					t$1.reverse();
					for (b = a; b--; t$1.push(0));
					t$1.reverse();
				} else {
					j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
					for (a = b = 0; b < j; b++) if (xc[b] != yc[b]) {
						xLTy = xc[b] < yc[b];
						break;
					}
				}
				if (xLTy) {
					t$1 = xc;
					xc = yc;
					yc = t$1;
					y$1.s = -y$1.s;
				}
				b = (j = yc.length) - (i$2 = xc.length);
				if (b > 0) for (; b--; xc[i$2++] = 0);
				b = BASE - 1;
				for (; j > a;) {
					if (xc[--j] < yc[j]) {
						for (i$2 = j; i$2 && !xc[--i$2]; xc[i$2] = b);
						--xc[i$2];
						xc[j] += BASE;
					}
					xc[j] -= yc[j];
				}
				for (; xc[0] == 0; xc.splice(0, 1), --ye);
				if (!xc[0]) {
					y$1.s = ROUNDING_MODE == 3 ? -1 : 1;
					y$1.c = [y$1.e = 0];
					return y$1;
				}
				return normalise(y$1, xc, ye);
			};
			P.modulo = P.mod = function(y$1, b) {
				var q, s$2, x$1 = this;
				y$1 = new BigNumber$3(y$1, b);
				if (!x$1.c || !y$1.s || y$1.c && !y$1.c[0]) return new BigNumber$3(NaN);
				else if (!y$1.c || x$1.c && !x$1.c[0]) return new BigNumber$3(x$1);
				if (MODULO_MODE == 9) {
					s$2 = y$1.s;
					y$1.s = 1;
					q = div(x$1, y$1, 0, 3);
					y$1.s = s$2;
					q.s *= s$2;
				} else q = div(x$1, y$1, 0, MODULO_MODE);
				y$1 = x$1.minus(q.times(y$1));
				if (!y$1.c[0] && MODULO_MODE == 1) y$1.s = x$1.s;
				return y$1;
			};
			P.multipliedBy = P.times = function(y$1, b) {
				var c, e$1, i$2, j, k, m$2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x$1 = this, xc = x$1.c, yc = (y$1 = new BigNumber$3(y$1, b)).c;
				if (!xc || !yc || !xc[0] || !yc[0]) {
					if (!x$1.s || !y$1.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) y$1.c = y$1.e = y$1.s = null;
					else {
						y$1.s *= x$1.s;
						if (!xc || !yc) y$1.c = y$1.e = null;
						else {
							y$1.c = [0];
							y$1.e = 0;
						}
					}
					return y$1;
				}
				e$1 = bitFloor(x$1.e / LOG_BASE) + bitFloor(y$1.e / LOG_BASE);
				y$1.s *= x$1.s;
				xcL = xc.length;
				ycL = yc.length;
				if (xcL < ycL) {
					zc = xc;
					xc = yc;
					yc = zc;
					i$2 = xcL;
					xcL = ycL;
					ycL = i$2;
				}
				for (i$2 = xcL + ycL, zc = []; i$2--; zc.push(0));
				base = BASE;
				sqrtBase = SQRT_BASE;
				for (i$2 = ycL; --i$2 >= 0;) {
					c = 0;
					ylo = yc[i$2] % sqrtBase;
					yhi = yc[i$2] / sqrtBase | 0;
					for (k = xcL, j = i$2 + k; j > i$2;) {
						xlo = xc[--k] % sqrtBase;
						xhi = xc[k] / sqrtBase | 0;
						m$2 = yhi * xlo + xhi * ylo;
						xlo = ylo * xlo + m$2 % sqrtBase * sqrtBase + zc[j] + c;
						c = (xlo / base | 0) + (m$2 / sqrtBase | 0) + yhi * xhi;
						zc[j--] = xlo % base;
					}
					zc[j] = c;
				}
				if (c) ++e$1;
				else zc.splice(0, 1);
				return normalise(y$1, zc, e$1);
			};
			P.negated = function() {
				var x$1 = new BigNumber$3(this);
				x$1.s = -x$1.s || null;
				return x$1;
			};
			P.plus = function(y$1, b) {
				var t$1, x$1 = this, a = x$1.s;
				y$1 = new BigNumber$3(y$1, b);
				b = y$1.s;
				if (!a || !b) return new BigNumber$3(NaN);
				if (a != b) {
					y$1.s = -b;
					return x$1.minus(y$1);
				}
				var xe = x$1.e / LOG_BASE, ye = y$1.e / LOG_BASE, xc = x$1.c, yc = y$1.c;
				if (!xe || !ye) {
					if (!xc || !yc) return new BigNumber$3(a / 0);
					if (!xc[0] || !yc[0]) return yc[0] ? y$1 : new BigNumber$3(xc[0] ? x$1 : a * 0);
				}
				xe = bitFloor(xe);
				ye = bitFloor(ye);
				xc = xc.slice();
				if (a = xe - ye) {
					if (a > 0) {
						ye = xe;
						t$1 = yc;
					} else {
						a = -a;
						t$1 = xc;
					}
					t$1.reverse();
					for (; a--; t$1.push(0));
					t$1.reverse();
				}
				a = xc.length;
				b = yc.length;
				if (a - b < 0) {
					t$1 = yc;
					yc = xc;
					xc = t$1;
					b = a;
				}
				for (a = 0; b;) {
					a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
					xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
				}
				if (a) {
					xc = [a].concat(xc);
					++ye;
				}
				return normalise(y$1, xc, ye);
			};
			P.precision = P.sd = function(sd, rm) {
				var c, n, v, x$1 = this;
				if (sd != null && sd !== !!sd) {
					intCheck(sd, 1, MAX);
					if (rm == null) rm = ROUNDING_MODE;
					else intCheck(rm, 0, 8);
					return round(new BigNumber$3(x$1), sd, rm);
				}
				if (!(c = x$1.c)) return null;
				v = c.length - 1;
				n = v * LOG_BASE + 1;
				if (v = c[v]) {
					for (; v % 10 == 0; v /= 10, n--);
					for (v = c[0]; v >= 10; v /= 10, n++);
				}
				if (sd && x$1.e + 1 > n) n = x$1.e + 1;
				return n;
			};
			P.shiftedBy = function(k) {
				intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
				return this.times("1e" + k);
			};
			P.squareRoot = P.sqrt = function() {
				var m$2, n, r$1, rep, t$1, x$1 = this, c = x$1.c, s$2 = x$1.s, e$1 = x$1.e, dp = DECIMAL_PLACES + 4, half = new BigNumber$3("0.5");
				if (s$2 !== 1 || !c || !c[0]) return new BigNumber$3(!s$2 || s$2 < 0 && (!c || c[0]) ? NaN : c ? x$1 : Infinity);
				s$2 = Math.sqrt(+valueOf(x$1));
				if (s$2 == 0 || s$2 == Infinity) {
					n = coeffToString(c);
					if ((n.length + e$1) % 2 == 0) n += "0";
					s$2 = Math.sqrt(+n);
					e$1 = bitFloor((e$1 + 1) / 2) - (e$1 < 0 || e$1 % 2);
					if (s$2 == Infinity) n = "5e" + e$1;
					else {
						n = s$2.toExponential();
						n = n.slice(0, n.indexOf("e") + 1) + e$1;
					}
					r$1 = new BigNumber$3(n);
				} else r$1 = new BigNumber$3(s$2 + "");
				if (r$1.c[0]) {
					e$1 = r$1.e;
					s$2 = e$1 + dp;
					if (s$2 < 3) s$2 = 0;
					for (;;) {
						t$1 = r$1;
						r$1 = half.times(t$1.plus(div(x$1, t$1, dp, 1)));
						if (coeffToString(t$1.c).slice(0, s$2) === (n = coeffToString(r$1.c)).slice(0, s$2)) {
							if (r$1.e < e$1) --s$2;
							n = n.slice(s$2 - 3, s$2 + 1);
							if (n == "9999" || !rep && n == "4999") {
								if (!rep) {
									round(t$1, t$1.e + DECIMAL_PLACES + 2, 0);
									if (t$1.times(t$1).eq(x$1)) {
										r$1 = t$1;
										break;
									}
								}
								dp += 4;
								s$2 += 4;
								rep = 1;
							} else {
								if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
									round(r$1, r$1.e + DECIMAL_PLACES + 2, 1);
									m$2 = !r$1.times(r$1).eq(x$1);
								}
								break;
							}
						}
					}
				}
				return round(r$1, r$1.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m$2);
			};
			P.toExponential = function(dp, rm) {
				if (dp != null) {
					intCheck(dp, 0, MAX);
					dp++;
				}
				return format$2(this, dp, rm, 1);
			};
			P.toFixed = function(dp, rm) {
				if (dp != null) {
					intCheck(dp, 0, MAX);
					dp = dp + this.e + 1;
				}
				return format$2(this, dp, rm);
			};
			P.toFormat = function(dp, rm, format$3) {
				var str, x$1 = this;
				if (format$3 == null) if (dp != null && rm && typeof rm == "object") {
					format$3 = rm;
					rm = null;
				} else if (dp && typeof dp == "object") {
					format$3 = dp;
					dp = rm = null;
				} else format$3 = FORMAT;
				else if (typeof format$3 != "object") throw Error(bignumberError + "Argument not an object: " + format$3);
				str = x$1.toFixed(dp, rm);
				if (x$1.c) {
					var i$2, arr = str.split("."), g1 = +format$3.groupSize, g2 = +format$3.secondaryGroupSize, groupSeparator = format$3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x$1.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len$1 = intDigits.length;
					if (g2) {
						i$2 = g1;
						g1 = g2;
						g2 = i$2;
						len$1 -= i$2;
					}
					if (g1 > 0 && len$1 > 0) {
						i$2 = len$1 % g1 || g1;
						intPart = intDigits.substr(0, i$2);
						for (; i$2 < len$1; i$2 += g1) intPart += groupSeparator + intDigits.substr(i$2, g1);
						if (g2 > 0) intPart += groupSeparator + intDigits.slice(i$2);
						if (isNeg) intPart = "-" + intPart;
					}
					str = fractionPart ? intPart + (format$3.decimalSeparator || "") + ((g2 = +format$3.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format$3.fractionGroupSeparator || "")) : fractionPart) : intPart;
				}
				return (format$3.prefix || "") + str + (format$3.suffix || "");
			};
			P.toFraction = function(md) {
				var d$1, d0, d1, d2, e$1, exp, n, n0, n1, q, r$1, s$2, x$1 = this, xc = x$1.c;
				if (md != null) {
					n = new BigNumber$3(md);
					if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
				}
				if (!xc) return new BigNumber$3(x$1);
				d$1 = new BigNumber$3(ONE);
				n1 = d0 = new BigNumber$3(ONE);
				d1 = n0 = new BigNumber$3(ONE);
				s$2 = coeffToString(xc);
				e$1 = d$1.e = s$2.length - x$1.e - 1;
				d$1.c[0] = POWS_TEN[(exp = e$1 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
				md = !md || n.comparedTo(d$1) > 0 ? e$1 > 0 ? d$1 : n1 : n;
				exp = MAX_EXP;
				MAX_EXP = Infinity;
				n = new BigNumber$3(s$2);
				n0.c[0] = 0;
				for (;;) {
					q = div(n, d$1, 0, 1);
					d2 = d0.plus(q.times(d1));
					if (d2.comparedTo(md) == 1) break;
					d0 = d1;
					d1 = d2;
					n1 = n0.plus(q.times(d2 = n1));
					n0 = d2;
					d$1 = n.minus(q.times(d2 = d$1));
					n = d2;
				}
				d2 = div(md.minus(d0), d1, 0, 1);
				n0 = n0.plus(d2.times(n1));
				d0 = d0.plus(d2.times(d1));
				n0.s = n1.s = x$1.s;
				e$1 = e$1 * 2;
				r$1 = div(n1, d1, e$1, ROUNDING_MODE).minus(x$1).abs().comparedTo(div(n0, d0, e$1, ROUNDING_MODE).minus(x$1).abs()) < 1 ? [n1, d1] : [n0, d0];
				MAX_EXP = exp;
				return r$1;
			};
			P.toNumber = function() {
				return +valueOf(this);
			};
			P.toPrecision = function(sd, rm) {
				if (sd != null) intCheck(sd, 1, MAX);
				return format$2(this, sd, rm, 2);
			};
			P.toString = function(b) {
				var str, n = this, s$2 = n.s, e$1 = n.e;
				if (e$1 === null) if (s$2) {
					str = "Infinity";
					if (s$2 < 0) str = "-" + str;
				} else str = "NaN";
				else {
					if (b == null) str = e$1 <= TO_EXP_NEG || e$1 >= TO_EXP_POS ? toExponential(coeffToString(n.c), e$1) : toFixedPoint(coeffToString(n.c), e$1, "0");
					else if (b === 10 && alphabetHasNormalDecimalDigits) {
						n = round(new BigNumber$3(n), DECIMAL_PLACES + e$1 + 1, ROUNDING_MODE);
						str = toFixedPoint(coeffToString(n.c), n.e, "0");
					} else {
						intCheck(b, 2, ALPHABET.length, "Base");
						str = convertBase(toFixedPoint(coeffToString(n.c), e$1, "0"), 10, b, s$2, true);
					}
					if (s$2 < 0 && n.c[0]) str = "-" + str;
				}
				return str;
			};
			P.valueOf = P.toJSON = function() {
				return valueOf(this);
			};
			P._isBigNumber = true;
			if (configObject != null) BigNumber$3.set(configObject);
			return BigNumber$3;
		}
		function bitFloor(n) {
			var i$2 = n | 0;
			return n > 0 || n === i$2 ? i$2 : i$2 - 1;
		}
		function coeffToString(a) {
			var s$2, z, i$2 = 1, j = a.length, r$1 = a[0] + "";
			for (; i$2 < j;) {
				s$2 = a[i$2++] + "";
				z = LOG_BASE - s$2.length;
				for (; z--; s$2 = "0" + s$2);
				r$1 += s$2;
			}
			for (j = r$1.length; r$1.charCodeAt(--j) === 48;);
			return r$1.slice(0, j + 1 || 1);
		}
		function compare(x$1, y$1) {
			var a, b, xc = x$1.c, yc = y$1.c, i$2 = x$1.s, j = y$1.s, k = x$1.e, l = y$1.e;
			if (!i$2 || !j) return null;
			a = xc && !xc[0];
			b = yc && !yc[0];
			if (a || b) return a ? b ? 0 : -j : i$2;
			if (i$2 != j) return i$2;
			a = i$2 < 0;
			b = k == l;
			if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
			if (!b) return k > l ^ a ? 1 : -1;
			j = (k = xc.length) < (l = yc.length) ? k : l;
			for (i$2 = 0; i$2 < j; i$2++) if (xc[i$2] != yc[i$2]) return xc[i$2] > yc[i$2] ^ a ? 1 : -1;
			return k == l ? 0 : k > l ^ a ? 1 : -1;
		}
		function intCheck(n, min, max, name) {
			if (n < min || n > max || n !== mathfloor(n)) throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
		}
		function isOdd(n) {
			var k = n.c.length - 1;
			return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
		}
		function toExponential(str, e$1) {
			return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e$1 < 0 ? "e" : "e+") + e$1;
		}
		function toFixedPoint(str, e$1, z) {
			var len$1, zs;
			if (e$1 < 0) {
				for (zs = z + "."; ++e$1; zs += z);
				str = zs + str;
			} else {
				len$1 = str.length;
				if (++e$1 > len$1) {
					for (zs = z, e$1 -= len$1; --e$1; zs += z);
					str += zs;
				} else if (e$1 < len$1) str = str.slice(0, e$1) + "." + str.slice(e$1);
			}
			return str;
		}
		BigNumber$2 = clone$1();
		BigNumber$2["default"] = BigNumber$2.BigNumber = BigNumber$2;
		if (typeof define == "function" && define.amd) define(function() {
			return BigNumber$2;
		});
		else if (typeof module != "undefined" && module.exports) module.exports = BigNumber$2;
		else {
			if (!globalObject) globalObject = typeof self != "undefined" && self ? self : window;
			globalObject.BigNumber = BigNumber$2;
		}
	})(exports);
}));

//#endregion
//#region node_modules/json-bigint/lib/stringify.js
var require_stringify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var BigNumber$1 = require_bignumber();
	var JSON$1 = module.exports;
	(function() {
		"use strict";
		var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
			"\b": "\\b",
			"	": "\\t",
			"\n": "\\n",
			"\f": "\\f",
			"\r": "\\r",
			"\"": "\\\"",
			"\\": "\\\\"
		}, rep;
		function quote(string) {
			escapable.lastIndex = 0;
			return escapable.test(string) ? "\"" + string.replace(escapable, function(a) {
				var c = meta[a];
				return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
			}) + "\"" : "\"" + string + "\"";
		}
		function str(key, holder) {
			var i$2, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber$1 || BigNumber$1.isBigNumber(value));
			if (value && typeof value === "object" && typeof value.toJSON === "function") value = value.toJSON(key);
			if (typeof rep === "function") value = rep.call(holder, key, value);
			switch (typeof value) {
				case "string": if (isBigNumber) return value;
				else return quote(value);
				case "number": return isFinite(value) ? String(value) : "null";
				case "boolean":
				case "null":
				case "bigint": return String(value);
				case "object":
					if (!value) return "null";
					gap += indent;
					partial = [];
					if (Object.prototype.toString.apply(value) === "[object Array]") {
						length = value.length;
						for (i$2 = 0; i$2 < length; i$2 += 1) partial[i$2] = str(i$2, value) || "null";
						v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
						gap = mind;
						return v;
					}
					if (rep && typeof rep === "object") {
						length = rep.length;
						for (i$2 = 0; i$2 < length; i$2 += 1) if (typeof rep[i$2] === "string") {
							k = rep[i$2];
							v = str(k, value);
							if (v) partial.push(quote(k) + (gap ? ": " : ":") + v);
						}
					} else Object.keys(value).forEach(function(k$1) {
						var v$1 = str(k$1, value);
						if (v$1) partial.push(quote(k$1) + (gap ? ": " : ":") + v$1);
					});
					v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
					gap = mind;
					return v;
			}
		}
		if (typeof JSON$1.stringify !== "function") JSON$1.stringify = function(value, replacer, space) {
			var i$2;
			gap = "";
			indent = "";
			if (typeof space === "number") for (i$2 = 0; i$2 < space; i$2 += 1) indent += " ";
			else if (typeof space === "string") indent = space;
			rep = replacer;
			if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) throw new Error("JSON.stringify");
			return str("", { "": value });
		};
	})();
}));

//#endregion
//#region node_modules/json-bigint/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var BigNumber = null;
	const suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
	const suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
	var json_parse$1 = function(options) {
		"use strict";
		var _options = {
			strict: false,
			storeAsString: false,
			alwaysParseAsBig: false,
			useNativeBigInt: false,
			protoAction: "error",
			constructorAction: "error"
		};
		if (options !== void 0 && options !== null) {
			if (options.strict === true) _options.strict = true;
			if (options.storeAsString === true) _options.storeAsString = true;
			_options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
			_options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
			if (typeof options.constructorAction !== "undefined") if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") _options.constructorAction = options.constructorAction;
			else throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`);
			if (typeof options.protoAction !== "undefined") if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") _options.protoAction = options.protoAction;
			else throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`);
		}
		var at, ch, escapee = {
			"\"": "\"",
			"\\": "\\",
			"/": "/",
			b: "\b",
			f: "\f",
			n: "\n",
			r: "\r",
			t: "	"
		}, text, error$1 = function(m$2) {
			throw {
				name: "SyntaxError",
				message: m$2,
				at,
				text
			};
		}, next = function(c) {
			if (c && c !== ch) error$1("Expected '" + c + "' instead of '" + ch + "'");
			ch = text.charAt(at);
			at += 1;
			return ch;
		}, number = function() {
			var number$1, string$1 = "";
			if (ch === "-") {
				string$1 = "-";
				next("-");
			}
			while (ch >= "0" && ch <= "9") {
				string$1 += ch;
				next();
			}
			if (ch === ".") {
				string$1 += ".";
				while (next() && ch >= "0" && ch <= "9") string$1 += ch;
			}
			if (ch === "e" || ch === "E") {
				string$1 += ch;
				next();
				if (ch === "-" || ch === "+") {
					string$1 += ch;
					next();
				}
				while (ch >= "0" && ch <= "9") {
					string$1 += ch;
					next();
				}
			}
			number$1 = +string$1;
			if (!isFinite(number$1)) error$1("Bad number");
			else {
				if (BigNumber == null) BigNumber = require_bignumber();
				if (string$1.length > 15) return _options.storeAsString ? string$1 : _options.useNativeBigInt ? BigInt(string$1) : new BigNumber(string$1);
				else return !_options.alwaysParseAsBig ? number$1 : _options.useNativeBigInt ? BigInt(number$1) : new BigNumber(number$1);
			}
		}, string = function() {
			var hex, i$2, string$1 = "", uffff;
			if (ch === "\"") {
				var startAt = at;
				while (next()) {
					if (ch === "\"") {
						if (at - 1 > startAt) string$1 += text.substring(startAt, at - 1);
						next();
						return string$1;
					}
					if (ch === "\\") {
						if (at - 1 > startAt) string$1 += text.substring(startAt, at - 1);
						next();
						if (ch === "u") {
							uffff = 0;
							for (i$2 = 0; i$2 < 4; i$2 += 1) {
								hex = parseInt(next(), 16);
								if (!isFinite(hex)) break;
								uffff = uffff * 16 + hex;
							}
							string$1 += String.fromCharCode(uffff);
						} else if (typeof escapee[ch] === "string") string$1 += escapee[ch];
						else break;
						startAt = at;
					}
				}
			}
			error$1("Bad string");
		}, white = function() {
			while (ch && ch <= " ") next();
		}, word = function() {
			switch (ch) {
				case "t":
					next("t");
					next("r");
					next("u");
					next("e");
					return true;
				case "f":
					next("f");
					next("a");
					next("l");
					next("s");
					next("e");
					return false;
				case "n":
					next("n");
					next("u");
					next("l");
					next("l");
					return null;
			}
			error$1("Unexpected '" + ch + "'");
		}, value, array = function() {
			var array$1 = [];
			if (ch === "[") {
				next("[");
				white();
				if (ch === "]") {
					next("]");
					return array$1;
				}
				while (ch) {
					array$1.push(value());
					white();
					if (ch === "]") {
						next("]");
						return array$1;
					}
					next(",");
					white();
				}
			}
			error$1("Bad array");
		}, object = function() {
			var key, object$1 = Object.create(null);
			if (ch === "{") {
				next("{");
				white();
				if (ch === "}") {
					next("}");
					return object$1;
				}
				while (ch) {
					key = string();
					white();
					next(":");
					if (_options.strict === true && Object.hasOwnProperty.call(object$1, key)) error$1("Duplicate key \"" + key + "\"");
					if (suspectProtoRx.test(key) === true) if (_options.protoAction === "error") error$1("Object contains forbidden prototype property");
					else if (_options.protoAction === "ignore") value();
					else object$1[key] = value();
					else if (suspectConstructorRx.test(key) === true) if (_options.constructorAction === "error") error$1("Object contains forbidden constructor property");
					else if (_options.constructorAction === "ignore") value();
					else object$1[key] = value();
					else object$1[key] = value();
					white();
					if (ch === "}") {
						next("}");
						return object$1;
					}
					next(",");
					white();
				}
			}
			error$1("Bad object");
		};
		value = function() {
			white();
			switch (ch) {
				case "{": return object();
				case "[": return array();
				case "\"": return string();
				case "-": return number();
				default: return ch >= "0" && ch <= "9" ? number() : word();
			}
		};
		return function(source, reviver) {
			var result;
			text = source + "";
			at = 0;
			ch = " ";
			result = value();
			white();
			if (ch) error$1("Syntax error");
			return typeof reviver === "function" ? (function walk(holder, key) {
				var v, value$1 = holder[key];
				if (value$1 && typeof value$1 === "object") Object.keys(value$1).forEach(function(k) {
					v = walk(value$1, k);
					if (v !== void 0) value$1[k] = v;
					else delete value$1[k];
				});
				return reviver.call(holder, key, value$1);
			})({ "": result }, "") : result;
		};
	};
	module.exports = json_parse$1;
}));

//#endregion
//#region node_modules/json-bigint/index.js
var require_json_bigint = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var json_stringify = require_stringify().stringify;
	var json_parse = require_parse();
	module.exports = function(options) {
		return {
			parse: json_parse(options),
			stringify: json_stringify
		};
	};
	module.exports.parse = json_parse();
	module.exports.stringify = json_stringify;
}));

//#endregion
//#region node_modules/gcp-metadata/build/src/gcp-residency.js
var require_gcp_residency = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Copyright 2022 Google LLC
	*
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*      http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GCE_LINUX_BIOS_PATHS = void 0;
	exports.isGoogleCloudServerless = isGoogleCloudServerless;
	exports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;
	exports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;
	exports.isGoogleComputeEngine = isGoogleComputeEngine;
	exports.detectGCPResidency = detectGCPResidency;
	const fs_1 = require("fs");
	const os_1 = require("os");
	/**
	* Known paths unique to Google Compute Engine Linux instances
	*/
	exports.GCE_LINUX_BIOS_PATHS = {
		BIOS_DATE: "/sys/class/dmi/id/bios_date",
		BIOS_VENDOR: "/sys/class/dmi/id/bios_vendor"
	};
	const GCE_MAC_ADDRESS_REGEX = /^42:01/;
	/**
	* Determines if the process is running on a Google Cloud Serverless environment (Cloud Run or Cloud Functions instance).
	*
	* Uses the:
	* - {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.
	* - {@link https://cloud.google.com/functions/docs/env-var Cloud Functions environment variables}.
	*
	* @returns {boolean} `true` if the process is running on GCP serverless, `false` otherwise.
	*/
	function isGoogleCloudServerless() {
		return !!(process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE);
	}
	/**
	* Determines if the process is running on a Linux Google Compute Engine instance.
	*
	* @returns {boolean} `true` if the process is running on Linux GCE, `false` otherwise.
	*/
	function isGoogleComputeEngineLinux() {
		if ((0, os_1.platform)() !== "linux") return false;
		try {
			(0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);
			const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, "utf8");
			return /Google/.test(biosVendor);
		} catch {
			return false;
		}
	}
	/**
	* Determines if the process is running on a Google Compute Engine instance with a known
	* MAC address.
	*
	* @returns {boolean} `true` if the process is running on GCE (as determined by MAC address), `false` otherwise.
	*/
	function isGoogleComputeEngineMACAddress() {
		const interfaces = (0, os_1.networkInterfaces)();
		for (const item of Object.values(interfaces)) {
			if (!item) continue;
			for (const { mac } of item) if (GCE_MAC_ADDRESS_REGEX.test(mac)) return true;
		}
		return false;
	}
	/**
	* Determines if the process is running on a Google Compute Engine instance.
	*
	* @returns {boolean} `true` if the process is running on GCE, `false` otherwise.
	*/
	function isGoogleComputeEngine() {
		return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();
	}
	/**
	* Determines if the process is running on Google Cloud Platform.
	*
	* @returns {boolean} `true` if the process is running on GCP, `false` otherwise.
	*/
	function detectGCPResidency() {
		return isGoogleCloudServerless() || isGoogleComputeEngine();
	}
}));

//#endregion
//#region node_modules/google-logging-utils/build/src/colours.js
var require_colours = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Colours = void 0;
	/**
	* Handles figuring out if we can use ANSI colours and handing out the escape codes.
	*
	* This is for package-internal use only, and may change at any time.
	*
	* @private
	* @internal
	*/
	var Colours = class Colours {
		/**
		* @param stream The stream (e.g. process.stderr)
		* @returns true if the stream should have colourization enabled
		*/
		static isEnabled(stream$6) {
			return stream$6 && stream$6.isTTY && (typeof stream$6.getColorDepth === "function" ? stream$6.getColorDepth() > 2 : true);
		}
		static refresh() {
			Colours.enabled = Colours.isEnabled(process === null || process === void 0 ? void 0 : process.stderr);
			if (!this.enabled) {
				Colours.reset = "";
				Colours.bright = "";
				Colours.dim = "";
				Colours.red = "";
				Colours.green = "";
				Colours.yellow = "";
				Colours.blue = "";
				Colours.magenta = "";
				Colours.cyan = "";
				Colours.white = "";
				Colours.grey = "";
			} else {
				Colours.reset = "\x1B[0m";
				Colours.bright = "\x1B[1m";
				Colours.dim = "\x1B[2m";
				Colours.red = "\x1B[31m";
				Colours.green = "\x1B[32m";
				Colours.yellow = "\x1B[33m";
				Colours.blue = "\x1B[34m";
				Colours.magenta = "\x1B[35m";
				Colours.cyan = "\x1B[36m";
				Colours.white = "\x1B[37m";
				Colours.grey = "\x1B[90m";
			}
		}
	};
	exports.Colours = Colours;
	Colours.enabled = false;
	Colours.reset = "";
	Colours.bright = "";
	Colours.dim = "";
	Colours.red = "";
	Colours.green = "";
	Colours.yellow = "";
	Colours.blue = "";
	Colours.magenta = "";
	Colours.cyan = "";
	Colours.white = "";
	Colours.grey = "";
	Colours.refresh();
}));

//#endregion
//#region node_modules/google-logging-utils/build/src/logging-utils.js
var require_logging_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$3 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault$1 = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar$1 = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i$2 = 0; i$2 < k.length; i$2++) if (k[i$2] !== "default") __createBinding$3(result, mod, k[i$2]);
			}
			__setModuleDefault$1(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.env = exports.DebugLogBackendBase = exports.placeholder = exports.AdhocDebugLogger = exports.LogSeverity = void 0;
	exports.getNodeBackend = getNodeBackend;
	exports.getDebugBackend = getDebugBackend;
	exports.getStructuredBackend = getStructuredBackend;
	exports.setBackend = setBackend;
	exports.log = log$1;
	const events_1$1 = require("events");
	const process$1 = __importStar$1(require("process"));
	const util$4 = __importStar$1(require("util"));
	const colours_1 = require_colours();
	/**
	* This module defines an ad-hoc debug logger for Google Cloud Platform
	* client libraries in Node. An ad-hoc debug logger is a tool which lets
	* users use an external, unified interface (in this case, environment
	* variables) to determine what logging they want to see at runtime. This
	* isn't necessarily fed into the console, but is meant to be under the
	* control of the user. The kind of logging that will be produced by this
	* is more like "call retry happened", not "events you'd want to record
	* in Cloud Logger".
	*
	* More for Googlers implementing libraries with it:
	* go/cloud-client-logging-design
	*/
	/**
	* Possible log levels. These are a subset of Cloud Observability levels.
	* https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#LogSeverity
	*/
	var LogSeverity;
	(function(LogSeverity$1) {
		LogSeverity$1["DEFAULT"] = "DEFAULT";
		LogSeverity$1["DEBUG"] = "DEBUG";
		LogSeverity$1["INFO"] = "INFO";
		LogSeverity$1["WARNING"] = "WARNING";
		LogSeverity$1["ERROR"] = "ERROR";
	})(LogSeverity || (exports.LogSeverity = LogSeverity = {}));
	/**
	* Our logger instance. This actually contains the meat of dealing
	* with log lines, including EventEmitter. This contains the function
	* that will be passed back to users of the package.
	*/
	var AdhocDebugLogger = class extends events_1$1.EventEmitter {
		/**
		* @param upstream The backend will pass a function that will be
		*   called whenever our logger function is invoked.
		*/
		constructor(namespace, upstream) {
			super();
			this.namespace = namespace;
			this.upstream = upstream;
			this.func = Object.assign(this.invoke.bind(this), {
				instance: this,
				on: (event, listener) => this.on(event, listener)
			});
			this.func.debug = (...args) => this.invokeSeverity(LogSeverity.DEBUG, ...args);
			this.func.info = (...args) => this.invokeSeverity(LogSeverity.INFO, ...args);
			this.func.warn = (...args) => this.invokeSeverity(LogSeverity.WARNING, ...args);
			this.func.error = (...args) => this.invokeSeverity(LogSeverity.ERROR, ...args);
			this.func.sublog = (namespace$1) => log$1(namespace$1, this.func);
		}
		invoke(fields, ...args) {
			if (this.upstream) try {
				this.upstream(fields, ...args);
			} catch (e$1) {}
			try {
				this.emit("log", fields, args);
			} catch (e$1) {}
		}
		invokeSeverity(severity, ...args) {
			this.invoke({ severity }, ...args);
		}
	};
	exports.AdhocDebugLogger = AdhocDebugLogger;
	/**
	* This can be used in place of a real logger while waiting for Promises or disabling logging.
	*/
	exports.placeholder = new AdhocDebugLogger("", () => {}).func;
	/**
	* The base class for debug logging backends. It's possible to use this, but the
	* same non-guarantees above still apply (unstable interface, etc).
	*
	* @private
	* @internal
	*/
	var DebugLogBackendBase = class {
		constructor() {
			var _a$2;
			this.cached = /* @__PURE__ */ new Map();
			this.filters = [];
			this.filtersSet = false;
			let nodeFlag = (_a$2 = process$1.env[exports.env.nodeEnables]) !== null && _a$2 !== void 0 ? _a$2 : "*";
			if (nodeFlag === "all") nodeFlag = "*";
			this.filters = nodeFlag.split(",");
		}
		log(namespace, fields, ...args) {
			try {
				if (!this.filtersSet) {
					this.setFilters();
					this.filtersSet = true;
				}
				let logger$1 = this.cached.get(namespace);
				if (!logger$1) {
					logger$1 = this.makeLogger(namespace);
					this.cached.set(namespace, logger$1);
				}
				logger$1(fields, ...args);
			} catch (e$1) {
				console.error(e$1);
			}
		}
	};
	exports.DebugLogBackendBase = DebugLogBackendBase;
	var NodeBackend = class extends DebugLogBackendBase {
		constructor() {
			super(...arguments);
			this.enabledRegexp = /.*/g;
		}
		isEnabled(namespace) {
			return this.enabledRegexp.test(namespace);
		}
		makeLogger(namespace) {
			if (!this.enabledRegexp.test(namespace)) return () => {};
			return (fields, ...args) => {
				var _a$2;
				const nscolour = `${colours_1.Colours.green}${namespace}${colours_1.Colours.reset}`;
				const pid = `${colours_1.Colours.yellow}${process$1.pid}${colours_1.Colours.reset}`;
				let level;
				switch (fields.severity) {
					case LogSeverity.ERROR:
						level = `${colours_1.Colours.red}${fields.severity}${colours_1.Colours.reset}`;
						break;
					case LogSeverity.INFO:
						level = `${colours_1.Colours.magenta}${fields.severity}${colours_1.Colours.reset}`;
						break;
					case LogSeverity.WARNING:
						level = `${colours_1.Colours.yellow}${fields.severity}${colours_1.Colours.reset}`;
						break;
					default:
						level = (_a$2 = fields.severity) !== null && _a$2 !== void 0 ? _a$2 : LogSeverity.DEFAULT;
						break;
				}
				const msg = util$4.formatWithOptions({ colors: colours_1.Colours.enabled }, ...args);
				const filteredFields = Object.assign({}, fields);
				delete filteredFields.severity;
				const fieldsJson = Object.getOwnPropertyNames(filteredFields).length ? JSON.stringify(filteredFields) : "";
				const fieldsColour = fieldsJson ? `${colours_1.Colours.grey}${fieldsJson}${colours_1.Colours.reset}` : "";
				console.error("%s [%s|%s] %s%s", pid, nscolour, level, msg, fieldsJson ? ` ${fieldsColour}` : "");
			};
		}
		setFilters() {
			const regexp = this.filters.join(",").replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^");
			this.enabledRegexp = new RegExp(`^${regexp}$`, "i");
		}
	};
	/**
	* @returns A backend based on Node util.debuglog; this is the default.
	*/
	function getNodeBackend() {
		return new NodeBackend();
	}
	var DebugBackend = class extends DebugLogBackendBase {
		constructor(pkg$3) {
			super();
			this.debugPkg = pkg$3;
		}
		makeLogger(namespace) {
			const debugLogger = this.debugPkg(namespace);
			return (fields, ...args) => {
				debugLogger(args[0], ...args.slice(1));
			};
		}
		setFilters() {
			var _a$2;
			const existingFilters = (_a$2 = process$1.env["NODE_DEBUG"]) !== null && _a$2 !== void 0 ? _a$2 : "";
			process$1.env["NODE_DEBUG"] = `${existingFilters}${existingFilters ? "," : ""}${this.filters.join(",")}`;
		}
	};
	/**
	* Creates a "debug" package backend. The user must call require('debug') and pass
	* the resulting object to this function.
	*
	* ```
	*  setBackend(getDebugBackend(require('debug')))
	* ```
	*
	* https://www.npmjs.com/package/debug
	*
	* Note: Google does not explicitly endorse or recommend this package; it's just
	* being provided as an option.
	*
	* @returns A backend based on the npm "debug" package.
	*/
	function getDebugBackend(debugPkg) {
		return new DebugBackend(debugPkg);
	}
	/**
	* This pretty much works like the Node logger, but it outputs structured
	* logging JSON matching Google Cloud's ingestion specs. Rather than handling
	* its own output, it wraps another backend. The passed backend must be a subclass
	* of `DebugLogBackendBase` (any of the backends exposed by this package will work).
	*/
	var StructuredBackend = class extends DebugLogBackendBase {
		constructor(upstream) {
			var _a$2;
			super();
			this.upstream = (_a$2 = upstream) !== null && _a$2 !== void 0 ? _a$2 : void 0;
		}
		makeLogger(namespace) {
			var _a$2;
			const debugLogger = (_a$2 = this.upstream) === null || _a$2 === void 0 ? void 0 : _a$2.makeLogger(namespace);
			return (fields, ...args) => {
				var _a$3;
				const severity = (_a$3 = fields.severity) !== null && _a$3 !== void 0 ? _a$3 : LogSeverity.INFO;
				const json$1 = Object.assign({
					severity,
					message: util$4.format(...args)
				}, fields);
				const jsonString = JSON.stringify(json$1);
				if (debugLogger) debugLogger(fields, jsonString);
				else console.log("%s", jsonString);
			};
		}
		setFilters() {
			var _a$2;
			(_a$2 = this.upstream) === null || _a$2 === void 0 || _a$2.setFilters();
		}
	};
	/**
	* Creates a "structured logging" backend. This pretty much works like the
	* Node logger, but it outputs structured logging JSON matching Google
	* Cloud's ingestion specs instead of plain text.
	*
	* ```
	*  setBackend(getStructuredBackend())
	* ```
	*
	* @param upstream If you want to use something besides the Node backend to
	*   write the actual log lines into, pass that here.
	* @returns A backend based on Google Cloud structured logging.
	*/
	function getStructuredBackend(upstream) {
		return new StructuredBackend(upstream);
	}
	/**
	* The environment variables that we standardized on, for all ad-hoc logging.
	*/
	exports.env = { nodeEnables: "GOOGLE_SDK_NODE_LOGGING" };
	const loggerCache = /* @__PURE__ */ new Map();
	let cachedBackend = void 0;
	/**
	* Set the backend to use for our log output.
	* - A backend object
	* - null to disable logging
	* - undefined for "nothing yet", defaults to the Node backend
	*
	* @param backend Results from one of the get*Backend() functions.
	*/
	function setBackend(backend) {
		cachedBackend = backend;
		loggerCache.clear();
	}
	/**
	* Creates a logging function. Multiple calls to this with the same namespace
	* will produce the same logger, with the same event emitter hooks.
	*
	* Namespaces can be a simple string ("system" name), or a qualified string
	* (system:subsystem), which can be used for filtering, or for "system:*".
	*
	* @param namespace The namespace, a descriptive text string.
	* @returns A function you can call that works similar to console.log().
	*/
	function log$1(namespace, parent) {
		if (!cachedBackend) {
			if (!process$1.env[exports.env.nodeEnables]) return exports.placeholder;
		}
		if (!namespace) return exports.placeholder;
		if (parent) namespace = `${parent.instance.namespace}:${namespace}`;
		const existing = loggerCache.get(namespace);
		if (existing) return existing.func;
		if (cachedBackend === null) return exports.placeholder;
		else if (cachedBackend === void 0) cachedBackend = getNodeBackend();
		const logger$1 = (() => {
			let previousBackend = void 0;
			return new AdhocDebugLogger(namespace, (fields, ...args) => {
				if (previousBackend !== cachedBackend) {
					if (cachedBackend === null) return;
					else if (cachedBackend === void 0) cachedBackend = getNodeBackend();
					previousBackend = cachedBackend;
				}
				cachedBackend === null || cachedBackend === void 0 || cachedBackend.log(namespace, fields, ...args);
			});
		})();
		loggerCache.set(namespace, logger$1);
		return logger$1.func;
	}
}));

//#endregion
//#region node_modules/google-logging-utils/build/src/index.js
var require_src$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$2 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __exportStar$2 = exports && exports.__exportStar || function(m$2, exports$1) {
		for (var p in m$2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$2(exports$1, m$2, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar$2(require_logging_utils(), exports);
}));

//#endregion
//#region node_modules/gcp-metadata/build/src/index.js
var require_src$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$1 = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i$2 = 0; i$2 < k.length; i$2++) if (k[i$2] !== "default") __createBinding$1(result, mod, k[i$2]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __exportStar$1 = exports && exports.__exportStar || function(m$2, exports$1) {
		for (var p in m$2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$1(exports$1, m$2, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.gcpResidencyCache = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;
	exports.instance = instance;
	exports.project = project;
	exports.universe = universe;
	exports.bulk = bulk;
	exports.isAvailable = isAvailable;
	exports.resetIsAvailableCache = resetIsAvailableCache;
	exports.getGCPResidency = getGCPResidency;
	exports.setGCPResidency = setGCPResidency;
	exports.requestTimeout = requestTimeout;
	/**
	* Copyright 2018 Google LLC
	*
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*      http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
	*/
	const gaxios_1$13 = require_src$4();
	const jsonBigint = require_json_bigint();
	const gcp_residency_1 = require_gcp_residency();
	const logger = __importStar(require_src$3());
	exports.BASE_PATH = "/computeMetadata/v1";
	exports.HOST_ADDRESS = "http://169.254.169.254";
	exports.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.";
	exports.HEADER_NAME = "Metadata-Flavor";
	exports.HEADER_VALUE = "Google";
	exports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });
	const log = logger.log("gcp-metadata");
	/**
	* Metadata server detection override options.
	*
	* Available via `process.env.METADATA_SERVER_DETECTION`.
	*/
	exports.METADATA_SERVER_DETECTION = Object.freeze({
		"assume-present": "don't try to ping the metadata server, but assume it's present",
		none: "don't try to ping the metadata server, but don't try to use it either",
		"bios-only": "treat the result of a BIOS probe as canonical (don't fall back to pinging)",
		"ping-only": "skip the BIOS probe, and go straight to pinging"
	});
	/**
	* Returns the base URL while taking into account the GCE_METADATA_HOST
	* environment variable if it exists.
	*
	* @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.
	*/
	function getBaseUrl$1(baseUrl$1) {
		if (!baseUrl$1) baseUrl$1 = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;
		if (!/^https?:\/\//.test(baseUrl$1)) baseUrl$1 = `http://${baseUrl$1}`;
		return new URL(exports.BASE_PATH, baseUrl$1).href;
	}
	function validate(options) {
		Object.keys(options).forEach((key) => {
			switch (key) {
				case "params":
				case "property":
				case "headers": break;
				case "qs": throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
				default: throw new Error(`'${key}' is not a valid configuration option.`);
			}
		});
	}
	async function metadataAccessor(type, options = {}, noResponseRetries = 3, fastFail = false) {
		const headers = new Headers(exports.HEADERS);
		let metadataKey = "";
		let params = {};
		if (typeof type === "object") {
			const metadataAccessor$1 = type;
			new Headers(metadataAccessor$1.headers).forEach((value, key) => headers.set(key, value));
			metadataKey = metadataAccessor$1.metadataKey;
			params = metadataAccessor$1.params || params;
			noResponseRetries = metadataAccessor$1.noResponseRetries || noResponseRetries;
			fastFail = metadataAccessor$1.fastFail || fastFail;
		} else metadataKey = type;
		if (typeof options === "string") metadataKey += `/${options}`;
		else {
			validate(options);
			if (options.property) metadataKey += `/${options.property}`;
			new Headers(options.headers).forEach((value, key) => headers.set(key, value));
			params = options.params || params;
		}
		const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1$13.request;
		const req$1 = {
			url: `${getBaseUrl$1()}/${metadataKey}`,
			headers,
			retryConfig: { noResponseRetries },
			params,
			responseType: "text",
			timeout: requestTimeout()
		};
		log.info("instance request %j", req$1);
		const res = await requestMethod(req$1);
		log.info("instance metadata is %s", res.data);
		const metadataFlavor = res.headers.get(exports.HEADER_NAME);
		if (metadataFlavor !== exports.HEADER_VALUE) throw new RangeError(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header. Expected '${exports.HEADER_VALUE}', got ${metadataFlavor ? `'${metadataFlavor}'` : "no header"}`);
		if (typeof res.data === "string") try {
			return jsonBigint.parse(res.data);
		} catch {}
		return res.data;
	}
	async function fastFailMetadataRequest(options) {
		const secondaryOptions = {
			...options,
			url: options.url?.toString().replace(getBaseUrl$1(), getBaseUrl$1(exports.SECONDARY_HOST_ADDRESS))
		};
		const r1 = (0, gaxios_1$13.request)(options);
		const r2 = (0, gaxios_1$13.request)(secondaryOptions);
		return Promise.any([r1, r2]);
	}
	/**
	* Obtain metadata for the current GCE instance.
	*
	* @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}
	*
	* @example
	* ```
	* const serviceAccount: {} = await instance('service-accounts/');
	* const serviceAccountEmail: string = await instance('service-accounts/default/email');
	* ```
	*/
	function instance(options) {
		return metadataAccessor("instance", options);
	}
	/**
	* Obtain metadata for the current GCP project.
	*
	* @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}
	*
	* @example
	* ```
	* const projectId: string = await project('project-id');
	* const numericProjectId: number = await project('numeric-project-id');
	* ```
	*/
	function project(options) {
		return metadataAccessor("project", options);
	}
	/**
	* Obtain metadata for the current universe.
	*
	* @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}
	*
	* @example
	* ```
	* const universeDomain: string = await universe('universe-domain');
	* ```
	*/
	function universe(options) {
		return metadataAccessor("universe", options);
	}
	/**
	* Retrieve metadata items in parallel.
	*
	* @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}
	*
	* @example
	* ```
	* const data = await bulk([
	*   {
	*     metadataKey: 'instance',
	*   },
	*   {
	*     metadataKey: 'project/project-id',
	*   },
	* ] as const);
	*
	* // data.instance;
	* // data['project/project-id'];
	* ```
	*
	* @param properties The metadata properties to retrieve
	* @returns The metadata in `metadatakey:value` format
	*/
	async function bulk(properties) {
		const r$1 = {};
		await Promise.all(properties.map((item) => {
			return (async () => {
				const res = await metadataAccessor(item);
				const key = item.metadataKey;
				r$1[key] = res;
			})();
		}));
		return r$1;
	}
	function detectGCPAvailableRetries() {
		return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
	}
	let cachedIsAvailableResponse;
	/**
	* Determine if the metadata server is currently available.
	*/
	async function isAvailable() {
		if (process.env.METADATA_SERVER_DETECTION) {
			const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();
			if (!(value in exports.METADATA_SERVER_DETECTION)) throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${value}\`, but it should be \`${Object.keys(exports.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);
			switch (value) {
				case "assume-present": return true;
				case "none": return false;
				case "bios-only": return getGCPResidency();
				case "ping-only":
			}
		}
		try {
			if (cachedIsAvailableResponse === void 0) cachedIsAvailableResponse = metadataAccessor("instance", void 0, detectGCPAvailableRetries(), !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));
			await cachedIsAvailableResponse;
			return true;
		} catch (e$1) {
			const err = e$1;
			if (process.env.DEBUG_AUTH) console.info(err);
			if (err.type === "request-timeout") return false;
			if (err.response && err.response.status === 404) return false;
			else {
				if (!(err.response && err.response.status === 404) && (!err.code || ![
					"EHOSTDOWN",
					"EHOSTUNREACH",
					"ENETUNREACH",
					"ENOENT",
					"ENOTFOUND",
					"ECONNREFUSED"
				].includes(err.code.toString()))) {
					let code$1 = "UNKNOWN";
					if (err.code) code$1 = err.code.toString();
					process.emitWarning(`received unexpected error = ${err.message} code = ${code$1}`, "MetadataLookupWarning");
				}
				return false;
			}
		}
	}
	/**
	* reset the memoized isAvailable() lookup.
	*/
	function resetIsAvailableCache() {
		cachedIsAvailableResponse = void 0;
	}
	/**
	* A cache for the detected GCP Residency.
	*/
	exports.gcpResidencyCache = null;
	/**
	* Detects GCP Residency.
	* Caches results to reduce costs for subsequent calls.
	*
	* @see setGCPResidency for setting
	*/
	function getGCPResidency() {
		if (exports.gcpResidencyCache === null) setGCPResidency();
		return exports.gcpResidencyCache;
	}
	/**
	* Sets the detected GCP Residency.
	* Useful for forcing metadata server detection behavior.
	*
	* Set `null` to autodetect the environment (default behavior).
	* @see getGCPResidency for getting
	*/
	function setGCPResidency(value = null) {
		exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();
	}
	/**
	* Obtain the timeout for requests to the metadata server.
	*
	* In certain environments and conditions requests can take longer than
	* the default timeout to complete. This function will determine the
	* appropriate timeout based on the environment.
	*
	* @returns {number} a request timeout duration in milliseconds.
	*/
	function requestTimeout() {
		return getGCPResidency() ? 0 : 3e3;
	}
	__exportStar$1(require_gcp_residency(), exports);
}));

//#endregion
//#region node_modules/base64-js/index.js
var require_base64_js = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.byteLength = byteLength;
	exports.toByteArray = toByteArray;
	exports.fromByteArray = fromByteArray;
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
	var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	for (var i = 0, len = code.length; i < len; ++i) {
		lookup[i] = code[i];
		revLookup[code.charCodeAt(i)] = i;
	}
	revLookup["-".charCodeAt(0)] = 62;
	revLookup["_".charCodeAt(0)] = 63;
	function getLens(b64) {
		var len$1 = b64.length;
		if (len$1 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
		var validLen = b64.indexOf("=");
		if (validLen === -1) validLen = len$1;
		var placeHoldersLen = validLen === len$1 ? 0 : 4 - validLen % 4;
		return [validLen, placeHoldersLen];
	}
	function byteLength(b64) {
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function _byteLength(b64, validLen, placeHoldersLen) {
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function toByteArray(b64) {
		var tmp;
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		var curByte = 0;
		var len$1 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		var i$2;
		for (i$2 = 0; i$2 < len$1; i$2 += 4) {
			tmp = revLookup[b64.charCodeAt(i$2)] << 18 | revLookup[b64.charCodeAt(i$2 + 1)] << 12 | revLookup[b64.charCodeAt(i$2 + 2)] << 6 | revLookup[b64.charCodeAt(i$2 + 3)];
			arr[curByte++] = tmp >> 16 & 255;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 2) {
			tmp = revLookup[b64.charCodeAt(i$2)] << 2 | revLookup[b64.charCodeAt(i$2 + 1)] >> 4;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 1) {
			tmp = revLookup[b64.charCodeAt(i$2)] << 10 | revLookup[b64.charCodeAt(i$2 + 1)] << 4 | revLookup[b64.charCodeAt(i$2 + 2)] >> 2;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		return arr;
	}
	function tripletToBase64(num) {
		return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
	}
	function encodeChunk(uint8, start, end) {
		var tmp;
		var output = [];
		for (var i$2 = start; i$2 < end; i$2 += 3) {
			tmp = (uint8[i$2] << 16 & 16711680) + (uint8[i$2 + 1] << 8 & 65280) + (uint8[i$2 + 2] & 255);
			output.push(tripletToBase64(tmp));
		}
		return output.join("");
	}
	function fromByteArray(uint8) {
		var tmp;
		var len$1 = uint8.length;
		var extraBytes = len$1 % 3;
		var parts = [];
		var maxChunkLength = 16383;
		for (var i$2 = 0, len2 = len$1 - extraBytes; i$2 < len2; i$2 += maxChunkLength) parts.push(encodeChunk(uint8, i$2, i$2 + maxChunkLength > len2 ? len2 : i$2 + maxChunkLength));
		if (extraBytes === 1) {
			tmp = uint8[len$1 - 1];
			parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
		} else if (extraBytes === 2) {
			tmp = (uint8[len$1 - 2] << 8) + uint8[len$1 - 1];
			parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
		}
		return parts.join("");
	}
}));

//#endregion
//#region node_modules/google-auth-library/build/src/crypto/shared.js
var require_shared$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fromArrayBufferToHex = fromArrayBufferToHex;
	/**
	* Converts an ArrayBuffer to a hexadecimal string.
	* @param arrayBuffer The ArrayBuffer to convert to hexadecimal string.
	* @return The hexadecimal encoding of the ArrayBuffer.
	*/
	function fromArrayBufferToHex(arrayBuffer) {
		return Array.from(new Uint8Array(arrayBuffer)).map((byte) => {
			return byte.toString(16).padStart(2, "0");
		}).join("");
	}
}));

//#endregion
//#region node_modules/google-auth-library/build/src/crypto/browser/crypto.js
var require_crypto$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BrowserCrypto = void 0;
	const base64js = require_base64_js();
	const shared_1 = require_shared$1();
	var BrowserCrypto = class BrowserCrypto {
		constructor() {
			if (typeof window === "undefined" || window.crypto === void 0 || window.crypto.subtle === void 0) throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
		}
		async sha256DigestBase64(str) {
			const inputBuffer = new TextEncoder().encode(str);
			const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
			return base64js.fromByteArray(new Uint8Array(outputBuffer));
		}
		randomBytesBase64(count) {
			const array = new Uint8Array(count);
			window.crypto.getRandomValues(array);
			return base64js.fromByteArray(array);
		}
		static padBase64(base64) {
			while (base64.length % 4 !== 0) base64 += "=";
			return base64;
		}
		async verify(pubkey, data, signature) {
			const algo = {
				name: "RSASSA-PKCS1-v1_5",
				hash: { name: "SHA-256" }
			};
			const dataArray = new TextEncoder().encode(data);
			const signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));
			const cryptoKey = await window.crypto.subtle.importKey("jwk", pubkey, algo, true, ["verify"]);
			return await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);
		}
		async sign(privateKey, data) {
			const algo = {
				name: "RSASSA-PKCS1-v1_5",
				hash: { name: "SHA-256" }
			};
			const dataArray = new TextEncoder().encode(data);
			const cryptoKey = await window.crypto.subtle.importKey("jwk", privateKey, algo, true, ["sign"]);
			const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);
			return base64js.fromByteArray(new Uint8Array(result));
		}
		decodeBase64StringUtf8(base64) {
			const uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64));
			return new TextDecoder().decode(uint8array);
		}
		encodeBase64StringUtf8(text) {
			const uint8array = new TextEncoder().encode(text);
			return base64js.fromByteArray(uint8array);
		}
		/**
		* Computes the SHA-256 hash of the provided string.
		* @param str The plain text string to hash.
		* @return A promise that resolves with the SHA-256 hash of the provided
		*   string in hexadecimal encoding.
		*/
		async sha256DigestHex(str) {
			const inputBuffer = new TextEncoder().encode(str);
			const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
			return (0, shared_1.fromArrayBufferToHex)(outputBuffer);
		}
		/**
		* Computes the HMAC hash of a message using the provided crypto key and the
		* SHA-256 algorithm.
		* @param key The secret crypto key in utf-8 or ArrayBuffer format.
		* @param msg The plain text message.
		* @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
		*   format.
		*/
		async signWithHmacSha256(key, msg) {
			const rawKey = typeof key === "string" ? key : String.fromCharCode(...new Uint16Array(key));
			const enc = new TextEncoder();
			const cryptoKey = await window.crypto.subtle.importKey("raw", enc.encode(rawKey), {
				name: "HMAC",
				hash: { name: "SHA-256" }
			}, false, ["sign"]);
			return window.crypto.subtle.sign("HMAC", cryptoKey, enc.encode(msg));
		}
	};
	exports.BrowserCrypto = BrowserCrypto;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/crypto/node/crypto.js
var require_crypto$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.NodeCrypto = void 0;
	const crypto$2 = require("crypto");
	var NodeCrypto = class {
		async sha256DigestBase64(str) {
			return crypto$2.createHash("sha256").update(str).digest("base64");
		}
		randomBytesBase64(count) {
			return crypto$2.randomBytes(count).toString("base64");
		}
		async verify(pubkey, data, signature) {
			const verifier = crypto$2.createVerify("RSA-SHA256");
			verifier.update(data);
			verifier.end();
			return verifier.verify(pubkey, signature, "base64");
		}
		async sign(privateKey, data) {
			const signer = crypto$2.createSign("RSA-SHA256");
			signer.update(data);
			signer.end();
			return signer.sign(privateKey, "base64");
		}
		decodeBase64StringUtf8(base64) {
			return Buffer.from(base64, "base64").toString("utf-8");
		}
		encodeBase64StringUtf8(text) {
			return Buffer.from(text, "utf-8").toString("base64");
		}
		/**
		* Computes the SHA-256 hash of the provided string.
		* @param str The plain text string to hash.
		* @return A promise that resolves with the SHA-256 hash of the provided
		*   string in hexadecimal encoding.
		*/
		async sha256DigestHex(str) {
			return crypto$2.createHash("sha256").update(str).digest("hex");
		}
		/**
		* Computes the HMAC hash of a message using the provided crypto key and the
		* SHA-256 algorithm.
		* @param key The secret crypto key in utf-8 or ArrayBuffer format.
		* @param msg The plain text message.
		* @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
		*   format.
		*/
		async signWithHmacSha256(key, msg) {
			const cryptoKey = typeof key === "string" ? key : toBuffer$3(key);
			return toArrayBuffer$2(crypto$2.createHmac("sha256", cryptoKey).update(msg).digest());
		}
	};
	exports.NodeCrypto = NodeCrypto;
	/**
	* Converts a Node.js Buffer to an ArrayBuffer.
	* https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer
	* @param buffer The Buffer input to covert.
	* @return The ArrayBuffer representation of the input.
	*/
	function toArrayBuffer$2(buffer$1) {
		return buffer$1.buffer.slice(buffer$1.byteOffset, buffer$1.byteOffset + buffer$1.byteLength);
	}
	/**
	* Converts an ArrayBuffer to a Node.js Buffer.
	* @param arrayBuffer The ArrayBuffer input to covert.
	* @return The Buffer representation of the input.
	*/
	function toBuffer$3(arrayBuffer) {
		return Buffer.from(arrayBuffer);
	}
}));

//#endregion
//#region node_modules/google-auth-library/build/src/crypto/crypto.js
var require_crypto = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$2, k);
		if (!desc || ("get" in desc ? !m$2.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$2[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$2, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$2[k];
	}));
	var __exportStar = exports && exports.__exportStar || function(m$2, exports$1) {
		for (var p in m$2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m$2, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createCrypto = createCrypto;
	exports.hasBrowserCrypto = hasBrowserCrypto;
	const crypto_1$5 = require_crypto$2();
	const crypto_2 = require_crypto$1();
	__exportStar(require_shared$1(), exports);
	function createCrypto() {
		if (hasBrowserCrypto()) return new crypto_1$5.BrowserCrypto();
		return new crypto_2.NodeCrypto();
	}
	function hasBrowserCrypto() {
		return typeof window !== "undefined" && typeof window.crypto !== "undefined" && typeof window.crypto.subtle !== "undefined";
	}
}));

//#endregion
//#region node_modules/safe-buffer/index.js
var require_safe_buffer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	var buffer = require("buffer");
	var Buffer$8 = buffer.Buffer;
	function copyProps(src, dst) {
		for (var key in src) dst[key] = src[key];
	}
	if (Buffer$8.from && Buffer$8.alloc && Buffer$8.allocUnsafe && Buffer$8.allocUnsafeSlow) module.exports = buffer;
	else {
		copyProps(buffer, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer$8(arg, encodingOrOffset, length);
	}
	SafeBuffer.prototype = Object.create(Buffer$8.prototype);
	copyProps(Buffer$8, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer$8(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function(size, fill$2, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer$8(size);
		if (fill$2 !== void 0) if (typeof encoding === "string") buf.fill(fill$2, encoding);
		else buf.fill(fill$2);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer$8(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer.SlowBuffer(size);
	};
}));

//#endregion
//#region node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function getParamSize(keySize) {
		return (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
	}
	var paramBytesForAlg = {
		ES256: getParamSize(256),
		ES384: getParamSize(384),
		ES512: getParamSize(521)
	};
	function getParamBytesForAlg$1(alg) {
		var paramBytes = paramBytesForAlg[alg];
		if (paramBytes) return paramBytes;
		throw new Error("Unknown algorithm \"" + alg + "\"");
	}
	module.exports = getParamBytesForAlg$1;
}));

//#endregion
//#region node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$7 = require_safe_buffer().Buffer;
	var getParamBytesForAlg = require_param_bytes_for_alg();
	var MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
	function base64Url(base64) {
		return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function signatureAsBuffer(signature) {
		if (Buffer$7.isBuffer(signature)) return signature;
		else if ("string" === typeof signature) return Buffer$7.from(signature, "base64");
		throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
	}
	function derToJose(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);
		var maxEncodedParamLength = paramBytes + 1;
		var inputLength = signature.length;
		var offset = 0;
		if (signature[offset++] !== ENCODED_TAG_SEQ) throw new Error("Could not find expected \"seq\"");
		var seqLength = signature[offset++];
		if (seqLength === (MAX_OCTET | 1)) seqLength = signature[offset++];
		if (inputLength - offset < seqLength) throw new Error("\"seq\" specified length of \"" + seqLength + "\", only \"" + (inputLength - offset) + "\" remaining");
		if (signature[offset++] !== ENCODED_TAG_INT) throw new Error("Could not find expected \"int\" for \"r\"");
		var rLength = signature[offset++];
		if (inputLength - offset - 2 < rLength) throw new Error("\"r\" specified length of \"" + rLength + "\", only \"" + (inputLength - offset - 2) + "\" available");
		if (maxEncodedParamLength < rLength) throw new Error("\"r\" specified length of \"" + rLength + "\", max of \"" + maxEncodedParamLength + "\" is acceptable");
		var rOffset = offset;
		offset += rLength;
		if (signature[offset++] !== ENCODED_TAG_INT) throw new Error("Could not find expected \"int\" for \"s\"");
		var sLength = signature[offset++];
		if (inputLength - offset !== sLength) throw new Error("\"s\" specified length of \"" + sLength + "\", expected \"" + (inputLength - offset) + "\"");
		if (maxEncodedParamLength < sLength) throw new Error("\"s\" specified length of \"" + sLength + "\", max of \"" + maxEncodedParamLength + "\" is acceptable");
		var sOffset = offset;
		offset += sLength;
		if (offset !== inputLength) throw new Error("Expected to consume entire buffer, but \"" + (inputLength - offset) + "\" bytes remain");
		var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
		var dst = Buffer$7.allocUnsafe(rPadding + rLength + sPadding + sLength);
		for (offset = 0; offset < rPadding; ++offset) dst[offset] = 0;
		signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
		offset = paramBytes;
		for (var o = offset; offset < o + sPadding; ++offset) dst[offset] = 0;
		signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
		dst = dst.toString("base64");
		dst = base64Url(dst);
		return dst;
	}
	function countPadding(buf, start, stop) {
		var padding = 0;
		while (start + padding < stop && buf[start + padding] === 0) ++padding;
		if (buf[start + padding] >= MAX_OCTET) --padding;
		return padding;
	}
	function joseToDer(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);
		var signatureBytes = signature.length;
		if (signatureBytes !== paramBytes * 2) throw new TypeError("\"" + alg + "\" signatures must be \"" + paramBytes * 2 + "\" bytes, saw \"" + signatureBytes + "\"");
		var rPadding = countPadding(signature, 0, paramBytes);
		var sPadding = countPadding(signature, paramBytes, signature.length);
		var rLength = paramBytes - rPadding;
		var sLength = paramBytes - sPadding;
		var rsBytes = 2 + rLength + 1 + 1 + sLength;
		var shortLength = rsBytes < MAX_OCTET;
		var dst = Buffer$7.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
		var offset = 0;
		dst[offset++] = ENCODED_TAG_SEQ;
		if (shortLength) dst[offset++] = rsBytes;
		else {
			dst[offset++] = MAX_OCTET | 1;
			dst[offset++] = rsBytes & 255;
		}
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = rLength;
		if (rPadding < 0) {
			dst[offset++] = 0;
			offset += signature.copy(dst, offset, 0, paramBytes);
		} else offset += signature.copy(dst, offset, rPadding, paramBytes);
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = sLength;
		if (sPadding < 0) {
			dst[offset++] = 0;
			signature.copy(dst, offset, paramBytes);
		} else signature.copy(dst, offset, paramBytes + sPadding);
		return dst;
	}
	module.exports = {
		derToJose,
		joseToDer
	};
}));

//#endregion
//#region node_modules/google-auth-library/build/src/util.js
var require_util = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LRUCache = void 0;
	exports.snakeToCamel = snakeToCamel;
	exports.originalOrCamelOptions = originalOrCamelOptions;
	exports.removeUndefinedValuesInObject = removeUndefinedValuesInObject;
	exports.isValidFile = isValidFile;
	exports.getWellKnownCertificateConfigFileLocation = getWellKnownCertificateConfigFileLocation;
	const fs$6 = require("fs");
	const os$1 = require("os");
	const path$3 = require("path");
	const WELL_KNOWN_CERTIFICATE_CONFIG_FILE = "certificate_config.json";
	const CLOUDSDK_CONFIG_DIRECTORY = "gcloud";
	/**
	* Returns the camel case of a provided string.
	*
	* @remarks
	*
	* Match any `_` and not `_` pair, then return the uppercase of the not `_`
	* character.
	*
	* @param str the string to convert
	* @returns the camelCase'd string
	*/
	function snakeToCamel(str) {
		return str.replace(/([_][^_])/g, (match) => match.slice(1).toUpperCase());
	}
	/**
	* Get the value of `obj[key]` or `obj[camelCaseKey]`, with a preference
	* for original, non-camelCase key.
	*
	* @param obj object to lookup a value in
	* @returns a `get` function for getting `obj[key || snakeKey]`, if available
	*/
	function originalOrCamelOptions(obj) {
		/**
		*
		* @param key an index of object, preferably snake_case
		* @returns the value `obj[key || snakeKey]`, if available
		*/
		function get(key) {
			const o = obj || {};
			return o[key] ?? o[snakeToCamel(key)];
		}
		return { get };
	}
	/**
	* A simple LRU cache utility.
	* Not meant for external usage.
	*
	* @experimental
	*/
	var LRUCache = class {
		capacity;
		/**
		* Maps are in order. Thus, the older item is the first item.
		*
		* {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}
		*/
		#cache = /* @__PURE__ */ new Map();
		maxAge;
		constructor(options) {
			this.capacity = options.capacity;
			this.maxAge = options.maxAge;
		}
		/**
		* Moves the key to the end of the cache.
		*
		* @param key the key to move
		* @param value the value of the key
		*/
		#moveToEnd(key, value) {
			this.#cache.delete(key);
			this.#cache.set(key, {
				value,
				lastAccessed: Date.now()
			});
		}
		/**
		* Add an item to the cache.
		*
		* @param key the key to upsert
		* @param value the value of the key
		*/
		set(key, value) {
			this.#moveToEnd(key, value);
			this.#evict();
		}
		/**
		* Get an item from the cache.
		*
		* @param key the key to retrieve
		*/
		get(key) {
			const item = this.#cache.get(key);
			if (!item) return;
			this.#moveToEnd(key, item.value);
			this.#evict();
			return item.value;
		}
		/**
		* Maintain the cache based on capacity and TTL.
		*/
		#evict() {
			const cutoffDate = this.maxAge ? Date.now() - this.maxAge : 0;
			/**
			* Because we know Maps are in order, this item is both the
			* last item in the list (capacity) and oldest (maxAge).
			*/
			let oldestItem = this.#cache.entries().next();
			while (!oldestItem.done && (this.#cache.size > this.capacity || oldestItem.value[1].lastAccessed < cutoffDate)) {
				this.#cache.delete(oldestItem.value[0]);
				oldestItem = this.#cache.entries().next();
			}
		}
	};
	exports.LRUCache = LRUCache;
	function removeUndefinedValuesInObject(object) {
		Object.entries(object).forEach(([key, value]) => {
			if (value === void 0 || value === "undefined") delete object[key];
		});
		return object;
	}
	/**
	* Helper to check if a path points to a valid file.
	*/
	async function isValidFile(filePath) {
		try {
			return (await fs$6.promises.lstat(filePath)).isFile();
		} catch (e$1) {
			return false;
		}
	}
	/**
	* Determines the well-known gcloud location for the certificate config file.
	* @returns The platform-specific path to the configuration file.
	* @internal
	*/
	function getWellKnownCertificateConfigFileLocation() {
		const configDir = process.env.CLOUDSDK_CONFIG || (_isWindows() ? path$3.join(process.env.APPDATA || "", CLOUDSDK_CONFIG_DIRECTORY) : path$3.join(process.env.HOME || "", ".config", CLOUDSDK_CONFIG_DIRECTORY));
		return path$3.join(configDir, WELL_KNOWN_CERTIFICATE_CONFIG_FILE);
	}
	/**
	* Checks if the current operating system is Windows.
	* @returns True if the OS is Windows, false otherwise.
	* @internal
	*/
	function _isWindows() {
		return os$1.platform().startsWith("win");
	}
}));

//#endregion
//#region node_modules/google-auth-library/package.json
var require_package = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"name": "google-auth-library",
		"version": "10.5.0",
		"author": "Google Inc.",
		"description": "Google APIs Authentication Client Library for Node.js",
		"engines": { "node": ">=18" },
		"main": "./build/src/index.js",
		"types": "./build/src/index.d.ts",
		"repository": "googleapis/google-auth-library-nodejs.git",
		"keywords": [
			"google",
			"api",
			"google apis",
			"client",
			"client library"
		],
		"dependencies": {
			"base64-js": "^1.3.0",
			"ecdsa-sig-formatter": "^1.0.11",
			"gaxios": "^7.0.0",
			"gcp-metadata": "^8.0.0",
			"google-logging-utils": "^1.0.0",
			"gtoken": "^8.0.0",
			"jws": "^4.0.0"
		},
		"devDependencies": {
			"@types/base64-js": "^1.2.5",
			"@types/jws": "^3.1.0",
			"@types/mocha": "^10.0.10",
			"@types/mv": "^2.1.0",
			"@types/ncp": "^2.0.1",
			"@types/node": "^22.0.0",
			"@types/sinon": "^17.0.0",
			"assert-rejects": "^1.0.0",
			"c8": "^10.0.0",
			"codecov": "^3.0.2",
			"gts": "^6.0.0",
			"is-docker": "^3.0.0",
			"jsdoc": "^4.0.0",
			"jsdoc-fresh": "^5.0.0",
			"jsdoc-region-tag": "^4.0.0",
			"karma": "^6.0.0",
			"karma-chrome-launcher": "^3.0.0",
			"karma-coverage": "^2.0.0",
			"karma-firefox-launcher": "^2.0.0",
			"karma-mocha": "^2.0.0",
			"karma-sourcemap-loader": "^0.4.0",
			"karma-webpack": "^5.0.1",
			"keypair": "^1.0.4",
			"mocha": "^11.1.0",
			"mv": "^2.1.1",
			"ncp": "^2.0.0",
			"nock": "^14.0.5",
			"null-loader": "^4.0.0",
			"puppeteer": "^24.0.0",
			"sinon": "^21.0.0",
			"ts-loader": "^8.0.0",
			"typescript": "5.8.2",
			"webpack": "^5.21.2",
			"webpack-cli": "^4.0.0"
		},
		"files": ["build/src", "!build/src/**/*.map"],
		"scripts": {
			"test": "c8 mocha build/test",
			"clean": "gts clean",
			"prepare": "npm run compile",
			"lint": "gts check --no-inline-config",
			"compile": "tsc -p .",
			"fix": "gts fix",
			"pretest": "npm run compile -- --sourceMap",
			"docs": "jsdoc -c .jsdoc.js",
			"samples-setup": "cd samples/ && npm link ../ && npm run setup && cd ../",
			"samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
			"system-test": "mocha build/system-test --timeout 60000",
			"presystem-test": "npm run compile -- --sourceMap",
			"webpack": "webpack",
			"browser-test": "karma start",
			"docs-test": "echo 'disabled until linkinator is fixed'",
			"predocs-test": "npm run docs",
			"prelint": "cd samples; npm link ../; npm install"
		},
		"license": "Apache-2.0"
	};
}));

//#endregion
//#region node_modules/google-auth-library/build/src/shared.cjs
var require_shared = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.USER_AGENT = exports.PRODUCT_NAME = exports.pkg = void 0;
	const pkg = require_package();
	exports.pkg = pkg;
	const PRODUCT_NAME = "google-api-nodejs-client";
	exports.PRODUCT_NAME = PRODUCT_NAME;
	const USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;
	exports.USER_AGENT = USER_AGENT;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/authclient.js
var require_authclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AuthClient = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = exports.DEFAULT_UNIVERSE = void 0;
	const events_1 = require("events");
	const gaxios_1$12 = require_src$4();
	const util_1$10 = require_util();
	const google_logging_utils_1 = require_src$3();
	const shared_cjs_1$1 = require_shared();
	/**
	* The default cloud universe
	*
	* @see {@link AuthJSONOptions.universe_domain}
	*/
	exports.DEFAULT_UNIVERSE = "googleapis.com";
	/**
	* The default {@link AuthClientOptions.eagerRefreshThresholdMillis}
	*/
	exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 300 * 1e3;
	/**
	* The base of all Auth Clients.
	*/
	var AuthClient = class AuthClient extends events_1.EventEmitter {
		apiKey;
		projectId;
		/**
		* The quota project ID. The quota project can be used by client libraries for the billing purpose.
		* See {@link https://cloud.google.com/docs/quota Working with quotas}
		*/
		quotaProjectId;
		/**
		* The {@link Gaxios `Gaxios`} instance used for making requests.
		*/
		transporter;
		credentials = {};
		eagerRefreshThresholdMillis = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS;
		forceRefreshOnFailure = false;
		universeDomain = exports.DEFAULT_UNIVERSE;
		/**
		* Symbols that can be added to GaxiosOptions to specify the method name that is
		* making an RPC call, for logging purposes, as well as a string ID that can be
		* used to correlate calls and responses.
		*/
		static RequestMethodNameSymbol = Symbol("request method name");
		static RequestLogIdSymbol = Symbol("request log id");
		constructor(opts = {}) {
			super();
			const options = (0, util_1$10.originalOrCamelOptions)(opts);
			this.apiKey = opts.apiKey;
			this.projectId = options.get("project_id") ?? null;
			this.quotaProjectId = options.get("quota_project_id");
			this.credentials = options.get("credentials") ?? {};
			this.universeDomain = options.get("universe_domain") ?? exports.DEFAULT_UNIVERSE;
			this.transporter = opts.transporter ?? new gaxios_1$12.Gaxios(opts.transporterOptions);
			if (options.get("useAuthRequestParameters") !== false) {
				this.transporter.interceptors.request.add(AuthClient.DEFAULT_REQUEST_INTERCEPTOR);
				this.transporter.interceptors.response.add(AuthClient.DEFAULT_RESPONSE_INTERCEPTOR);
			}
			if (opts.eagerRefreshThresholdMillis) this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis;
			this.forceRefreshOnFailure = opts.forceRefreshOnFailure ?? false;
		}
		/**
		* A {@link fetch `fetch`} compliant API for {@link AuthClient}.
		*
		* @see {@link AuthClient.request} for the classic method.
		*
		* @remarks
		*
		* This is useful as a drop-in replacement for `fetch` API usage.
		*
		* @example
		*
		* ```ts
		* const authClient = new AuthClient();
		* const fetchWithAuthClient: typeof fetch = (...args) => authClient.fetch(...args);
		* await fetchWithAuthClient('https://example.com');
		* ```
		*
		* @param args `fetch` API or {@link Gaxios.fetch `Gaxios#fetch`} parameters
		* @returns the {@link GaxiosResponse} with Gaxios-added properties
		*/
		fetch(...args) {
			const input = args[0];
			const init$1 = args[1];
			let url = void 0;
			const headers = new Headers();
			if (typeof input === "string") url = new URL(input);
			else if (input instanceof URL) url = input;
			else if (input && input.url) url = new URL(input.url);
			if (input && typeof input === "object" && "headers" in input) gaxios_1$12.Gaxios.mergeHeaders(headers, input.headers);
			if (init$1) gaxios_1$12.Gaxios.mergeHeaders(headers, new Headers(init$1.headers));
			if (typeof input === "object" && !(input instanceof URL)) return this.request({
				...init$1,
				...input,
				headers,
				url
			});
			else return this.request({
				...init$1,
				headers,
				url
			});
		}
		/**
		* Sets the auth credentials.
		*/
		setCredentials(credentials) {
			this.credentials = credentials;
		}
		/**
		* Append additional headers, e.g., x-goog-user-project, shared across the
		* classes inheriting AuthClient. This method should be used by any method
		* that overrides getRequestMetadataAsync(), which is a shared helper for
		* setting request information in both gRPC and HTTP API calls.
		*
		* @param headers object to append additional headers to.
		*/
		addSharedMetadataHeaders(headers) {
			if (!headers.has("x-goog-user-project") && this.quotaProjectId) headers.set("x-goog-user-project", this.quotaProjectId);
			return headers;
		}
		/**
		* Adds the `x-goog-user-project` and `authorization` headers to the target Headers
		* object, if they exist on the source.
		*
		* @param target the headers to target
		* @param source the headers to source from
		* @returns the target headers
		*/
		addUserProjectAndAuthHeaders(target, source) {
			const xGoogUserProject = source.get("x-goog-user-project");
			const authorizationHeader = source.get("authorization");
			if (xGoogUserProject) target.set("x-goog-user-project", xGoogUserProject);
			if (authorizationHeader) target.set("authorization", authorizationHeader);
			return target;
		}
		static log = (0, google_logging_utils_1.log)("auth");
		static DEFAULT_REQUEST_INTERCEPTOR = { resolved: async (config) => {
			if (!config.headers.has("x-goog-api-client")) {
				const nodeVersion = process.version.replace(/^v/, "");
				config.headers.set("x-goog-api-client", `gl-node/${nodeVersion}`);
			}
			const userAgent$1 = config.headers.get("User-Agent");
			if (!userAgent$1) config.headers.set("User-Agent", shared_cjs_1$1.USER_AGENT);
			else if (!userAgent$1.includes(`${shared_cjs_1$1.PRODUCT_NAME}/`)) config.headers.set("User-Agent", `${userAgent$1} ${shared_cjs_1$1.USER_AGENT}`);
			try {
				const symbols = config;
				const methodName = symbols[AuthClient.RequestMethodNameSymbol];
				const logId = `${Math.floor(Math.random() * 1e3)}`;
				symbols[AuthClient.RequestLogIdSymbol] = logId;
				const logObject = {
					url: config.url,
					headers: config.headers
				};
				if (methodName) AuthClient.log.info("%s [%s] request %j", methodName, logId, logObject);
				else AuthClient.log.info("[%s] request %j", logId, logObject);
			} catch (e$1) {}
			return config;
		} };
		static DEFAULT_RESPONSE_INTERCEPTOR = {
			resolved: async (response) => {
				try {
					const symbols = response.config;
					const methodName = symbols[AuthClient.RequestMethodNameSymbol];
					const logId = symbols[AuthClient.RequestLogIdSymbol];
					if (methodName) AuthClient.log.info("%s [%s] response %j", methodName, logId, response.data);
					else AuthClient.log.info("[%s] response %j", logId, response.data);
				} catch (e$1) {}
				return response;
			},
			rejected: async (error$1) => {
				try {
					const symbols = error$1.config;
					const methodName = symbols[AuthClient.RequestMethodNameSymbol];
					const logId = symbols[AuthClient.RequestLogIdSymbol];
					if (methodName) AuthClient.log.info("%s [%s] error %j", methodName, logId, error$1.response?.data);
					else AuthClient.log.error("[%s] error %j", logId, error$1.response?.data);
				} catch (e$1) {}
				throw error$1;
			}
		};
		/**
		* Sets the method name that is making a Gaxios request, so that logging may tag
		* log lines with the operation.
		* @param config A Gaxios request config
		* @param methodName The method name making the call
		*/
		static setMethodName(config, methodName) {
			try {
				const symbols = config;
				symbols[AuthClient.RequestMethodNameSymbol] = methodName;
			} catch (e$1) {}
		}
		/**
		* Retry config for Auth-related requests.
		*
		* @remarks
		*
		* This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
		* config as some downstream APIs would prefer if customers explicitly enable retries,
		* such as GCS.
		*/
		static get RETRY_CONFIG() {
			return {
				retry: true,
				retryConfig: { httpMethodsToRetry: [
					"GET",
					"PUT",
					"POST",
					"HEAD",
					"OPTIONS",
					"DELETE"
				] }
			};
		}
	};
	exports.AuthClient = AuthClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/loginticket.js
var require_loginticket = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LoginTicket = void 0;
	var LoginTicket = class {
		envelope;
		payload;
		/**
		* Create a simple class to extract user ID from an ID Token
		*
		* @param {string} env Envelope of the jwt
		* @param {TokenPayload} pay Payload of the jwt
		* @constructor
		*/
		constructor(env, pay) {
			this.envelope = env;
			this.payload = pay;
		}
		getEnvelope() {
			return this.envelope;
		}
		getPayload() {
			return this.payload;
		}
		/**
		* Create a simple class to extract user ID from an ID Token
		*
		* @return The user ID
		*/
		getUserId() {
			const payload = this.getPayload();
			if (payload && payload.sub) return payload.sub;
			return null;
		}
		/**
		* Returns attributes from the login ticket.  This can contain
		* various information about the user session.
		*
		* @return The envelope and payload
		*/
		getAttributes() {
			return {
				envelope: this.getEnvelope(),
				payload: this.getPayload()
			};
		}
	};
	exports.LoginTicket = LoginTicket;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/oauth2client.js
var require_oauth2client = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OAuth2Client = exports.ClientAuthentication = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;
	const gaxios_1$11 = require_src$4();
	const querystring = require("querystring");
	const stream$3 = require("stream");
	const formatEcdsa$1 = require_ecdsa_sig_formatter();
	const util_1$9 = require_util();
	const crypto_1$4 = require_crypto();
	const authclient_1$11 = require_authclient();
	const loginticket_1$1 = require_loginticket();
	var CodeChallengeMethod;
	(function(CodeChallengeMethod$1) {
		CodeChallengeMethod$1["Plain"] = "plain";
		CodeChallengeMethod$1["S256"] = "S256";
	})(CodeChallengeMethod || (exports.CodeChallengeMethod = CodeChallengeMethod = {}));
	var CertificateFormat;
	(function(CertificateFormat$1) {
		CertificateFormat$1["PEM"] = "PEM";
		CertificateFormat$1["JWK"] = "JWK";
	})(CertificateFormat || (exports.CertificateFormat = CertificateFormat = {}));
	/**
	* The client authentication type. Supported values are basic, post, and none.
	* https://datatracker.ietf.org/doc/html/rfc7591#section-2
	*/
	var ClientAuthentication;
	(function(ClientAuthentication$1) {
		ClientAuthentication$1["ClientSecretPost"] = "ClientSecretPost";
		ClientAuthentication$1["ClientSecretBasic"] = "ClientSecretBasic";
		ClientAuthentication$1["None"] = "None";
	})(ClientAuthentication || (exports.ClientAuthentication = ClientAuthentication = {}));
	var OAuth2Client = class OAuth2Client extends authclient_1$11.AuthClient {
		redirectUri;
		certificateCache = {};
		certificateExpiry = null;
		certificateCacheFormat = CertificateFormat.PEM;
		refreshTokenPromises = /* @__PURE__ */ new Map();
		endpoints;
		issuers;
		clientAuthentication;
		_clientId;
		_clientSecret;
		refreshHandler;
		/**
		* An OAuth2 Client for Google APIs.
		*
		* @param options The OAuth2 Client Options. Passing an `clientId` directly is **@DEPRECATED**.
		* @param clientSecret **@DEPRECATED**. Provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead.
		* @param redirectUri **@DEPRECATED**. Provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead.
		*/
		constructor(options = {}, clientSecret, redirectUri) {
			super(typeof options === "object" ? options : {});
			if (typeof options !== "object") options = {
				clientId: options,
				clientSecret,
				redirectUri
			};
			this._clientId = options.clientId || options.client_id;
			this._clientSecret = options.clientSecret || options.client_secret;
			this.redirectUri = options.redirectUri || options.redirect_uris?.[0];
			this.endpoints = {
				tokenInfoUrl: "https://oauth2.googleapis.com/tokeninfo",
				oauth2AuthBaseUrl: "https://accounts.google.com/o/oauth2/v2/auth",
				oauth2TokenUrl: "https://oauth2.googleapis.com/token",
				oauth2RevokeUrl: "https://oauth2.googleapis.com/revoke",
				oauth2FederatedSignonPemCertsUrl: "https://www.googleapis.com/oauth2/v1/certs",
				oauth2FederatedSignonJwkCertsUrl: "https://www.googleapis.com/oauth2/v3/certs",
				oauth2IapPublicKeyUrl: "https://www.gstatic.com/iap/verify/public_key",
				...options.endpoints
			};
			this.clientAuthentication = options.clientAuthentication || ClientAuthentication.ClientSecretPost;
			this.issuers = options.issuers || [
				"accounts.google.com",
				"https://accounts.google.com",
				this.universeDomain
			];
		}
		/**
		* @deprecated use instance's {@link OAuth2Client.endpoints}
		*/
		static GOOGLE_TOKEN_INFO_URL = "https://oauth2.googleapis.com/tokeninfo";
		/**
		* Clock skew - five minutes in seconds
		*/
		static CLOCK_SKEW_SECS_ = 300;
		/**
		* The default max Token Lifetime is one day in seconds
		*/
		static DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;
		/**
		* Generates URL for consent page landing.
		* @param opts Options.
		* @return URL to consent page.
		*/
		generateAuthUrl(opts = {}) {
			if (opts.code_challenge_method && !opts.code_challenge) throw new Error("If a code_challenge_method is provided, code_challenge must be included.");
			opts.response_type = opts.response_type || "code";
			opts.client_id = opts.client_id || this._clientId;
			opts.redirect_uri = opts.redirect_uri || this.redirectUri;
			if (Array.isArray(opts.scope)) opts.scope = opts.scope.join(" ");
			return this.endpoints.oauth2AuthBaseUrl.toString() + "?" + querystring.stringify(opts);
		}
		generateCodeVerifier() {
			throw new Error("generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.");
		}
		/**
		* Convenience method to automatically generate a code_verifier, and its
		* resulting SHA256. If used, this must be paired with a S256
		* code_challenge_method.
		*
		* For a full example see:
		* https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js
		*/
		async generateCodeVerifierAsync() {
			const crypto$7 = (0, crypto_1$4.createCrypto)();
			const codeVerifier = crypto$7.randomBytesBase64(96).replace(/\+/g, "~").replace(/=/g, "_").replace(/\//g, "-");
			return {
				codeVerifier,
				codeChallenge: (await crypto$7.sha256DigestBase64(codeVerifier)).split("=")[0].replace(/\+/g, "-").replace(/\//g, "_")
			};
		}
		getToken(codeOrOptions, callback) {
			const options = typeof codeOrOptions === "string" ? { code: codeOrOptions } : codeOrOptions;
			if (callback) this.getTokenAsync(options).then((r$1) => callback(null, r$1.tokens, r$1.res), (e$1) => callback(e$1, null, e$1.response));
			else return this.getTokenAsync(options);
		}
		async getTokenAsync(options) {
			const url = this.endpoints.oauth2TokenUrl.toString();
			const headers = new Headers();
			const values = {
				client_id: options.client_id || this._clientId,
				code_verifier: options.codeVerifier,
				code: options.code,
				grant_type: "authorization_code",
				redirect_uri: options.redirect_uri || this.redirectUri
			};
			if (this.clientAuthentication === ClientAuthentication.ClientSecretBasic) {
				const basic = Buffer.from(`${this._clientId}:${this._clientSecret}`);
				headers.set("authorization", `Basic ${basic.toString("base64")}`);
			}
			if (this.clientAuthentication === ClientAuthentication.ClientSecretPost) values.client_secret = this._clientSecret;
			const opts = {
				...OAuth2Client.RETRY_CONFIG,
				method: "POST",
				url,
				data: new URLSearchParams((0, util_1$9.removeUndefinedValuesInObject)(values)),
				headers
			};
			authclient_1$11.AuthClient.setMethodName(opts, "getTokenAsync");
			const res = await this.transporter.request(opts);
			const tokens = res.data;
			if (res.data && res.data.expires_in) {
				tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + res.data.expires_in * 1e3;
				delete tokens.expires_in;
			}
			this.emit("tokens", tokens);
			return {
				tokens,
				res
			};
		}
		/**
		* Refreshes the access token.
		* @param refresh_token Existing refresh token.
		* @private
		*/
		async refreshToken(refreshToken) {
			if (!refreshToken) return this.refreshTokenNoCache(refreshToken);
			if (this.refreshTokenPromises.has(refreshToken)) return this.refreshTokenPromises.get(refreshToken);
			const p = this.refreshTokenNoCache(refreshToken).then((r$1) => {
				this.refreshTokenPromises.delete(refreshToken);
				return r$1;
			}, (e$1) => {
				this.refreshTokenPromises.delete(refreshToken);
				throw e$1;
			});
			this.refreshTokenPromises.set(refreshToken, p);
			return p;
		}
		async refreshTokenNoCache(refreshToken) {
			if (!refreshToken) throw new Error("No refresh token is set.");
			const url = this.endpoints.oauth2TokenUrl.toString();
			const data = {
				refresh_token: refreshToken,
				client_id: this._clientId,
				client_secret: this._clientSecret,
				grant_type: "refresh_token"
			};
			let res;
			try {
				const opts = {
					...OAuth2Client.RETRY_CONFIG,
					method: "POST",
					url,
					data: new URLSearchParams((0, util_1$9.removeUndefinedValuesInObject)(data))
				};
				authclient_1$11.AuthClient.setMethodName(opts, "refreshTokenNoCache");
				res = await this.transporter.request(opts);
			} catch (e$1) {
				if (e$1 instanceof gaxios_1$11.GaxiosError && e$1.message === "invalid_grant" && e$1.response?.data && /ReAuth/i.test(e$1.response.data.error_description)) e$1.message = JSON.stringify(e$1.response.data);
				throw e$1;
			}
			const tokens = res.data;
			if (res.data && res.data.expires_in) {
				tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + res.data.expires_in * 1e3;
				delete tokens.expires_in;
			}
			this.emit("tokens", tokens);
			return {
				tokens,
				res
			};
		}
		refreshAccessToken(callback) {
			if (callback) this.refreshAccessTokenAsync().then((r$1) => callback(null, r$1.credentials, r$1.res), callback);
			else return this.refreshAccessTokenAsync();
		}
		async refreshAccessTokenAsync() {
			const r$1 = await this.refreshToken(this.credentials.refresh_token);
			const tokens = r$1.tokens;
			tokens.refresh_token = this.credentials.refresh_token;
			this.credentials = tokens;
			return {
				credentials: this.credentials,
				res: r$1.res
			};
		}
		getAccessToken(callback) {
			if (callback) this.getAccessTokenAsync().then((r$1) => callback(null, r$1.token, r$1.res), callback);
			else return this.getAccessTokenAsync();
		}
		async getAccessTokenAsync() {
			if (!this.credentials.access_token || this.isTokenExpiring()) {
				if (!this.credentials.refresh_token) if (this.refreshHandler) {
					const refreshedAccessToken = await this.processAndValidateRefreshHandler();
					if (refreshedAccessToken?.access_token) {
						this.setCredentials(refreshedAccessToken);
						return { token: this.credentials.access_token };
					}
				} else throw new Error("No refresh token or refresh handler callback is set.");
				const r$1 = await this.refreshAccessTokenAsync();
				if (!r$1.credentials || r$1.credentials && !r$1.credentials.access_token) throw new Error("Could not refresh access token.");
				return {
					token: r$1.credentials.access_token,
					res: r$1.res
				};
			} else return { token: this.credentials.access_token };
		}
		/**
		* The main authentication interface.  It takes an optional url which when
		* present is the endpoint being accessed, and returns a Promise which
		* resolves with authorization header fields.
		*
		* In OAuth2Client, the result has the form:
		* { authorization: 'Bearer <access_token_value>' }
		*/
		async getRequestHeaders(url) {
			return (await this.getRequestMetadataAsync(url)).headers;
		}
		async getRequestMetadataAsync(url) {
			const thisCreds = this.credentials;
			if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) throw new Error("No access, refresh token, API key or refresh handler callback is set.");
			if (thisCreds.access_token && !this.isTokenExpiring()) {
				thisCreds.token_type = thisCreds.token_type || "Bearer";
				const headers$1 = new Headers({ authorization: thisCreds.token_type + " " + thisCreds.access_token });
				return { headers: this.addSharedMetadataHeaders(headers$1) };
			}
			if (this.refreshHandler) {
				const refreshedAccessToken = await this.processAndValidateRefreshHandler();
				if (refreshedAccessToken?.access_token) {
					this.setCredentials(refreshedAccessToken);
					const headers$1 = new Headers({ authorization: "Bearer " + this.credentials.access_token });
					return { headers: this.addSharedMetadataHeaders(headers$1) };
				}
			}
			if (this.apiKey) return { headers: new Headers({ "X-Goog-Api-Key": this.apiKey }) };
			let r$1 = null;
			let tokens = null;
			try {
				r$1 = await this.refreshToken(thisCreds.refresh_token);
				tokens = r$1.tokens;
			} catch (err) {
				const e$1 = err;
				if (e$1.response && (e$1.response.status === 403 || e$1.response.status === 404)) e$1.message = `Could not refresh access token: ${e$1.message}`;
				throw e$1;
			}
			const credentials = this.credentials;
			credentials.token_type = credentials.token_type || "Bearer";
			tokens.refresh_token = credentials.refresh_token;
			this.credentials = tokens;
			const headers = new Headers({ authorization: credentials.token_type + " " + tokens.access_token });
			return {
				headers: this.addSharedMetadataHeaders(headers),
				res: r$1.res
			};
		}
		/**
		* Generates an URL to revoke the given token.
		* @param token The existing token to be revoked.
		*
		* @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}
		*/
		static getRevokeTokenUrl(token) {
			return new OAuth2Client().getRevokeTokenURL(token).toString();
		}
		/**
		* Generates a URL to revoke the given token.
		*
		* @param token The existing token to be revoked.
		*/
		getRevokeTokenURL(token) {
			const url = new URL(this.endpoints.oauth2RevokeUrl);
			url.searchParams.append("token", token);
			return url;
		}
		revokeToken(token, callback) {
			const opts = {
				...OAuth2Client.RETRY_CONFIG,
				url: this.getRevokeTokenURL(token).toString(),
				method: "POST"
			};
			authclient_1$11.AuthClient.setMethodName(opts, "revokeToken");
			if (callback) this.transporter.request(opts).then((r$1) => callback(null, r$1), callback);
			else return this.transporter.request(opts);
		}
		revokeCredentials(callback) {
			if (callback) this.revokeCredentialsAsync().then((res) => callback(null, res), callback);
			else return this.revokeCredentialsAsync();
		}
		async revokeCredentialsAsync() {
			const token = this.credentials.access_token;
			this.credentials = {};
			if (token) return this.revokeToken(token);
			else throw new Error("No access token to revoke.");
		}
		request(opts, callback) {
			if (callback) this.requestAsync(opts).then((r$1) => callback(null, r$1), (e$1) => {
				return callback(e$1, e$1.response);
			});
			else return this.requestAsync(opts);
		}
		async requestAsync(opts, reAuthRetried = false) {
			try {
				const r$1 = await this.getRequestMetadataAsync();
				opts.headers = gaxios_1$11.Gaxios.mergeHeaders(opts.headers);
				this.addUserProjectAndAuthHeaders(opts.headers, r$1.headers);
				if (this.apiKey) opts.headers.set("X-Goog-Api-Key", this.apiKey);
				return await this.transporter.request(opts);
			} catch (e$1) {
				const res = e$1.response;
				if (res) {
					const statusCode = res.status;
					const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);
					const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;
					const isReadableStream = res.config.data instanceof stream$3.Readable;
					const isAuthErr = statusCode === 401 || statusCode === 403;
					if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefresh) {
						await this.refreshAccessTokenAsync();
						return this.requestAsync(opts, true);
					} else if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {
						const refreshedAccessToken = await this.processAndValidateRefreshHandler();
						if (refreshedAccessToken?.access_token) this.setCredentials(refreshedAccessToken);
						return this.requestAsync(opts, true);
					}
				}
				throw e$1;
			}
		}
		verifyIdToken(options, callback) {
			if (callback && typeof callback !== "function") throw new Error("This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.");
			if (callback) this.verifyIdTokenAsync(options).then((r$1) => callback(null, r$1), callback);
			else return this.verifyIdTokenAsync(options);
		}
		async verifyIdTokenAsync(options) {
			if (!options.idToken) throw new Error("The verifyIdToken method requires an ID Token");
			const response = await this.getFederatedSignonCertsAsync();
			return await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);
		}
		/**
		* Obtains information about the provisioned access token.  Especially useful
		* if you want to check the scopes that were provisioned to a given token.
		*
		* @param accessToken Required.  The Access Token for which you want to get
		* user info.
		*/
		async getTokenInfo(accessToken) {
			const { data } = await this.transporter.request({
				...OAuth2Client.RETRY_CONFIG,
				method: "POST",
				headers: {
					"content-type": "application/x-www-form-urlencoded;charset=UTF-8",
					authorization: `Bearer ${accessToken}`
				},
				url: this.endpoints.tokenInfoUrl.toString()
			});
			const info$1 = Object.assign({
				expiry_date: (/* @__PURE__ */ new Date()).getTime() + data.expires_in * 1e3,
				scopes: data.scope.split(" ")
			}, data);
			delete info$1.expires_in;
			delete info$1.scope;
			return info$1;
		}
		getFederatedSignonCerts(callback) {
			if (callback) this.getFederatedSignonCertsAsync().then((r$1) => callback(null, r$1.certs, r$1.res), callback);
			else return this.getFederatedSignonCertsAsync();
		}
		async getFederatedSignonCertsAsync() {
			const nowTime = (/* @__PURE__ */ new Date()).getTime();
			const format$2 = (0, crypto_1$4.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;
			if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format$2) return {
				certs: this.certificateCache,
				format: format$2
			};
			let res;
			let url;
			switch (format$2) {
				case CertificateFormat.PEM:
					url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();
					break;
				case CertificateFormat.JWK:
					url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();
					break;
				default: throw new Error(`Unsupported certificate format ${format$2}`);
			}
			try {
				const opts = {
					...OAuth2Client.RETRY_CONFIG,
					url
				};
				authclient_1$11.AuthClient.setMethodName(opts, "getFederatedSignonCertsAsync");
				res = await this.transporter.request(opts);
			} catch (e$1) {
				if (e$1 instanceof Error) e$1.message = `Failed to retrieve verification certificates: ${e$1.message}`;
				throw e$1;
			}
			const cacheControl = res?.headers.get("cache-control");
			let cacheAge = -1;
			if (cacheControl) {
				const maxAge = /max-age=(?<maxAge>[0-9]+)/.exec(cacheControl)?.groups?.maxAge;
				if (maxAge) cacheAge = Number(maxAge) * 1e3;
			}
			let certificates = {};
			switch (format$2) {
				case CertificateFormat.PEM:
					certificates = res.data;
					break;
				case CertificateFormat.JWK:
					for (const key of res.data.keys) certificates[key.kid] = key;
					break;
				default: throw new Error(`Unsupported certificate format ${format$2}`);
			}
			const now = /* @__PURE__ */ new Date();
			this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
			this.certificateCache = certificates;
			this.certificateCacheFormat = format$2;
			return {
				certs: certificates,
				format: format$2,
				res
			};
		}
		getIapPublicKeys(callback) {
			if (callback) this.getIapPublicKeysAsync().then((r$1) => callback(null, r$1.pubkeys, r$1.res), callback);
			else return this.getIapPublicKeysAsync();
		}
		async getIapPublicKeysAsync() {
			let res;
			const url = this.endpoints.oauth2IapPublicKeyUrl.toString();
			try {
				const opts = {
					...OAuth2Client.RETRY_CONFIG,
					url
				};
				authclient_1$11.AuthClient.setMethodName(opts, "getIapPublicKeysAsync");
				res = await this.transporter.request(opts);
			} catch (e$1) {
				if (e$1 instanceof Error) e$1.message = `Failed to retrieve verification certificates: ${e$1.message}`;
				throw e$1;
			}
			return {
				pubkeys: res.data,
				res
			};
		}
		verifySignedJwtWithCerts() {
			throw new Error("verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.");
		}
		/**
		* Verify the id token is signed with the correct certificate
		* and is from the correct audience.
		* @param jwt The jwt to verify (The ID Token in this case).
		* @param certs The array of certs to test the jwt against.
		* @param requiredAudience The audience to test the jwt against.
		* @param issuers The allowed issuers of the jwt (Optional).
		* @param maxExpiry The max expiry the certificate can be (Optional).
		* @return Returns a promise resolving to LoginTicket on verification.
		*/
		async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {
			const crypto$7 = (0, crypto_1$4.createCrypto)();
			if (!maxExpiry) maxExpiry = OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;
			const segments = jwt.split(".");
			if (segments.length !== 3) throw new Error("Wrong number of segments in token: " + jwt);
			const signed = segments[0] + "." + segments[1];
			let signature = segments[2];
			let envelope;
			let payload;
			try {
				envelope = JSON.parse(crypto$7.decodeBase64StringUtf8(segments[0]));
			} catch (err) {
				if (err instanceof Error) err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;
				throw err;
			}
			if (!envelope) throw new Error("Can't parse token envelope: " + segments[0]);
			try {
				payload = JSON.parse(crypto$7.decodeBase64StringUtf8(segments[1]));
			} catch (err) {
				if (err instanceof Error) err.message = `Can't parse token payload '${segments[0]}`;
				throw err;
			}
			if (!payload) throw new Error("Can't parse token payload: " + segments[1]);
			if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) throw new Error("No pem found for envelope: " + JSON.stringify(envelope));
			const cert = certs[envelope.kid];
			if (envelope.alg === "ES256") signature = formatEcdsa$1.joseToDer(signature, "ES256").toString("base64");
			if (!await crypto$7.verify(cert, signed, signature)) throw new Error("Invalid token signature: " + jwt);
			if (!payload.iat) throw new Error("No issue time in token: " + JSON.stringify(payload));
			if (!payload.exp) throw new Error("No expiration time in token: " + JSON.stringify(payload));
			const iat = Number(payload.iat);
			if (isNaN(iat)) throw new Error("iat field using invalid format");
			const exp = Number(payload.exp);
			if (isNaN(exp)) throw new Error("exp field using invalid format");
			const now = (/* @__PURE__ */ new Date()).getTime() / 1e3;
			if (exp >= now + maxExpiry) throw new Error("Expiration time too far in future: " + JSON.stringify(payload));
			const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;
			const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;
			if (now < earliest) throw new Error("Token used too early, " + now + " < " + earliest + ": " + JSON.stringify(payload));
			if (now > latest) throw new Error("Token used too late, " + now + " > " + latest + ": " + JSON.stringify(payload));
			if (issuers && issuers.indexOf(payload.iss) < 0) throw new Error("Invalid issuer, expected one of [" + issuers + "], but got " + payload.iss);
			if (typeof requiredAudience !== "undefined" && requiredAudience !== null) {
				const aud = payload.aud;
				let audVerified = false;
				if (requiredAudience.constructor === Array) audVerified = requiredAudience.indexOf(aud) > -1;
				else audVerified = aud === requiredAudience;
				if (!audVerified) throw new Error("Wrong recipient, payload audience != requiredAudience");
			}
			return new loginticket_1$1.LoginTicket(envelope, payload);
		}
		/**
		* Returns a promise that resolves with AccessTokenResponse type if
		* refreshHandler is defined.
		* If not, nothing is returned.
		*/
		async processAndValidateRefreshHandler() {
			if (this.refreshHandler) {
				const accessTokenResponse = await this.refreshHandler();
				if (!accessTokenResponse.access_token) throw new Error("No access token is returned by the refreshHandler callback.");
				return accessTokenResponse;
			}
		}
		/**
		* Returns true if a token is expired or will expire within
		* eagerRefreshThresholdMillismilliseconds.
		* If there is no expiry time, assumes the token is not expired or expiring.
		*/
		isTokenExpiring() {
			const expiryDate = this.credentials.expiry_date;
			return expiryDate ? expiryDate <= (/* @__PURE__ */ new Date()).getTime() + this.eagerRefreshThresholdMillis : false;
		}
	};
	exports.OAuth2Client = OAuth2Client;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/computeclient.js
var require_computeclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Compute = void 0;
	const gaxios_1$10 = require_src$4();
	const gcpMetadata$2 = require_src$2();
	const oauth2client_1$5 = require_oauth2client();
	var Compute = class extends oauth2client_1$5.OAuth2Client {
		serviceAccountEmail;
		scopes;
		/**
		* Google Compute Engine service account credentials.
		*
		* Retrieve access token from the metadata server.
		* See: https://cloud.google.com/compute/docs/access/authenticate-workloads#applications
		*/
		constructor(options = {}) {
			super(options);
			this.credentials = {
				expiry_date: 1,
				refresh_token: "compute-placeholder"
			};
			this.serviceAccountEmail = options.serviceAccountEmail || "default";
			this.scopes = Array.isArray(options.scopes) ? options.scopes : options.scopes ? [options.scopes] : [];
		}
		/**
		* Refreshes the access token.
		* @param refreshToken Unused parameter
		*/
		async refreshTokenNoCache() {
			const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;
			let data;
			try {
				const instanceOptions = { property: tokenPath };
				if (this.scopes.length > 0) instanceOptions.params = { scopes: this.scopes.join(",") };
				data = await gcpMetadata$2.instance(instanceOptions);
			} catch (e$1) {
				if (e$1 instanceof gaxios_1$10.GaxiosError) {
					e$1.message = `Could not refresh access token: ${e$1.message}`;
					this.wrapError(e$1);
				}
				throw e$1;
			}
			const tokens = data;
			if (data && data.expires_in) {
				tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + data.expires_in * 1e3;
				delete tokens.expires_in;
			}
			this.emit("tokens", tokens);
			return {
				tokens,
				res: null
			};
		}
		/**
		* Fetches an ID token.
		* @param targetAudience the audience for the fetched ID token.
		*/
		async fetchIdToken(targetAudience) {
			const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity?format=full&audience=${targetAudience}`;
			let idToken;
			try {
				const instanceOptions = { property: idTokenPath };
				idToken = await gcpMetadata$2.instance(instanceOptions);
			} catch (e$1) {
				if (e$1 instanceof Error) e$1.message = `Could not fetch ID token: ${e$1.message}`;
				throw e$1;
			}
			return idToken;
		}
		wrapError(e$1) {
			const res = e$1.response;
			if (res && res.status) {
				e$1.status = res.status;
				if (res.status === 403) e$1.message = "A Forbidden error was returned while attempting to retrieve an access token for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have the correct permission scopes specified: " + e$1.message;
				else if (res.status === 404) e$1.message = "A Not Found error was returned while attempting to retrieve an accesstoken for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have any permission scopes specified: " + e$1.message;
			}
		}
	};
	exports.Compute = Compute;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/idtokenclient.js
var require_idtokenclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IdTokenClient = void 0;
	const oauth2client_1$4 = require_oauth2client();
	var IdTokenClient = class extends oauth2client_1$4.OAuth2Client {
		targetAudience;
		idTokenProvider;
		/**
		* Google ID Token client
		*
		* Retrieve ID token from the metadata server.
		* See: https://cloud.google.com/docs/authentication/get-id-token#metadata-server
		*/
		constructor(options) {
			super(options);
			this.targetAudience = options.targetAudience;
			this.idTokenProvider = options.idTokenProvider;
		}
		async getRequestMetadataAsync() {
			if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {
				const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);
				this.credentials = {
					id_token: idToken,
					expiry_date: this.getIdTokenExpiryDate(idToken)
				};
			}
			return { headers: new Headers({ authorization: "Bearer " + this.credentials.id_token }) };
		}
		getIdTokenExpiryDate(idToken) {
			const payloadB64 = idToken.split(".")[1];
			if (payloadB64) return JSON.parse(Buffer.from(payloadB64, "base64").toString("ascii")).exp * 1e3;
		}
	};
	exports.IdTokenClient = IdTokenClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/envDetect.js
var require_envDetect = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GCPEnv = void 0;
	exports.clear = clear;
	exports.getEnv = getEnv$1;
	const gcpMetadata$1 = require_src$2();
	var GCPEnv;
	(function(GCPEnv$1) {
		GCPEnv$1["APP_ENGINE"] = "APP_ENGINE";
		GCPEnv$1["KUBERNETES_ENGINE"] = "KUBERNETES_ENGINE";
		GCPEnv$1["CLOUD_FUNCTIONS"] = "CLOUD_FUNCTIONS";
		GCPEnv$1["COMPUTE_ENGINE"] = "COMPUTE_ENGINE";
		GCPEnv$1["CLOUD_RUN"] = "CLOUD_RUN";
		GCPEnv$1["CLOUD_RUN_JOBS"] = "CLOUD_RUN_JOBS";
		GCPEnv$1["NONE"] = "NONE";
	})(GCPEnv || (exports.GCPEnv = GCPEnv = {}));
	let envPromise;
	function clear() {
		envPromise = void 0;
	}
	async function getEnv$1() {
		if (envPromise) return envPromise;
		envPromise = getEnvMemoized();
		return envPromise;
	}
	async function getEnvMemoized() {
		let env = GCPEnv.NONE;
		if (isAppEngine()) env = GCPEnv.APP_ENGINE;
		else if (isCloudFunction()) env = GCPEnv.CLOUD_FUNCTIONS;
		else if (await isComputeEngine()) if (await isKubernetesEngine()) env = GCPEnv.KUBERNETES_ENGINE;
		else if (isCloudRun()) env = GCPEnv.CLOUD_RUN;
		else if (isCloudRunJob()) env = GCPEnv.CLOUD_RUN_JOBS;
		else env = GCPEnv.COMPUTE_ENGINE;
		else env = GCPEnv.NONE;
		return env;
	}
	function isAppEngine() {
		return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
	}
	function isCloudFunction() {
		return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);
	}
	/**
	* This check only verifies that the environment is running knative.
	* This must be run *after* checking for Kubernetes, otherwise it will
	* return a false positive.
	*/
	function isCloudRun() {
		return !!process.env.K_CONFIGURATION;
	}
	function isCloudRunJob() {
		return !!process.env.CLOUD_RUN_JOB;
	}
	async function isKubernetesEngine() {
		try {
			await gcpMetadata$1.instance("attributes/cluster-name");
			return true;
		} catch (e$1) {
			return false;
		}
	}
	async function isComputeEngine() {
		return gcpMetadata$1.isAvailable();
	}
}));

//#endregion
//#region node_modules/jws/lib/data-stream.js
var require_data_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$6 = require_safe_buffer().Buffer;
	var Stream$2 = require("stream");
	var util$3 = require("util");
	function DataStream$2(data) {
		this.buffer = null;
		this.writable = true;
		this.readable = true;
		if (!data) {
			this.buffer = Buffer$6.alloc(0);
			return this;
		}
		if (typeof data.pipe === "function") {
			this.buffer = Buffer$6.alloc(0);
			data.pipe(this);
			return this;
		}
		if (data.length || typeof data === "object") {
			this.buffer = data;
			this.writable = false;
			process.nextTick(function() {
				this.emit("end", data);
				this.readable = false;
				this.emit("close");
			}.bind(this));
			return this;
		}
		throw new TypeError("Unexpected data type (" + typeof data + ")");
	}
	util$3.inherits(DataStream$2, Stream$2);
	DataStream$2.prototype.write = function write$1(data) {
		this.buffer = Buffer$6.concat([this.buffer, Buffer$6.from(data)]);
		this.emit("data", data);
	};
	DataStream$2.prototype.end = function end(data) {
		if (data) this.write(data);
		this.emit("end", data);
		this.emit("close");
		this.writable = false;
		this.readable = false;
	};
	module.exports = DataStream$2;
}));

//#endregion
//#region node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$5 = require("buffer").Buffer;
	var SlowBuffer = require("buffer").SlowBuffer;
	module.exports = bufferEq;
	function bufferEq(a, b) {
		if (!Buffer$5.isBuffer(a) || !Buffer$5.isBuffer(b)) return false;
		if (a.length !== b.length) return false;
		var c = 0;
		for (var i$2 = 0; i$2 < a.length; i$2++) c |= a[i$2] ^ b[i$2];
		return c === 0;
	}
	bufferEq.install = function() {
		Buffer$5.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
			return bufferEq(this, that);
		};
	};
	var origBufEqual = Buffer$5.prototype.equal;
	var origSlowBufEqual = SlowBuffer.prototype.equal;
	bufferEq.restore = function() {
		Buffer$5.prototype.equal = origBufEqual;
		SlowBuffer.prototype.equal = origSlowBufEqual;
	};
}));

//#endregion
//#region node_modules/jwa/index.js
var require_jwa = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$4 = require_safe_buffer().Buffer;
	var crypto$1 = require("crypto");
	var formatEcdsa = require_ecdsa_sig_formatter();
	var util$2 = require("util");
	var MSG_INVALID_ALGORITHM = "\"%s\" is not a valid algorithm.\n  Supported algorithms are:\n  \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\", \"ES384\", \"ES512\" and \"none\".";
	var MSG_INVALID_SECRET = "secret must be a string or buffer";
	var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
	var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
	var supportsKeyObjects = typeof crypto$1.createPublicKey === "function";
	if (supportsKeyObjects) {
		MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
		MSG_INVALID_SECRET += "or a KeyObject";
	}
	function checkIsPublicKey(key) {
		if (Buffer$4.isBuffer(key)) return;
		if (typeof key === "string") return;
		if (!supportsKeyObjects) throw typeError(MSG_INVALID_VERIFIER_KEY);
		if (typeof key !== "object") throw typeError(MSG_INVALID_VERIFIER_KEY);
		if (typeof key.type !== "string") throw typeError(MSG_INVALID_VERIFIER_KEY);
		if (typeof key.asymmetricKeyType !== "string") throw typeError(MSG_INVALID_VERIFIER_KEY);
		if (typeof key.export !== "function") throw typeError(MSG_INVALID_VERIFIER_KEY);
	}
	function checkIsPrivateKey(key) {
		if (Buffer$4.isBuffer(key)) return;
		if (typeof key === "string") return;
		if (typeof key === "object") return;
		throw typeError(MSG_INVALID_SIGNER_KEY);
	}
	function checkIsSecretKey(key) {
		if (Buffer$4.isBuffer(key)) return;
		if (typeof key === "string") return key;
		if (!supportsKeyObjects) throw typeError(MSG_INVALID_SECRET);
		if (typeof key !== "object") throw typeError(MSG_INVALID_SECRET);
		if (key.type !== "secret") throw typeError(MSG_INVALID_SECRET);
		if (typeof key.export !== "function") throw typeError(MSG_INVALID_SECRET);
	}
	function fromBase64(base64) {
		return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function toBase64(base64url$1) {
		base64url$1 = base64url$1.toString();
		var padding = 4 - base64url$1.length % 4;
		if (padding !== 4) for (var i$2 = 0; i$2 < padding; ++i$2) base64url$1 += "=";
		return base64url$1.replace(/\-/g, "+").replace(/_/g, "/");
	}
	function typeError(template) {
		var args = [].slice.call(arguments, 1);
		var errMsg = util$2.format.bind(util$2, template).apply(null, args);
		return new TypeError(errMsg);
	}
	function bufferOrString(obj) {
		return Buffer$4.isBuffer(obj) || typeof obj === "string";
	}
	function normalizeInput(thing) {
		if (!bufferOrString(thing)) thing = JSON.stringify(thing);
		return thing;
	}
	function createHmacSigner(bits) {
		return function sign$1(thing, secret) {
			checkIsSecretKey(secret);
			thing = normalizeInput(thing);
			var hmac = crypto$1.createHmac("sha" + bits, secret);
			return fromBase64((hmac.update(thing), hmac.digest("base64")));
		};
	}
	var bufferEqual;
	var timingSafeEqual = "timingSafeEqual" in crypto$1 ? function timingSafeEqual$1(a, b) {
		if (a.byteLength !== b.byteLength) return false;
		return crypto$1.timingSafeEqual(a, b);
	} : function timingSafeEqual$1(a, b) {
		if (!bufferEqual) bufferEqual = require_buffer_equal_constant_time();
		return bufferEqual(a, b);
	};
	function createHmacVerifier(bits) {
		return function verify(thing, signature, secret) {
			var computedSig = createHmacSigner(bits)(thing, secret);
			return timingSafeEqual(Buffer$4.from(signature), Buffer$4.from(computedSig));
		};
	}
	function createKeySigner(bits) {
		return function sign$1(thing, privateKey) {
			checkIsPrivateKey(privateKey);
			thing = normalizeInput(thing);
			var signer = crypto$1.createSign("RSA-SHA" + bits);
			return fromBase64((signer.update(thing), signer.sign(privateKey, "base64")));
		};
	}
	function createKeyVerifier(bits) {
		return function verify(thing, signature, publicKey) {
			checkIsPublicKey(publicKey);
			thing = normalizeInput(thing);
			signature = toBase64(signature);
			var verifier = crypto$1.createVerify("RSA-SHA" + bits);
			verifier.update(thing);
			return verifier.verify(publicKey, signature, "base64");
		};
	}
	function createPSSKeySigner(bits) {
		return function sign$1(thing, privateKey) {
			checkIsPrivateKey(privateKey);
			thing = normalizeInput(thing);
			var signer = crypto$1.createSign("RSA-SHA" + bits);
			return fromBase64((signer.update(thing), signer.sign({
				key: privateKey,
				padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
				saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
			}, "base64")));
		};
	}
	function createPSSKeyVerifier(bits) {
		return function verify(thing, signature, publicKey) {
			checkIsPublicKey(publicKey);
			thing = normalizeInput(thing);
			signature = toBase64(signature);
			var verifier = crypto$1.createVerify("RSA-SHA" + bits);
			verifier.update(thing);
			return verifier.verify({
				key: publicKey,
				padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
				saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
			}, signature, "base64");
		};
	}
	function createECDSASigner(bits) {
		var inner = createKeySigner(bits);
		return function sign$1() {
			var signature = inner.apply(null, arguments);
			signature = formatEcdsa.derToJose(signature, "ES" + bits);
			return signature;
		};
	}
	function createECDSAVerifer(bits) {
		var inner = createKeyVerifier(bits);
		return function verify(thing, signature, publicKey) {
			signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
			return inner(thing, signature, publicKey);
		};
	}
	function createNoneSigner() {
		return function sign$1() {
			return "";
		};
	}
	function createNoneVerifier() {
		return function verify(thing, signature) {
			return signature === "";
		};
	}
	module.exports = function jwa$2(algorithm) {
		var signerFactories = {
			hs: createHmacSigner,
			rs: createKeySigner,
			ps: createPSSKeySigner,
			es: createECDSASigner,
			none: createNoneSigner
		};
		var verifierFactories = {
			hs: createHmacVerifier,
			rs: createKeyVerifier,
			ps: createPSSKeyVerifier,
			es: createECDSAVerifer,
			none: createNoneVerifier
		};
		var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
		if (!match) throw typeError(MSG_INVALID_ALGORITHM, algorithm);
		var algo = (match[1] || match[3]).toLowerCase();
		var bits = match[2];
		return {
			sign: signerFactories[algo](bits),
			verify: verifierFactories[algo](bits)
		};
	};
}));

//#endregion
//#region node_modules/jws/lib/tostring.js
var require_tostring = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$3 = require("buffer").Buffer;
	module.exports = function toString$2(obj) {
		if (typeof obj === "string") return obj;
		if (typeof obj === "number" || Buffer$3.isBuffer(obj)) return obj.toString();
		return JSON.stringify(obj);
	};
}));

//#endregion
//#region node_modules/jws/lib/sign-stream.js
var require_sign_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$2 = require_safe_buffer().Buffer;
	var DataStream$1 = require_data_stream();
	var jwa$1 = require_jwa();
	var Stream$1 = require("stream");
	var toString$1 = require_tostring();
	var util$1 = require("util");
	function base64url(string, encoding) {
		return Buffer$2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function jwsSecuredInput(header, payload, encoding) {
		encoding = encoding || "utf8";
		var encodedHeader = base64url(toString$1(header), "binary");
		var encodedPayload = base64url(toString$1(payload), encoding);
		return util$1.format("%s.%s", encodedHeader, encodedPayload);
	}
	function jwsSign(opts) {
		var header = opts.header;
		var payload = opts.payload;
		var secretOrKey = opts.secret || opts.privateKey;
		var encoding = opts.encoding;
		var algo = jwa$1(header.alg);
		var securedInput = jwsSecuredInput(header, payload, encoding);
		var signature = algo.sign(securedInput, secretOrKey);
		return util$1.format("%s.%s", securedInput, signature);
	}
	function SignStream$1(opts) {
		var secretStream = new DataStream$1(opts.secret || opts.privateKey || opts.key);
		this.readable = true;
		this.header = opts.header;
		this.encoding = opts.encoding;
		this.secret = this.privateKey = this.key = secretStream;
		this.payload = new DataStream$1(opts.payload);
		this.secret.once("close", function() {
			if (!this.payload.writable && this.readable) this.sign();
		}.bind(this));
		this.payload.once("close", function() {
			if (!this.secret.writable && this.readable) this.sign();
		}.bind(this));
	}
	util$1.inherits(SignStream$1, Stream$1);
	SignStream$1.prototype.sign = function sign$1() {
		try {
			var signature = jwsSign({
				header: this.header,
				payload: this.payload.buffer,
				secret: this.secret.buffer,
				encoding: this.encoding
			});
			this.emit("done", signature);
			this.emit("data", signature);
			this.emit("end");
			this.readable = false;
			return signature;
		} catch (e$1) {
			this.readable = false;
			this.emit("error", e$1);
			this.emit("close");
		}
	};
	SignStream$1.sign = jwsSign;
	module.exports = SignStream$1;
}));

//#endregion
//#region node_modules/jws/lib/verify-stream.js
var require_verify_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$1 = require_safe_buffer().Buffer;
	var DataStream = require_data_stream();
	var jwa = require_jwa();
	var Stream = require("stream");
	var toString = require_tostring();
	var util = require("util");
	var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
	function isObject(thing) {
		return Object.prototype.toString.call(thing) === "[object Object]";
	}
	function safeJsonParse(thing) {
		if (isObject(thing)) return thing;
		try {
			return JSON.parse(thing);
		} catch (e$1) {
			return;
		}
	}
	function headerFromJWS(jwsSig) {
		var encodedHeader = jwsSig.split(".", 1)[0];
		return safeJsonParse(Buffer$1.from(encodedHeader, "base64").toString("binary"));
	}
	function securedInputFromJWS(jwsSig) {
		return jwsSig.split(".", 2).join(".");
	}
	function signatureFromJWS(jwsSig) {
		return jwsSig.split(".")[2];
	}
	function payloadFromJWS(jwsSig, encoding) {
		encoding = encoding || "utf8";
		var payload = jwsSig.split(".")[1];
		return Buffer$1.from(payload, "base64").toString(encoding);
	}
	function isValidJws(string) {
		return JWS_REGEX.test(string) && !!headerFromJWS(string);
	}
	function jwsVerify(jwsSig, algorithm, secretOrKey) {
		if (!algorithm) {
			var err = /* @__PURE__ */ new Error("Missing algorithm parameter for jws.verify");
			err.code = "MISSING_ALGORITHM";
			throw err;
		}
		jwsSig = toString(jwsSig);
		var signature = signatureFromJWS(jwsSig);
		var securedInput = securedInputFromJWS(jwsSig);
		return jwa(algorithm).verify(securedInput, signature, secretOrKey);
	}
	function jwsDecode(jwsSig, opts) {
		opts = opts || {};
		jwsSig = toString(jwsSig);
		if (!isValidJws(jwsSig)) return null;
		var header = headerFromJWS(jwsSig);
		if (!header) return null;
		var payload = payloadFromJWS(jwsSig);
		if (header.typ === "JWT" || opts.json) payload = JSON.parse(payload, opts.encoding);
		return {
			header,
			payload,
			signature: signatureFromJWS(jwsSig)
		};
	}
	function VerifyStream$1(opts) {
		opts = opts || {};
		var secretStream = new DataStream(opts.secret || opts.publicKey || opts.key);
		this.readable = true;
		this.algorithm = opts.algorithm;
		this.encoding = opts.encoding;
		this.secret = this.publicKey = this.key = secretStream;
		this.signature = new DataStream(opts.signature);
		this.secret.once("close", function() {
			if (!this.signature.writable && this.readable) this.verify();
		}.bind(this));
		this.signature.once("close", function() {
			if (!this.secret.writable && this.readable) this.verify();
		}.bind(this));
	}
	util.inherits(VerifyStream$1, Stream);
	VerifyStream$1.prototype.verify = function verify() {
		try {
			var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
			var obj = jwsDecode(this.signature.buffer, this.encoding);
			this.emit("done", valid, obj);
			this.emit("data", valid);
			this.emit("end");
			this.readable = false;
			return valid;
		} catch (e$1) {
			this.readable = false;
			this.emit("error", e$1);
			this.emit("close");
		}
	};
	VerifyStream$1.decode = jwsDecode;
	VerifyStream$1.isValid = isValidJws;
	VerifyStream$1.verify = jwsVerify;
	module.exports = VerifyStream$1;
}));

//#endregion
//#region node_modules/jws/index.js
var require_jws = /* @__PURE__ */ __commonJSMin(((exports) => {
	var SignStream = require_sign_stream();
	var VerifyStream = require_verify_stream();
	var ALGORITHMS = [
		"HS256",
		"HS384",
		"HS512",
		"RS256",
		"RS384",
		"RS512",
		"PS256",
		"PS384",
		"PS512",
		"ES256",
		"ES384",
		"ES512"
	];
	exports.ALGORITHMS = ALGORITHMS;
	exports.sign = SignStream.sign;
	exports.verify = VerifyStream.verify;
	exports.decode = VerifyStream.decode;
	exports.isValid = VerifyStream.isValid;
	exports.createSign = function createSign(opts) {
		return new SignStream(opts);
	};
	exports.createVerify = function createVerify(opts) {
		return new VerifyStream(opts);
	};
}));

//#endregion
//#region node_modules/gtoken/build/cjs/src/index.cjs
var require_src$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GoogleToken = void 0;
	var fs$5 = _interopRequireWildcard(require("fs"));
	var _gaxios = require_src$4();
	var jws$1 = _interopRequireWildcard(require_jws());
	var path$2 = _interopRequireWildcard(require("path"));
	var _util = require("util");
	function _interopRequireWildcard(e$1, t$1) {
		if ("function" == typeof WeakMap) var r$1 = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
		return (_interopRequireWildcard = function _interopRequireWildcard$1(e$2, t$2) {
			if (!t$2 && e$2 && e$2.__esModule) return e$2;
			var o, i$2, f$2 = {
				__proto__: null,
				"default": e$2
			};
			if (null === e$2 || "object" != _typeof(e$2) && "function" != typeof e$2) return f$2;
			if (o = t$2 ? n : r$1) {
				if (o.has(e$2)) return o.get(e$2);
				o.set(e$2, f$2);
			}
			for (var _t3 in e$2) "default" !== _t3 && {}.hasOwnProperty.call(e$2, _t3) && ((i$2 = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e$2, _t3)) && (i$2.get || i$2.set) ? o(f$2, _t3, i$2) : f$2[_t3] = e$2[_t3]);
			return f$2;
		})(e$1, t$1);
	}
	function _typeof(o) {
		"@babel/helpers - typeof";
		return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
			return typeof o$1;
		} : function(o$1) {
			return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
		}, _typeof(o);
	}
	function _classPrivateMethodInitSpec(e$1, a) {
		_checkPrivateRedeclaration(e$1, a), a.add(e$1);
	}
	function _classPrivateFieldInitSpec(e$1, t$1, a) {
		_checkPrivateRedeclaration(e$1, t$1), t$1.set(e$1, a);
	}
	function _checkPrivateRedeclaration(e$1, t$1) {
		if (t$1.has(e$1)) throw new TypeError("Cannot initialize the same private elements twice on an object");
	}
	function _classPrivateFieldSet(s$2, a, r$1) {
		return s$2.set(_assertClassBrand(s$2, a), r$1), r$1;
	}
	function _classPrivateFieldGet(s$2, a) {
		return s$2.get(_assertClassBrand(s$2, a));
	}
	function _assertClassBrand(e$1, t$1, n) {
		if ("function" == typeof e$1 ? e$1 === t$1 : e$1.has(t$1)) return arguments.length < 3 ? t$1 : n;
		throw new TypeError("Private element is not present on this object");
	}
	function _defineProperties(e$1, r$1) {
		for (var t$1 = 0; t$1 < r$1.length; t$1++) {
			var o = r$1[t$1];
			o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e$1, _toPropertyKey(o.key), o);
		}
	}
	function _createClass(e$1, r$1, t$1) {
		return r$1 && _defineProperties(e$1.prototype, r$1), t$1 && _defineProperties(e$1, t$1), Object.defineProperty(e$1, "prototype", { writable: !1 }), e$1;
	}
	function _classCallCheck(a, n) {
		if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
	}
	function _callSuper(t$1, o, e$1) {
		return o = _getPrototypeOf(o), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o, e$1 || [], _getPrototypeOf(t$1).constructor) : o.apply(t$1, e$1));
	}
	function _possibleConstructorReturn(t$1, e$1) {
		if (e$1 && ("object" == _typeof(e$1) || "function" == typeof e$1)) return e$1;
		if (void 0 !== e$1) throw new TypeError("Derived constructors may only return object or undefined");
		return _assertThisInitialized(t$1);
	}
	function _assertThisInitialized(e$1) {
		if (void 0 === e$1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e$1;
	}
	function _inherits(t$1, e$1) {
		if ("function" != typeof e$1 && null !== e$1) throw new TypeError("Super expression must either be null or a function");
		t$1.prototype = Object.create(e$1 && e$1.prototype, { constructor: {
			value: t$1,
			writable: !0,
			configurable: !0
		} }), Object.defineProperty(t$1, "prototype", { writable: !1 }), e$1 && _setPrototypeOf(t$1, e$1);
	}
	function _wrapNativeSuper(t$1) {
		var r$1 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
		return _wrapNativeSuper = function _wrapNativeSuper$1(t$2) {
			if (null === t$2 || !_isNativeFunction(t$2)) return t$2;
			if ("function" != typeof t$2) throw new TypeError("Super expression must either be null or a function");
			if (void 0 !== r$1) {
				if (r$1.has(t$2)) return r$1.get(t$2);
				r$1.set(t$2, Wrapper);
			}
			function Wrapper() {
				return _construct(t$2, arguments, _getPrototypeOf(this).constructor);
			}
			return Wrapper.prototype = Object.create(t$2.prototype, { constructor: {
				value: Wrapper,
				enumerable: !1,
				writable: !0,
				configurable: !0
			} }), _setPrototypeOf(Wrapper, t$2);
		}, _wrapNativeSuper(t$1);
	}
	function _construct(t$1, e$1, r$1) {
		if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
		var o = [null];
		o.push.apply(o, e$1);
		var p = new (t$1.bind.apply(t$1, o))();
		return r$1 && _setPrototypeOf(p, r$1.prototype), p;
	}
	function _isNativeReflectConstruct() {
		try {
			var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
		} catch (t$2) {}
		return (_isNativeReflectConstruct = function _isNativeReflectConstruct$1() {
			return !!t$1;
		})();
	}
	function _isNativeFunction(t$1) {
		try {
			return -1 !== Function.toString.call(t$1).indexOf("[native code]");
		} catch (n) {
			return "function" == typeof t$1;
		}
	}
	function _setPrototypeOf(t$1, e$1) {
		return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t$2, e$2) {
			return t$2.__proto__ = e$2, t$2;
		}, _setPrototypeOf(t$1, e$1);
	}
	function _getPrototypeOf(t$1) {
		return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t$2) {
			return t$2.__proto__ || Object.getPrototypeOf(t$2);
		}, _getPrototypeOf(t$1);
	}
	function _defineProperty(e$1, r$1, t$1) {
		return (r$1 = _toPropertyKey(r$1)) in e$1 ? Object.defineProperty(e$1, r$1, {
			value: t$1,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : e$1[r$1] = t$1, e$1;
	}
	function _toPropertyKey(t$1) {
		var i$2 = _toPrimitive(t$1, "string");
		return "symbol" == _typeof(i$2) ? i$2 : i$2 + "";
	}
	function _toPrimitive(t$1, r$1) {
		if ("object" != _typeof(t$1) || !t$1) return t$1;
		var e$1 = t$1[Symbol.toPrimitive];
		if (void 0 !== e$1) {
			var i$2 = e$1.call(t$1, r$1 || "default");
			if ("object" != _typeof(i$2)) return i$2;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return ("string" === r$1 ? String : Number)(t$1);
	}
	function _regenerator() {
		/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e$1, t$1, r$1 = "function" == typeof Symbol ? Symbol : {}, n = r$1.iterator || "@@iterator", o = r$1.toStringTag || "@@toStringTag";
		function i$2(r$2, n$1, o$1, i$3) {
			var c$1 = n$1 && n$1.prototype instanceof Generator ? n$1 : Generator, u$1 = Object.create(c$1.prototype);
			return _regeneratorDefine2(u$1, "_invoke", function(r$3, n$2, o$2) {
				var i$4, c$2, u$2, f$3 = 0, p = o$2 || [], y$1 = !1, G = {
					p: 0,
					n: 0,
					v: e$1,
					a: d$1,
					f: d$1.bind(e$1, 4),
					d: function d$2(t$2, r$4) {
						return i$4 = t$2, c$2 = 0, u$2 = e$1, G.n = r$4, a;
					}
				};
				function d$1(r$4, n$3) {
					for (c$2 = r$4, u$2 = n$3, t$1 = 0; !y$1 && f$3 && !o$3 && t$1 < p.length; t$1++) {
						var o$3, i$5 = p[t$1], d$2 = G.p, l = i$5[2];
						r$4 > 3 ? (o$3 = l === n$3) && (u$2 = i$5[(c$2 = i$5[4]) ? 5 : (c$2 = 3, 3)], i$5[4] = i$5[5] = e$1) : i$5[0] <= d$2 && ((o$3 = r$4 < 2 && d$2 < i$5[1]) ? (c$2 = 0, G.v = n$3, G.n = i$5[1]) : d$2 < l && (o$3 = r$4 < 3 || i$5[0] > n$3 || n$3 > l) && (i$5[4] = r$4, i$5[5] = n$3, G.n = l, c$2 = 0));
					}
					if (o$3 || r$4 > 1) return a;
					throw y$1 = !0, n$3;
				}
				return function(o$3, p$1, l) {
					if (f$3 > 1) throw TypeError("Generator is already running");
					for (y$1 && 1 === p$1 && d$1(p$1, l), c$2 = p$1, u$2 = l; (t$1 = c$2 < 2 ? e$1 : u$2) || !y$1;) {
						i$4 || (c$2 ? c$2 < 3 ? (c$2 > 1 && (G.n = -1), d$1(c$2, u$2)) : G.n = u$2 : G.v = u$2);
						try {
							if (f$3 = 2, i$4) {
								if (c$2 || (o$3 = "next"), t$1 = i$4[o$3]) {
									if (!(t$1 = t$1.call(i$4, u$2))) throw TypeError("iterator result is not an object");
									if (!t$1.done) return t$1;
									u$2 = t$1.value, c$2 < 2 && (c$2 = 0);
								} else 1 === c$2 && (t$1 = i$4["return"]) && t$1.call(i$4), c$2 < 2 && (u$2 = TypeError("The iterator does not provide a '" + o$3 + "' method"), c$2 = 1);
								i$4 = e$1;
							} else if ((t$1 = (y$1 = G.n < 0) ? u$2 : r$3.call(n$2, G)) !== a) break;
						} catch (t$2) {
							i$4 = e$1, c$2 = 1, u$2 = t$2;
						} finally {
							f$3 = 1;
						}
					}
					return {
						value: t$1,
						done: y$1
					};
				};
			}(r$2, o$1, i$3), !0), u$1;
		}
		var a = {};
		function Generator() {}
		function GeneratorFunction() {}
		function GeneratorFunctionPrototype() {}
		t$1 = Object.getPrototypeOf;
		var c = [][n] ? t$1(t$1([][n]())) : (_regeneratorDefine2(t$1 = {}, n, function() {
			return this;
		}), t$1), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
		function f$2(e$2) {
			return Object.setPrototypeOf ? Object.setPrototypeOf(e$2, GeneratorFunctionPrototype) : (e$2.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e$2, o, "GeneratorFunction")), e$2.prototype = Object.create(u), e$2;
		}
		return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function() {
			return this;
		}), _regeneratorDefine2(u, "toString", function() {
			return "[object Generator]";
		}), (_regenerator = function _regenerator$1() {
			return {
				w: i$2,
				m: f$2
			};
		})();
	}
	function _regeneratorDefine2(e$1, r$1, n, t$1) {
		var i$2 = Object.defineProperty;
		try {
			i$2({}, "", {});
		} catch (e$2) {
			i$2 = 0;
		}
		_regeneratorDefine2 = function _regeneratorDefine(e$2, r$2, n$1, t$2) {
			if (r$2) i$2 ? i$2(e$2, r$2, {
				value: n$1,
				enumerable: !t$2,
				configurable: !t$2,
				writable: !t$2
			}) : e$2[r$2] = n$1;
			else {
				var o = function o$1(r$3, n$2) {
					_regeneratorDefine2(e$2, r$3, function(e$3) {
						return this._invoke(r$3, n$2, e$3);
					});
				};
				o("next", 0), o("throw", 1), o("return", 2);
			}
		}, _regeneratorDefine2(e$1, r$1, n, t$1);
	}
	function asyncGeneratorStep(n, t$1, e$1, r$1, o, a, c) {
		try {
			var i$2 = n[a](c), u = i$2.value;
		} catch (n$1) {
			e$1(n$1);
			return;
		}
		i$2.done ? t$1(u) : Promise.resolve(u).then(r$1, o);
	}
	function _asyncToGenerator(n) {
		return function() {
			var t$1 = this, e$1 = arguments;
			return new Promise(function(r$1, o) {
				var a = n.apply(t$1, e$1);
				function _next(n$1) {
					asyncGeneratorStep(a, r$1, o, _next, _throw, "next", n$1);
				}
				function _throw(n$1) {
					asyncGeneratorStep(a, r$1, o, _next, _throw, "throw", n$1);
				}
				_next(void 0);
			});
		};
	}
	var readFile$1 = fs$5.readFile ? (0, _util.promisify)(fs$5.readFile) : /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee() {
		return _regenerator().w(function(_context) {
			while (1) switch (_context.n) {
				case 0: throw new ErrorWithCode("use key rather than keyFile.", "MISSING_CREDENTIALS");
				case 1: return _context.a(2);
			}
		}, _callee);
	}));
	var GOOGLE_TOKEN_URL = "https://oauth2.googleapis.com/token";
	var GOOGLE_REVOKE_TOKEN_URL = "https://oauth2.googleapis.com/revoke?token=";
	var ErrorWithCode = /* @__PURE__ */ function(_Error) {
		function ErrorWithCode$1(message, code$1) {
			var _this;
			_classCallCheck(this, ErrorWithCode$1);
			_this = _callSuper(this, ErrorWithCode$1, [message]);
			_defineProperty(_this, "code", void 0);
			_this.code = code$1;
			return _this;
		}
		_inherits(ErrorWithCode$1, _Error);
		return _createClass(ErrorWithCode$1);
	}(/* @__PURE__ */ _wrapNativeSuper(Error));
	var _inFlightRequest = /* @__PURE__ */ new WeakMap();
	var _GoogleToken_brand = /* @__PURE__ */ new WeakSet();
	exports.GoogleToken = /* @__PURE__ */ function() {
		/**
		* Create a GoogleToken.
		*
		* @param options  Configuration object.
		*/
		function GoogleToken(_options) {
			_classCallCheck(this, GoogleToken);
			_classPrivateMethodInitSpec(this, _GoogleToken_brand);
			_defineProperty(this, "expiresAt", void 0);
			_defineProperty(this, "key", void 0);
			_defineProperty(this, "keyFile", void 0);
			_defineProperty(this, "iss", void 0);
			_defineProperty(this, "sub", void 0);
			_defineProperty(this, "scope", void 0);
			_defineProperty(this, "rawToken", void 0);
			_defineProperty(this, "tokenExpires", void 0);
			_defineProperty(this, "email", void 0);
			_defineProperty(this, "additionalClaims", void 0);
			_defineProperty(this, "eagerRefreshThresholdMillis", void 0);
			_defineProperty(this, "transporter", { request: function request$3(opts) {
				return (0, _gaxios.request)(opts);
			} });
			_classPrivateFieldInitSpec(this, _inFlightRequest, void 0);
			_assertClassBrand(_GoogleToken_brand, this, _configure).call(this, _options);
		}
		/**
		* Returns whether the token has expired.
		*
		* @return true if the token has expired, false otherwise.
		*/
		return _createClass(GoogleToken, [
			{
				key: "accessToken",
				get: function get() {
					return this.rawToken ? this.rawToken.access_token : void 0;
				}
			},
			{
				key: "idToken",
				get: function get() {
					return this.rawToken ? this.rawToken.id_token : void 0;
				}
			},
			{
				key: "tokenType",
				get: function get() {
					return this.rawToken ? this.rawToken.token_type : void 0;
				}
			},
			{
				key: "refreshToken",
				get: function get() {
					return this.rawToken ? this.rawToken.refresh_token : void 0;
				}
			},
			{
				key: "hasExpired",
				value: function hasExpired() {
					var now = (/* @__PURE__ */ new Date()).getTime();
					if (this.rawToken && this.expiresAt) return now >= this.expiresAt;
					else return true;
				}
			},
			{
				key: "isTokenExpiring",
				value: function isTokenExpiring() {
					var _this$eagerRefreshThr;
					var now = (/* @__PURE__ */ new Date()).getTime();
					var eagerRefreshThresholdMillis = (_this$eagerRefreshThr = this.eagerRefreshThresholdMillis) !== null && _this$eagerRefreshThr !== void 0 ? _this$eagerRefreshThr : 0;
					if (this.rawToken && this.expiresAt) return this.expiresAt <= now + eagerRefreshThresholdMillis;
					else return true;
				}
			},
			{
				key: "getToken",
				value: function getToken(callback) {
					var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
					if (_typeof(callback) === "object") {
						opts = callback;
						callback = void 0;
					}
					opts = Object.assign({ forceRefresh: false }, opts);
					if (callback) {
						var cb = callback;
						_assertClassBrand(_GoogleToken_brand, this, _getTokenAsync).call(this, opts).then(function(t$1) {
							return cb(null, t$1);
						}, callback);
						return;
					}
					return _assertClassBrand(_GoogleToken_brand, this, _getTokenAsync).call(this, opts);
				}
			},
			{
				key: "getCredentials",
				value: function() {
					var _getCredentials = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee2(keyFile) {
						var ext, key, body, privateKey, clientEmail, _privateKey, _t;
						return _regenerator().w(function(_context2) {
							while (1) switch (_context2.n) {
								case 0:
									ext = path$2.extname(keyFile);
									_t = ext;
									_context2.n = _t === ".json" ? 1 : _t === ".der" ? 4 : _t === ".crt" ? 4 : _t === ".pem" ? 4 : _t === ".p12" ? 6 : _t === ".pfx" ? 6 : 7;
									break;
								case 1:
									_context2.n = 2;
									return readFile$1(keyFile, "utf8");
								case 2:
									key = _context2.v;
									body = JSON.parse(key);
									privateKey = body.private_key;
									clientEmail = body.client_email;
									if (!(!privateKey || !clientEmail)) {
										_context2.n = 3;
										break;
									}
									throw new ErrorWithCode("private_key and client_email are required.", "MISSING_CREDENTIALS");
								case 3: return _context2.a(2, {
									privateKey,
									clientEmail
								});
								case 4:
									_context2.n = 5;
									return readFile$1(keyFile, "utf8");
								case 5:
									_privateKey = _context2.v;
									return _context2.a(2, { privateKey: _privateKey });
								case 6: throw new ErrorWithCode("*.p12 certificates are not supported after v6.1.2. Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.", "UNKNOWN_CERTIFICATE_TYPE");
								case 7: throw new ErrorWithCode("Unknown certificate type. Type is determined based on file extension. Current supported extensions are *.json, and *.pem.", "UNKNOWN_CERTIFICATE_TYPE");
								case 8: return _context2.a(2);
							}
						}, _callee2);
					}));
					function getCredentials(_x) {
						return _getCredentials.apply(this, arguments);
					}
					return getCredentials;
				}()
			},
			{
				key: "revokeToken",
				value: function revokeToken(callback) {
					if (callback) {
						_assertClassBrand(_GoogleToken_brand, this, _revokeTokenAsync).call(this).then(function() {
							return callback();
						}, callback);
						return;
					}
					return _assertClassBrand(_GoogleToken_brand, this, _revokeTokenAsync).call(this);
				}
			}
		]);
	}();
	function _getTokenAsync(_x2) {
		return _getTokenAsync2.apply(this, arguments);
	}
	function _getTokenAsync2() {
		_getTokenAsync2 = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee3(opts) {
			return _regenerator().w(function(_context3) {
				while (1) switch (_context3.n) {
					case 0:
						if (!(_classPrivateFieldGet(_inFlightRequest, this) && !opts.forceRefresh)) {
							_context3.n = 1;
							break;
						}
						return _context3.a(2, _classPrivateFieldGet(_inFlightRequest, this));
					case 1:
						_context3.p = 1;
						_context3.n = 2;
						return _classPrivateFieldSet(_inFlightRequest, this, _assertClassBrand(_GoogleToken_brand, this, _getTokenAsyncInner).call(this, opts));
					case 2: return _context3.a(2, _context3.v);
					case 3:
						_context3.p = 3;
						_classPrivateFieldSet(_inFlightRequest, this, void 0);
						return _context3.f(3);
					case 4: return _context3.a(2);
				}
			}, _callee3, this, [[
				1,
				,
				3,
				4
			]]);
		}));
		return _getTokenAsync2.apply(this, arguments);
	}
	function _getTokenAsyncInner(_x3) {
		return _getTokenAsyncInner2.apply(this, arguments);
	}
	function _getTokenAsyncInner2() {
		_getTokenAsyncInner2 = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee4(opts) {
			var creds;
			return _regenerator().w(function(_context4) {
				while (1) switch (_context4.n) {
					case 0:
						if (!(this.isTokenExpiring() === false && opts.forceRefresh === false)) {
							_context4.n = 1;
							break;
						}
						return _context4.a(2, Promise.resolve(this.rawToken));
					case 1:
						if (!(!this.key && !this.keyFile)) {
							_context4.n = 2;
							break;
						}
						throw new Error("No key or keyFile set.");
					case 2:
						if (!(!this.key && this.keyFile)) {
							_context4.n = 4;
							break;
						}
						_context4.n = 3;
						return this.getCredentials(this.keyFile);
					case 3:
						creds = _context4.v;
						this.key = creds.privateKey;
						this.iss = creds.clientEmail || this.iss;
						if (!creds.clientEmail) _assertClassBrand(_GoogleToken_brand, this, _ensureEmail).call(this);
					case 4: return _context4.a(2, _assertClassBrand(_GoogleToken_brand, this, _requestToken).call(this));
				}
			}, _callee4, this);
		}));
		return _getTokenAsyncInner2.apply(this, arguments);
	}
	function _ensureEmail() {
		if (!this.iss) throw new ErrorWithCode("email is required.", "MISSING_CREDENTIALS");
	}
	function _revokeTokenAsync() {
		return _revokeTokenAsync2.apply(this, arguments);
	}
	function _revokeTokenAsync2() {
		_revokeTokenAsync2 = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee5() {
			var url;
			return _regenerator().w(function(_context5) {
				while (1) switch (_context5.n) {
					case 0:
						if (this.accessToken) {
							_context5.n = 1;
							break;
						}
						throw new Error("No token to revoke.");
					case 1:
						url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;
						_context5.n = 2;
						return this.transporter.request({
							url,
							retry: true
						});
					case 2: _assertClassBrand(_GoogleToken_brand, this, _configure).call(this, {
						email: this.iss,
						sub: this.sub,
						key: this.key,
						keyFile: this.keyFile,
						scope: this.scope,
						additionalClaims: this.additionalClaims
					});
					case 3: return _context5.a(2);
				}
			}, _callee5, this);
		}));
		return _revokeTokenAsync2.apply(this, arguments);
	}
	/**
	* Configure the GoogleToken for re-use.
	* @param  {object} options Configuration object.
	*/
	function _configure() {
		var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		this.keyFile = options.keyFile;
		this.key = options.key;
		this.rawToken = void 0;
		this.iss = options.email || options.iss;
		this.sub = options.sub;
		this.additionalClaims = options.additionalClaims;
		if (_typeof(options.scope) === "object") this.scope = options.scope.join(" ");
		else this.scope = options.scope;
		this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
		if (options.transporter) this.transporter = options.transporter;
	}
	/**
	* Request the token from Google.
	*/
	function _requestToken() {
		return _requestToken2.apply(this, arguments);
	}
	function _requestToken2() {
		_requestToken2 = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee6() {
			var iat, additionalClaims, payload, signedJWT, r$1, _response, _response2, body, desc, _t2;
			return _regenerator().w(function(_context6) {
				while (1) switch (_context6.n) {
					case 0:
						iat = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
						additionalClaims = this.additionalClaims || {};
						payload = Object.assign({
							iss: this.iss,
							scope: this.scope,
							aud: GOOGLE_TOKEN_URL,
							exp: iat + 3600,
							iat,
							sub: this.sub
						}, additionalClaims);
						signedJWT = jws$1.sign({
							header: { alg: "RS256" },
							payload,
							secret: this.key
						});
						_context6.p = 1;
						_context6.n = 2;
						return this.transporter.request({
							method: "POST",
							url: GOOGLE_TOKEN_URL,
							data: new URLSearchParams({
								grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
								assertion: signedJWT
							}),
							responseType: "json",
							retryConfig: { httpMethodsToRetry: ["POST"] }
						});
					case 2:
						r$1 = _context6.v;
						this.rawToken = r$1.data;
						this.expiresAt = r$1.data.expires_in === null || r$1.data.expires_in === void 0 ? void 0 : (iat + r$1.data.expires_in) * 1e3;
						return _context6.a(2, this.rawToken);
					case 3:
						_context6.p = 3;
						_t2 = _context6.v;
						this.rawToken = void 0;
						this.tokenExpires = void 0;
						body = _t2.response && (_response = _t2.response) !== null && _response !== void 0 && _response.data ? (_response2 = _t2.response) === null || _response2 === void 0 ? void 0 : _response2.data : {};
						if (body.error) {
							desc = body.error_description ? ": ".concat(body.error_description) : "";
							_t2.message = "".concat(body.error).concat(desc);
						}
						throw _t2;
					case 4: return _context6.a(2);
				}
			}, _callee6, this, [[1, 3]]);
		}));
		return _requestToken2.apply(this, arguments);
	}
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/jwtaccess.js
var require_jwtaccess = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JWTAccess = void 0;
	const jws = require_jws();
	const util_1$8 = require_util();
	const DEFAULT_HEADER = {
		alg: "RS256",
		typ: "JWT"
	};
	var JWTAccess = class JWTAccess {
		email;
		key;
		keyId;
		projectId;
		eagerRefreshThresholdMillis;
		cache = new util_1$8.LRUCache({
			capacity: 500,
			maxAge: 3600 * 1e3
		});
		/**
		* JWTAccess service account credentials.
		*
		* Create a new access token by using the credential to create a new JWT token
		* that's recognized as the access token.
		*
		* @param email the service account email address.
		* @param key the private key that will be used to sign the token.
		* @param keyId the ID of the private key used to sign the token.
		*/
		constructor(email, key, keyId, eagerRefreshThresholdMillis) {
			this.email = email;
			this.key = key;
			this.keyId = keyId;
			this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis ?? 300 * 1e3;
		}
		/**
		* Ensures that we're caching a key appropriately, giving precedence to scopes vs. url
		*
		* @param url The URI being authorized.
		* @param scopes The scope or scopes being authorized
		* @returns A string that returns the cached key.
		*/
		getCachedKey(url, scopes) {
			let cacheKey = url;
			if (scopes && Array.isArray(scopes) && scopes.length) cacheKey = url ? `${url}_${scopes.join("_")}` : `${scopes.join("_")}`;
			else if (typeof scopes === "string") cacheKey = url ? `${url}_${scopes}` : scopes;
			if (!cacheKey) throw Error("Scopes or url must be provided");
			return cacheKey;
		}
		/**
		* Get a non-expired access token, after refreshing if necessary.
		*
		* @param url The URI being authorized.
		* @param additionalClaims An object with a set of additional claims to
		* include in the payload.
		* @returns An object that includes the authorization header.
		*/
		getRequestHeaders(url, additionalClaims, scopes) {
			const key = this.getCachedKey(url, scopes);
			const cachedToken = this.cache.get(key);
			const now = Date.now();
			if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) return new Headers(cachedToken.headers);
			const iat = Math.floor(Date.now() / 1e3);
			const exp = JWTAccess.getExpirationTime(iat);
			let defaultClaims;
			if (Array.isArray(scopes)) scopes = scopes.join(" ");
			if (scopes) defaultClaims = {
				iss: this.email,
				sub: this.email,
				scope: scopes,
				exp,
				iat
			};
			else defaultClaims = {
				iss: this.email,
				sub: this.email,
				aud: url,
				exp,
				iat
			};
			if (additionalClaims) {
				for (const claim in defaultClaims) if (additionalClaims[claim]) throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
			}
			const header = this.keyId ? {
				...DEFAULT_HEADER,
				kid: this.keyId
			} : DEFAULT_HEADER;
			const payload = Object.assign(defaultClaims, additionalClaims);
			const signedJWT = jws.sign({
				header,
				payload,
				secret: this.key
			});
			const headers = new Headers({ authorization: `Bearer ${signedJWT}` });
			this.cache.set(key, {
				expiration: exp * 1e3,
				headers
			});
			return headers;
		}
		/**
		* Returns an expiration time for the JWT token.
		*
		* @param iat The issued at time for the JWT.
		* @returns An expiration time for the JWT.
		*/
		static getExpirationTime(iat) {
			return iat + 3600;
		}
		/**
		* Create a JWTAccess credentials instance using the given input options.
		* @param json The input object.
		*/
		fromJSON(json$1) {
			if (!json$1) throw new Error("Must pass in a JSON object containing the service account auth settings.");
			if (!json$1.client_email) throw new Error("The incoming JSON object does not contain a client_email field");
			if (!json$1.private_key) throw new Error("The incoming JSON object does not contain a private_key field");
			this.email = json$1.client_email;
			this.key = json$1.private_key;
			this.keyId = json$1.private_key_id;
			this.projectId = json$1.project_id;
		}
		fromStream(inputStream, callback) {
			if (callback) this.fromStreamAsync(inputStream).then(() => callback(), callback);
			else return this.fromStreamAsync(inputStream);
		}
		fromStreamAsync(inputStream) {
			return new Promise((resolve, reject) => {
				if (!inputStream) reject(/* @__PURE__ */ new Error("Must pass in a stream containing the service account auth settings."));
				let s$2 = "";
				inputStream.setEncoding("utf8").on("data", (chunk) => s$2 += chunk).on("error", reject).on("end", () => {
					try {
						const data = JSON.parse(s$2);
						this.fromJSON(data);
						resolve();
					} catch (err) {
						reject(err);
					}
				});
			});
		}
	};
	exports.JWTAccess = JWTAccess;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/jwtclient.js
var require_jwtclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JWT = void 0;
	const gtoken_1 = require_src$1();
	const jwtaccess_1$1 = require_jwtaccess();
	const oauth2client_1$3 = require_oauth2client();
	const authclient_1$10 = require_authclient();
	var JWT = class JWT extends oauth2client_1$3.OAuth2Client {
		email;
		keyFile;
		key;
		keyId;
		defaultScopes;
		scopes;
		scope;
		subject;
		gtoken;
		additionalClaims;
		useJWTAccessWithScope;
		defaultServicePath;
		access;
		/**
		* JWT service account credentials.
		*
		* Retrieve access token using gtoken.
		*
		* @param options the
		*/
		constructor(options = {}) {
			super(options);
			this.email = options.email;
			this.keyFile = options.keyFile;
			this.key = options.key;
			this.keyId = options.keyId;
			this.scopes = options.scopes;
			this.subject = options.subject;
			this.additionalClaims = options.additionalClaims;
			this.credentials = {
				refresh_token: "jwt-placeholder",
				expiry_date: 1
			};
		}
		/**
		* Creates a copy of the credential with the specified scopes.
		* @param scopes List of requested scopes or a single scope.
		* @return The cloned instance.
		*/
		createScoped(scopes) {
			const jwt = new JWT(this);
			jwt.scopes = scopes;
			return jwt;
		}
		/**
		* Obtains the metadata to be sent with the request.
		*
		* @param url the URI being authorized.
		*/
		async getRequestMetadataAsync(url) {
			url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;
			const useSelfSignedJWT = !this.hasUserScopes() && url || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== authclient_1$10.DEFAULT_UNIVERSE;
			if (this.subject && this.universeDomain !== authclient_1$10.DEFAULT_UNIVERSE) throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${authclient_1$10.DEFAULT_UNIVERSE}`);
			if (!this.apiKey && useSelfSignedJWT) if (this.additionalClaims && this.additionalClaims.target_audience) {
				const { tokens } = await this.refreshToken();
				return { headers: this.addSharedMetadataHeaders(new Headers({ authorization: `Bearer ${tokens.id_token}` })) };
			} else {
				if (!this.access) this.access = new jwtaccess_1$1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);
				let scopes;
				if (this.hasUserScopes()) scopes = this.scopes;
				else if (!url) scopes = this.defaultScopes;
				const useScopes = this.useJWTAccessWithScope || this.universeDomain !== authclient_1$10.DEFAULT_UNIVERSE;
				const headers = await this.access.getRequestHeaders(url ?? void 0, this.additionalClaims, useScopes ? scopes : void 0);
				return { headers: this.addSharedMetadataHeaders(headers) };
			}
			else if (this.hasAnyScopes() || this.apiKey) return super.getRequestMetadataAsync(url);
			else return { headers: new Headers() };
		}
		/**
		* Fetches an ID token.
		* @param targetAudience the audience for the fetched ID token.
		*/
		async fetchIdToken(targetAudience) {
			const gtoken = new gtoken_1.GoogleToken({
				iss: this.email,
				sub: this.subject,
				scope: this.scopes || this.defaultScopes,
				keyFile: this.keyFile,
				key: this.key,
				additionalClaims: { target_audience: targetAudience },
				transporter: this.transporter
			});
			await gtoken.getToken({ forceRefresh: true });
			if (!gtoken.idToken) throw new Error("Unknown error: Failed to fetch ID token");
			return gtoken.idToken;
		}
		/**
		* Determine if there are currently scopes available.
		*/
		hasUserScopes() {
			if (!this.scopes) return false;
			return this.scopes.length > 0;
		}
		/**
		* Are there any default or user scopes defined.
		*/
		hasAnyScopes() {
			if (this.scopes && this.scopes.length > 0) return true;
			if (this.defaultScopes && this.defaultScopes.length > 0) return true;
			return false;
		}
		authorize(callback) {
			if (callback) this.authorizeAsync().then((r$1) => callback(null, r$1), callback);
			else return this.authorizeAsync();
		}
		async authorizeAsync() {
			const result = await this.refreshToken();
			if (!result) throw new Error("No result returned");
			this.credentials = result.tokens;
			this.credentials.refresh_token = "jwt-placeholder";
			this.key = this.gtoken.key;
			this.email = this.gtoken.iss;
			return result.tokens;
		}
		/**
		* Refreshes the access token.
		* @param refreshToken ignored
		* @private
		*/
		async refreshTokenNoCache() {
			const gtoken = this.createGToken();
			const tokens = {
				access_token: (await gtoken.getToken({ forceRefresh: this.isTokenExpiring() })).access_token,
				token_type: "Bearer",
				expiry_date: gtoken.expiresAt,
				id_token: gtoken.idToken
			};
			this.emit("tokens", tokens);
			return {
				res: null,
				tokens
			};
		}
		/**
		* Create a gToken if it doesn't already exist.
		*/
		createGToken() {
			if (!this.gtoken) this.gtoken = new gtoken_1.GoogleToken({
				iss: this.email,
				sub: this.subject,
				scope: this.scopes || this.defaultScopes,
				keyFile: this.keyFile,
				key: this.key,
				additionalClaims: this.additionalClaims,
				transporter: this.transporter
			});
			return this.gtoken;
		}
		/**
		* Create a JWT credentials instance using the given input options.
		* @param json The input object.
		*
		* @remarks
		*
		* **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
		*/
		fromJSON(json$1) {
			if (!json$1) throw new Error("Must pass in a JSON object containing the service account auth settings.");
			if (!json$1.client_email) throw new Error("The incoming JSON object does not contain a client_email field");
			if (!json$1.private_key) throw new Error("The incoming JSON object does not contain a private_key field");
			this.email = json$1.client_email;
			this.key = json$1.private_key;
			this.keyId = json$1.private_key_id;
			this.projectId = json$1.project_id;
			this.quotaProjectId = json$1.quota_project_id;
			this.universeDomain = json$1.universe_domain || this.universeDomain;
		}
		fromStream(inputStream, callback) {
			if (callback) this.fromStreamAsync(inputStream).then(() => callback(), callback);
			else return this.fromStreamAsync(inputStream);
		}
		fromStreamAsync(inputStream) {
			return new Promise((resolve, reject) => {
				if (!inputStream) throw new Error("Must pass in a stream containing the service account auth settings.");
				let s$2 = "";
				inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s$2 += chunk).on("end", () => {
					try {
						const data = JSON.parse(s$2);
						this.fromJSON(data);
						resolve();
					} catch (e$1) {
						reject(e$1);
					}
				});
			});
		}
		/**
		* Creates a JWT credentials instance using an API Key for authentication.
		* @param apiKey The API Key in string form.
		*/
		fromAPIKey(apiKey) {
			if (typeof apiKey !== "string") throw new Error("Must provide an API Key string.");
			this.apiKey = apiKey;
		}
		/**
		* Using the key or keyFile on the JWT client, obtain an object that contains
		* the key and the client email.
		*/
		async getCredentials() {
			if (this.key) return {
				private_key: this.key,
				client_email: this.email
			};
			else if (this.keyFile) {
				const creds = await this.createGToken().getCredentials(this.keyFile);
				return {
					private_key: creds.privateKey,
					client_email: creds.clientEmail
				};
			}
			throw new Error("A key or a keyFile must be provided to getCredentials.");
		}
	};
	exports.JWT = JWT;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/refreshclient.js
var require_refreshclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = void 0;
	const oauth2client_1$2 = require_oauth2client();
	const authclient_1$9 = require_authclient();
	exports.USER_REFRESH_ACCOUNT_TYPE = "authorized_user";
	var UserRefreshClient = class UserRefreshClient extends oauth2client_1$2.OAuth2Client {
		_refreshToken;
		/**
		* The User Refresh Token client.
		*
		* @param optionsOrClientId The User Refresh Token client options. Passing an `clientId` directly is **@DEPRECATED**.
		* @param clientSecret **@DEPRECATED**. Provide a {@link UserRefreshClientOptions `UserRefreshClientOptions`} object in the first parameter instead.
		* @param refreshToken **@DEPRECATED**. Provide a {@link UserRefreshClientOptions `UserRefreshClientOptions`} object in the first parameter instead.
		* @param eagerRefreshThresholdMillis **@DEPRECATED**. Provide a {@link UserRefreshClientOptions `UserRefreshClientOptions`} object in the first parameter instead.
		* @param forceRefreshOnFailure **@DEPRECATED**. Provide a {@link UserRefreshClientOptions `UserRefreshClientOptions`} object in the first parameter instead.
		*/
		constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure) {
			const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : {
				clientId: optionsOrClientId,
				clientSecret,
				refreshToken,
				eagerRefreshThresholdMillis,
				forceRefreshOnFailure
			};
			super(opts);
			this._refreshToken = opts.refreshToken;
			this.credentials.refresh_token = opts.refreshToken;
		}
		/**
		* Refreshes the access token.
		* @param refreshToken An ignored refreshToken..
		* @param callback Optional callback.
		*/
		async refreshTokenNoCache() {
			return super.refreshTokenNoCache(this._refreshToken);
		}
		async fetchIdToken(targetAudience) {
			const opts = {
				...UserRefreshClient.RETRY_CONFIG,
				url: this.endpoints.oauth2TokenUrl,
				method: "POST",
				data: new URLSearchParams({
					client_id: this._clientId,
					client_secret: this._clientSecret,
					grant_type: "refresh_token",
					refresh_token: this._refreshToken,
					target_audience: targetAudience
				})
			};
			authclient_1$9.AuthClient.setMethodName(opts, "fetchIdToken");
			return (await this.transporter.request(opts)).data.id_token;
		}
		/**
		* Create a UserRefreshClient credentials instance using the given input
		* options.
		* @param json The input object.
		*/
		fromJSON(json$1) {
			if (!json$1) throw new Error("Must pass in a JSON object containing the user refresh token");
			if (json$1.type !== "authorized_user") throw new Error("The incoming JSON object does not have the \"authorized_user\" type");
			if (!json$1.client_id) throw new Error("The incoming JSON object does not contain a client_id field");
			if (!json$1.client_secret) throw new Error("The incoming JSON object does not contain a client_secret field");
			if (!json$1.refresh_token) throw new Error("The incoming JSON object does not contain a refresh_token field");
			this._clientId = json$1.client_id;
			this._clientSecret = json$1.client_secret;
			this._refreshToken = json$1.refresh_token;
			this.credentials.refresh_token = json$1.refresh_token;
			this.quotaProjectId = json$1.quota_project_id;
			this.universeDomain = json$1.universe_domain || this.universeDomain;
		}
		fromStream(inputStream, callback) {
			if (callback) this.fromStreamAsync(inputStream).then(() => callback(), callback);
			else return this.fromStreamAsync(inputStream);
		}
		async fromStreamAsync(inputStream) {
			return new Promise((resolve, reject) => {
				if (!inputStream) return reject(/* @__PURE__ */ new Error("Must pass in a stream containing the user refresh token."));
				let s$2 = "";
				inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s$2 += chunk).on("end", () => {
					try {
						const data = JSON.parse(s$2);
						this.fromJSON(data);
						return resolve();
					} catch (err) {
						return reject(err);
					}
				});
			});
		}
		/**
		* Create a UserRefreshClient credentials instance using the given input
		* options.
		* @param json The input object.
		*/
		static fromJSON(json$1) {
			const client = new UserRefreshClient();
			client.fromJSON(json$1);
			return client;
		}
	};
	exports.UserRefreshClient = UserRefreshClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/impersonated.js
var require_impersonated = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Copyright 2021 Google LLC
	*
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*      http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;
	const oauth2client_1$1 = require_oauth2client();
	const gaxios_1$9 = require_src$4();
	const util_1$7 = require_util();
	exports.IMPERSONATED_ACCOUNT_TYPE = "impersonated_service_account";
	var Impersonated = class Impersonated extends oauth2client_1$1.OAuth2Client {
		sourceClient;
		targetPrincipal;
		targetScopes;
		delegates;
		lifetime;
		endpoint;
		/**
		* Impersonated service account credentials.
		*
		* Create a new access token by impersonating another service account.
		*
		* Impersonated Credentials allowing credentials issued to a user or
		* service account to impersonate another. The source project using
		* Impersonated Credentials must enable the "IAMCredentials" API.
		* Also, the target service account must grant the orginating principal
		* the "Service Account Token Creator" IAM role.
		*
		* **IMPORTANT**: This method does not validate the credential configuration.
		* A security risk occurs when a credential configuration configured with
		* malicious URLs is used. When the credential configuration is accepted from
		* an untrusted source, you should validate it before using it with this
		* method. For more details, see
		* https://cloud.google.com/docs/authentication/external/externally-sourced-credentials.
		*
		* @param {object} options - The configuration object.
		* @param {object} [options.sourceClient] the source credential used as to
		* acquire the impersonated credentials.
		* @param {string} [options.targetPrincipal] the service account to
		* impersonate.
		* @param {string[]} [options.delegates] the chained list of delegates
		* required to grant the final access_token. If set, the sequence of
		* identities must have "Service Account Token Creator" capability granted to
		* the preceding identity. For example, if set to [serviceAccountB,
		* serviceAccountC], the sourceCredential must have the Token Creator role on
		* serviceAccountB. serviceAccountB must have the Token Creator on
		* serviceAccountC. Finally, C must have Token Creator on target_principal.
		* If left unset, sourceCredential must have that role on targetPrincipal.
		* @param {string[]} [options.targetScopes] scopes to request during the
		* authorization grant.
		* @param {number} [options.lifetime] number of seconds the delegated
		* credential should be valid for up to 3600 seconds by default, or 43,200
		* seconds by extending the token's lifetime, see:
		* https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth
		* @param {string} [options.endpoint] api endpoint override.
		*/
		constructor(options = {}) {
			super(options);
			this.credentials = {
				expiry_date: 1,
				refresh_token: "impersonated-placeholder"
			};
			this.sourceClient = options.sourceClient ?? new oauth2client_1$1.OAuth2Client();
			this.targetPrincipal = options.targetPrincipal ?? "";
			this.delegates = options.delegates ?? [];
			this.targetScopes = options.targetScopes ?? [];
			this.lifetime = options.lifetime ?? 3600;
			if (!!!(0, util_1$7.originalOrCamelOptions)(options).get("universe_domain")) this.universeDomain = this.sourceClient.universeDomain;
			else if (this.sourceClient.universeDomain !== this.universeDomain) throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);
			this.endpoint = options.endpoint ?? `https://iamcredentials.${this.universeDomain}`;
		}
		/**
		* Signs some bytes.
		*
		* {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}
		* @param blobToSign String to sign.
		*
		* @returns A {@link SignBlobResponse} denoting the keyID and signedBlob in base64 string
		*/
		async sign(blobToSign) {
			await this.sourceClient.getAccessToken();
			const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
			const u = `${this.endpoint}/v1/${name}:signBlob`;
			const body = {
				delegates: this.delegates,
				payload: Buffer.from(blobToSign).toString("base64")
			};
			return (await this.sourceClient.request({
				...Impersonated.RETRY_CONFIG,
				url: u,
				data: body,
				method: "POST"
			})).data;
		}
		/** The service account email to be impersonated. */
		getTargetPrincipal() {
			return this.targetPrincipal;
		}
		/**
		* Refreshes the access token.
		*/
		async refreshToken() {
			try {
				await this.sourceClient.getAccessToken();
				const name = "projects/-/serviceAccounts/" + this.targetPrincipal;
				const u = `${this.endpoint}/v1/${name}:generateAccessToken`;
				const body = {
					delegates: this.delegates,
					scope: this.targetScopes,
					lifetime: this.lifetime + "s"
				};
				const res = await this.sourceClient.request({
					...Impersonated.RETRY_CONFIG,
					url: u,
					data: body,
					method: "POST"
				});
				const tokenResponse = res.data;
				this.credentials.access_token = tokenResponse.accessToken;
				this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);
				return {
					tokens: this.credentials,
					res
				};
			} catch (error$1) {
				if (!(error$1 instanceof Error)) throw error$1;
				let status = 0;
				let message = "";
				if (error$1 instanceof gaxios_1$9.GaxiosError) {
					status = error$1?.response?.data?.error?.status;
					message = error$1?.response?.data?.error?.message;
				}
				if (status && message) {
					error$1.message = `${status}: unable to impersonate: ${message}`;
					throw error$1;
				} else {
					error$1.message = `unable to impersonate: ${error$1}`;
					throw error$1;
				}
			}
		}
		/**
		* Generates an OpenID Connect ID token for a service account.
		*
		* {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}
		*
		* @param targetAudience the audience for the fetched ID token.
		* @param options the for the request
		* @return an OpenID Connect ID token
		*/
		async fetchIdToken(targetAudience, options) {
			await this.sourceClient.getAccessToken();
			const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
			const u = `${this.endpoint}/v1/${name}:generateIdToken`;
			const body = {
				delegates: this.delegates,
				audience: targetAudience,
				includeEmail: options?.includeEmail ?? true,
				useEmailAzp: options?.includeEmail ?? true
			};
			return (await this.sourceClient.request({
				...Impersonated.RETRY_CONFIG,
				url: u,
				data: body,
				method: "POST"
			})).data.token;
		}
	};
	exports.Impersonated = Impersonated;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/oauth2common.js
var require_oauth2common = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OAuthClientAuthHandler = void 0;
	exports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;
	const gaxios_1$8 = require_src$4();
	const crypto_1$3 = require_crypto();
	/** List of HTTP methods that accept request bodies. */
	const METHODS_SUPPORTING_REQUEST_BODY = [
		"PUT",
		"POST",
		"PATCH"
	];
	/**
	* Abstract class for handling client authentication in OAuth-based
	* operations.
	* When request-body client authentication is used, only application/json and
	* application/x-www-form-urlencoded content types for HTTP methods that support
	* request bodies are supported.
	*/
	var OAuthClientAuthHandler = class {
		#crypto = (0, crypto_1$3.createCrypto)();
		#clientAuthentication;
		transporter;
		/**
		* Instantiates an OAuth client authentication handler.
		* @param options The OAuth Client Auth Handler instance options. Passing an `ClientAuthentication` directly is **@DEPRECATED**.
		*/
		constructor(options) {
			if (options && "clientId" in options) {
				this.#clientAuthentication = options;
				this.transporter = new gaxios_1$8.Gaxios();
			} else {
				this.#clientAuthentication = options?.clientAuthentication;
				this.transporter = options?.transporter || new gaxios_1$8.Gaxios();
			}
		}
		/**
		* Applies client authentication on the OAuth request's headers or POST
		* body but does not process the request.
		* @param opts The GaxiosOptions whose headers or data are to be modified
		*   depending on the client authentication mechanism to be used.
		* @param bearerToken The optional bearer token to use for authentication.
		*   When this is used, no client authentication credentials are needed.
		*/
		applyClientAuthenticationOptions(opts, bearerToken) {
			opts.headers = gaxios_1$8.Gaxios.mergeHeaders(opts.headers);
			this.injectAuthenticatedHeaders(opts, bearerToken);
			if (!bearerToken) this.injectAuthenticatedRequestBody(opts);
		}
		/**
		* Applies client authentication on the request's header if either
		* basic authentication or bearer token authentication is selected.
		*
		* @param opts The GaxiosOptions whose headers or data are to be modified
		*   depending on the client authentication mechanism to be used.
		* @param bearerToken The optional bearer token to use for authentication.
		*   When this is used, no client authentication credentials are needed.
		*/
		injectAuthenticatedHeaders(opts, bearerToken) {
			if (bearerToken) opts.headers = gaxios_1$8.Gaxios.mergeHeaders(opts.headers, { authorization: `Bearer ${bearerToken}` });
			else if (this.#clientAuthentication?.confidentialClientType === "basic") {
				opts.headers = gaxios_1$8.Gaxios.mergeHeaders(opts.headers);
				const clientId = this.#clientAuthentication.clientId;
				const clientSecret = this.#clientAuthentication.clientSecret || "";
				const base64EncodedCreds = this.#crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);
				gaxios_1$8.Gaxios.mergeHeaders(opts.headers, { authorization: `Basic ${base64EncodedCreds}` });
			}
		}
		/**
		* Applies client authentication on the request's body if request-body
		* client authentication is selected.
		*
		* @param opts The GaxiosOptions whose headers or data are to be modified
		*   depending on the client authentication mechanism to be used.
		*/
		injectAuthenticatedRequestBody(opts) {
			if (this.#clientAuthentication?.confidentialClientType === "request-body") {
				const method = (opts.method || "GET").toUpperCase();
				if (!METHODS_SUPPORTING_REQUEST_BODY.includes(method)) throw new Error(`${method} HTTP method does not support ${this.#clientAuthentication.confidentialClientType} client authentication`);
				const contentType = new Headers(opts.headers).get("content-type");
				if (contentType?.startsWith("application/x-www-form-urlencoded") || opts.data instanceof URLSearchParams) {
					const data = new URLSearchParams(opts.data ?? "");
					data.append("client_id", this.#clientAuthentication.clientId);
					data.append("client_secret", this.#clientAuthentication.clientSecret || "");
					opts.data = data;
				} else if (contentType?.startsWith("application/json")) {
					opts.data = opts.data || {};
					Object.assign(opts.data, {
						client_id: this.#clientAuthentication.clientId,
						client_secret: this.#clientAuthentication.clientSecret || ""
					});
				} else throw new Error(`${contentType} content-types are not supported with ${this.#clientAuthentication.confidentialClientType} client authentication`);
			}
		}
		/**
		* Retry config for Auth-related requests.
		*
		* @remarks
		*
		* This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
		* config as some downstream APIs would prefer if customers explicitly enable retries,
		* such as GCS.
		*/
		static get RETRY_CONFIG() {
			return {
				retry: true,
				retryConfig: { httpMethodsToRetry: [
					"GET",
					"PUT",
					"POST",
					"HEAD",
					"OPTIONS",
					"DELETE"
				] }
			};
		}
	};
	exports.OAuthClientAuthHandler = OAuthClientAuthHandler;
	/**
	* Converts an OAuth error response to a native JavaScript Error.
	* @param resp The OAuth error response to convert to a native Error object.
	* @param err The optional original error. If provided, the error properties
	*   will be copied to the new error.
	* @return The converted native Error object.
	*/
	function getErrorFromOAuthErrorResponse(resp, err) {
		const errorCode = resp.error;
		const errorDescription = resp.error_description;
		const errorUri = resp.error_uri;
		let message = `Error code ${errorCode}`;
		if (typeof errorDescription !== "undefined") message += `: ${errorDescription}`;
		if (typeof errorUri !== "undefined") message += ` - ${errorUri}`;
		const newError = new Error(message);
		if (err) {
			const keys = Object.keys(err);
			if (err.stack) keys.push("stack");
			keys.forEach((key) => {
				if (key !== "message") Object.defineProperty(newError, key, {
					value: err[key],
					writable: false,
					enumerable: true
				});
			});
		}
		return newError;
	}
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/stscredentials.js
var require_stscredentials = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StsCredentials = void 0;
	const gaxios_1$7 = require_src$4();
	const authclient_1$8 = require_authclient();
	const oauth2common_1$1 = require_oauth2common();
	const util_1$6 = require_util();
	/**
	* Implements the OAuth 2.0 token exchange based on
	* https://tools.ietf.org/html/rfc8693
	*/
	var StsCredentials = class StsCredentials extends oauth2common_1$1.OAuthClientAuthHandler {
		#tokenExchangeEndpoint;
		/**
		* Initializes an STS credentials instance.
		*
		* @param options The STS credentials instance options. Passing an `tokenExchangeEndpoint` directly is **@DEPRECATED**.
		* @param clientAuthentication **@DEPRECATED**. Provide a {@link StsCredentialsConstructionOptions `StsCredentialsConstructionOptions`} object in the first parameter instead.
		*/
		constructor(options = { tokenExchangeEndpoint: "" }, clientAuthentication) {
			if (typeof options !== "object" || options instanceof URL) options = {
				tokenExchangeEndpoint: options,
				clientAuthentication
			};
			super(options);
			this.#tokenExchangeEndpoint = options.tokenExchangeEndpoint;
		}
		/**
		* Exchanges the provided token for another type of token based on the
		* rfc8693 spec.
		* @param stsCredentialsOptions The token exchange options used to populate
		*   the token exchange request.
		* @param additionalHeaders Optional additional headers to pass along the
		*   request.
		* @param options Optional additional GCP-specific non-spec defined options
		*   to send with the request.
		*   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`
		* @return A promise that resolves with the token exchange response containing
		*   the requested token and its expiration time.
		*/
		async exchangeToken(stsCredentialsOptions, headers, options) {
			const values = {
				grant_type: stsCredentialsOptions.grantType,
				resource: stsCredentialsOptions.resource,
				audience: stsCredentialsOptions.audience,
				scope: stsCredentialsOptions.scope?.join(" "),
				requested_token_type: stsCredentialsOptions.requestedTokenType,
				subject_token: stsCredentialsOptions.subjectToken,
				subject_token_type: stsCredentialsOptions.subjectTokenType,
				actor_token: stsCredentialsOptions.actingParty?.actorToken,
				actor_token_type: stsCredentialsOptions.actingParty?.actorTokenType,
				options: options && JSON.stringify(options)
			};
			const opts = {
				...StsCredentials.RETRY_CONFIG,
				url: this.#tokenExchangeEndpoint.toString(),
				method: "POST",
				headers,
				data: new URLSearchParams((0, util_1$6.removeUndefinedValuesInObject)(values))
			};
			authclient_1$8.AuthClient.setMethodName(opts, "exchangeToken");
			this.applyClientAuthenticationOptions(opts);
			try {
				const response = await this.transporter.request(opts);
				const stsSuccessfulResponse = response.data;
				stsSuccessfulResponse.res = response;
				return stsSuccessfulResponse;
			} catch (error$1) {
				if (error$1 instanceof gaxios_1$7.GaxiosError && error$1.response) throw (0, oauth2common_1$1.getErrorFromOAuthErrorResponse)(error$1.response.data, error$1);
				throw error$1;
			}
		}
	};
	exports.StsCredentials = StsCredentials;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/baseexternalclient.js
var require_baseexternalclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;
	const gaxios_1$6 = require_src$4();
	const stream$2 = require("stream");
	const authclient_1$7 = require_authclient();
	const sts$1 = require_stscredentials();
	const util_1$5 = require_util();
	const shared_cjs_1 = require_shared();
	/**
	* The required token exchange grant_type: rfc8693#section-2.1
	*/
	const STS_GRANT_TYPE$1 = "urn:ietf:params:oauth:grant-type:token-exchange";
	/**
	* The requested token exchange requested_token_type: rfc8693#section-2.1
	*/
	const STS_REQUEST_TOKEN_TYPE$1 = "urn:ietf:params:oauth:token-type:access_token";
	/** The default OAuth scope to request when none is provided. */
	const DEFAULT_OAUTH_SCOPE = "https://www.googleapis.com/auth/cloud-platform";
	/** Default impersonated token lifespan in seconds.*/
	const DEFAULT_TOKEN_LIFESPAN = 3600;
	/**
	* Offset to take into account network delays and server clock skews.
	*/
	exports.EXPIRATION_TIME_OFFSET = 300 * 1e3;
	/**
	* The credentials JSON file type for external account clients.
	* There are 3 types of JSON configs:
	* 1. authorized_user => Google end user credential
	* 2. service_account => Google service account credential
	* 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)
	*/
	exports.EXTERNAL_ACCOUNT_TYPE = "external_account";
	/**
	* Cloud resource manager URL used to retrieve project information.
	*
	* @deprecated use {@link BaseExternalAccountClient.cloudResourceManagerURL} instead
	**/
	exports.CLOUD_RESOURCE_MANAGER = "https://cloudresourcemanager.googleapis.com/v1/projects/";
	/** The workforce audience pattern. */
	const WORKFORCE_AUDIENCE_PATTERN = "//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+";
	const DEFAULT_TOKEN_URL$1 = "https://sts.{universeDomain}/v1/token";
	/**
	* Base external account client. This is used to instantiate AuthClients for
	* exchanging external account credentials for GCP access token and authorizing
	* requests to GCP APIs.
	* The base class implements common logic for exchanging various type of
	* external credentials for GCP access token. The logic of determining and
	* retrieving the external credential based on the environment and
	* credential_source will be left for the subclasses.
	*/
	var BaseExternalAccountClient = class BaseExternalAccountClient extends authclient_1$7.AuthClient {
		/**
		* OAuth scopes for the GCP access token to use. When not provided,
		* the default https://www.googleapis.com/auth/cloud-platform is
		* used.
		*/
		scopes;
		projectNumber;
		audience;
		subjectTokenType;
		stsCredential;
		clientAuth;
		credentialSourceType;
		cachedAccessToken;
		serviceAccountImpersonationUrl;
		serviceAccountImpersonationLifetime;
		workforcePoolUserProject;
		configLifetimeRequested;
		tokenUrl;
		/**
		* @example
		* ```ts
		* new URL('https://cloudresourcemanager.googleapis.com/v1/projects/');
		* ```
		*/
		cloudResourceManagerURL;
		supplierContext;
		/**
		* A pending access token request. Used for concurrent calls.
		*/
		#pendingAccessToken = null;
		/**
		* Instantiate a BaseExternalAccountClient instance using the provided JSON
		* object loaded from an external account credentials file.
		* @param options The external account options object typically loaded
		*   from the external account JSON credential file. The camelCased options
		*   are aliases for the snake_cased options.
		*/
		constructor(options) {
			super(options);
			const opts = (0, util_1$5.originalOrCamelOptions)(options);
			const type = opts.get("type");
			if (type && type !== exports.EXTERNAL_ACCOUNT_TYPE) throw new Error(`Expected "${exports.EXTERNAL_ACCOUNT_TYPE}" type but received "${options.type}"`);
			const clientId = opts.get("client_id");
			const clientSecret = opts.get("client_secret");
			this.tokenUrl = opts.get("token_url") ?? DEFAULT_TOKEN_URL$1.replace("{universeDomain}", this.universeDomain);
			const subjectTokenType = opts.get("subject_token_type");
			const workforcePoolUserProject = opts.get("workforce_pool_user_project");
			const serviceAccountImpersonationUrl = opts.get("service_account_impersonation_url");
			const serviceAccountImpersonation = opts.get("service_account_impersonation");
			const serviceAccountImpersonationLifetime = (0, util_1$5.originalOrCamelOptions)(serviceAccountImpersonation).get("token_lifetime_seconds");
			this.cloudResourceManagerURL = new URL(opts.get("cloud_resource_manager_url") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);
			if (clientId) this.clientAuth = {
				confidentialClientType: "basic",
				clientId,
				clientSecret
			};
			this.stsCredential = new sts$1.StsCredentials({
				tokenExchangeEndpoint: this.tokenUrl,
				clientAuthentication: this.clientAuth
			});
			this.scopes = opts.get("scopes") || [DEFAULT_OAUTH_SCOPE];
			this.cachedAccessToken = null;
			this.audience = opts.get("audience");
			this.subjectTokenType = subjectTokenType;
			this.workforcePoolUserProject = workforcePoolUserProject;
			const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);
			if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) throw new Error("workforcePoolUserProject should not be set for non-workforce pool credentials.");
			this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;
			this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;
			if (this.serviceAccountImpersonationLifetime) this.configLifetimeRequested = true;
			else {
				this.configLifetimeRequested = false;
				this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;
			}
			this.projectNumber = this.getProjectNumber(this.audience);
			this.supplierContext = {
				audience: this.audience,
				subjectTokenType: this.subjectTokenType,
				transporter: this.transporter
			};
		}
		/** The service account email to be impersonated, if available. */
		getServiceAccountEmail() {
			if (this.serviceAccountImpersonationUrl) {
				if (this.serviceAccountImpersonationUrl.length > 256)
 /**
				* Prevents DOS attacks.
				* @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/84}
				**/
				throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);
				return /serviceAccounts\/(?<email>[^:]+):generateAccessToken$/.exec(this.serviceAccountImpersonationUrl)?.groups?.email || null;
			}
			return null;
		}
		/**
		* Provides a mechanism to inject GCP access tokens directly.
		* When the provided credential expires, a new credential, using the
		* external account options, is retrieved.
		* @param credentials The Credentials object to set on the current client.
		*/
		setCredentials(credentials) {
			super.setCredentials(credentials);
			this.cachedAccessToken = credentials;
		}
		/**
		* @return A promise that resolves with the current GCP access token
		*   response. If the current credential is expired, a new one is retrieved.
		*/
		async getAccessToken() {
			if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) await this.refreshAccessTokenAsync();
			return {
				token: this.cachedAccessToken.access_token,
				res: this.cachedAccessToken.res
			};
		}
		/**
		* The main authentication interface. It takes an optional url which when
		* present is the endpoint being accessed, and returns a Promise which
		* resolves with authorization header fields.
		*
		* The result has the form:
		* { authorization: 'Bearer <access_token_value>' }
		*/
		async getRequestHeaders() {
			const accessTokenResponse = await this.getAccessToken();
			const headers = new Headers({ authorization: `Bearer ${accessTokenResponse.token}` });
			return this.addSharedMetadataHeaders(headers);
		}
		request(opts, callback) {
			if (callback) this.requestAsync(opts).then((r$1) => callback(null, r$1), (e$1) => {
				return callback(e$1, e$1.response);
			});
			else return this.requestAsync(opts);
		}
		/**
		* @return A promise that resolves with the project ID corresponding to the
		*   current workload identity pool or current workforce pool if
		*   determinable. For workforce pool credential, it returns the project ID
		*   corresponding to the workforcePoolUserProject.
		*   This is introduced to match the current pattern of using the Auth
		*   library:
		*   const projectId = await auth.getProjectId();
		*   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;
		*   const res = await client.request({ url });
		*   The resource may not have permission
		*   (resourcemanager.projects.get) to call this API or the required
		*   scopes may not be selected:
		*   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes
		*/
		async getProjectId() {
			const projectNumber = this.projectNumber || this.workforcePoolUserProject;
			if (this.projectId) return this.projectId;
			else if (projectNumber) {
				const headers = await this.getRequestHeaders();
				const opts = {
					...BaseExternalAccountClient.RETRY_CONFIG,
					headers,
					url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`
				};
				authclient_1$7.AuthClient.setMethodName(opts, "getProjectId");
				this.projectId = (await this.transporter.request(opts)).data.projectId;
				return this.projectId;
			}
			return null;
		}
		/**
		* Authenticates the provided HTTP request, processes it and resolves with the
		* returned response.
		* @param opts The HTTP request options.
		* @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
		* @return A promise that resolves with the successful response.
		*/
		async requestAsync(opts, reAuthRetried = false) {
			let response;
			try {
				const requestHeaders = await this.getRequestHeaders();
				opts.headers = gaxios_1$6.Gaxios.mergeHeaders(opts.headers);
				this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);
				response = await this.transporter.request(opts);
			} catch (e$1) {
				const res = e$1.response;
				if (res) {
					const statusCode = res.status;
					const isReadableStream = res.config.data instanceof stream$2.Readable;
					if (!reAuthRetried && (statusCode === 401 || statusCode === 403) && !isReadableStream && this.forceRefreshOnFailure) {
						await this.refreshAccessTokenAsync();
						return await this.requestAsync(opts, true);
					}
				}
				throw e$1;
			}
			return response;
		}
		/**
		* Forces token refresh, even if unexpired tokens are currently cached.
		* External credentials are exchanged for GCP access tokens via the token
		* exchange endpoint and other settings provided in the client options
		* object.
		* If the service_account_impersonation_url is provided, an additional
		* step to exchange the external account GCP access token for a service
		* account impersonated token is performed.
		* @return A promise that resolves with the fresh GCP access tokens.
		*/
		async refreshAccessTokenAsync() {
			this.#pendingAccessToken = this.#pendingAccessToken || this.#internalRefreshAccessTokenAsync();
			try {
				return await this.#pendingAccessToken;
			} finally {
				this.#pendingAccessToken = null;
			}
		}
		async #internalRefreshAccessTokenAsync() {
			const subjectToken = await this.retrieveSubjectToken();
			const stsCredentialsOptions = {
				grantType: STS_GRANT_TYPE$1,
				audience: this.audience,
				requestedTokenType: STS_REQUEST_TOKEN_TYPE$1,
				subjectToken,
				subjectTokenType: this.subjectTokenType,
				scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()
			};
			const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? { userProject: this.workforcePoolUserProject } : void 0;
			const additionalHeaders = new Headers({ "x-goog-api-client": this.getMetricsHeaderValue() });
			const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);
			if (this.serviceAccountImpersonationUrl) this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);
			else if (stsResponse.expires_in) this.cachedAccessToken = {
				access_token: stsResponse.access_token,
				expiry_date: (/* @__PURE__ */ new Date()).getTime() + stsResponse.expires_in * 1e3,
				res: stsResponse.res
			};
			else this.cachedAccessToken = {
				access_token: stsResponse.access_token,
				res: stsResponse.res
			};
			this.credentials = {};
			Object.assign(this.credentials, this.cachedAccessToken);
			delete this.credentials.res;
			this.emit("tokens", {
				refresh_token: null,
				expiry_date: this.cachedAccessToken.expiry_date,
				access_token: this.cachedAccessToken.access_token,
				token_type: "Bearer",
				id_token: null
			});
			return this.cachedAccessToken;
		}
		/**
		* Returns the workload identity pool project number if it is determinable
		* from the audience resource name.
		* @param audience The STS audience used to determine the project number.
		* @return The project number associated with the workload identity pool, if
		*   this can be determined from the STS audience field. Otherwise, null is
		*   returned.
		*/
		getProjectNumber(audience) {
			const match = audience.match(/\/projects\/([^/]+)/);
			if (!match) return null;
			return match[1];
		}
		/**
		* Exchanges an external account GCP access token for a service
		* account impersonated access token using iamcredentials
		* GenerateAccessToken API.
		* @param token The access token to exchange for a service account access
		*   token.
		* @return A promise that resolves with the service account impersonated
		*   credentials response.
		*/
		async getImpersonatedAccessToken(token) {
			const opts = {
				...BaseExternalAccountClient.RETRY_CONFIG,
				url: this.serviceAccountImpersonationUrl,
				method: "POST",
				headers: {
					"content-type": "application/json",
					authorization: `Bearer ${token}`
				},
				data: {
					scope: this.getScopesArray(),
					lifetime: this.serviceAccountImpersonationLifetime + "s"
				}
			};
			authclient_1$7.AuthClient.setMethodName(opts, "getImpersonatedAccessToken");
			const response = await this.transporter.request(opts);
			const successResponse = response.data;
			return {
				access_token: successResponse.accessToken,
				expiry_date: new Date(successResponse.expireTime).getTime(),
				res: response
			};
		}
		/**
		* Returns whether the provided credentials are expired or not.
		* If there is no expiry time, assumes the token is not expired or expiring.
		* @param accessToken The credentials to check for expiration.
		* @return Whether the credentials are expired or not.
		*/
		isExpired(accessToken) {
			const now = (/* @__PURE__ */ new Date()).getTime();
			return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
		}
		/**
		* @return The list of scopes for the requested GCP access token.
		*/
		getScopesArray() {
			if (typeof this.scopes === "string") return [this.scopes];
			return this.scopes || [DEFAULT_OAUTH_SCOPE];
		}
		getMetricsHeaderValue() {
			const nodeVersion = process.version.replace(/^v/, "");
			const saImpersonation = this.serviceAccountImpersonationUrl !== void 0;
			const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : "unknown";
			return `gl-node/${nodeVersion} auth/${shared_cjs_1.pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;
		}
		getTokenUrl() {
			return this.tokenUrl;
		}
	};
	exports.BaseExternalAccountClient = BaseExternalAccountClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js
var require_filesubjecttokensupplier = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FileSubjectTokenSupplier = void 0;
	const util_1$4 = require("util");
	const fs$4 = require("fs");
	const readFile = (0, util_1$4.promisify)(fs$4.readFile ?? (() => {}));
	const realpath = (0, util_1$4.promisify)(fs$4.realpath ?? (() => {}));
	const lstat = (0, util_1$4.promisify)(fs$4.lstat ?? (() => {}));
	/**
	* Internal subject token supplier implementation used when a file location
	* is configured in the credential configuration used to build an {@link IdentityPoolClient}
	*/
	var FileSubjectTokenSupplier = class {
		filePath;
		formatType;
		subjectTokenFieldName;
		/**
		* Instantiates a new file based subject token supplier.
		* @param opts The file subject token supplier options to build the supplier
		*   with.
		*/
		constructor(opts) {
			this.filePath = opts.filePath;
			this.formatType = opts.formatType;
			this.subjectTokenFieldName = opts.subjectTokenFieldName;
		}
		/**
		* Returns the subject token stored at the file specified in the constructor.
		* @param context {@link ExternalAccountSupplierContext} from the calling
		*   {@link IdentityPoolClient}, contains the requested audience and subject
		*   token type for the external account identity. Not used.
		*/
		async getSubjectToken() {
			let parsedFilePath = this.filePath;
			try {
				parsedFilePath = await realpath(parsedFilePath);
				if (!(await lstat(parsedFilePath)).isFile()) throw new Error();
			} catch (err) {
				if (err instanceof Error) err.message = `The file at ${parsedFilePath} does not exist, or it is not a file. ${err.message}`;
				throw err;
			}
			let subjectToken;
			const rawText = await readFile(parsedFilePath, { encoding: "utf8" });
			if (this.formatType === "text") subjectToken = rawText;
			else if (this.formatType === "json" && this.subjectTokenFieldName) subjectToken = JSON.parse(rawText)[this.subjectTokenFieldName];
			if (!subjectToken) throw new Error("Unable to parse the subject_token from the credential_source file");
			return subjectToken;
		}
	};
	exports.FileSubjectTokenSupplier = FileSubjectTokenSupplier;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js
var require_urlsubjecttokensupplier = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.UrlSubjectTokenSupplier = void 0;
	const authclient_1$6 = require_authclient();
	/**
	* Internal subject token supplier implementation used when a URL
	* is configured in the credential configuration used to build an {@link IdentityPoolClient}
	*/
	var UrlSubjectTokenSupplier = class {
		url;
		headers;
		formatType;
		subjectTokenFieldName;
		additionalGaxiosOptions;
		/**
		* Instantiates a URL subject token supplier.
		* @param opts The URL subject token supplier options to build the supplier with.
		*/
		constructor(opts) {
			this.url = opts.url;
			this.formatType = opts.formatType;
			this.subjectTokenFieldName = opts.subjectTokenFieldName;
			this.headers = opts.headers;
			this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
		}
		/**
		* Sends a GET request to the URL provided in the constructor and resolves
		* with the returned external subject token.
		* @param context {@link ExternalAccountSupplierContext} from the calling
		*   {@link IdentityPoolClient}, contains the requested audience and subject
		*   token type for the external account identity. Not used.
		*/
		async getSubjectToken(context) {
			const opts = {
				...this.additionalGaxiosOptions,
				url: this.url,
				method: "GET",
				headers: this.headers
			};
			authclient_1$6.AuthClient.setMethodName(opts, "getSubjectToken");
			let subjectToken;
			if (this.formatType === "text") subjectToken = (await context.transporter.request(opts)).data;
			else if (this.formatType === "json" && this.subjectTokenFieldName) subjectToken = (await context.transporter.request(opts)).data[this.subjectTokenFieldName];
			if (!subjectToken) throw new Error("Unable to parse the subject_token from the credential_source URL");
			return subjectToken;
		}
	};
	exports.UrlSubjectTokenSupplier = UrlSubjectTokenSupplier;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/certificatesubjecttokensupplier.js
var require_certificatesubjecttokensupplier = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CertificateSubjectTokenSupplier = exports.InvalidConfigurationError = exports.CertificateSourceUnavailableError = exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = void 0;
	const util_1$3 = require_util();
	const fs$3 = require("fs");
	const crypto_1$2 = require("crypto");
	const https$1 = require("https");
	exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = "GOOGLE_API_CERTIFICATE_CONFIG";
	/**
	* Thrown when the certificate source cannot be located or accessed.
	*/
	var CertificateSourceUnavailableError = class extends Error {
		constructor(message) {
			super(message);
			this.name = "CertificateSourceUnavailableError";
		}
	};
	exports.CertificateSourceUnavailableError = CertificateSourceUnavailableError;
	/**
	* Thrown for invalid configuration that is not related to file availability.
	*/
	var InvalidConfigurationError = class extends Error {
		constructor(message) {
			super(message);
			this.name = "InvalidConfigurationError";
		}
	};
	exports.InvalidConfigurationError = InvalidConfigurationError;
	/**
	* A subject token supplier that uses a client certificate for authentication.
	* It provides the certificate chain as the subject token for identity federation.
	*/
	var CertificateSubjectTokenSupplier = class {
		certificateConfigPath;
		trustChainPath;
		cert;
		key;
		/**
		* Initializes a new instance of the CertificateSubjectTokenSupplier.
		* @param opts The configuration options for the supplier.
		*/
		constructor(opts) {
			if (!opts.useDefaultCertificateConfig && !opts.certificateConfigLocation) throw new InvalidConfigurationError("Either `useDefaultCertificateConfig` must be true or a `certificateConfigLocation` must be provided.");
			if (opts.useDefaultCertificateConfig && opts.certificateConfigLocation) throw new InvalidConfigurationError("Both `useDefaultCertificateConfig` and `certificateConfigLocation` cannot be provided.");
			this.trustChainPath = opts.trustChainPath;
			this.certificateConfigPath = opts.certificateConfigLocation ?? "";
		}
		/**
		* Creates an HTTPS agent configured with the client certificate and private key for mTLS.
		* @returns An mTLS-configured https.Agent.
		*/
		async createMtlsHttpsAgent() {
			if (!this.key || !this.cert) throw new InvalidConfigurationError("Cannot create mTLS Agent with missing certificate or key");
			return new https$1.Agent({
				key: this.key,
				cert: this.cert
			});
		}
		/**
		* Constructs the subject token, which is the base64-encoded certificate chain.
		* @returns A promise that resolves with the subject token.
		*/
		async getSubjectToken() {
			this.certificateConfigPath = await this.#resolveCertificateConfigFilePath();
			const { certPath, keyPath } = await this.#getCertAndKeyPaths();
			({cert: this.cert, key: this.key} = await this.#getKeyAndCert(certPath, keyPath));
			return await this.#processChainFromPaths(this.cert);
		}
		/**
		* Resolves the absolute path to the certificate configuration file
		* by checking the "certificate_config_location" provided in the ADC file,
		* or the "GOOGLE_API_CERTIFICATE_CONFIG" environment variable
		* or in the default gcloud path.
		* @param overridePath An optional path to check first.
		* @returns The resolved file path.
		*/
		async #resolveCertificateConfigFilePath() {
			const overridePath = this.certificateConfigPath;
			if (overridePath) {
				if (await (0, util_1$3.isValidFile)(overridePath)) return overridePath;
				throw new CertificateSourceUnavailableError(`Provided certificate config path is invalid: ${overridePath}`);
			}
			const envPath = process.env[exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE];
			if (envPath) {
				if (await (0, util_1$3.isValidFile)(envPath)) return envPath;
				throw new CertificateSourceUnavailableError(`Path from environment variable "${exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}" is invalid: ${envPath}`);
			}
			const wellKnownPath = (0, util_1$3.getWellKnownCertificateConfigFileLocation)();
			if (await (0, util_1$3.isValidFile)(wellKnownPath)) return wellKnownPath;
			throw new CertificateSourceUnavailableError(`Could not find certificate configuration file. Searched override path, the "${exports.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}" env var, and the gcloud path (${wellKnownPath}).`);
		}
		/**
		* Reads and parses the certificate config JSON file to extract the certificate and key paths.
		* @returns An object containing the certificate and key paths.
		*/
		async #getCertAndKeyPaths() {
			const configPath = this.certificateConfigPath;
			let fileContents;
			try {
				fileContents = await fs$3.promises.readFile(configPath, "utf8");
			} catch (err) {
				throw new CertificateSourceUnavailableError(`Failed to read certificate config file at: ${configPath}`);
			}
			try {
				const config = JSON.parse(fileContents);
				const certPath = config?.cert_configs?.workload?.cert_path;
				const keyPath = config?.cert_configs?.workload?.key_path;
				if (!certPath || !keyPath) throw new InvalidConfigurationError(`Certificate config file (${configPath}) is missing required "cert_path" or "key_path" in the workload config.`);
				return {
					certPath,
					keyPath
				};
			} catch (e$1) {
				if (e$1 instanceof InvalidConfigurationError) throw e$1;
				throw new InvalidConfigurationError(`Failed to parse certificate config from ${configPath}: ${e$1.message}`);
			}
		}
		/**
		* Reads and parses the cert and key files get their content and check valid format.
		* @returns An object containing the cert content and key content in buffer format.
		*/
		async #getKeyAndCert(certPath, keyPath) {
			let cert, key;
			try {
				cert = await fs$3.promises.readFile(certPath);
				new crypto_1$2.X509Certificate(cert);
			} catch (err) {
				throw new CertificateSourceUnavailableError(`Failed to read certificate file at ${certPath}: ${err instanceof Error ? err.message : String(err)}`);
			}
			try {
				key = await fs$3.promises.readFile(keyPath);
				(0, crypto_1$2.createPrivateKey)(key);
			} catch (err) {
				throw new CertificateSourceUnavailableError(`Failed to read private key file at ${keyPath}: ${err instanceof Error ? err.message : String(err)}`);
			}
			return {
				cert,
				key
			};
		}
		/**
		* Reads the leaf certificate and trust chain, combines them,
		* and returns a JSON array of base64-encoded certificates.
		* @returns A stringified JSON array of the certificate chain.
		*/
		async #processChainFromPaths(leafCertBuffer) {
			const leafCert = new crypto_1$2.X509Certificate(leafCertBuffer);
			if (!this.trustChainPath) return JSON.stringify([leafCert.raw.toString("base64")]);
			try {
				const chainCerts = ((await fs$3.promises.readFile(this.trustChainPath, "utf8")).match(/-----BEGIN CERTIFICATE-----[^-]+-----END CERTIFICATE-----/g) ?? []).map((pem, index) => {
					try {
						return new crypto_1$2.X509Certificate(pem);
					} catch (err) {
						const message = err instanceof Error ? err.message : String(err);
						throw new InvalidConfigurationError(`Failed to parse certificate at index ${index} in trust chain file ${this.trustChainPath}: ${message}`);
					}
				});
				const leafIndex = chainCerts.findIndex((chainCert) => leafCert.raw.equals(chainCert.raw));
				let finalChain;
				if (leafIndex === -1) finalChain = [leafCert, ...chainCerts];
				else if (leafIndex === 0) finalChain = chainCerts;
				else throw new InvalidConfigurationError(`Leaf certificate exists in the trust chain but is not the first entry (found at index ${leafIndex}).`);
				return JSON.stringify(finalChain.map((cert) => cert.raw.toString("base64")));
			} catch (err) {
				if (err instanceof InvalidConfigurationError) throw err;
				const message = err instanceof Error ? err.message : String(err);
				throw new CertificateSourceUnavailableError(`Failed to process certificate chain from ${this.trustChainPath}: ${message}`);
			}
		}
	};
	exports.CertificateSubjectTokenSupplier = CertificateSubjectTokenSupplier;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/identitypoolclient.js
var require_identitypoolclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IdentityPoolClient = void 0;
	const baseexternalclient_1$6 = require_baseexternalclient();
	const util_1$2 = require_util();
	const filesubjecttokensupplier_1 = require_filesubjecttokensupplier();
	const urlsubjecttokensupplier_1 = require_urlsubjecttokensupplier();
	const certificatesubjecttokensupplier_1 = require_certificatesubjecttokensupplier();
	const stscredentials_1 = require_stscredentials();
	const gaxios_1$5 = require_src$4();
	/**
	* Defines the Url-sourced and file-sourced external account clients mainly
	* used for K8s and Azure workloads.
	*/
	var IdentityPoolClient = class IdentityPoolClient extends baseexternalclient_1$6.BaseExternalAccountClient {
		subjectTokenSupplier;
		/**
		* Instantiate an IdentityPoolClient instance using the provided JSON
		* object loaded from an external account credentials file.
		* An error is thrown if the credential is not a valid file-sourced or
		* url-sourced credential or a workforce pool user project is provided
		* with a non workforce audience.
		* @param options The external account options object typically loaded
		*   from the external account JSON credential file. The camelCased options
		*   are aliases for the snake_cased options.
		*/
		constructor(options) {
			super(options);
			const opts = (0, util_1$2.originalOrCamelOptions)(options);
			const credentialSource = opts.get("credential_source");
			const subjectTokenSupplier = opts.get("subject_token_supplier");
			if (!credentialSource && !subjectTokenSupplier) throw new Error("A credential source or subject token supplier must be specified.");
			if (credentialSource && subjectTokenSupplier) throw new Error("Only one of credential source or subject token supplier can be specified.");
			if (subjectTokenSupplier) {
				this.subjectTokenSupplier = subjectTokenSupplier;
				this.credentialSourceType = "programmatic";
			} else {
				const credentialSourceOpts = (0, util_1$2.originalOrCamelOptions)(credentialSource);
				const formatOpts = (0, util_1$2.originalOrCamelOptions)(credentialSourceOpts.get("format"));
				const formatType = formatOpts.get("type") || "text";
				const formatSubjectTokenFieldName = formatOpts.get("subject_token_field_name");
				if (formatType !== "json" && formatType !== "text") throw new Error(`Invalid credential_source format "${formatType}"`);
				if (formatType === "json" && !formatSubjectTokenFieldName) throw new Error("Missing subject_token_field_name for JSON credential_source format");
				const file = credentialSourceOpts.get("file");
				const url = credentialSourceOpts.get("url");
				const certificate = credentialSourceOpts.get("certificate");
				const headers = credentialSourceOpts.get("headers");
				if (file && url || url && certificate || file && certificate) throw new Error("No valid Identity Pool \"credential_source\" provided, must be either file, url, or certificate.");
				else if (file) {
					this.credentialSourceType = "file";
					this.subjectTokenSupplier = new filesubjecttokensupplier_1.FileSubjectTokenSupplier({
						filePath: file,
						formatType,
						subjectTokenFieldName: formatSubjectTokenFieldName
					});
				} else if (url) {
					this.credentialSourceType = "url";
					this.subjectTokenSupplier = new urlsubjecttokensupplier_1.UrlSubjectTokenSupplier({
						url,
						formatType,
						subjectTokenFieldName: formatSubjectTokenFieldName,
						headers,
						additionalGaxiosOptions: IdentityPoolClient.RETRY_CONFIG
					});
				} else if (certificate) {
					this.credentialSourceType = "certificate";
					this.subjectTokenSupplier = new certificatesubjecttokensupplier_1.CertificateSubjectTokenSupplier({
						useDefaultCertificateConfig: certificate.use_default_certificate_config,
						certificateConfigLocation: certificate.certificate_config_location,
						trustChainPath: certificate.trust_chain_path
					});
				} else throw new Error("No valid Identity Pool \"credential_source\" provided, must be either file, url, or certificate.");
			}
		}
		/**
		* Triggered when a external subject token is needed to be exchanged for a GCP
		* access token via GCP STS endpoint. Gets a subject token by calling
		* the configured {@link SubjectTokenSupplier}
		* @return A promise that resolves with the external subject token.
		*/
		async retrieveSubjectToken() {
			const subjectToken = await this.subjectTokenSupplier.getSubjectToken(this.supplierContext);
			if (this.subjectTokenSupplier instanceof certificatesubjecttokensupplier_1.CertificateSubjectTokenSupplier) {
				const mtlsAgent = await this.subjectTokenSupplier.createMtlsHttpsAgent();
				this.stsCredential = new stscredentials_1.StsCredentials({
					tokenExchangeEndpoint: this.getTokenUrl(),
					clientAuthentication: this.clientAuth,
					transporter: new gaxios_1$5.Gaxios({ agent: mtlsAgent })
				});
				this.transporter = new gaxios_1$5.Gaxios({
					...this.transporter.defaults || {},
					agent: mtlsAgent
				});
			}
			return subjectToken;
		}
	};
	exports.IdentityPoolClient = IdentityPoolClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/awsrequestsigner.js
var require_awsrequestsigner = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AwsRequestSigner = void 0;
	const gaxios_1$4 = require_src$4();
	const crypto_1$1 = require_crypto();
	/** AWS Signature Version 4 signing algorithm identifier.  */
	const AWS_ALGORITHM = "AWS4-HMAC-SHA256";
	/**
	* The termination string for the AWS credential scope value as defined in
	* https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html
	*/
	const AWS_REQUEST_TYPE = "aws4_request";
	/**
	* Implements an AWS API request signer based on the AWS Signature Version 4
	* signing process.
	* https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
	*/
	var AwsRequestSigner = class {
		getCredentials;
		region;
		crypto;
		/**
		* Instantiates an AWS API request signer used to send authenticated signed
		* requests to AWS APIs based on the AWS Signature Version 4 signing process.
		* This also provides a mechanism to generate the signed request without
		* sending it.
		* @param getCredentials A mechanism to retrieve AWS security credentials
		*   when needed.
		* @param region The AWS region to use.
		*/
		constructor(getCredentials, region) {
			this.getCredentials = getCredentials;
			this.region = region;
			this.crypto = (0, crypto_1$1.createCrypto)();
		}
		/**
		* Generates the signed request for the provided HTTP request for calling
		* an AWS API. This follows the steps described at:
		* https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
		* @param amzOptions The AWS request options that need to be signed.
		* @return A promise that resolves with the GaxiosOptions containing the
		*   signed HTTP request parameters.
		*/
		async getRequestOptions(amzOptions) {
			if (!amzOptions.url) throw new RangeError("\"url\" is required in \"amzOptions\"");
			const requestPayloadData = typeof amzOptions.data === "object" ? JSON.stringify(amzOptions.data) : amzOptions.data;
			const url = amzOptions.url;
			const method = amzOptions.method || "GET";
			const requestPayload = amzOptions.body || requestPayloadData;
			const additionalAmzHeaders = amzOptions.headers;
			const awsSecurityCredentials = await this.getCredentials();
			const uri = new URL(url);
			if (typeof requestPayload !== "string" && requestPayload !== void 0) throw new TypeError(`'requestPayload' is expected to be a string if provided. Got: ${requestPayload}`);
			const headerMap = await generateAuthenticationHeaderMap({
				crypto: this.crypto,
				host: uri.host,
				canonicalUri: uri.pathname,
				canonicalQuerystring: uri.search.slice(1),
				method,
				region: this.region,
				securityCredentials: awsSecurityCredentials,
				requestPayload,
				additionalAmzHeaders
			});
			const headers = gaxios_1$4.Gaxios.mergeHeaders(headerMap.amzDate ? { "x-amz-date": headerMap.amzDate } : {}, {
				authorization: headerMap.authorizationHeader,
				host: uri.host
			}, additionalAmzHeaders || {});
			if (awsSecurityCredentials.token) gaxios_1$4.Gaxios.mergeHeaders(headers, { "x-amz-security-token": awsSecurityCredentials.token });
			const awsSignedReq = {
				url,
				method,
				headers
			};
			if (requestPayload !== void 0) awsSignedReq.body = requestPayload;
			return awsSignedReq;
		}
	};
	exports.AwsRequestSigner = AwsRequestSigner;
	/**
	* Creates the HMAC-SHA256 hash of the provided message using the
	* provided key.
	*
	* @param crypto The crypto instance used to facilitate cryptographic
	*   operations.
	* @param key The HMAC-SHA256 key to use.
	* @param msg The message to hash.
	* @return The computed hash bytes.
	*/
	async function sign(crypto$7, key, msg) {
		return await crypto$7.signWithHmacSha256(key, msg);
	}
	/**
	* Calculates the signing key used to calculate the signature for
	* AWS Signature Version 4 based on:
	* https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html
	*
	* @param crypto The crypto instance used to facilitate cryptographic
	*   operations.
	* @param key The AWS secret access key.
	* @param dateStamp The '%Y%m%d' date format.
	* @param region The AWS region.
	* @param serviceName The AWS service name, eg. sts.
	* @return The signing key bytes.
	*/
	async function getSigningKey(crypto$7, key, dateStamp, region, serviceName) {
		return await sign(crypto$7, await sign(crypto$7, await sign(crypto$7, await sign(crypto$7, `AWS4${key}`, dateStamp), region), serviceName), "aws4_request");
	}
	/**
	* Generates the authentication header map needed for generating the AWS
	* Signature Version 4 signed request.
	*
	* @param option The options needed to compute the authentication header map.
	* @return The AWS authentication header map which constitutes of the following
	*   components: amz-date, authorization header and canonical query string.
	*/
	async function generateAuthenticationHeaderMap(options) {
		const additionalAmzHeaders = gaxios_1$4.Gaxios.mergeHeaders(options.additionalAmzHeaders);
		const requestPayload = options.requestPayload || "";
		const serviceName = options.host.split(".")[0];
		const now = /* @__PURE__ */ new Date();
		const amzDate = now.toISOString().replace(/[-:]/g, "").replace(/\.[0-9]+/, "");
		const dateStamp = now.toISOString().replace(/[-]/g, "").replace(/T.*/, "");
		if (options.securityCredentials.token) additionalAmzHeaders.set("x-amz-security-token", options.securityCredentials.token);
		const amzHeaders = gaxios_1$4.Gaxios.mergeHeaders({ host: options.host }, additionalAmzHeaders.has("date") ? {} : { "x-amz-date": amzDate }, additionalAmzHeaders);
		let canonicalHeaders = "";
		const signedHeadersList = [...amzHeaders.keys()].sort();
		signedHeadersList.forEach((key) => {
			canonicalHeaders += `${key}:${amzHeaders.get(key)}\n`;
		});
		const signedHeaders = signedHeadersList.join(";");
		const payloadHash = await options.crypto.sha256DigestHex(requestPayload);
		const canonicalRequest = `${options.method.toUpperCase()}\n${options.canonicalUri}\n${options.canonicalQuerystring}\n${canonicalHeaders}\n${signedHeaders}\n${payloadHash}`;
		const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;
		const stringToSign = `${AWS_ALGORITHM}\n${amzDate}\n${credentialScope}\n` + await options.crypto.sha256DigestHex(canonicalRequest);
		const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);
		const signature = await sign(options.crypto, signingKey, stringToSign);
		const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${(0, crypto_1$1.fromArrayBufferToHex)(signature)}`;
		return {
			amzDate: additionalAmzHeaders.has("date") ? void 0 : amzDate,
			authorizationHeader,
			canonicalQuerystring: options.canonicalQuerystring
		};
	}
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js
var require_defaultawssecuritycredentialssupplier = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DefaultAwsSecurityCredentialsSupplier = void 0;
	const authclient_1$5 = require_authclient();
	/**
	* Internal AWS security credentials supplier implementation used by {@link AwsClient}
	* when a credential source is provided instead of a user defined supplier.
	* The logic is summarized as:
	* 1. If imdsv2_session_token_url is provided in the credential source, then
	*    fetch the aws session token and include it in the headers of the
	*    metadata requests. This is a requirement for IDMSv2 but optional
	*    for IDMSv1.
	* 2. Retrieve AWS region from availability-zone.
	* 3a. Check AWS credentials in environment variables. If not found, get
	*     from security-credentials endpoint.
	* 3b. Get AWS credentials from security-credentials endpoint. In order
	*     to retrieve this, the AWS role needs to be determined by calling
	*     security-credentials endpoint without any argument. Then the
	*     credentials can be retrieved via: security-credentials/role_name
	* 4. Generate the signed request to AWS STS GetCallerIdentity action.
	* 5. Inject x-goog-cloud-target-resource into header and serialize the
	*    signed request. This will be the subject-token to pass to GCP STS.
	*/
	var DefaultAwsSecurityCredentialsSupplier = class {
		regionUrl;
		securityCredentialsUrl;
		imdsV2SessionTokenUrl;
		additionalGaxiosOptions;
		/**
		* Instantiates a new DefaultAwsSecurityCredentialsSupplier using information
		* from the credential_source stored in the ADC file.
		* @param opts The default aws security credentials supplier options object to
		*   build the supplier with.
		*/
		constructor(opts) {
			this.regionUrl = opts.regionUrl;
			this.securityCredentialsUrl = opts.securityCredentialsUrl;
			this.imdsV2SessionTokenUrl = opts.imdsV2SessionTokenUrl;
			this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
		}
		/**
		* Returns the active AWS region. This first checks to see if the region
		* is available as an environment variable. If it is not, then the supplier
		* will call the region URL.
		* @param context {@link ExternalAccountSupplierContext} from the calling
		*   {@link AwsClient}, contains the requested audience and subject token type
		*   for the external account identity.
		* @return A promise that resolves with the AWS region string.
		*/
		async getAwsRegion(context) {
			if (this.#regionFromEnv) return this.#regionFromEnv;
			const metadataHeaders = new Headers();
			if (!this.#regionFromEnv && this.imdsV2SessionTokenUrl) metadataHeaders.set("x-aws-ec2-metadata-token", await this.#getImdsV2SessionToken(context.transporter));
			if (!this.regionUrl) throw new RangeError("Unable to determine AWS region due to missing \"options.credential_source.region_url\"");
			const opts = {
				...this.additionalGaxiosOptions,
				url: this.regionUrl,
				method: "GET",
				headers: metadataHeaders
			};
			authclient_1$5.AuthClient.setMethodName(opts, "getAwsRegion");
			const response = await context.transporter.request(opts);
			return response.data.substr(0, response.data.length - 1);
		}
		/**
		* Returns AWS security credentials. This first checks to see if the credentials
		* is available as environment variables. If it is not, then the supplier
		* will call the security credentials URL.
		* @param context {@link ExternalAccountSupplierContext} from the calling
		*   {@link AwsClient}, contains the requested audience and subject token type
		*   for the external account identity.
		* @return A promise that resolves with the AWS security credentials.
		*/
		async getAwsSecurityCredentials(context) {
			if (this.#securityCredentialsFromEnv) return this.#securityCredentialsFromEnv;
			const metadataHeaders = new Headers();
			if (this.imdsV2SessionTokenUrl) metadataHeaders.set("x-aws-ec2-metadata-token", await this.#getImdsV2SessionToken(context.transporter));
			const roleName = await this.#getAwsRoleName(metadataHeaders, context.transporter);
			const awsCreds = await this.#retrieveAwsSecurityCredentials(roleName, metadataHeaders, context.transporter);
			return {
				accessKeyId: awsCreds.AccessKeyId,
				secretAccessKey: awsCreds.SecretAccessKey,
				token: awsCreds.Token
			};
		}
		/**
		* @param transporter The transporter to use for requests.
		* @return A promise that resolves with the IMDSv2 Session Token.
		*/
		async #getImdsV2SessionToken(transporter) {
			const opts = {
				...this.additionalGaxiosOptions,
				url: this.imdsV2SessionTokenUrl,
				method: "PUT",
				headers: { "x-aws-ec2-metadata-token-ttl-seconds": "300" }
			};
			authclient_1$5.AuthClient.setMethodName(opts, "#getImdsV2SessionToken");
			return (await transporter.request(opts)).data;
		}
		/**
		* @param headers The headers to be used in the metadata request.
		* @param transporter The transporter to use for requests.
		* @return A promise that resolves with the assigned role to the current
		*   AWS VM. This is needed for calling the security-credentials endpoint.
		*/
		async #getAwsRoleName(headers, transporter) {
			if (!this.securityCredentialsUrl) throw new Error("Unable to determine AWS role name due to missing \"options.credential_source.url\"");
			const opts = {
				...this.additionalGaxiosOptions,
				url: this.securityCredentialsUrl,
				method: "GET",
				headers
			};
			authclient_1$5.AuthClient.setMethodName(opts, "#getAwsRoleName");
			return (await transporter.request(opts)).data;
		}
		/**
		* Retrieves the temporary AWS credentials by calling the security-credentials
		* endpoint as specified in the `credential_source` object.
		* @param roleName The role attached to the current VM.
		* @param headers The headers to be used in the metadata request.
		* @param transporter The transporter to use for requests.
		* @return A promise that resolves with the temporary AWS credentials
		*   needed for creating the GetCallerIdentity signed request.
		*/
		async #retrieveAwsSecurityCredentials(roleName, headers, transporter) {
			const opts = {
				...this.additionalGaxiosOptions,
				url: `${this.securityCredentialsUrl}/${roleName}`,
				headers
			};
			authclient_1$5.AuthClient.setMethodName(opts, "#retrieveAwsSecurityCredentials");
			return (await transporter.request(opts)).data;
		}
		get #regionFromEnv() {
			return process.env["AWS_REGION"] || process.env["AWS_DEFAULT_REGION"] || null;
		}
		get #securityCredentialsFromEnv() {
			if (process.env["AWS_ACCESS_KEY_ID"] && process.env["AWS_SECRET_ACCESS_KEY"]) return {
				accessKeyId: process.env["AWS_ACCESS_KEY_ID"],
				secretAccessKey: process.env["AWS_SECRET_ACCESS_KEY"],
				token: process.env["AWS_SESSION_TOKEN"]
			};
			return null;
		}
	};
	exports.DefaultAwsSecurityCredentialsSupplier = DefaultAwsSecurityCredentialsSupplier;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/awsclient.js
var require_awsclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AwsClient = void 0;
	const awsrequestsigner_1$1 = require_awsrequestsigner();
	const baseexternalclient_1$5 = require_baseexternalclient();
	const defaultawssecuritycredentialssupplier_1 = require_defaultawssecuritycredentialssupplier();
	const util_1$1 = require_util();
	const gaxios_1$3 = require_src$4();
	/**
	* AWS external account client. This is used for AWS workloads, where
	* AWS STS GetCallerIdentity serialized signed requests are exchanged for
	* GCP access token.
	*/
	var AwsClient = class AwsClient extends baseexternalclient_1$5.BaseExternalAccountClient {
		environmentId;
		awsSecurityCredentialsSupplier;
		regionalCredVerificationUrl;
		awsRequestSigner;
		region;
		static #DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL = "https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15";
		/**
		* @deprecated AWS client no validates the EC2 metadata address.
		**/
		static AWS_EC2_METADATA_IPV4_ADDRESS = "169.254.169.254";
		/**
		* @deprecated AWS client no validates the EC2 metadata address.
		**/
		static AWS_EC2_METADATA_IPV6_ADDRESS = "fd00:ec2::254";
		/**
		* Instantiates an AwsClient instance using the provided JSON
		* object loaded from an external account credentials file.
		* An error is thrown if the credential is not a valid AWS credential.
		* @param options The external account options object typically loaded
		*   from the external account JSON credential file.
		*/
		constructor(options) {
			super(options);
			const opts = (0, util_1$1.originalOrCamelOptions)(options);
			const credentialSource = opts.get("credential_source");
			const awsSecurityCredentialsSupplier = opts.get("aws_security_credentials_supplier");
			if (!credentialSource && !awsSecurityCredentialsSupplier) throw new Error("A credential source or AWS security credentials supplier must be specified.");
			if (credentialSource && awsSecurityCredentialsSupplier) throw new Error("Only one of credential source or AWS security credentials supplier can be specified.");
			if (awsSecurityCredentialsSupplier) {
				this.awsSecurityCredentialsSupplier = awsSecurityCredentialsSupplier;
				this.regionalCredVerificationUrl = AwsClient.#DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL;
				this.credentialSourceType = "programmatic";
			} else {
				const credentialSourceOpts = (0, util_1$1.originalOrCamelOptions)(credentialSource);
				this.environmentId = credentialSourceOpts.get("environment_id");
				const regionUrl = credentialSourceOpts.get("region_url");
				const securityCredentialsUrl = credentialSourceOpts.get("url");
				const imdsV2SessionTokenUrl = credentialSourceOpts.get("imdsv2_session_token_url");
				this.awsSecurityCredentialsSupplier = new defaultawssecuritycredentialssupplier_1.DefaultAwsSecurityCredentialsSupplier({
					regionUrl,
					securityCredentialsUrl,
					imdsV2SessionTokenUrl
				});
				this.regionalCredVerificationUrl = credentialSourceOpts.get("regional_cred_verification_url");
				this.credentialSourceType = "aws";
				this.validateEnvironmentId();
			}
			this.awsRequestSigner = null;
			this.region = "";
		}
		validateEnvironmentId() {
			const match = this.environmentId?.match(/^(aws)(\d+)$/);
			if (!match || !this.regionalCredVerificationUrl) throw new Error("No valid AWS \"credential_source\" provided");
			else if (parseInt(match[2], 10) !== 1) throw new Error(`aws version "${match[2]}" is not supported in the current build.`);
		}
		/**
		* Triggered when an external subject token is needed to be exchanged for a
		* GCP access token via GCP STS endpoint. This will call the
		* {@link AwsSecurityCredentialsSupplier} to retrieve an AWS region and AWS
		* Security Credentials, then use them to create a signed AWS STS request that
		* can be exchanged for a GCP access token.
		* @return A promise that resolves with the external subject token.
		*/
		async retrieveSubjectToken() {
			if (!this.awsRequestSigner) {
				this.region = await this.awsSecurityCredentialsSupplier.getAwsRegion(this.supplierContext);
				this.awsRequestSigner = new awsrequestsigner_1$1.AwsRequestSigner(async () => {
					return this.awsSecurityCredentialsSupplier.getAwsSecurityCredentials(this.supplierContext);
				}, this.region);
			}
			const options = await this.awsRequestSigner.getRequestOptions({
				...AwsClient.RETRY_CONFIG,
				url: this.regionalCredVerificationUrl.replace("{region}", this.region),
				method: "POST"
			});
			const reformattedHeader = [];
			gaxios_1$3.Gaxios.mergeHeaders({ "x-goog-cloud-target-resource": this.audience }, options.headers).forEach((value, key) => reformattedHeader.push({
				key,
				value
			}));
			return encodeURIComponent(JSON.stringify({
				url: options.url,
				method: options.method,
				headers: reformattedHeader
			}));
		}
	};
	exports.AwsClient = AwsClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/executable-response.js
var require_executable_response = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = void 0;
	const SAML_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:saml2";
	const OIDC_SUBJECT_TOKEN_TYPE1 = "urn:ietf:params:oauth:token-type:id_token";
	const OIDC_SUBJECT_TOKEN_TYPE2 = "urn:ietf:params:oauth:token-type:jwt";
	/**
	* Defines the response of a 3rd party executable run by the pluggable auth client.
	*/
	var ExecutableResponse = class {
		/**
		* The version of the Executable response. Only version 1 is currently supported.
		*/
		version;
		/**
		* Whether the executable ran successfully.
		*/
		success;
		/**
		* The epoch time for expiration of the token in seconds.
		*/
		expirationTime;
		/**
		* The type of subject token in the response, currently supported values are:
		* urn:ietf:params:oauth:token-type:saml2
		* urn:ietf:params:oauth:token-type:id_token
		* urn:ietf:params:oauth:token-type:jwt
		*/
		tokenType;
		/**
		* The error code from the executable.
		*/
		errorCode;
		/**
		* The error message from the executable.
		*/
		errorMessage;
		/**
		* The subject token from the executable, format depends on tokenType.
		*/
		subjectToken;
		/**
		* Instantiates an ExecutableResponse instance using the provided JSON object
		* from the output of the executable.
		* @param responseJson Response from a 3rd party executable, loaded from a
		* run of the executable or a cached output file.
		*/
		constructor(responseJson) {
			if (!responseJson.version) throw new InvalidVersionFieldError("Executable response must contain a 'version' field.");
			if (responseJson.success === void 0) throw new InvalidSuccessFieldError("Executable response must contain a 'success' field.");
			this.version = responseJson.version;
			this.success = responseJson.success;
			if (this.success) {
				this.expirationTime = responseJson.expiration_time;
				this.tokenType = responseJson.token_type;
				if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) throw new InvalidTokenTypeFieldError(`Executable response must contain a 'token_type' field when successful and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);
				if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {
					if (!responseJson.saml_response) throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);
					this.subjectToken = responseJson.saml_response;
				} else {
					if (!responseJson.id_token) throw new InvalidSubjectTokenError(`Executable response must contain a 'id_token' field when token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);
					this.subjectToken = responseJson.id_token;
				}
			} else {
				if (!responseJson.code) throw new InvalidCodeFieldError("Executable response must contain a 'code' field when unsuccessful.");
				if (!responseJson.message) throw new InvalidMessageFieldError("Executable response must contain a 'message' field when unsuccessful.");
				this.errorCode = responseJson.code;
				this.errorMessage = responseJson.message;
			}
		}
		/**
		* @return A boolean representing if the response has a valid token. Returns
		* true when the response was successful and the token is not expired.
		*/
		isValid() {
			return !this.isExpired() && this.success;
		}
		/**
		* @return A boolean representing if the response is expired. Returns true if the
		* provided timeout has passed.
		*/
		isExpired() {
			return this.expirationTime !== void 0 && this.expirationTime < Math.round(Date.now() / 1e3);
		}
	};
	exports.ExecutableResponse = ExecutableResponse;
	/**
	* An error thrown by the ExecutableResponse class.
	*/
	var ExecutableResponseError = class extends Error {
		constructor(message) {
			super(message);
			Object.setPrototypeOf(this, new.target.prototype);
		}
	};
	exports.ExecutableResponseError = ExecutableResponseError;
	/**
	* An error thrown when the 'version' field in an executable response is missing or invalid.
	*/
	var InvalidVersionFieldError = class extends ExecutableResponseError {};
	exports.InvalidVersionFieldError = InvalidVersionFieldError;
	/**
	* An error thrown when the 'success' field in an executable response is missing or invalid.
	*/
	var InvalidSuccessFieldError = class extends ExecutableResponseError {};
	exports.InvalidSuccessFieldError = InvalidSuccessFieldError;
	/**
	* An error thrown when the 'expiration_time' field in an executable response is missing or invalid.
	*/
	var InvalidExpirationTimeFieldError = class extends ExecutableResponseError {};
	exports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;
	/**
	* An error thrown when the 'token_type' field in an executable response is missing or invalid.
	*/
	var InvalidTokenTypeFieldError = class extends ExecutableResponseError {};
	exports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;
	/**
	* An error thrown when the 'code' field in an executable response is missing or invalid.
	*/
	var InvalidCodeFieldError = class extends ExecutableResponseError {};
	exports.InvalidCodeFieldError = InvalidCodeFieldError;
	/**
	* An error thrown when the 'message' field in an executable response is missing or invalid.
	*/
	var InvalidMessageFieldError = class extends ExecutableResponseError {};
	exports.InvalidMessageFieldError = InvalidMessageFieldError;
	/**
	* An error thrown when the subject token in an executable response is missing or invalid.
	*/
	var InvalidSubjectTokenError = class extends ExecutableResponseError {};
	exports.InvalidSubjectTokenError = InvalidSubjectTokenError;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js
var require_pluggable_auth_handler = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PluggableAuthHandler = exports.ExecutableError = void 0;
	const executable_response_1$1 = require_executable_response();
	const childProcess = require("child_process");
	const fs$2 = require("fs");
	/**
	* Error thrown from the executable run by PluggableAuthClient.
	*/
	var ExecutableError = class extends Error {
		/**
		* The exit code returned by the executable.
		*/
		code;
		constructor(message, code$1) {
			super(`The executable failed with exit code: ${code$1} and error message: ${message}.`);
			this.code = code$1;
			Object.setPrototypeOf(this, new.target.prototype);
		}
	};
	exports.ExecutableError = ExecutableError;
	/**
	* A handler used to retrieve 3rd party token responses from user defined
	* executables and cached file output for the PluggableAuthClient class.
	*/
	var PluggableAuthHandler = class PluggableAuthHandler {
		commandComponents;
		timeoutMillis;
		outputFile;
		/**
		* Instantiates a PluggableAuthHandler instance using the provided
		* PluggableAuthHandlerOptions object.
		*/
		constructor(options) {
			if (!options.command) throw new Error("No command provided.");
			this.commandComponents = PluggableAuthHandler.parseCommand(options.command);
			this.timeoutMillis = options.timeoutMillis;
			if (!this.timeoutMillis) throw new Error("No timeoutMillis provided.");
			this.outputFile = options.outputFile;
		}
		/**
		* Calls user provided executable to get a 3rd party subject token and
		* returns the response.
		* @param envMap a Map of additional Environment Variables required for
		*   the executable.
		* @return A promise that resolves with the executable response.
		*/
		retrieveResponseFromExecutable(envMap) {
			return new Promise((resolve, reject) => {
				const child$1 = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), { env: {
					...process.env,
					...Object.fromEntries(envMap)
				} });
				let output = "";
				child$1.stdout.on("data", (data) => {
					output += data;
				});
				child$1.stderr.on("data", (err) => {
					output += err;
				});
				const timeout = setTimeout(() => {
					child$1.removeAllListeners();
					child$1.kill();
					return reject(/* @__PURE__ */ new Error("The executable failed to finish within the timeout specified."));
				}, this.timeoutMillis);
				child$1.on("close", (code$1) => {
					clearTimeout(timeout);
					if (code$1 === 0) try {
						const responseJson = JSON.parse(output);
						return resolve(new executable_response_1$1.ExecutableResponse(responseJson));
					} catch (error$1) {
						if (error$1 instanceof executable_response_1$1.ExecutableResponseError) return reject(error$1);
						return reject(new executable_response_1$1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));
					}
					else return reject(new ExecutableError(output, code$1.toString()));
				});
			});
		}
		/**
		* Checks user provided output file for response from previous run of
		* executable and return the response if it exists, is formatted correctly, and is not expired.
		*/
		async retrieveCachedResponse() {
			if (!this.outputFile || this.outputFile.length === 0) return;
			let filePath;
			try {
				filePath = await fs$2.promises.realpath(this.outputFile);
			} catch {
				return;
			}
			if (!(await fs$2.promises.lstat(filePath)).isFile()) return;
			const responseString = await fs$2.promises.readFile(filePath, { encoding: "utf8" });
			if (responseString === "") return;
			try {
				const responseJson = JSON.parse(responseString);
				if (new executable_response_1$1.ExecutableResponse(responseJson).isValid()) return new executable_response_1$1.ExecutableResponse(responseJson);
				return;
			} catch (error$1) {
				if (error$1 instanceof executable_response_1$1.ExecutableResponseError) throw error$1;
				throw new executable_response_1$1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);
			}
		}
		/**
		* Parses given command string into component array, splitting on spaces unless
		* spaces are between quotation marks.
		*/
		static parseCommand(command) {
			const components = command.match(/(?:[^\s"]+|"[^"]*")+/g);
			if (!components) throw new Error(`Provided command: "${command}" could not be parsed.`);
			for (let i$2 = 0; i$2 < components.length; i$2++) if (components[i$2][0] === "\"" && components[i$2].slice(-1) === "\"") components[i$2] = components[i$2].slice(1, -1);
			return components;
		}
	};
	exports.PluggableAuthHandler = PluggableAuthHandler;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js
var require_pluggable_auth_client = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PluggableAuthClient = exports.ExecutableError = void 0;
	const baseexternalclient_1$4 = require_baseexternalclient();
	const executable_response_1 = require_executable_response();
	const pluggable_auth_handler_1 = require_pluggable_auth_handler();
	var pluggable_auth_handler_2 = require_pluggable_auth_handler();
	Object.defineProperty(exports, "ExecutableError", {
		enumerable: true,
		get: function() {
			return pluggable_auth_handler_2.ExecutableError;
		}
	});
	/**
	* The default executable timeout when none is provided, in milliseconds.
	*/
	const DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1e3;
	/**
	* The minimum allowed executable timeout in milliseconds.
	*/
	const MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1e3;
	/**
	* The maximum allowed executable timeout in milliseconds.
	*/
	const MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1e3;
	/**
	* The environment variable to check to see if executable can be run.
	* Value must be set to '1' for the executable to run.
	*/
	const GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = "GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES";
	/**
	* The maximum currently supported executable version.
	*/
	const MAXIMUM_EXECUTABLE_VERSION = 1;
	/**
	* PluggableAuthClient enables the exchange of workload identity pool external credentials for
	* Google access tokens by retrieving 3rd party tokens through a user supplied executable. These
	* scripts/executables are completely independent of the Google Cloud Auth libraries. These
	* credentials plug into ADC and will call the specified executable to retrieve the 3rd party token
	* to be exchanged for a Google access token.
	*
	* <p>To use these credentials, the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment variable
	* must be set to '1'. This is for security reasons.
	*
	* <p>Both OIDC and SAML are supported. The executable must adhere to a specific response format
	* defined below.
	*
	* <p>The executable must print out the 3rd party token to STDOUT in JSON format. When an
	* output_file is specified in the credential configuration, the executable must also handle writing the
	* JSON response to this file.
	*
	* <pre>
	* OIDC response sample:
	* {
	*   "version": 1,
	*   "success": true,
	*   "token_type": "urn:ietf:params:oauth:token-type:id_token",
	*   "id_token": "HEADER.PAYLOAD.SIGNATURE",
	*   "expiration_time": 1620433341
	* }
	*
	* SAML2 response sample:
	* {
	*   "version": 1,
	*   "success": true,
	*   "token_type": "urn:ietf:params:oauth:token-type:saml2",
	*   "saml_response": "...",
	*   "expiration_time": 1620433341
	* }
	*
	* Error response sample:
	* {
	*   "version": 1,
	*   "success": false,
	*   "code": "401",
	*   "message": "Error message."
	* }
	* </pre>
	*
	* <p>The "expiration_time" field in the JSON response is only required for successful
	* responses when an output file was specified in the credential configuration
	*
	* <p>The auth libraries will populate certain environment variables that will be accessible by the
	* executable, such as: GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE, GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE,
	* GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE, GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL, and
	* GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE.
	*
	* <p>Please see this repositories README for a complete executable request/response specification.
	*/
	var PluggableAuthClient = class extends baseexternalclient_1$4.BaseExternalAccountClient {
		/**
		* The command used to retrieve the third party token.
		*/
		command;
		/**
		* The timeout in milliseconds for running executable,
		* set to default if none provided.
		*/
		timeoutMillis;
		/**
		* The path to file to check for cached executable response.
		*/
		outputFile;
		/**
		* Executable and output file handler.
		*/
		handler;
		/**
		* Instantiates a PluggableAuthClient instance using the provided JSON
		* object loaded from an external account credentials file.
		* An error is thrown if the credential is not a valid pluggable auth credential.
		* @param options The external account options object typically loaded from
		*   the external account JSON credential file.
		*/
		constructor(options) {
			super(options);
			if (!options.credential_source.executable) throw new Error("No valid Pluggable Auth \"credential_source\" provided.");
			this.command = options.credential_source.executable.command;
			if (!this.command) throw new Error("No valid Pluggable Auth \"credential_source\" provided.");
			if (options.credential_source.executable.timeout_millis === void 0) this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;
			else {
				this.timeoutMillis = options.credential_source.executable.timeout_millis;
				if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS || this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);
			}
			this.outputFile = options.credential_source.executable.output_file;
			this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({
				command: this.command,
				timeoutMillis: this.timeoutMillis,
				outputFile: this.outputFile
			});
			this.credentialSourceType = "executable";
		}
		/**
		* Triggered when an external subject token is needed to be exchanged for a
		* GCP access token via GCP STS endpoint.
		* This uses the `options.credential_source` object to figure out how
		* to retrieve the token using the current environment. In this case,
		* this calls a user provided executable which returns the subject token.
		* The logic is summarized as:
		* 1. Validated that the executable is allowed to run. The
		*    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to
		*    1 for security reasons.
		* 2. If an output file is specified by the user, check the file location
		*    for a response. If the file exists and contains a valid response,
		*    return the subject token from the file.
		* 3. Call the provided executable and return response.
		* @return A promise that resolves with the external subject token.
		*/
		async retrieveSubjectToken() {
			if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== "1") throw new Error("Pluggable Auth executables need to be explicitly allowed to run by setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment Variable to 1.");
			let executableResponse = void 0;
			if (this.outputFile) executableResponse = await this.handler.retrieveCachedResponse();
			if (!executableResponse) {
				const envMap = /* @__PURE__ */ new Map();
				envMap.set("GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE", this.audience);
				envMap.set("GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE", this.subjectTokenType);
				envMap.set("GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE", "0");
				if (this.outputFile) envMap.set("GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE", this.outputFile);
				const serviceAccountEmail = this.getServiceAccountEmail();
				if (serviceAccountEmail) envMap.set("GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL", serviceAccountEmail);
				executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);
			}
			if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);
			if (!executableResponse.success) throw new pluggable_auth_handler_1.ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);
			if (this.outputFile) {
				if (!executableResponse.expirationTime) throw new executable_response_1.InvalidExpirationTimeFieldError("The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.");
			}
			if (executableResponse.isExpired()) throw new Error("Executable response is expired.");
			return executableResponse.subjectToken;
		}
	};
	exports.PluggableAuthClient = PluggableAuthClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/externalclient.js
var require_externalclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ExternalAccountClient = void 0;
	const baseexternalclient_1$3 = require_baseexternalclient();
	const identitypoolclient_1$1 = require_identitypoolclient();
	const awsclient_1$1 = require_awsclient();
	const pluggable_auth_client_1$1 = require_pluggable_auth_client();
	/**
	* Dummy class with no constructor. Developers are expected to use fromJSON.
	*/
	var ExternalAccountClient = class {
		constructor() {
			throw new Error("ExternalAccountClients should be initialized via: ExternalAccountClient.fromJSON(), directly via explicit constructors, eg. new AwsClient(options), new IdentityPoolClient(options), newPluggableAuthClientOptions, or via new GoogleAuth(options).getClient()");
		}
		/**
		* This static method will instantiate the
		* corresponding type of external account credential depending on the
		* underlying credential source.
		*
		* **IMPORTANT**: This method does not validate the credential configuration.
		* A security risk occurs when a credential configuration configured with
		* malicious URLs is used. When the credential configuration is accepted from
		* an untrusted source, you should validate it before using it with this
		* method. For more details, see
		* https://cloud.google.com/docs/authentication/external/externally-sourced-credentials.
		*
		* @param options The external account options object typically loaded
		*   from the external account JSON credential file.
		* @return A BaseExternalAccountClient instance or null if the options
		*   provided do not correspond to an external account credential.
		*/
		static fromJSON(options) {
			if (options && options.type === baseexternalclient_1$3.EXTERNAL_ACCOUNT_TYPE) if (options.credential_source?.environment_id) return new awsclient_1$1.AwsClient(options);
			else if (options.credential_source?.executable) return new pluggable_auth_client_1$1.PluggableAuthClient(options);
			else return new identitypoolclient_1$1.IdentityPoolClient(options);
			else return null;
		}
	};
	exports.ExternalAccountClient = ExternalAccountClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js
var require_externalAccountAuthorizedUserClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;
	const authclient_1$4 = require_authclient();
	const oauth2common_1 = require_oauth2common();
	const gaxios_1$2 = require_src$4();
	const stream$1 = require("stream");
	const baseexternalclient_1$2 = require_baseexternalclient();
	/**
	* The credentials JSON file type for external account authorized user clients.
	*/
	exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = "external_account_authorized_user";
	const DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/oauthtoken";
	/**
	* Handler for token refresh requests sent to the token_url endpoint for external
	* authorized user credentials.
	*/
	var ExternalAccountAuthorizedUserHandler = class ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {
		#tokenRefreshEndpoint;
		/**
		* Initializes an ExternalAccountAuthorizedUserHandler instance.
		* @param url The URL of the token refresh endpoint.
		* @param transporter The transporter to use for the refresh request.
		* @param clientAuthentication The client authentication credentials to use
		*   for the refresh request.
		*/
		constructor(options) {
			super(options);
			this.#tokenRefreshEndpoint = options.tokenRefreshEndpoint;
		}
		/**
		* Requests a new access token from the token_url endpoint using the provided
		*   refresh token.
		* @param refreshToken The refresh token to use to generate a new access token.
		* @param additionalHeaders Optional additional headers to pass along the
		*   request.
		* @return A promise that resolves with the token refresh response containing
		*   the requested access token and its expiration time.
		*/
		async refreshToken(refreshToken, headers) {
			const opts = {
				...ExternalAccountAuthorizedUserHandler.RETRY_CONFIG,
				url: this.#tokenRefreshEndpoint,
				method: "POST",
				headers,
				data: new URLSearchParams({
					grant_type: "refresh_token",
					refresh_token: refreshToken
				})
			};
			authclient_1$4.AuthClient.setMethodName(opts, "refreshToken");
			this.applyClientAuthenticationOptions(opts);
			try {
				const response = await this.transporter.request(opts);
				const tokenRefreshResponse = response.data;
				tokenRefreshResponse.res = response;
				return tokenRefreshResponse;
			} catch (error$1) {
				if (error$1 instanceof gaxios_1$2.GaxiosError && error$1.response) throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error$1.response.data, error$1);
				throw error$1;
			}
		}
	};
	/**
	* External Account Authorized User Client. This is used for OAuth2 credentials
	* sourced using external identities through Workforce Identity Federation.
	* Obtaining the initial access and refresh token can be done through the
	* Google Cloud CLI.
	*/
	var ExternalAccountAuthorizedUserClient = class extends authclient_1$4.AuthClient {
		cachedAccessToken;
		externalAccountAuthorizedUserHandler;
		refreshToken;
		/**
		* Instantiates an ExternalAccountAuthorizedUserClient instances using the
		* provided JSON object loaded from a credentials files.
		* An error is throws if the credential is not valid.
		* @param options The external account authorized user option object typically
		*   from the external accoutn authorized user JSON credential file.
		*/
		constructor(options) {
			super(options);
			if (options.universe_domain) this.universeDomain = options.universe_domain;
			this.refreshToken = options.refresh_token;
			const clientAuthentication = {
				confidentialClientType: "basic",
				clientId: options.client_id,
				clientSecret: options.client_secret
			};
			this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler({
				tokenRefreshEndpoint: options.token_url ?? DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain),
				transporter: this.transporter,
				clientAuthentication
			});
			this.cachedAccessToken = null;
			this.quotaProjectId = options.quota_project_id;
			if (typeof options?.eagerRefreshThresholdMillis !== "number") this.eagerRefreshThresholdMillis = baseexternalclient_1$2.EXPIRATION_TIME_OFFSET;
			else this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
			this.forceRefreshOnFailure = !!options?.forceRefreshOnFailure;
		}
		async getAccessToken() {
			if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) await this.refreshAccessTokenAsync();
			return {
				token: this.cachedAccessToken.access_token,
				res: this.cachedAccessToken.res
			};
		}
		async getRequestHeaders() {
			const accessTokenResponse = await this.getAccessToken();
			const headers = new Headers({ authorization: `Bearer ${accessTokenResponse.token}` });
			return this.addSharedMetadataHeaders(headers);
		}
		request(opts, callback) {
			if (callback) this.requestAsync(opts).then((r$1) => callback(null, r$1), (e$1) => {
				return callback(e$1, e$1.response);
			});
			else return this.requestAsync(opts);
		}
		/**
		* Authenticates the provided HTTP request, processes it and resolves with the
		* returned response.
		* @param opts The HTTP request options.
		* @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
		* @return A promise that resolves with the successful response.
		*/
		async requestAsync(opts, reAuthRetried = false) {
			let response;
			try {
				const requestHeaders = await this.getRequestHeaders();
				opts.headers = gaxios_1$2.Gaxios.mergeHeaders(opts.headers);
				this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);
				response = await this.transporter.request(opts);
			} catch (e$1) {
				const res = e$1.response;
				if (res) {
					const statusCode = res.status;
					const isReadableStream = res.config.data instanceof stream$1.Readable;
					if (!reAuthRetried && (statusCode === 401 || statusCode === 403) && !isReadableStream && this.forceRefreshOnFailure) {
						await this.refreshAccessTokenAsync();
						return await this.requestAsync(opts, true);
					}
				}
				throw e$1;
			}
			return response;
		}
		/**
		* Forces token refresh, even if unexpired tokens are currently cached.
		* @return A promise that resolves with the refreshed credential.
		*/
		async refreshAccessTokenAsync() {
			const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);
			this.cachedAccessToken = {
				access_token: refreshResponse.access_token,
				expiry_date: (/* @__PURE__ */ new Date()).getTime() + refreshResponse.expires_in * 1e3,
				res: refreshResponse.res
			};
			if (refreshResponse.refresh_token !== void 0) this.refreshToken = refreshResponse.refresh_token;
			return this.cachedAccessToken;
		}
		/**
		* Returns whether the provided credentials are expired or not.
		* If there is no expiry time, assumes the token is not expired or expiring.
		* @param credentials The credentials to check for expiration.
		* @return Whether the credentials are expired or not.
		*/
		isExpired(credentials) {
			const now = (/* @__PURE__ */ new Date()).getTime();
			return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;
		}
	};
	exports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/googleauth.js
var require_googleauth = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GoogleAuth = exports.GoogleAuthExceptionMessages = void 0;
	const child_process_1 = require("child_process");
	const fs$1 = require("fs");
	const gaxios_1$1 = require_src$4();
	const gcpMetadata = require_src$2();
	const os = require("os");
	const path$1 = require("path");
	const crypto_1 = require_crypto();
	const computeclient_1$1 = require_computeclient();
	const idtokenclient_1$1 = require_idtokenclient();
	const envDetect_1$1 = require_envDetect();
	const jwtclient_1$1 = require_jwtclient();
	const refreshclient_1$1 = require_refreshclient();
	const impersonated_1$1 = require_impersonated();
	const externalclient_1$1 = require_externalclient();
	const baseexternalclient_1$1 = require_baseexternalclient();
	const authclient_1$3 = require_authclient();
	const externalAccountAuthorizedUserClient_1$1 = require_externalAccountAuthorizedUserClient();
	const util_1 = require_util();
	exports.GoogleAuthExceptionMessages = {
		API_KEY_WITH_CREDENTIALS: "API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.",
		NO_PROJECT_ID_FOUND: "Unable to detect a Project Id in the current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
		NO_CREDENTIALS_FOUND: "Unable to find credentials in current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
		NO_ADC_FOUND: "Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.",
		NO_UNIVERSE_DOMAIN_FOUND: "Unable to detect a Universe Domain in the current environment.\nTo learn more about Universe Domain retrieval, visit: \nhttps://cloud.google.com/compute/docs/metadata/predefined-metadata-keys"
	};
	var GoogleAuth$1 = class {
		/**
		* Caches a value indicating whether the auth layer is running on Google
		* Compute Engine.
		* @private
		*/
		checkIsGCE = void 0;
		useJWTAccessWithScope;
		defaultServicePath;
		get isGCE() {
			return this.checkIsGCE;
		}
		_findProjectIdPromise;
		_cachedProjectId;
		jsonContent = null;
		apiKey;
		cachedCredential = null;
		/**
		* A pending {@link AuthClient}. Used for concurrent {@link GoogleAuth.getClient} calls.
		*/
		#pendingAuthClient = null;
		/**
		* Scopes populated by the client library by default. We differentiate between
		* these and user defined scopes when deciding whether to use a self-signed JWT.
		*/
		defaultScopes;
		keyFilename;
		scopes;
		clientOptions = {};
		/**
		* Configuration is resolved in the following order of precedence:
		* - {@link GoogleAuthOptions.credentials `credentials`}
		* - {@link GoogleAuthOptions.keyFilename `keyFilename`}
		* - {@link GoogleAuthOptions.keyFile `keyFile`}
		*
		* {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the
		* {@link AuthClient `AuthClient`s}.
		*
		* @param opts
		*/
		constructor(opts = {}) {
			this._cachedProjectId = opts.projectId || null;
			this.cachedCredential = opts.authClient || null;
			this.keyFilename = opts.keyFilename || opts.keyFile;
			this.scopes = opts.scopes;
			this.clientOptions = opts.clientOptions || {};
			this.jsonContent = opts.credentials || null;
			this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;
			if (this.apiKey && (this.jsonContent || this.clientOptions.credentials)) throw new RangeError(exports.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);
			if (opts.universeDomain) this.clientOptions.universeDomain = opts.universeDomain;
		}
		setGapicJWTValues(client) {
			client.defaultServicePath = this.defaultServicePath;
			client.useJWTAccessWithScope = this.useJWTAccessWithScope;
			client.defaultScopes = this.defaultScopes;
		}
		getProjectId(callback) {
			if (callback) this.getProjectIdAsync().then((r$1) => callback(null, r$1), callback);
			else return this.getProjectIdAsync();
		}
		/**
		* A temporary method for internal `getProjectId` usages where `null` is
		* acceptable. In a future major release, `getProjectId` should return `null`
		* (as the `Promise<string | null>` base signature describes) and this private
		* method should be removed.
		*
		* @returns Promise that resolves with project id (or `null`)
		*/
		async getProjectIdOptional() {
			try {
				return await this.getProjectId();
			} catch (e$1) {
				if (e$1 instanceof Error && e$1.message === exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) return null;
				else throw e$1;
			}
		}
		/**
		* A private method for finding and caching a projectId.
		*
		* Supports environments in order of precedence:
		* - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable
		* - GOOGLE_APPLICATION_CREDENTIALS JSON file
		* - Cloud SDK: `gcloud config config-helper --format json`
		* - GCE project ID from metadata server
		*
		* @returns projectId
		*/
		async findAndCacheProjectId() {
			let projectId = null;
			projectId ||= await this.getProductionProjectId();
			projectId ||= await this.getFileProjectId();
			projectId ||= await this.getDefaultServiceProjectId();
			projectId ||= await this.getGCEProjectId();
			projectId ||= await this.getExternalAccountClientProjectId();
			if (projectId) {
				this._cachedProjectId = projectId;
				return projectId;
			} else throw new Error(exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);
		}
		async getProjectIdAsync() {
			if (this._cachedProjectId) return this._cachedProjectId;
			if (!this._findProjectIdPromise) this._findProjectIdPromise = this.findAndCacheProjectId();
			return this._findProjectIdPromise;
		}
		/**
		* Retrieves a universe domain from the metadata server via
		* {@link gcpMetadata.universe}.
		*
		* @returns a universe domain
		*/
		async getUniverseDomainFromMetadataServer() {
			let universeDomain;
			try {
				universeDomain = await gcpMetadata.universe("universe-domain");
				universeDomain ||= authclient_1$3.DEFAULT_UNIVERSE;
			} catch (e$1) {
				if (e$1 && e$1?.response?.status === 404) universeDomain = authclient_1$3.DEFAULT_UNIVERSE;
				else throw e$1;
			}
			return universeDomain;
		}
		/**
		* Retrieves, caches, and returns the universe domain in the following order
		* of precedence:
		* - The universe domain in {@link GoogleAuth.clientOptions}
		* - An existing or ADC {@link AuthClient}'s universe domain
		* - {@link gcpMetadata.universe}, if {@link Compute} client
		*
		* @returns The universe domain
		*/
		async getUniverseDomain() {
			let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get("universe_domain");
			try {
				universeDomain ??= (await this.getClient()).universeDomain;
			} catch {
				universeDomain ??= authclient_1$3.DEFAULT_UNIVERSE;
			}
			return universeDomain;
		}
		/**
		* @returns Any scopes (user-specified or default scopes specified by the
		*   client library) that need to be set on the current Auth client.
		*/
		getAnyScopes() {
			return this.scopes || this.defaultScopes;
		}
		getApplicationDefault(optionsOrCallback = {}, callback) {
			let options;
			if (typeof optionsOrCallback === "function") callback = optionsOrCallback;
			else options = optionsOrCallback;
			if (callback) this.getApplicationDefaultAsync(options).then((r$1) => callback(null, r$1.credential, r$1.projectId), callback);
			else return this.getApplicationDefaultAsync(options);
		}
		async getApplicationDefaultAsync(options = {}) {
			if (this.cachedCredential) return await this.#prepareAndCacheClient(this.cachedCredential, null);
			let credential;
			credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);
			if (credential) {
				if (credential instanceof jwtclient_1$1.JWT) credential.scopes = this.scopes;
				else if (credential instanceof baseexternalclient_1$1.BaseExternalAccountClient) credential.scopes = this.getAnyScopes();
				return await this.#prepareAndCacheClient(credential);
			}
			credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);
			if (credential) {
				if (credential instanceof jwtclient_1$1.JWT) credential.scopes = this.scopes;
				else if (credential instanceof baseexternalclient_1$1.BaseExternalAccountClient) credential.scopes = this.getAnyScopes();
				return await this.#prepareAndCacheClient(credential);
			}
			if (await this._checkIsGCE()) {
				options.scopes = this.getAnyScopes();
				return await this.#prepareAndCacheClient(new computeclient_1$1.Compute(options));
			}
			throw new Error(exports.GoogleAuthExceptionMessages.NO_ADC_FOUND);
		}
		async #prepareAndCacheClient(credential, quotaProjectIdOverride = process.env["GOOGLE_CLOUD_QUOTA_PROJECT"] || null) {
			const projectId = await this.getProjectIdOptional();
			if (quotaProjectIdOverride) credential.quotaProjectId = quotaProjectIdOverride;
			this.cachedCredential = credential;
			return {
				credential,
				projectId
			};
		}
		/**
		* Determines whether the auth layer is running on Google Compute Engine.
		* Checks for GCP Residency, then fallback to checking if metadata server
		* is available.
		*
		* @returns A promise that resolves with the boolean.
		* @api private
		*/
		async _checkIsGCE() {
			if (this.checkIsGCE === void 0) this.checkIsGCE = gcpMetadata.getGCPResidency() || await gcpMetadata.isAvailable();
			return this.checkIsGCE;
		}
		/**
		* Attempts to load default credentials from the environment variable path..
		* @returns Promise that resolves with the OAuth2Client or null.
		* @api private
		*/
		async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {
			const credentialsPath = process.env["GOOGLE_APPLICATION_CREDENTIALS"] || process.env["google_application_credentials"];
			if (!credentialsPath || credentialsPath.length === 0) return null;
			try {
				return this._getApplicationCredentialsFromFilePath(credentialsPath, options);
			} catch (e$1) {
				if (e$1 instanceof Error) e$1.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e$1.message}`;
				throw e$1;
			}
		}
		/**
		* Attempts to load default credentials from a well-known file location
		* @return Promise that resolves with the OAuth2Client or null.
		* @api private
		*/
		async _tryGetApplicationCredentialsFromWellKnownFile(options) {
			let location = null;
			if (this._isWindows()) location = process.env["APPDATA"];
			else {
				const home = process.env["HOME"];
				if (home) location = path$1.join(home, ".config");
			}
			if (location) {
				location = path$1.join(location, "gcloud", "application_default_credentials.json");
				if (!fs$1.existsSync(location)) location = null;
			}
			if (!location) return null;
			return await this._getApplicationCredentialsFromFilePath(location, options);
		}
		/**
		* Attempts to load default credentials from a file at the given path..
		* @param filePath The path to the file to read.
		* @returns Promise that resolves with the OAuth2Client
		* @api private
		*/
		async _getApplicationCredentialsFromFilePath(filePath, options = {}) {
			if (!filePath || filePath.length === 0) throw new Error("The file path is invalid.");
			try {
				filePath = fs$1.realpathSync(filePath);
				if (!fs$1.lstatSync(filePath).isFile()) throw new Error();
			} catch (err) {
				if (err instanceof Error) err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;
				throw err;
			}
			const readStream = fs$1.createReadStream(filePath);
			return this.fromStream(readStream, options);
		}
		/**
		* Create a credentials instance using a given impersonated input options.
		* @param json The impersonated input object.
		* @returns JWT or UserRefresh Client with data
		*/
		fromImpersonatedJSON(json$1) {
			if (!json$1) throw new Error("Must pass in a JSON object containing an  impersonated refresh token");
			if (json$1.type !== impersonated_1$1.IMPERSONATED_ACCOUNT_TYPE) throw new Error(`The incoming JSON object does not have the "${impersonated_1$1.IMPERSONATED_ACCOUNT_TYPE}" type`);
			if (!json$1.source_credentials) throw new Error("The incoming JSON object does not contain a source_credentials field");
			if (!json$1.service_account_impersonation_url) throw new Error("The incoming JSON object does not contain a service_account_impersonation_url field");
			const sourceClient = this.fromJSON(json$1.source_credentials);
			if (json$1.service_account_impersonation_url?.length > 256)
 /**
			* Prevents DOS attacks.
			* @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/85}
			**/
			throw new RangeError(`Target principal is too long: ${json$1.service_account_impersonation_url}`);
			const targetPrincipal = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(json$1.service_account_impersonation_url)?.groups?.target;
			if (!targetPrincipal) throw new RangeError(`Cannot extract target principal from ${json$1.service_account_impersonation_url}`);
			const targetScopes = (this.scopes || json$1.scopes || this.defaultScopes) ?? [];
			return new impersonated_1$1.Impersonated({
				...json$1,
				sourceClient,
				targetPrincipal,
				targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes]
			});
		}
		/**
		* Create a credentials instance using the given input options.
		* This client is not cached.
		*
		* **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
		*
		* @deprecated This method is being deprecated because of a potential security risk.
		*
		* This method does not validate the credential configuration. The security
		* risk occurs when a credential configuration is accepted from a source that
		* is not under your control and used without validation on your side.
		*
		* If you know that you will be loading credential configurations of a
		* specific type, it is recommended to use a credential-type-specific
		* constructor. This will ensure that an unexpected credential type with
		* potential for malicious intent is not loaded unintentionally. You might
		* still have to do validation for certain credential types. Please follow
		* the recommendation for that method. For example, if you want to load only
		* service accounts, you can use the `JWT` constructor:
		* ```
		* const {JWT} = require('google-auth-library');
		* const keys = require('/path/to/key.json');
		* const client = new JWT({
		*   email: keys.client_email,
		*   key: keys.private_key,
		*   scopes: ['https://www.googleapis.com/auth/cloud-platform'],
		* });
		* ```
		*
		* If you are loading your credential configuration from an untrusted source and have
		* not mitigated the risks (e.g. by validating the configuration yourself), make
		* these changes as soon as possible to prevent security risks to your environment.
		*
		* Regardless of the method used, it is always your responsibility to validate
		* configurations received from external sources.
		*
		* For more details, see https://cloud.google.com/docs/authentication/external/externally-sourced-credentials.
		*
		* @param json The input object.
		* @param options The JWT or UserRefresh options for the client
		* @returns JWT or UserRefresh Client with data
		*/
		fromJSON(json$1, options = {}) {
			let client;
			const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get("universe_domain");
			if (json$1.type === refreshclient_1$1.USER_REFRESH_ACCOUNT_TYPE) {
				client = new refreshclient_1$1.UserRefreshClient(options);
				client.fromJSON(json$1);
			} else if (json$1.type === impersonated_1$1.IMPERSONATED_ACCOUNT_TYPE) client = this.fromImpersonatedJSON(json$1);
			else if (json$1.type === baseexternalclient_1$1.EXTERNAL_ACCOUNT_TYPE) {
				client = externalclient_1$1.ExternalAccountClient.fromJSON({
					...json$1,
					...options
				});
				client.scopes = this.getAnyScopes();
			} else if (json$1.type === externalAccountAuthorizedUserClient_1$1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) client = new externalAccountAuthorizedUserClient_1$1.ExternalAccountAuthorizedUserClient({
				...json$1,
				...options
			});
			else {
				options.scopes = this.scopes;
				client = new jwtclient_1$1.JWT(options);
				this.setGapicJWTValues(client);
				client.fromJSON(json$1);
			}
			if (preferredUniverseDomain) client.universeDomain = preferredUniverseDomain;
			return client;
		}
		/**
		* Return a JWT or UserRefreshClient from JavaScript object, caching both the
		* object used to instantiate and the client.
		* @param json The input object.
		* @param options The JWT or UserRefresh options for the client
		* @returns JWT or UserRefresh Client with data
		*/
		_cacheClientFromJSON(json$1, options) {
			const client = this.fromJSON(json$1, options);
			this.jsonContent = json$1;
			this.cachedCredential = client;
			return client;
		}
		fromStream(inputStream, optionsOrCallback = {}, callback) {
			let options = {};
			if (typeof optionsOrCallback === "function") callback = optionsOrCallback;
			else options = optionsOrCallback;
			if (callback) this.fromStreamAsync(inputStream, options).then((r$1) => callback(null, r$1), callback);
			else return this.fromStreamAsync(inputStream, options);
		}
		fromStreamAsync(inputStream, options) {
			return new Promise((resolve, reject) => {
				if (!inputStream) throw new Error("Must pass in a stream containing the Google auth settings.");
				const chunks = [];
				inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => chunks.push(chunk)).on("end", () => {
					try {
						try {
							const data = JSON.parse(chunks.join(""));
							return resolve(this._cacheClientFromJSON(data, options));
						} catch (err) {
							if (!this.keyFilename) throw err;
							const client = new jwtclient_1$1.JWT({
								...this.clientOptions,
								keyFile: this.keyFilename
							});
							this.cachedCredential = client;
							this.setGapicJWTValues(client);
							return resolve(client);
						}
					} catch (err) {
						return reject(err);
					}
				});
			});
		}
		/**
		* Create a credentials instance using the given API key string.
		* The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.
		*
		* @param apiKey The API key string
		* @param options An optional options object.
		* @returns A JWT loaded from the key
		*/
		fromAPIKey(apiKey, options = {}) {
			return new jwtclient_1$1.JWT({
				...options,
				apiKey
			});
		}
		/**
		* Determines whether the current operating system is Windows.
		* @api private
		*/
		_isWindows() {
			const sys = os.platform();
			if (sys && sys.length >= 3) {
				if (sys.substring(0, 3).toLowerCase() === "win") return true;
			}
			return false;
		}
		/**
		* Run the Google Cloud SDK command that prints the default project ID
		*/
		async getDefaultServiceProjectId() {
			return new Promise((resolve) => {
				(0, child_process_1.exec)("gcloud config config-helper --format json", (err, stdout) => {
					if (!err && stdout) try {
						const projectId = JSON.parse(stdout).configuration.properties.core.project;
						resolve(projectId);
						return;
					} catch (e$1) {}
					resolve(null);
				});
			});
		}
		/**
		* Loads the project id from environment variables.
		* @api private
		*/
		getProductionProjectId() {
			return process.env["GCLOUD_PROJECT"] || process.env["GOOGLE_CLOUD_PROJECT"] || process.env["gcloud_project"] || process.env["google_cloud_project"];
		}
		/**
		* Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.
		* @api private
		*/
		async getFileProjectId() {
			if (this.cachedCredential) return this.cachedCredential.projectId;
			if (this.keyFilename) {
				const creds = await this.getClient();
				if (creds && creds.projectId) return creds.projectId;
			}
			const r$1 = await this._tryGetApplicationCredentialsFromEnvironmentVariable();
			if (r$1) return r$1.projectId;
			else return null;
		}
		/**
		* Gets the project ID from external account client if available.
		*/
		async getExternalAccountClientProjectId() {
			if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1$1.EXTERNAL_ACCOUNT_TYPE) return null;
			return await (await this.getClient()).getProjectId();
		}
		/**
		* Gets the Compute Engine project ID if it can be inferred.
		*/
		async getGCEProjectId() {
			try {
				return await gcpMetadata.project("project-id");
			} catch (e$1) {
				return null;
			}
		}
		getCredentials(callback) {
			if (callback) this.getCredentialsAsync().then((r$1) => callback(null, r$1), callback);
			else return this.getCredentialsAsync();
		}
		async getCredentialsAsync() {
			const client = await this.getClient();
			if (client instanceof impersonated_1$1.Impersonated) return { client_email: client.getTargetPrincipal() };
			if (client instanceof baseexternalclient_1$1.BaseExternalAccountClient) {
				const serviceAccountEmail = client.getServiceAccountEmail();
				if (serviceAccountEmail) return {
					client_email: serviceAccountEmail,
					universe_domain: client.universeDomain
				};
			}
			if (this.jsonContent) return {
				client_email: this.jsonContent.client_email,
				private_key: this.jsonContent.private_key,
				universe_domain: this.jsonContent.universe_domain
			};
			if (await this._checkIsGCE()) {
				const [client_email, universe_domain] = await Promise.all([gcpMetadata.instance("service-accounts/default/email"), this.getUniverseDomain()]);
				return {
					client_email,
					universe_domain
				};
			}
			throw new Error(exports.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);
		}
		/**
		* Automatically obtain an {@link AuthClient `AuthClient`} based on the
		* provided configuration. If no options were passed, use Application
		* Default Credentials.
		*/
		async getClient() {
			if (this.cachedCredential) return this.cachedCredential;
			this.#pendingAuthClient = this.#pendingAuthClient || this.#determineClient();
			try {
				return await this.#pendingAuthClient;
			} finally {
				this.#pendingAuthClient = null;
			}
		}
		async #determineClient() {
			if (this.jsonContent) return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
			else if (this.keyFilename) {
				const filePath = path$1.resolve(this.keyFilename);
				const stream$6 = fs$1.createReadStream(filePath);
				return await this.fromStreamAsync(stream$6, this.clientOptions);
			} else if (this.apiKey) {
				const client = await this.fromAPIKey(this.apiKey, this.clientOptions);
				client.scopes = this.scopes;
				const { credential } = await this.#prepareAndCacheClient(client);
				return credential;
			} else {
				const { credential } = await this.getApplicationDefaultAsync(this.clientOptions);
				return credential;
			}
		}
		/**
		* Creates a client which will fetch an ID token for authorization.
		* @param targetAudience the audience for the fetched ID token.
		* @returns IdTokenClient for making HTTP calls authenticated with ID tokens.
		*/
		async getIdTokenClient(targetAudience) {
			const client = await this.getClient();
			if (!("fetchIdToken" in client)) throw new Error("Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.");
			return new idtokenclient_1$1.IdTokenClient({
				targetAudience,
				idTokenProvider: client
			});
		}
		/**
		* Automatically obtain application default credentials, and return
		* an access token for making requests.
		*/
		async getAccessToken() {
			return (await (await this.getClient()).getAccessToken()).token;
		}
		/**
		* Obtain the HTTP headers that will provide authorization for a given
		* request.
		*/
		async getRequestHeaders(url) {
			return (await this.getClient()).getRequestHeaders(url);
		}
		/**
		* Obtain credentials for a request, then attach the appropriate headers to
		* the request options.
		* @param opts Axios or Request options on which to attach the headers
		*/
		async authorizeRequest(opts = {}) {
			const url = opts.url;
			const headers = await (await this.getClient()).getRequestHeaders(url);
			opts.headers = gaxios_1$1.Gaxios.mergeHeaders(opts.headers, headers);
			return opts;
		}
		/**
		* A {@link fetch `fetch`} compliant API for {@link GoogleAuth}.
		*
		* @see {@link GoogleAuth.request} for the classic method.
		*
		* @remarks
		*
		* This is useful as a drop-in replacement for `fetch` API usage.
		*
		* @example
		*
		* ```ts
		* const auth = new GoogleAuth();
		* const fetchWithAuth: typeof fetch = (...args) => auth.fetch(...args);
		* await fetchWithAuth('https://example.com');
		* ```
		*
		* @param args `fetch` API or {@link Gaxios.fetch `Gaxios#fetch`} parameters
		* @returns the {@link GaxiosResponse} with Gaxios-added properties
		*/
		async fetch(...args) {
			return (await this.getClient()).fetch(...args);
		}
		/**
		* Automatically obtain application default credentials, and make an
		* HTTP request using the given options.
		*
		* @see {@link GoogleAuth.fetch} for the modern method.
		*
		* @param opts Axios request options for the HTTP request.
		*/
		async request(opts) {
			return (await this.getClient()).request(opts);
		}
		/**
		* Determine the compute environment in which the code is running.
		*/
		getEnv() {
			return (0, envDetect_1$1.getEnv)();
		}
		/**
		* Sign the given data with the current private key, or go out
		* to the IAM API to sign it.
		* @param data The data to be signed.
		* @param endpoint A custom endpoint to use.
		*
		* @example
		* ```
		* sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');
		* ```
		*/
		async sign(data, endpoint$1) {
			const client = await this.getClient();
			const universe$1 = await this.getUniverseDomain();
			endpoint$1 = endpoint$1 || `https://iamcredentials.${universe$1}/v1/projects/-/serviceAccounts/`;
			if (client instanceof impersonated_1$1.Impersonated) return (await client.sign(data)).signedBlob;
			const crypto$7 = (0, crypto_1.createCrypto)();
			if (client instanceof jwtclient_1$1.JWT && client.key) return await crypto$7.sign(client.key, data);
			const creds = await this.getCredentials();
			if (!creds.client_email) throw new Error("Cannot sign data without `client_email`.");
			return this.signBlob(crypto$7, creds.client_email, data, endpoint$1);
		}
		async signBlob(crypto$7, emailOrUniqueId, data, endpoint$1) {
			const url = new URL(endpoint$1 + `${emailOrUniqueId}:signBlob`);
			return (await this.request({
				method: "POST",
				url: url.href,
				data: { payload: crypto$7.encodeBase64StringUtf8(data) },
				retry: true,
				retryConfig: { httpMethodsToRetry: ["POST"] }
			})).data.signedBlob;
		}
	};
	exports.GoogleAuth = GoogleAuth$1;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/iam.js
var require_iam = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IAMAuth = void 0;
	var IAMAuth = class {
		selector;
		token;
		/**
		* IAM credentials.
		*
		* @param selector the iam authority selector
		* @param token the token
		* @constructor
		*/
		constructor(selector, token) {
			this.selector = selector;
			this.token = token;
			this.selector = selector;
			this.token = token;
		}
		/**
		* Acquire the HTTP headers required to make an authenticated request.
		*/
		getRequestHeaders() {
			return {
				"x-goog-iam-authority-selector": this.selector,
				"x-goog-iam-authorization-token": this.token
			};
		}
	};
	exports.IAMAuth = IAMAuth;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/downscopedclient.js
var require_downscopedclient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;
	const gaxios_1 = require_src$4();
	const stream = require("stream");
	const authclient_1$2 = require_authclient();
	const sts = require_stscredentials();
	/**
	* The required token exchange grant_type: rfc8693#section-2.1
	*/
	const STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
	/**
	* The requested token exchange requested_token_type: rfc8693#section-2.1
	*/
	const STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
	/**
	* The requested token exchange subject_token_type: rfc8693#section-2.1
	*/
	const STS_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
	/**
	* The maximum number of access boundary rules a Credential Access Boundary
	* can contain.
	*/
	exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;
	/**
	* Offset to take into account network delays and server clock skews.
	*/
	exports.EXPIRATION_TIME_OFFSET = 300 * 1e3;
	/**
	* Defines a set of Google credentials that are downscoped from an existing set
	* of Google OAuth2 credentials. This is useful to restrict the Identity and
	* Access Management (IAM) permissions that a short-lived credential can use.
	* The common pattern of usage is to have a token broker with elevated access
	* generate these downscoped credentials from higher access source credentials
	* and pass the downscoped short-lived access tokens to a token consumer via
	* some secure authenticated channel for limited access to Google Cloud Storage
	* resources.
	*/
	var DownscopedClient = class extends authclient_1$2.AuthClient {
		authClient;
		credentialAccessBoundary;
		cachedDownscopedAccessToken;
		stsCredential;
		/**
		* Instantiates a downscoped client object using the provided source
		* AuthClient and credential access boundary rules.
		* To downscope permissions of a source AuthClient, a Credential Access
		* Boundary that specifies which resources the new credential can access, as
		* well as an upper bound on the permissions that are available on each
		* resource, has to be defined. A downscoped client can then be instantiated
		* using the source AuthClient and the Credential Access Boundary.
		* @param options the {@link DownscopedClientOptions `DownscopedClientOptions`} to use. Passing an `AuthClient` directly is **@DEPRECATED**.
		* @param credentialAccessBoundary **@DEPRECATED**. Provide a {@link DownscopedClientOptions `DownscopedClientOptions`} object in the first parameter instead.
		*/
		constructor(options, credentialAccessBoundary = { accessBoundary: { accessBoundaryRules: [] } }) {
			super(options instanceof authclient_1$2.AuthClient ? {} : options);
			if (options instanceof authclient_1$2.AuthClient) {
				this.authClient = options;
				this.credentialAccessBoundary = credentialAccessBoundary;
			} else {
				this.authClient = options.authClient;
				this.credentialAccessBoundary = options.credentialAccessBoundary;
			}
			if (this.credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) throw new Error("At least one access boundary rule needs to be defined.");
			else if (this.credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) throw new Error(`The provided access boundary has more than ${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);
			for (const rule of this.credentialAccessBoundary.accessBoundary.accessBoundaryRules) if (rule.availablePermissions.length === 0) throw new Error("At least one permission should be defined in access boundary rules.");
			this.stsCredential = new sts.StsCredentials({ tokenExchangeEndpoint: `https://sts.${this.universeDomain}/v1/token` });
			this.cachedDownscopedAccessToken = null;
		}
		/**
		* Provides a mechanism to inject Downscoped access tokens directly.
		* The expiry_date field is required to facilitate determination of the token
		* expiration which would make it easier for the token consumer to handle.
		* @param credentials The Credentials object to set on the current client.
		*/
		setCredentials(credentials) {
			if (!credentials.expiry_date) throw new Error("The access token expiry_date field is missing in the provided credentials.");
			super.setCredentials(credentials);
			this.cachedDownscopedAccessToken = credentials;
		}
		async getAccessToken() {
			if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) await this.refreshAccessTokenAsync();
			return {
				token: this.cachedDownscopedAccessToken.access_token,
				expirationTime: this.cachedDownscopedAccessToken.expiry_date,
				res: this.cachedDownscopedAccessToken.res
			};
		}
		/**
		* The main authentication interface. It takes an optional url which when
		* present is the endpoint being accessed, and returns a Promise which
		* resolves with authorization header fields.
		*
		* The result has the form:
		* { authorization: 'Bearer <access_token_value>' }
		*/
		async getRequestHeaders() {
			const accessTokenResponse = await this.getAccessToken();
			const headers = new Headers({ authorization: `Bearer ${accessTokenResponse.token}` });
			return this.addSharedMetadataHeaders(headers);
		}
		request(opts, callback) {
			if (callback) this.requestAsync(opts).then((r$1) => callback(null, r$1), (e$1) => {
				return callback(e$1, e$1.response);
			});
			else return this.requestAsync(opts);
		}
		/**
		* Authenticates the provided HTTP request, processes it and resolves with the
		* returned response.
		* @param opts The HTTP request options.
		* @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure
		* @return A promise that resolves with the successful response.
		*/
		async requestAsync(opts, reAuthRetried = false) {
			let response;
			try {
				const requestHeaders = await this.getRequestHeaders();
				opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);
				this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);
				response = await this.transporter.request(opts);
			} catch (e$1) {
				const res = e$1.response;
				if (res) {
					const statusCode = res.status;
					const isReadableStream = res.config.data instanceof stream.Readable;
					if (!reAuthRetried && (statusCode === 401 || statusCode === 403) && !isReadableStream && this.forceRefreshOnFailure) {
						await this.refreshAccessTokenAsync();
						return await this.requestAsync(opts, true);
					}
				}
				throw e$1;
			}
			return response;
		}
		/**
		* Forces token refresh, even if unexpired tokens are currently cached.
		* GCP access tokens are retrieved from authclient object/source credential.
		* Then GCP access tokens are exchanged for downscoped access tokens via the
		* token exchange endpoint.
		* @return A promise that resolves with the fresh downscoped access token.
		*/
		async refreshAccessTokenAsync() {
			const stsCredentialsOptions = {
				grantType: STS_GRANT_TYPE,
				requestedTokenType: STS_REQUEST_TOKEN_TYPE,
				subjectToken: (await this.authClient.getAccessToken()).token,
				subjectTokenType: STS_SUBJECT_TOKEN_TYPE
			};
			const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, void 0, this.credentialAccessBoundary);
			/**
			* The STS endpoint will only return the expiration time for the downscoped
			* access token if the original access token represents a service account.
			* The downscoped token's expiration time will always match the source
			* credential expiration. When no expires_in is returned, we can copy the
			* source credential's expiration time.
			*/
			const sourceCredExpireDate = this.authClient.credentials?.expiry_date || null;
			const expiryDate = stsResponse.expires_in ? (/* @__PURE__ */ new Date()).getTime() + stsResponse.expires_in * 1e3 : sourceCredExpireDate;
			this.cachedDownscopedAccessToken = {
				access_token: stsResponse.access_token,
				expiry_date: expiryDate,
				res: stsResponse.res
			};
			this.credentials = {};
			Object.assign(this.credentials, this.cachedDownscopedAccessToken);
			delete this.credentials.res;
			this.emit("tokens", {
				refresh_token: null,
				expiry_date: this.cachedDownscopedAccessToken.expiry_date,
				access_token: this.cachedDownscopedAccessToken.access_token,
				token_type: "Bearer",
				id_token: null
			});
			return this.cachedDownscopedAccessToken;
		}
		/**
		* Returns whether the provided credentials are expired or not.
		* If there is no expiry time, assumes the token is not expired or expiring.
		* @param downscopedAccessToken The credentials to check for expiration.
		* @return Whether the credentials are expired or not.
		*/
		isExpired(downscopedAccessToken) {
			const now = (/* @__PURE__ */ new Date()).getTime();
			return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
		}
	};
	exports.DownscopedClient = DownscopedClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/auth/passthrough.js
var require_passthrough = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PassThroughClient = void 0;
	const authclient_1$1 = require_authclient();
	/**
	* An AuthClient without any Authentication information. Useful for:
	* - Anonymous access
	* - Local Emulators
	* - Testing Environments
	*
	*/
	var PassThroughClient = class extends authclient_1$1.AuthClient {
		/**
		* Creates a request without any authentication headers or checks.
		*
		* @remarks
		*
		* In testing environments it may be useful to change the provided
		* {@link AuthClient.transporter} for any desired request overrides/handling.
		*
		* @param opts
		* @returns The response of the request.
		*/
		async request(opts) {
			return this.transporter.request(opts);
		}
		/**
		* A required method of the base class.
		* Always will return an empty object.
		*
		* @returns {}
		*/
		async getAccessToken() {
			return {};
		}
		/**
		* A required method of the base class.
		* Always will return an empty object.
		*
		* @returns {}
		*/
		async getRequestHeaders() {
			return new Headers();
		}
	};
	exports.PassThroughClient = PassThroughClient;
}));

//#endregion
//#region node_modules/google-auth-library/build/src/index.js
var require_src = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GoogleAuth = exports.auth = exports.PassThroughClient = exports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = exports.ExecutableError = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsRequestSigner = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.ClientAuthentication = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.DEFAULT_UNIVERSE = exports.AuthClient = exports.gaxios = exports.gcpMetadata = void 0;
	const googleauth_1 = require_googleauth();
	Object.defineProperty(exports, "GoogleAuth", {
		enumerable: true,
		get: function() {
			return googleauth_1.GoogleAuth;
		}
	});
	exports.gcpMetadata = require_src$2();
	exports.gaxios = require_src$4();
	var authclient_1 = require_authclient();
	Object.defineProperty(exports, "AuthClient", {
		enumerable: true,
		get: function() {
			return authclient_1.AuthClient;
		}
	});
	Object.defineProperty(exports, "DEFAULT_UNIVERSE", {
		enumerable: true,
		get: function() {
			return authclient_1.DEFAULT_UNIVERSE;
		}
	});
	var computeclient_1 = require_computeclient();
	Object.defineProperty(exports, "Compute", {
		enumerable: true,
		get: function() {
			return computeclient_1.Compute;
		}
	});
	var envDetect_1 = require_envDetect();
	Object.defineProperty(exports, "GCPEnv", {
		enumerable: true,
		get: function() {
			return envDetect_1.GCPEnv;
		}
	});
	var iam_1 = require_iam();
	Object.defineProperty(exports, "IAMAuth", {
		enumerable: true,
		get: function() {
			return iam_1.IAMAuth;
		}
	});
	var idtokenclient_1 = require_idtokenclient();
	Object.defineProperty(exports, "IdTokenClient", {
		enumerable: true,
		get: function() {
			return idtokenclient_1.IdTokenClient;
		}
	});
	var jwtaccess_1 = require_jwtaccess();
	Object.defineProperty(exports, "JWTAccess", {
		enumerable: true,
		get: function() {
			return jwtaccess_1.JWTAccess;
		}
	});
	var jwtclient_1 = require_jwtclient();
	Object.defineProperty(exports, "JWT", {
		enumerable: true,
		get: function() {
			return jwtclient_1.JWT;
		}
	});
	var impersonated_1 = require_impersonated();
	Object.defineProperty(exports, "Impersonated", {
		enumerable: true,
		get: function() {
			return impersonated_1.Impersonated;
		}
	});
	var oauth2client_1 = require_oauth2client();
	Object.defineProperty(exports, "CodeChallengeMethod", {
		enumerable: true,
		get: function() {
			return oauth2client_1.CodeChallengeMethod;
		}
	});
	Object.defineProperty(exports, "OAuth2Client", {
		enumerable: true,
		get: function() {
			return oauth2client_1.OAuth2Client;
		}
	});
	Object.defineProperty(exports, "ClientAuthentication", {
		enumerable: true,
		get: function() {
			return oauth2client_1.ClientAuthentication;
		}
	});
	var loginticket_1 = require_loginticket();
	Object.defineProperty(exports, "LoginTicket", {
		enumerable: true,
		get: function() {
			return loginticket_1.LoginTicket;
		}
	});
	var refreshclient_1 = require_refreshclient();
	Object.defineProperty(exports, "UserRefreshClient", {
		enumerable: true,
		get: function() {
			return refreshclient_1.UserRefreshClient;
		}
	});
	var awsclient_1 = require_awsclient();
	Object.defineProperty(exports, "AwsClient", {
		enumerable: true,
		get: function() {
			return awsclient_1.AwsClient;
		}
	});
	var awsrequestsigner_1 = require_awsrequestsigner();
	Object.defineProperty(exports, "AwsRequestSigner", {
		enumerable: true,
		get: function() {
			return awsrequestsigner_1.AwsRequestSigner;
		}
	});
	var identitypoolclient_1 = require_identitypoolclient();
	Object.defineProperty(exports, "IdentityPoolClient", {
		enumerable: true,
		get: function() {
			return identitypoolclient_1.IdentityPoolClient;
		}
	});
	var externalclient_1 = require_externalclient();
	Object.defineProperty(exports, "ExternalAccountClient", {
		enumerable: true,
		get: function() {
			return externalclient_1.ExternalAccountClient;
		}
	});
	var baseexternalclient_1 = require_baseexternalclient();
	Object.defineProperty(exports, "BaseExternalAccountClient", {
		enumerable: true,
		get: function() {
			return baseexternalclient_1.BaseExternalAccountClient;
		}
	});
	var downscopedclient_1 = require_downscopedclient();
	Object.defineProperty(exports, "DownscopedClient", {
		enumerable: true,
		get: function() {
			return downscopedclient_1.DownscopedClient;
		}
	});
	var pluggable_auth_client_1 = require_pluggable_auth_client();
	Object.defineProperty(exports, "PluggableAuthClient", {
		enumerable: true,
		get: function() {
			return pluggable_auth_client_1.PluggableAuthClient;
		}
	});
	Object.defineProperty(exports, "ExecutableError", {
		enumerable: true,
		get: function() {
			return pluggable_auth_client_1.ExecutableError;
		}
	});
	var externalAccountAuthorizedUserClient_1 = require_externalAccountAuthorizedUserClient();
	Object.defineProperty(exports, "EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE", {
		enumerable: true,
		get: function() {
			return externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE;
		}
	});
	Object.defineProperty(exports, "ExternalAccountAuthorizedUserClient", {
		enumerable: true,
		get: function() {
			return externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient;
		}
	});
	var passthrough_1 = require_passthrough();
	Object.defineProperty(exports, "PassThroughClient", {
		enumerable: true,
		get: function() {
			return passthrough_1.PassThroughClient;
		}
	});
	const auth = new googleauth_1.GoogleAuth();
	exports.auth = auth;
}));

//#endregion
//#region node_modules/ws/lib/constants.js
var require_constants = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const BINARY_TYPES$2 = [
		"nodebuffer",
		"arraybuffer",
		"fragments"
	];
	const hasBlob$1 = typeof Blob !== "undefined";
	if (hasBlob$1) BINARY_TYPES$2.push("blob");
	module.exports = {
		BINARY_TYPES: BINARY_TYPES$2,
		EMPTY_BUFFER: Buffer.alloc(0),
		GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
		hasBlob: hasBlob$1,
		kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
		kListener: Symbol("kListener"),
		kStatusCode: Symbol("status-code"),
		kWebSocket: Symbol("websocket"),
		NOOP: () => {}
	};
}));

//#endregion
//#region node_modules/ws/lib/buffer-util.js
var require_buffer_util = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { EMPTY_BUFFER: EMPTY_BUFFER$3 } = require_constants();
	const FastBuffer$2 = Buffer[Symbol.species];
	/**
	* Merges an array of buffers into a new buffer.
	*
	* @param {Buffer[]} list The array of buffers to concat
	* @param {Number} totalLength The total length of buffers in the list
	* @return {Buffer} The resulting buffer
	* @public
	*/
	function concat$1(list, totalLength) {
		if (list.length === 0) return EMPTY_BUFFER$3;
		if (list.length === 1) return list[0];
		const target = Buffer.allocUnsafe(totalLength);
		let offset = 0;
		for (let i$2 = 0; i$2 < list.length; i$2++) {
			const buf = list[i$2];
			target.set(buf, offset);
			offset += buf.length;
		}
		if (offset < totalLength) return new FastBuffer$2(target.buffer, target.byteOffset, offset);
		return target;
	}
	/**
	* Masks a buffer using the given mask.
	*
	* @param {Buffer} source The buffer to mask
	* @param {Buffer} mask The mask to use
	* @param {Buffer} output The buffer where to store the result
	* @param {Number} offset The offset at which to start writing
	* @param {Number} length The number of bytes to mask.
	* @public
	*/
	function _mask(source, mask, output, offset, length) {
		for (let i$2 = 0; i$2 < length; i$2++) output[offset + i$2] = source[i$2] ^ mask[i$2 & 3];
	}
	/**
	* Unmasks a buffer using the given mask.
	*
	* @param {Buffer} buffer The buffer to unmask
	* @param {Buffer} mask The mask to use
	* @public
	*/
	function _unmask(buffer$1, mask) {
		for (let i$2 = 0; i$2 < buffer$1.length; i$2++) buffer$1[i$2] ^= mask[i$2 & 3];
	}
	/**
	* Converts a buffer to an `ArrayBuffer`.
	*
	* @param {Buffer} buf The buffer to convert
	* @return {ArrayBuffer} Converted buffer
	* @public
	*/
	function toArrayBuffer$1(buf) {
		if (buf.length === buf.buffer.byteLength) return buf.buffer;
		return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}
	/**
	* Converts `data` to a `Buffer`.
	*
	* @param {*} data The data to convert
	* @return {Buffer} The buffer
	* @throws {TypeError}
	* @public
	*/
	function toBuffer$2(data) {
		toBuffer$2.readOnly = true;
		if (Buffer.isBuffer(data)) return data;
		let buf;
		if (data instanceof ArrayBuffer) buf = new FastBuffer$2(data);
		else if (ArrayBuffer.isView(data)) buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);
		else {
			buf = Buffer.from(data);
			toBuffer$2.readOnly = false;
		}
		return buf;
	}
	module.exports = {
		concat: concat$1,
		mask: _mask,
		toArrayBuffer: toArrayBuffer$1,
		toBuffer: toBuffer$2,
		unmask: _unmask
	};
	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) try {
		const bufferUtil$1 = require("bufferutil");
		module.exports.mask = function(source, mask, output, offset, length) {
			if (length < 48) _mask(source, mask, output, offset, length);
			else bufferUtil$1.mask(source, mask, output, offset, length);
		};
		module.exports.unmask = function(buffer$1, mask) {
			if (buffer$1.length < 32) _unmask(buffer$1, mask);
			else bufferUtil$1.unmask(buffer$1, mask);
		};
	} catch (e$1) {}
}));

//#endregion
//#region node_modules/ws/lib/limiter.js
var require_limiter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const kDone = Symbol("kDone");
	const kRun = Symbol("kRun");
	/**
	* A very simple job queue with adjustable concurrency. Adapted from
	* https://github.com/STRML/async-limiter
	*/
	var Limiter$1 = class {
		/**
		* Creates a new `Limiter`.
		*
		* @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
		*     to run concurrently
		*/
		constructor(concurrency) {
			this[kDone] = () => {
				this.pending--;
				this[kRun]();
			};
			this.concurrency = concurrency || Infinity;
			this.jobs = [];
			this.pending = 0;
		}
		/**
		* Adds a job to the queue.
		*
		* @param {Function} job The job to run
		* @public
		*/
		add(job) {
			this.jobs.push(job);
			this[kRun]();
		}
		/**
		* Removes a job from the queue and runs it if possible.
		*
		* @private
		*/
		[kRun]() {
			if (this.pending === this.concurrency) return;
			if (this.jobs.length) {
				const job = this.jobs.shift();
				this.pending++;
				job(this[kDone]);
			}
		}
	};
	module.exports = Limiter$1;
}));

//#endregion
//#region node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const zlib = require("zlib");
	const bufferUtil = require_buffer_util();
	const Limiter = require_limiter();
	const { kStatusCode: kStatusCode$2 } = require_constants();
	const FastBuffer$1 = Buffer[Symbol.species];
	const TRAILER = Buffer.from([
		0,
		0,
		255,
		255
	]);
	const kPerMessageDeflate = Symbol("permessage-deflate");
	const kTotalLength = Symbol("total-length");
	const kCallback = Symbol("callback");
	const kBuffers = Symbol("buffers");
	const kError$1 = Symbol("error");
	let zlibLimiter;
	/**
	* permessage-deflate implementation.
	*/
	var PerMessageDeflate$4 = class {
		/**
		* Creates a PerMessageDeflate instance.
		*
		* @param {Object} [options] Configuration options
		* @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
		*     for, or request, a custom client window size
		* @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
		*     acknowledge disabling of client context takeover
		* @param {Number} [options.concurrencyLimit=10] The number of concurrent
		*     calls to zlib
		* @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
		*     use of a custom server window size
		* @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
		*     disabling of server context takeover
		* @param {Number} [options.threshold=1024] Size (in bytes) below which
		*     messages should not be compressed if context takeover is disabled
		* @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
		*     deflate
		* @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
		*     inflate
		* @param {Boolean} [isServer=false] Create the instance in either server or
		*     client mode
		* @param {Number} [maxPayload=0] The maximum allowed message length
		*/
		constructor(options, isServer, maxPayload) {
			this._maxPayload = maxPayload | 0;
			this._options = options || {};
			this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
			this._isServer = !!isServer;
			this._deflate = null;
			this._inflate = null;
			this.params = null;
			if (!zlibLimiter) zlibLimiter = new Limiter(this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10);
		}
		/**
		* @type {String}
		*/
		static get extensionName() {
			return "permessage-deflate";
		}
		/**
		* Create an extension negotiation offer.
		*
		* @return {Object} Extension parameters
		* @public
		*/
		offer() {
			const params = {};
			if (this._options.serverNoContextTakeover) params.server_no_context_takeover = true;
			if (this._options.clientNoContextTakeover) params.client_no_context_takeover = true;
			if (this._options.serverMaxWindowBits) params.server_max_window_bits = this._options.serverMaxWindowBits;
			if (this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
			else if (this._options.clientMaxWindowBits == null) params.client_max_window_bits = true;
			return params;
		}
		/**
		* Accept an extension negotiation offer/response.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Object} Accepted configuration
		* @public
		*/
		accept(configurations) {
			configurations = this.normalizeParams(configurations);
			this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
			return this.params;
		}
		/**
		* Releases all resources used by the extension.
		*
		* @public
		*/
		cleanup() {
			if (this._inflate) {
				this._inflate.close();
				this._inflate = null;
			}
			if (this._deflate) {
				const callback = this._deflate[kCallback];
				this._deflate.close();
				this._deflate = null;
				if (callback) callback(/* @__PURE__ */ new Error("The deflate stream was closed while data was being processed"));
			}
		}
		/**
		*  Accept an extension negotiation offer.
		*
		* @param {Array} offers The extension negotiation offers
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsServer(offers) {
			const opts = this._options;
			const accepted = offers.find((params) => {
				if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) return false;
				return true;
			});
			if (!accepted) throw new Error("None of the extension offers can be accepted");
			if (opts.serverNoContextTakeover) accepted.server_no_context_takeover = true;
			if (opts.clientNoContextTakeover) accepted.client_no_context_takeover = true;
			if (typeof opts.serverMaxWindowBits === "number") accepted.server_max_window_bits = opts.serverMaxWindowBits;
			if (typeof opts.clientMaxWindowBits === "number") accepted.client_max_window_bits = opts.clientMaxWindowBits;
			else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) delete accepted.client_max_window_bits;
			return accepted;
		}
		/**
		* Accept the extension negotiation response.
		*
		* @param {Array} response The extension negotiation response
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsClient(response) {
			const params = response[0];
			if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) throw new Error("Unexpected parameter \"client_no_context_takeover\"");
			if (!params.client_max_window_bits) {
				if (typeof this._options.clientMaxWindowBits === "number") params.client_max_window_bits = this._options.clientMaxWindowBits;
			} else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error("Unexpected or invalid parameter \"client_max_window_bits\"");
			return params;
		}
		/**
		* Normalize parameters.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Array} The offers/response with normalized parameters
		* @private
		*/
		normalizeParams(configurations) {
			configurations.forEach((params) => {
				Object.keys(params).forEach((key) => {
					let value = params[key];
					if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
					value = value[0];
					if (key === "client_max_window_bits") {
						if (value !== true) {
							const num = +value;
							if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
							value = num;
						} else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else if (key === "server_max_window_bits") {
						const num = +value;
						if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
						value = num;
					} else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
						if (value !== true) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else throw new Error(`Unknown parameter "${key}"`);
					params[key] = value;
				});
			});
			return configurations;
		}
		/**
		* Decompress data. Concurrency limited.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		decompress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._decompress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Compress data. Concurrency limited.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		compress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._compress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Decompress data.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_decompress(data, fin, callback) {
			const endpoint$1 = this._isServer ? "client" : "server";
			if (!this._inflate) {
				const key = `${endpoint$1}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._inflate = zlib.createInflateRaw({
					...this._options.zlibInflateOptions,
					windowBits
				});
				this._inflate[kPerMessageDeflate] = this;
				this._inflate[kTotalLength] = 0;
				this._inflate[kBuffers] = [];
				this._inflate.on("error", inflateOnError);
				this._inflate.on("data", inflateOnData);
			}
			this._inflate[kCallback] = callback;
			this._inflate.write(data);
			if (fin) this._inflate.write(TRAILER);
			this._inflate.flush(() => {
				const err = this._inflate[kError$1];
				if (err) {
					this._inflate.close();
					this._inflate = null;
					callback(err);
					return;
				}
				const data$1 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
				if (this._inflate._readableState.endEmitted) {
					this._inflate.close();
					this._inflate = null;
				} else {
					this._inflate[kTotalLength] = 0;
					this._inflate[kBuffers] = [];
					if (fin && this.params[`${endpoint$1}_no_context_takeover`]) this._inflate.reset();
				}
				callback(null, data$1);
			});
		}
		/**
		* Compress data.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_compress(data, fin, callback) {
			const endpoint$1 = this._isServer ? "server" : "client";
			if (!this._deflate) {
				const key = `${endpoint$1}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._deflate = zlib.createDeflateRaw({
					...this._options.zlibDeflateOptions,
					windowBits
				});
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				this._deflate.on("data", deflateOnData);
			}
			this._deflate[kCallback] = callback;
			this._deflate.write(data);
			this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
				if (!this._deflate) return;
				let data$1 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
				if (fin) data$1 = new FastBuffer$1(data$1.buffer, data$1.byteOffset, data$1.length - 4);
				this._deflate[kCallback] = null;
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				if (fin && this.params[`${endpoint$1}_no_context_takeover`]) this._deflate.reset();
				callback(null, data$1);
			});
		}
	};
	module.exports = PerMessageDeflate$4;
	/**
	* The listener of the `zlib.DeflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function deflateOnData(chunk) {
		this[kBuffers].push(chunk);
		this[kTotalLength] += chunk.length;
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function inflateOnData(chunk) {
		this[kTotalLength] += chunk.length;
		if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
			this[kBuffers].push(chunk);
			return;
		}
		this[kError$1] = /* @__PURE__ */ new RangeError("Max payload size exceeded");
		this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
		this[kError$1][kStatusCode$2] = 1009;
		this.removeListener("data", inflateOnData);
		this.reset();
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'error'` event.
	*
	* @param {Error} err The emitted error
	* @private
	*/
	function inflateOnError(err) {
		this[kPerMessageDeflate]._inflate = null;
		if (this[kError$1]) {
			this[kCallback](this[kError$1]);
			return;
		}
		err[kStatusCode$2] = 1007;
		this[kCallback](err);
	}
}));

//#endregion
//#region node_modules/ws/lib/validation.js
var require_validation = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { isUtf8 } = require("buffer");
	const { hasBlob } = require_constants();
	const tokenChars$2 = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		1,
		1,
		0,
		1,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		1,
		0,
		1,
		0
	];
	/**
	* Checks if a status code is allowed in a close frame.
	*
	* @param {Number} code The status code
	* @return {Boolean} `true` if the status code is valid, else `false`
	* @public
	*/
	function isValidStatusCode$2(code$1) {
		return code$1 >= 1e3 && code$1 <= 1014 && code$1 !== 1004 && code$1 !== 1005 && code$1 !== 1006 || code$1 >= 3e3 && code$1 <= 4999;
	}
	/**
	* Checks if a given buffer contains only correct UTF-8.
	* Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	* Markus Kuhn.
	*
	* @param {Buffer} buf The buffer to check
	* @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	* @public
	*/
	function _isValidUTF8(buf) {
		const len$1 = buf.length;
		let i$2 = 0;
		while (i$2 < len$1) if ((buf[i$2] & 128) === 0) i$2++;
		else if ((buf[i$2] & 224) === 192) {
			if (i$2 + 1 === len$1 || (buf[i$2 + 1] & 192) !== 128 || (buf[i$2] & 254) === 192) return false;
			i$2 += 2;
		} else if ((buf[i$2] & 240) === 224) {
			if (i$2 + 2 >= len$1 || (buf[i$2 + 1] & 192) !== 128 || (buf[i$2 + 2] & 192) !== 128 || buf[i$2] === 224 && (buf[i$2 + 1] & 224) === 128 || buf[i$2] === 237 && (buf[i$2 + 1] & 224) === 160) return false;
			i$2 += 3;
		} else if ((buf[i$2] & 248) === 240) {
			if (i$2 + 3 >= len$1 || (buf[i$2 + 1] & 192) !== 128 || (buf[i$2 + 2] & 192) !== 128 || (buf[i$2 + 3] & 192) !== 128 || buf[i$2] === 240 && (buf[i$2 + 1] & 240) === 128 || buf[i$2] === 244 && buf[i$2 + 1] > 143 || buf[i$2] > 244) return false;
			i$2 += 4;
		} else return false;
		return true;
	}
	/**
	* Determines whether a value is a `Blob`.
	*
	* @param {*} value The value to be tested
	* @return {Boolean} `true` if `value` is a `Blob`, else `false`
	* @private
	*/
	function isBlob$2(value) {
		return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
	}
	module.exports = {
		isBlob: isBlob$2,
		isValidStatusCode: isValidStatusCode$2,
		isValidUTF8: _isValidUTF8,
		tokenChars: tokenChars$2
	};
	if (isUtf8) module.exports.isValidUTF8 = function(buf) {
		return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	};
	else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
		const isValidUTF8$1 = require("utf-8-validate");
		module.exports.isValidUTF8 = function(buf) {
			return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8$1(buf);
		};
	} catch (e$1) {}
}));

//#endregion
//#region node_modules/ws/lib/receiver.js
var require_receiver = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Writable } = require("stream");
	const PerMessageDeflate$3 = require_permessage_deflate();
	const { BINARY_TYPES: BINARY_TYPES$1, EMPTY_BUFFER: EMPTY_BUFFER$2, kStatusCode: kStatusCode$1, kWebSocket: kWebSocket$3 } = require_constants();
	const { concat, toArrayBuffer, unmask } = require_buffer_util();
	const { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = require_validation();
	const FastBuffer = Buffer[Symbol.species];
	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;
	/**
	* HyBi Receiver implementation.
	*
	* @extends Writable
	*/
	var Receiver$2 = class extends Writable {
		/**
		* Creates a Receiver instance.
		*
		* @param {Object} [options] Options object
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {String} [options.binaryType=nodebuffer] The type for binary data
		* @param {Object} [options.extensions] An object containing the negotiated
		*     extensions
		* @param {Boolean} [options.isServer=false] Specifies whether to operate in
		*     client or server mode
		* @param {Number} [options.maxPayload=0] The maximum allowed message length
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		*/
		constructor(options = {}) {
			super();
			this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
			this._binaryType = options.binaryType || BINARY_TYPES$1[0];
			this._extensions = options.extensions || {};
			this._isServer = !!options.isServer;
			this._maxPayload = options.maxPayload | 0;
			this._skipUTF8Validation = !!options.skipUTF8Validation;
			this[kWebSocket$3] = void 0;
			this._bufferedBytes = 0;
			this._buffers = [];
			this._compressed = false;
			this._payloadLength = 0;
			this._mask = void 0;
			this._fragmented = 0;
			this._masked = false;
			this._fin = false;
			this._opcode = 0;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragments = [];
			this._errored = false;
			this._loop = false;
			this._state = GET_INFO;
		}
		/**
		* Implements `Writable.prototype._write()`.
		*
		* @param {Buffer} chunk The chunk of data to write
		* @param {String} encoding The character encoding of `chunk`
		* @param {Function} cb Callback
		* @private
		*/
		_write(chunk, encoding, cb) {
			if (this._opcode === 8 && this._state == GET_INFO) return cb();
			this._bufferedBytes += chunk.length;
			this._buffers.push(chunk);
			this.startLoop(cb);
		}
		/**
		* Consumes `n` bytes from the buffered data.
		*
		* @param {Number} n The number of bytes to consume
		* @return {Buffer} The consumed bytes
		* @private
		*/
		consume(n) {
			this._bufferedBytes -= n;
			if (n === this._buffers[0].length) return this._buffers.shift();
			if (n < this._buffers[0].length) {
				const buf = this._buffers[0];
				this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				return new FastBuffer(buf.buffer, buf.byteOffset, n);
			}
			const dst = Buffer.allocUnsafe(n);
			do {
				const buf = this._buffers[0];
				const offset = dst.length - n;
				if (n >= buf.length) dst.set(this._buffers.shift(), offset);
				else {
					dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
					this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				}
				n -= buf.length;
			} while (n > 0);
			return dst;
		}
		/**
		* Starts the parsing loop.
		*
		* @param {Function} cb Callback
		* @private
		*/
		startLoop(cb) {
			this._loop = true;
			do
				switch (this._state) {
					case GET_INFO:
						this.getInfo(cb);
						break;
					case GET_PAYLOAD_LENGTH_16:
						this.getPayloadLength16(cb);
						break;
					case GET_PAYLOAD_LENGTH_64:
						this.getPayloadLength64(cb);
						break;
					case GET_MASK:
						this.getMask();
						break;
					case GET_DATA:
						this.getData(cb);
						break;
					case INFLATING:
					case DEFER_EVENT:
						this._loop = false;
						return;
				}
			while (this._loop);
			if (!this._errored) cb();
		}
		/**
		* Reads the first two bytes of a frame.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getInfo(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			const buf = this.consume(2);
			if ((buf[0] & 48) !== 0) {
				cb(this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3"));
				return;
			}
			const compressed = (buf[0] & 64) === 64;
			if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
				cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
				return;
			}
			this._fin = (buf[0] & 128) === 128;
			this._opcode = buf[0] & 15;
			this._payloadLength = buf[1] & 127;
			if (this._opcode === 0) {
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (!this._fragmented) {
					cb(this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._opcode = this._fragmented;
			} else if (this._opcode === 1 || this._opcode === 2) {
				if (this._fragmented) {
					cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._compressed = compressed;
			} else if (this._opcode > 7 && this._opcode < 11) {
				if (!this._fin) {
					cb(this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN"));
					return;
				}
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
					cb(this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"));
					return;
				}
			} else {
				cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
				return;
			}
			if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
			this._masked = (buf[1] & 128) === 128;
			if (this._isServer) {
				if (!this._masked) {
					cb(this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK"));
					return;
				}
			} else if (this._masked) {
				cb(this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK"));
				return;
			}
			if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
			else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
			else this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+16).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength16(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			this._payloadLength = this.consume(2).readUInt16BE(0);
			this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+64).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength64(cb) {
			if (this._bufferedBytes < 8) {
				this._loop = false;
				return;
			}
			const buf = this.consume(8);
			const num = buf.readUInt32BE(0);
			if (num > Math.pow(2, 21) - 1) {
				cb(this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"));
				return;
			}
			this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
			this.haveLength(cb);
		}
		/**
		* Payload length has been read.
		*
		* @param {Function} cb Callback
		* @private
		*/
		haveLength(cb) {
			if (this._payloadLength && this._opcode < 8) {
				this._totalPayloadLength += this._payloadLength;
				if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
					cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
					return;
				}
			}
			if (this._masked) this._state = GET_MASK;
			else this._state = GET_DATA;
		}
		/**
		* Reads mask bytes.
		*
		* @private
		*/
		getMask() {
			if (this._bufferedBytes < 4) {
				this._loop = false;
				return;
			}
			this._mask = this.consume(4);
			this._state = GET_DATA;
		}
		/**
		* Reads data bytes.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getData(cb) {
			let data = EMPTY_BUFFER$2;
			if (this._payloadLength) {
				if (this._bufferedBytes < this._payloadLength) {
					this._loop = false;
					return;
				}
				data = this.consume(this._payloadLength);
				if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) unmask(data, this._mask);
			}
			if (this._opcode > 7) {
				this.controlMessage(data, cb);
				return;
			}
			if (this._compressed) {
				this._state = INFLATING;
				this.decompress(data, cb);
				return;
			}
			if (data.length) {
				this._messageLength = this._totalPayloadLength;
				this._fragments.push(data);
			}
			this.dataMessage(cb);
		}
		/**
		* Decompresses data.
		*
		* @param {Buffer} data Compressed data
		* @param {Function} cb Callback
		* @private
		*/
		decompress(data, cb) {
			this._extensions[PerMessageDeflate$3.extensionName].decompress(data, this._fin, (err, buf) => {
				if (err) return cb(err);
				if (buf.length) {
					this._messageLength += buf.length;
					if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
						cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
						return;
					}
					this._fragments.push(buf);
				}
				this.dataMessage(cb);
				if (this._state === GET_INFO) this.startLoop(cb);
			});
		}
		/**
		* Handles a data message.
		*
		* @param {Function} cb Callback
		* @private
		*/
		dataMessage(cb) {
			if (!this._fin) {
				this._state = GET_INFO;
				return;
			}
			const messageLength = this._messageLength;
			const fragments = this._fragments;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragmented = 0;
			this._fragments = [];
			if (this._opcode === 2) {
				let data;
				if (this._binaryType === "nodebuffer") data = concat(fragments, messageLength);
				else if (this._binaryType === "arraybuffer") data = toArrayBuffer(concat(fragments, messageLength));
				else if (this._binaryType === "blob") data = new Blob(fragments);
				else data = fragments;
				if (this._allowSynchronousEvents) {
					this.emit("message", data, true);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", data, true);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			} else {
				const buf = concat(fragments, messageLength);
				if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
					cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
					return;
				}
				if (this._state === INFLATING || this._allowSynchronousEvents) {
					this.emit("message", buf, false);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", buf, false);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			}
		}
		/**
		* Handles a control message.
		*
		* @param {Buffer} data Data to handle
		* @return {(Error|RangeError|undefined)} A possible error
		* @private
		*/
		controlMessage(data, cb) {
			if (this._opcode === 8) {
				if (data.length === 0) {
					this._loop = false;
					this.emit("conclude", 1005, EMPTY_BUFFER$2);
					this.end();
				} else {
					const code$1 = data.readUInt16BE(0);
					if (!isValidStatusCode$1(code$1)) {
						cb(this.createError(RangeError, `invalid status code ${code$1}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE"));
						return;
					}
					const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
					if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
						cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
						return;
					}
					this._loop = false;
					this.emit("conclude", code$1, buf);
					this.end();
				}
				this._state = GET_INFO;
				return;
			}
			if (this._allowSynchronousEvents) {
				this.emit(this._opcode === 9 ? "ping" : "pong", data);
				this._state = GET_INFO;
			} else {
				this._state = DEFER_EVENT;
				setImmediate(() => {
					this.emit(this._opcode === 9 ? "ping" : "pong", data);
					this._state = GET_INFO;
					this.startLoop(cb);
				});
			}
		}
		/**
		* Builds an error object.
		*
		* @param {function(new:Error|RangeError)} ErrorCtor The error constructor
		* @param {String} message The error message
		* @param {Boolean} prefix Specifies whether or not to add a default prefix to
		*     `message`
		* @param {Number} statusCode The status code
		* @param {String} errorCode The exposed error code
		* @return {(Error|RangeError)} The error
		* @private
		*/
		createError(ErrorCtor, message, prefix, statusCode, errorCode) {
			this._loop = false;
			this._errored = true;
			const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
			Error.captureStackTrace(err, this.createError);
			err.code = errorCode;
			err[kStatusCode$1] = statusCode;
			return err;
		}
	};
	module.exports = Receiver$2;
}));

//#endregion
//#region node_modules/ws/lib/sender.js
var require_sender = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Duplex: Duplex$3 } = require("stream");
	const { randomFillSync } = require("crypto");
	const PerMessageDeflate$2 = require_permessage_deflate();
	const { EMPTY_BUFFER: EMPTY_BUFFER$1, kWebSocket: kWebSocket$2, NOOP: NOOP$1 } = require_constants();
	const { isBlob: isBlob$1, isValidStatusCode } = require_validation();
	const { mask: applyMask, toBuffer: toBuffer$1 } = require_buffer_util();
	const kByteLength = Symbol("kByteLength");
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;
	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;
	/**
	* HyBi Sender implementation.
	*/
	var Sender$2 = class Sender$2 {
		/**
		* Creates a Sender instance.
		*
		* @param {Duplex} socket The connection socket
		* @param {Object} [extensions] An object containing the negotiated extensions
		* @param {Function} [generateMask] The function used to generate the masking
		*     key
		*/
		constructor(socket, extensions, generateMask) {
			this._extensions = extensions || {};
			if (generateMask) {
				this._generateMask = generateMask;
				this._maskBuffer = Buffer.alloc(4);
			}
			this._socket = socket;
			this._firstFragment = true;
			this._compress = false;
			this._bufferedBytes = 0;
			this._queue = [];
			this._state = DEFAULT;
			this.onerror = NOOP$1;
			this[kWebSocket$2] = void 0;
		}
		/**
		* Frames a piece of data according to the HyBi WebSocket protocol.
		*
		* @param {(Buffer|String)} data The data to frame
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @return {(Buffer|String)[]} The framed data
		* @public
		*/
		static frame(data, options) {
			let mask;
			let merge$1 = false;
			let offset = 2;
			let skipMasking = false;
			if (options.mask) {
				mask = options.maskBuffer || maskBuffer;
				if (options.generateMask) options.generateMask(mask);
				else {
					if (randomPoolPointer === RANDOM_POOL_SIZE) {
						/* istanbul ignore else  */
						if (randomPool === void 0) randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
						randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
						randomPoolPointer = 0;
					}
					mask[0] = randomPool[randomPoolPointer++];
					mask[1] = randomPool[randomPoolPointer++];
					mask[2] = randomPool[randomPoolPointer++];
					mask[3] = randomPool[randomPoolPointer++];
				}
				skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
				offset = 6;
			}
			let dataLength;
			if (typeof data === "string") if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) dataLength = options[kByteLength];
			else {
				data = Buffer.from(data);
				dataLength = data.length;
			}
			else {
				dataLength = data.length;
				merge$1 = options.mask && options.readOnly && !skipMasking;
			}
			let payloadLength = dataLength;
			if (dataLength >= 65536) {
				offset += 8;
				payloadLength = 127;
			} else if (dataLength > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const target = Buffer.allocUnsafe(merge$1 ? dataLength + offset : offset);
			target[0] = options.fin ? options.opcode | 128 : options.opcode;
			if (options.rsv1) target[0] |= 64;
			target[1] = payloadLength;
			if (payloadLength === 126) target.writeUInt16BE(dataLength, 2);
			else if (payloadLength === 127) {
				target[2] = target[3] = 0;
				target.writeUIntBE(dataLength, 4, 6);
			}
			if (!options.mask) return [target, data];
			target[1] |= 128;
			target[offset - 4] = mask[0];
			target[offset - 3] = mask[1];
			target[offset - 2] = mask[2];
			target[offset - 1] = mask[3];
			if (skipMasking) return [target, data];
			if (merge$1) {
				applyMask(data, mask, target, offset, dataLength);
				return [target];
			}
			applyMask(data, mask, data, 0, dataLength);
			return [target, data];
		}
		/**
		* Sends a close message to the other peer.
		*
		* @param {Number} [code] The status code component of the body
		* @param {(String|Buffer)} [data] The message component of the body
		* @param {Boolean} [mask=false] Specifies whether or not to mask the message
		* @param {Function} [cb] Callback
		* @public
		*/
		close(code$1, data, mask, cb) {
			let buf;
			if (code$1 === void 0) buf = EMPTY_BUFFER$1;
			else if (typeof code$1 !== "number" || !isValidStatusCode(code$1)) throw new TypeError("First argument must be a valid error code number");
			else if (data === void 0 || !data.length) {
				buf = Buffer.allocUnsafe(2);
				buf.writeUInt16BE(code$1, 0);
			} else {
				const length = Buffer.byteLength(data);
				if (length > 123) throw new RangeError("The message must not be greater than 123 bytes");
				buf = Buffer.allocUnsafe(2 + length);
				buf.writeUInt16BE(code$1, 0);
				if (typeof data === "string") buf.write(data, 2);
				else buf.set(data, 2);
			}
			const options = {
				[kByteLength]: buf.length,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 8,
				readOnly: false,
				rsv1: false
			};
			if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				buf,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender$2.frame(buf, options), cb);
		}
		/**
		* Sends a ping message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		ping(data, mask, cb) {
			let byteLength$1;
			let readOnly;
			if (typeof data === "string") {
				byteLength$1 = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength$1 = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength$1 = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (byteLength$1 > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength$1,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 9,
				readOnly,
				rsv1: false
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender$2.frame(data, options), cb);
		}
		/**
		* Sends a pong message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		pong(data, mask, cb) {
			let byteLength$1;
			let readOnly;
			if (typeof data === "string") {
				byteLength$1 = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength$1 = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength$1 = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (byteLength$1 > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength$1,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 10,
				readOnly,
				rsv1: false
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender$2.frame(data, options), cb);
		}
		/**
		* Sends a data message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Object} options Options object
		* @param {Boolean} [options.binary=false] Specifies whether `data` is binary
		*     or text
		* @param {Boolean} [options.compress=false] Specifies whether or not to
		*     compress `data`
		* @param {Boolean} [options.fin=false] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		send(data, options, cb) {
			const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
			let opcode = options.binary ? 2 : 1;
			let rsv1 = options.compress;
			let byteLength$1;
			let readOnly;
			if (typeof data === "string") {
				byteLength$1 = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength$1 = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength$1 = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (this._firstFragment) {
				this._firstFragment = false;
				if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) rsv1 = byteLength$1 >= perMessageDeflate._threshold;
				this._compress = rsv1;
			} else {
				rsv1 = false;
				opcode = 0;
			}
			if (options.fin) this._firstFragment = true;
			const opts = {
				[kByteLength]: byteLength$1,
				fin: options.fin,
				generateMask: this._generateMask,
				mask: options.mask,
				maskBuffer: this._maskBuffer,
				opcode,
				readOnly,
				rsv1
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.getBlobData(data, this._compress, opts, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.dispatch(data, this._compress, opts, cb);
		}
		/**
		* Gets the contents of a blob as binary data.
		*
		* @param {Blob} blob The blob
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     the data
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		getBlobData(blob, compress, options, cb) {
			this._bufferedBytes += options[kByteLength];
			this._state = GET_BLOB_DATA;
			blob.arrayBuffer().then((arrayBuffer) => {
				if (this._socket.destroyed) {
					const err = /* @__PURE__ */ new Error("The socket was closed while the blob was being read");
					process.nextTick(callCallbacks, this, err, cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				const data = toBuffer$1(arrayBuffer);
				if (!compress) {
					this._state = DEFAULT;
					this.sendFrame(Sender$2.frame(data, options), cb);
					this.dequeue();
				} else this.dispatch(data, compress, options, cb);
			}).catch((err) => {
				process.nextTick(onError, this, err, cb);
			});
		}
		/**
		* Dispatches a message.
		*
		* @param {(Buffer|String)} data The message to send
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     `data`
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		dispatch(data, compress, options, cb) {
			if (!compress) {
				this.sendFrame(Sender$2.frame(data, options), cb);
				return;
			}
			const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
			this._bufferedBytes += options[kByteLength];
			this._state = DEFLATING;
			perMessageDeflate.compress(data, options.fin, (_, buf) => {
				if (this._socket.destroyed) {
					callCallbacks(this, /* @__PURE__ */ new Error("The socket was closed while data was being compressed"), cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				this._state = DEFAULT;
				options.readOnly = false;
				this.sendFrame(Sender$2.frame(buf, options), cb);
				this.dequeue();
			});
		}
		/**
		* Executes queued send operations.
		*
		* @private
		*/
		dequeue() {
			while (this._state === DEFAULT && this._queue.length) {
				const params = this._queue.shift();
				this._bufferedBytes -= params[3][kByteLength];
				Reflect.apply(params[0], this, params.slice(1));
			}
		}
		/**
		* Enqueues a send operation.
		*
		* @param {Array} params Send operation parameters.
		* @private
		*/
		enqueue(params) {
			this._bufferedBytes += params[3][kByteLength];
			this._queue.push(params);
		}
		/**
		* Sends a frame.
		*
		* @param {(Buffer | String)[]} list The frame to send
		* @param {Function} [cb] Callback
		* @private
		*/
		sendFrame(list, cb) {
			if (list.length === 2) {
				this._socket.cork();
				this._socket.write(list[0]);
				this._socket.write(list[1], cb);
				this._socket.uncork();
			} else this._socket.write(list[0], cb);
		}
	};
	module.exports = Sender$2;
	/**
	* Calls queued callbacks with an error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error to call the callbacks with
	* @param {Function} [cb] The first callback
	* @private
	*/
	function callCallbacks(sender, err, cb) {
		if (typeof cb === "function") cb(err);
		for (let i$2 = 0; i$2 < sender._queue.length; i$2++) {
			const params = sender._queue[i$2];
			const callback = params[params.length - 1];
			if (typeof callback === "function") callback(err);
		}
	}
	/**
	* Handles a `Sender` error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error
	* @param {Function} [cb] The first pending callback
	* @private
	*/
	function onError(sender, err, cb) {
		callCallbacks(sender, err, cb);
		sender.onerror(err);
	}
}));

//#endregion
//#region node_modules/ws/lib/event-target.js
var require_event_target = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = require_constants();
	const kCode = Symbol("kCode");
	const kData = Symbol("kData");
	const kError = Symbol("kError");
	const kMessage = Symbol("kMessage");
	const kReason = Symbol("kReason");
	const kTarget = Symbol("kTarget");
	const kType = Symbol("kType");
	const kWasClean = Symbol("kWasClean");
	/**
	* Class representing an event.
	*/
	var Event$1 = class {
		/**
		* Create a new `Event`.
		*
		* @param {String} type The name of the event
		* @throws {TypeError} If the `type` argument is not specified
		*/
		constructor(type) {
			this[kTarget] = null;
			this[kType] = type;
		}
		/**
		* @type {*}
		*/
		get target() {
			return this[kTarget];
		}
		/**
		* @type {String}
		*/
		get type() {
			return this[kType];
		}
	};
	Object.defineProperty(Event$1.prototype, "target", { enumerable: true });
	Object.defineProperty(Event$1.prototype, "type", { enumerable: true });
	/**
	* Class representing a close event.
	*
	* @extends Event
	*/
	var CloseEvent = class extends Event$1 {
		/**
		* Create a new `CloseEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {Number} [options.code=0] The status code explaining why the
		*     connection was closed
		* @param {String} [options.reason=''] A human-readable string explaining why
		*     the connection was closed
		* @param {Boolean} [options.wasClean=false] Indicates whether or not the
		*     connection was cleanly closed
		*/
		constructor(type, options = {}) {
			super(type);
			this[kCode] = options.code === void 0 ? 0 : options.code;
			this[kReason] = options.reason === void 0 ? "" : options.reason;
			this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
		}
		/**
		* @type {Number}
		*/
		get code() {
			return this[kCode];
		}
		/**
		* @type {String}
		*/
		get reason() {
			return this[kReason];
		}
		/**
		* @type {Boolean}
		*/
		get wasClean() {
			return this[kWasClean];
		}
	};
	Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
	/**
	* Class representing an error event.
	*
	* @extends Event
	*/
	var ErrorEvent = class extends Event$1 {
		/**
		* Create a new `ErrorEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.error=null] The error that generated this event
		* @param {String} [options.message=''] The error message
		*/
		constructor(type, options = {}) {
			super(type);
			this[kError] = options.error === void 0 ? null : options.error;
			this[kMessage] = options.message === void 0 ? "" : options.message;
		}
		/**
		* @type {*}
		*/
		get error() {
			return this[kError];
		}
		/**
		* @type {String}
		*/
		get message() {
			return this[kMessage];
		}
	};
	Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
	/**
	* Class representing a message event.
	*
	* @extends Event
	*/
	var MessageEvent = class extends Event$1 {
		/**
		* Create a new `MessageEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.data=null] The message content
		*/
		constructor(type, options = {}) {
			super(type);
			this[kData] = options.data === void 0 ? null : options.data;
		}
		/**
		* @type {*}
		*/
		get data() {
			return this[kData];
		}
	};
	Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
	/**
	* This provides methods for emulating the `EventTarget` interface. It's not
	* meant to be used directly.
	*
	* @mixin
	*/
	const EventTarget$1 = {
		addEventListener(type, handler$1, options = {}) {
			for (const listener of this.listeners(type)) if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler$1 && !listener[kForOnEventAttribute$1]) return;
			let wrapper;
			if (type === "message") wrapper = function onMessage(data, isBinary) {
				const event = new MessageEvent("message", { data: isBinary ? data : data.toString() });
				event[kTarget] = this;
				callListener(handler$1, this, event);
			};
			else if (type === "close") wrapper = function onClose(code$1, message) {
				const event = new CloseEvent("close", {
					code: code$1,
					reason: message.toString(),
					wasClean: this._closeFrameReceived && this._closeFrameSent
				});
				event[kTarget] = this;
				callListener(handler$1, this, event);
			};
			else if (type === "error") wrapper = function onError$2(error$1) {
				const event = new ErrorEvent("error", {
					error: error$1,
					message: error$1.message
				});
				event[kTarget] = this;
				callListener(handler$1, this, event);
			};
			else if (type === "open") wrapper = function onOpen() {
				const event = new Event$1("open");
				event[kTarget] = this;
				callListener(handler$1, this, event);
			};
			else return;
			wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];
			wrapper[kListener$1] = handler$1;
			if (options.once) this.once(type, wrapper);
			else this.on(type, wrapper);
		},
		removeEventListener(type, handler$1) {
			for (const listener of this.listeners(type)) if (listener[kListener$1] === handler$1 && !listener[kForOnEventAttribute$1]) {
				this.removeListener(type, listener);
				break;
			}
		}
	};
	module.exports = {
		CloseEvent,
		ErrorEvent,
		Event: Event$1,
		EventTarget: EventTarget$1,
		MessageEvent
	};
	/**
	* Call an event listener
	*
	* @param {(Function|Object)} listener The listener to call
	* @param {*} thisArg The value to use as `this`` when calling the listener
	* @param {Event} event The event to pass to the listener
	* @private
	*/
	function callListener(listener, thisArg, event) {
		if (typeof listener === "object" && listener.handleEvent) listener.handleEvent.call(listener, event);
		else listener.call(thisArg, event);
	}
}));

//#endregion
//#region node_modules/ws/lib/extension.js
var require_extension = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { tokenChars: tokenChars$1 } = require_validation();
	/**
	* Adds an offer to the map of extension offers or a parameter to the map of
	* parameters.
	*
	* @param {Object} dest The map of extension offers or parameters
	* @param {String} name The extension or parameter name
	* @param {(Object|Boolean|String)} elem The extension parameters or the
	*     parameter value
	* @private
	*/
	function push(dest, name, elem) {
		if (dest[name] === void 0) dest[name] = [elem];
		else dest[name].push(elem);
	}
	/**
	* Parses the `Sec-WebSocket-Extensions` header into an object.
	*
	* @param {String} header The field value of the header
	* @return {Object} The parsed object
	* @public
	*/
	function parse$2(header) {
		const offers = Object.create(null);
		let params = Object.create(null);
		let mustUnescape = false;
		let isEscaping = false;
		let inQuotes = false;
		let extensionName;
		let paramName;
		let start = -1;
		let code$1 = -1;
		let end = -1;
		let i$2 = 0;
		for (; i$2 < header.length; i$2++) {
			code$1 = header.charCodeAt(i$2);
			if (extensionName === void 0) if (end === -1 && tokenChars$1[code$1] === 1) {
				if (start === -1) start = i$2;
			} else if (i$2 !== 0 && (code$1 === 32 || code$1 === 9)) {
				if (end === -1 && start !== -1) end = i$2;
			} else if (code$1 === 59 || code$1 === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$2}`);
				if (end === -1) end = i$2;
				const name = header.slice(start, end);
				if (code$1 === 44) {
					push(offers, name, params);
					params = Object.create(null);
				} else extensionName = name;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$2}`);
			else if (paramName === void 0) if (end === -1 && tokenChars$1[code$1] === 1) {
				if (start === -1) start = i$2;
			} else if (code$1 === 32 || code$1 === 9) {
				if (end === -1 && start !== -1) end = i$2;
			} else if (code$1 === 59 || code$1 === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$2}`);
				if (end === -1) end = i$2;
				push(params, header.slice(start, end), true);
				if (code$1 === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				start = end = -1;
			} else if (code$1 === 61 && start !== -1 && end === -1) {
				paramName = header.slice(start, i$2);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$2}`);
			else if (isEscaping) {
				if (tokenChars$1[code$1] !== 1) throw new SyntaxError(`Unexpected character at index ${i$2}`);
				if (start === -1) start = i$2;
				else if (!mustUnescape) mustUnescape = true;
				isEscaping = false;
			} else if (inQuotes) if (tokenChars$1[code$1] === 1) {
				if (start === -1) start = i$2;
			} else if (code$1 === 34 && start !== -1) {
				inQuotes = false;
				end = i$2;
			} else if (code$1 === 92) isEscaping = true;
			else throw new SyntaxError(`Unexpected character at index ${i$2}`);
			else if (code$1 === 34 && header.charCodeAt(i$2 - 1) === 61) inQuotes = true;
			else if (end === -1 && tokenChars$1[code$1] === 1) {
				if (start === -1) start = i$2;
			} else if (start !== -1 && (code$1 === 32 || code$1 === 9)) {
				if (end === -1) end = i$2;
			} else if (code$1 === 59 || code$1 === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$2}`);
				if (end === -1) end = i$2;
				let value = header.slice(start, end);
				if (mustUnescape) {
					value = value.replace(/\\/g, "");
					mustUnescape = false;
				}
				push(params, paramName, value);
				if (code$1 === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				paramName = void 0;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$2}`);
		}
		if (start === -1 || inQuotes || code$1 === 32 || code$1 === 9) throw new SyntaxError("Unexpected end of input");
		if (end === -1) end = i$2;
		const token = header.slice(start, end);
		if (extensionName === void 0) push(offers, token, params);
		else {
			if (paramName === void 0) push(params, token, true);
			else if (mustUnescape) push(params, paramName, token.replace(/\\/g, ""));
			else push(params, paramName, token);
			push(offers, extensionName, params);
		}
		return offers;
	}
	/**
	* Builds the `Sec-WebSocket-Extensions` header field value.
	*
	* @param {Object} extensions The map of extensions and parameters to format
	* @return {String} A string representing the given object
	* @public
	*/
	function format$1(extensions) {
		return Object.keys(extensions).map((extension$1) => {
			let configurations = extensions[extension$1];
			if (!Array.isArray(configurations)) configurations = [configurations];
			return configurations.map((params) => {
				return [extension$1].concat(Object.keys(params).map((k) => {
					let values = params[k];
					if (!Array.isArray(values)) values = [values];
					return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
				})).join("; ");
			}).join(", ");
		}).join(", ");
	}
	module.exports = {
		format: format$1,
		parse: parse$2
	};
}));

//#endregion
//#region node_modules/ws/lib/websocket.js
var require_websocket = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter$1 = require("events");
	const https = require("https");
	const http$1 = require("http");
	const net = require("net");
	const tls = require("tls");
	const { randomBytes, createHash: createHash$1 } = require("crypto");
	const { Duplex: Duplex$2, Readable: Readable$1 } = require("stream");
	const { URL: URL$1 } = require("url");
	const PerMessageDeflate$1 = require_permessage_deflate();
	const Receiver$1 = require_receiver();
	const Sender$1 = require_sender();
	const { isBlob } = require_validation();
	const { BINARY_TYPES, EMPTY_BUFFER, GUID: GUID$1, kForOnEventAttribute, kListener, kStatusCode, kWebSocket: kWebSocket$1, NOOP } = require_constants();
	const { EventTarget: { addEventListener, removeEventListener } } = require_event_target();
	const { format, parse: parse$1 } = require_extension();
	const { toBuffer } = require_buffer_util();
	const closeTimeout = 30 * 1e3;
	const kAborted = Symbol("kAborted");
	const protocolVersions = [8, 13];
	const readyStates = [
		"CONNECTING",
		"OPEN",
		"CLOSING",
		"CLOSED"
	];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
	/**
	* Class representing a WebSocket.
	*
	* @extends EventEmitter
	*/
	var WebSocket$2 = class WebSocket$2 extends EventEmitter$1 {
		/**
		* Create a new `WebSocket`.
		*
		* @param {(String|URL)} address The URL to which to connect
		* @param {(String|String[])} [protocols] The subprotocols
		* @param {Object} [options] Connection options
		*/
		constructor(address, protocols, options) {
			super();
			this._binaryType = BINARY_TYPES[0];
			this._closeCode = 1006;
			this._closeFrameReceived = false;
			this._closeFrameSent = false;
			this._closeMessage = EMPTY_BUFFER;
			this._closeTimer = null;
			this._errorEmitted = false;
			this._extensions = {};
			this._paused = false;
			this._protocol = "";
			this._readyState = WebSocket$2.CONNECTING;
			this._receiver = null;
			this._sender = null;
			this._socket = null;
			if (address !== null) {
				this._bufferedAmount = 0;
				this._isServer = false;
				this._redirects = 0;
				if (protocols === void 0) protocols = [];
				else if (!Array.isArray(protocols)) if (typeof protocols === "object" && protocols !== null) {
					options = protocols;
					protocols = [];
				} else protocols = [protocols];
				initAsClient(this, address, protocols, options);
			} else {
				this._autoPong = options.autoPong;
				this._isServer = true;
			}
		}
		/**
		* For historical reasons, the custom "nodebuffer" type is used by the default
		* instead of "blob".
		*
		* @type {String}
		*/
		get binaryType() {
			return this._binaryType;
		}
		set binaryType(type) {
			if (!BINARY_TYPES.includes(type)) return;
			this._binaryType = type;
			if (this._receiver) this._receiver._binaryType = type;
		}
		/**
		* @type {Number}
		*/
		get bufferedAmount() {
			if (!this._socket) return this._bufferedAmount;
			return this._socket._writableState.length + this._sender._bufferedBytes;
		}
		/**
		* @type {String}
		*/
		get extensions() {
			return Object.keys(this._extensions).join();
		}
		/**
		* @type {Boolean}
		*/
		get isPaused() {
			return this._paused;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onclose() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onerror() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onopen() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onmessage() {
			return null;
		}
		/**
		* @type {String}
		*/
		get protocol() {
			return this._protocol;
		}
		/**
		* @type {Number}
		*/
		get readyState() {
			return this._readyState;
		}
		/**
		* @type {String}
		*/
		get url() {
			return this._url;
		}
		/**
		* Set up the socket and the internal resources.
		*
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Object} options Options object
		* @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Number} [options.maxPayload=0] The maximum allowed message size
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @private
		*/
		setSocket(socket, head, options) {
			const receiver = new Receiver$1({
				allowSynchronousEvents: options.allowSynchronousEvents,
				binaryType: this.binaryType,
				extensions: this._extensions,
				isServer: this._isServer,
				maxPayload: options.maxPayload,
				skipUTF8Validation: options.skipUTF8Validation
			});
			const sender = new Sender$1(socket, this._extensions, options.generateMask);
			this._receiver = receiver;
			this._sender = sender;
			this._socket = socket;
			receiver[kWebSocket$1] = this;
			sender[kWebSocket$1] = this;
			socket[kWebSocket$1] = this;
			receiver.on("conclude", receiverOnConclude);
			receiver.on("drain", receiverOnDrain);
			receiver.on("error", receiverOnError);
			receiver.on("message", receiverOnMessage);
			receiver.on("ping", receiverOnPing);
			receiver.on("pong", receiverOnPong);
			sender.onerror = senderOnError;
			if (socket.setTimeout) socket.setTimeout(0);
			if (socket.setNoDelay) socket.setNoDelay();
			if (head.length > 0) socket.unshift(head);
			socket.on("close", socketOnClose);
			socket.on("data", socketOnData);
			socket.on("end", socketOnEnd);
			socket.on("error", socketOnError$1);
			this._readyState = WebSocket$2.OPEN;
			this.emit("open");
		}
		/**
		* Emit the `'close'` event.
		*
		* @private
		*/
		emitClose() {
			if (!this._socket) {
				this._readyState = WebSocket$2.CLOSED;
				this.emit("close", this._closeCode, this._closeMessage);
				return;
			}
			if (this._extensions[PerMessageDeflate$1.extensionName]) this._extensions[PerMessageDeflate$1.extensionName].cleanup();
			this._receiver.removeAllListeners();
			this._readyState = WebSocket$2.CLOSED;
			this.emit("close", this._closeCode, this._closeMessage);
		}
		/**
		* Start a closing handshake.
		*
		*          +----------+   +-----------+   +----------+
		*     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
		*    |     +----------+   +-----------+   +----------+     |
		*          +----------+   +-----------+         |
		* CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
		*          +----------+   +-----------+   |
		*    |           |                        |   +---+        |
		*                +------------------------+-->|fin| - - - -
		*    |         +---+                      |   +---+
		*     - - - - -|fin|<---------------------+
		*              +---+
		*
		* @param {Number} [code] Status code explaining why the connection is closing
		* @param {(String|Buffer)} [data] The reason why the connection is
		*     closing
		* @public
		*/
		close(code$1, data) {
			if (this.readyState === WebSocket$2.CLOSED) return;
			if (this.readyState === WebSocket$2.CONNECTING) {
				abortHandshake$1(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this.readyState === WebSocket$2.CLOSING) {
				if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
				return;
			}
			this._readyState = WebSocket$2.CLOSING;
			this._sender.close(code$1, data, !this._isServer, (err) => {
				if (err) return;
				this._closeFrameSent = true;
				if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end();
			});
			setCloseTimer(this);
		}
		/**
		* Pause the socket.
		*
		* @public
		*/
		pause() {
			if (this.readyState === WebSocket$2.CONNECTING || this.readyState === WebSocket$2.CLOSED) return;
			this._paused = true;
			this._socket.pause();
		}
		/**
		* Send a ping.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the ping is sent
		* @public
		*/
		ping(data, mask, cb) {
			if (this.readyState === WebSocket$2.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$2.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.ping(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Send a pong.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the pong is sent
		* @public
		*/
		pong(data, mask, cb) {
			if (this.readyState === WebSocket$2.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$2.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.pong(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Resume the socket.
		*
		* @public
		*/
		resume() {
			if (this.readyState === WebSocket$2.CONNECTING || this.readyState === WebSocket$2.CLOSED) return;
			this._paused = false;
			if (!this._receiver._writableState.needDrain) this._socket.resume();
		}
		/**
		* Send a data message.
		*
		* @param {*} data The message to send
		* @param {Object} [options] Options object
		* @param {Boolean} [options.binary] Specifies whether `data` is binary or
		*     text
		* @param {Boolean} [options.compress] Specifies whether or not to compress
		*     `data`
		* @param {Boolean} [options.fin=true] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when data is written out
		* @public
		*/
		send(data, options, cb) {
			if (this.readyState === WebSocket$2.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof options === "function") {
				cb = options;
				options = {};
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$2.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			const opts = {
				binary: typeof data !== "string",
				mask: !this._isServer,
				compress: true,
				fin: true,
				...options
			};
			if (!this._extensions[PerMessageDeflate$1.extensionName]) opts.compress = false;
			this._sender.send(data || EMPTY_BUFFER, opts, cb);
		}
		/**
		* Forcibly close the connection.
		*
		* @public
		*/
		terminate() {
			if (this.readyState === WebSocket$2.CLOSED) return;
			if (this.readyState === WebSocket$2.CONNECTING) {
				abortHandshake$1(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this._socket) {
				this._readyState = WebSocket$2.CLOSING;
				this._socket.destroy();
			}
		}
	};
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	[
		"binaryType",
		"bufferedAmount",
		"extensions",
		"isPaused",
		"protocol",
		"readyState",
		"url"
	].forEach((property) => {
		Object.defineProperty(WebSocket$2.prototype, property, { enumerable: true });
	});
	[
		"open",
		"error",
		"close",
		"message"
	].forEach((method) => {
		Object.defineProperty(WebSocket$2.prototype, `on${method}`, {
			enumerable: true,
			get() {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) return listener[kListener];
				return null;
			},
			set(handler$1) {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) {
					this.removeListener(method, listener);
					break;
				}
				if (typeof handler$1 !== "function") return;
				this.addEventListener(method, handler$1, { [kForOnEventAttribute]: true });
			}
		});
	});
	WebSocket$2.prototype.addEventListener = addEventListener;
	WebSocket$2.prototype.removeEventListener = removeEventListener;
	module.exports = WebSocket$2;
	/**
	* Initialize a WebSocket client.
	*
	* @param {WebSocket} websocket The client to initialize
	* @param {(String|URL)} address The URL to which to connect
	* @param {Array} protocols The subprotocols
	* @param {Object} [options] Connection options
	* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	*     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	*     times in the same tick
	* @param {Boolean} [options.autoPong=true] Specifies whether or not to
	*     automatically send a pong in response to a ping
	* @param {Function} [options.finishRequest] A function which can be used to
	*     customize the headers of each http request before it is sent
	* @param {Boolean} [options.followRedirects=false] Whether or not to follow
	*     redirects
	* @param {Function} [options.generateMask] The function used to generate the
	*     masking key
	* @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	*     handshake request
	* @param {Number} [options.maxPayload=104857600] The maximum allowed message
	*     size
	* @param {Number} [options.maxRedirects=10] The maximum number of redirects
	*     allowed
	* @param {String} [options.origin] Value of the `Origin` or
	*     `Sec-WebSocket-Origin` header
	* @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	*     permessage-deflate
	* @param {Number} [options.protocolVersion=13] Value of the
	*     `Sec-WebSocket-Version` header
	* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	*     not to skip UTF-8 validation for text and close messages
	* @private
	*/
	function initAsClient(websocket, address, protocols, options) {
		const opts = {
			allowSynchronousEvents: true,
			autoPong: true,
			protocolVersion: protocolVersions[1],
			maxPayload: 100 * 1024 * 1024,
			skipUTF8Validation: false,
			perMessageDeflate: true,
			followRedirects: false,
			maxRedirects: 10,
			...options,
			socketPath: void 0,
			hostname: void 0,
			protocol: void 0,
			timeout: void 0,
			method: "GET",
			host: void 0,
			path: void 0,
			port: void 0
		};
		websocket._autoPong = opts.autoPong;
		if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
		let parsedUrl;
		if (address instanceof URL$1) parsedUrl = address;
		else try {
			parsedUrl = new URL$1(address);
		} catch (e$1) {
			throw new SyntaxError(`Invalid URL: ${address}`);
		}
		if (parsedUrl.protocol === "http:") parsedUrl.protocol = "ws:";
		else if (parsedUrl.protocol === "https:") parsedUrl.protocol = "wss:";
		websocket._url = parsedUrl.href;
		const isSecure = parsedUrl.protocol === "wss:";
		const isIpcUrl = parsedUrl.protocol === "ws+unix:";
		let invalidUrlMessage;
		if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) invalidUrlMessage = "The URL's protocol must be one of \"ws:\", \"wss:\", \"http:\", \"https:\", or \"ws+unix:\"";
		else if (isIpcUrl && !parsedUrl.pathname) invalidUrlMessage = "The URL's pathname is empty";
		else if (parsedUrl.hash) invalidUrlMessage = "The URL contains a fragment identifier";
		if (invalidUrlMessage) {
			const err = new SyntaxError(invalidUrlMessage);
			if (websocket._redirects === 0) throw err;
			else {
				emitErrorAndClose(websocket, err);
				return;
			}
		}
		const defaultPort = isSecure ? 443 : 80;
		const key = randomBytes(16).toString("base64");
		const request$3 = isSecure ? https.request : http$1.request;
		const protocolSet = /* @__PURE__ */ new Set();
		let perMessageDeflate;
		opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
		opts.defaultPort = opts.defaultPort || defaultPort;
		opts.port = parsedUrl.port || defaultPort;
		opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
		opts.headers = {
			...opts.headers,
			"Sec-WebSocket-Version": opts.protocolVersion,
			"Sec-WebSocket-Key": key,
			Connection: "Upgrade",
			Upgrade: "websocket"
		};
		opts.path = parsedUrl.pathname + parsedUrl.search;
		opts.timeout = opts.handshakeTimeout;
		if (opts.perMessageDeflate) {
			perMessageDeflate = new PerMessageDeflate$1(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
			opts.headers["Sec-WebSocket-Extensions"] = format({ [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer() });
		}
		if (protocols.length) {
			for (const protocol of protocols) {
				if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError("An invalid or duplicated subprotocol was specified");
				protocolSet.add(protocol);
			}
			opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
		}
		if (opts.origin) if (opts.protocolVersion < 13) opts.headers["Sec-WebSocket-Origin"] = opts.origin;
		else opts.headers.Origin = opts.origin;
		if (parsedUrl.username || parsedUrl.password) opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
		if (isIpcUrl) {
			const parts = opts.path.split(":");
			opts.socketPath = parts[0];
			opts.path = parts[1];
		}
		let req$1;
		if (opts.followRedirects) {
			if (websocket._redirects === 0) {
				websocket._originalIpc = isIpcUrl;
				websocket._originalSecure = isSecure;
				websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
				const headers = options && options.headers;
				options = {
					...options,
					headers: {}
				};
				if (headers) for (const [key$1, value] of Object.entries(headers)) options.headers[key$1.toLowerCase()] = value;
			} else if (websocket.listenerCount("redirect") === 0) {
				const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
				if (!isSameHost || websocket._originalSecure && !isSecure) {
					delete opts.headers.authorization;
					delete opts.headers.cookie;
					if (!isSameHost) delete opts.headers.host;
					opts.auth = void 0;
				}
			}
			if (opts.auth && !options.headers.authorization) options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
			req$1 = websocket._req = request$3(opts);
			if (websocket._redirects) websocket.emit("redirect", websocket.url, req$1);
		} else req$1 = websocket._req = request$3(opts);
		if (opts.timeout) req$1.on("timeout", () => {
			abortHandshake$1(websocket, req$1, "Opening handshake has timed out");
		});
		req$1.on("error", (err) => {
			if (req$1 === null || req$1[kAborted]) return;
			req$1 = websocket._req = null;
			emitErrorAndClose(websocket, err);
		});
		req$1.on("response", (res) => {
			const location = res.headers.location;
			const statusCode = res.statusCode;
			if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
				if (++websocket._redirects > opts.maxRedirects) {
					abortHandshake$1(websocket, req$1, "Maximum redirects exceeded");
					return;
				}
				req$1.abort();
				let addr;
				try {
					addr = new URL$1(location, address);
				} catch (e$1) {
					emitErrorAndClose(websocket, /* @__PURE__ */ new SyntaxError(`Invalid URL: ${location}`));
					return;
				}
				initAsClient(websocket, addr, protocols, options);
			} else if (!websocket.emit("unexpected-response", req$1, res)) abortHandshake$1(websocket, req$1, `Unexpected server response: ${res.statusCode}`);
		});
		req$1.on("upgrade", (res, socket, head) => {
			websocket.emit("upgrade", res);
			if (websocket.readyState !== WebSocket$2.CONNECTING) return;
			req$1 = websocket._req = null;
			const upgrade$1 = res.headers.upgrade;
			if (upgrade$1 === void 0 || upgrade$1.toLowerCase() !== "websocket") {
				abortHandshake$1(websocket, socket, "Invalid Upgrade header");
				return;
			}
			const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
			if (res.headers["sec-websocket-accept"] !== digest) {
				abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Accept header");
				return;
			}
			const serverProt = res.headers["sec-websocket-protocol"];
			let protError;
			if (serverProt !== void 0) {
				if (!protocolSet.size) protError = "Server sent a subprotocol but none was requested";
				else if (!protocolSet.has(serverProt)) protError = "Server sent an invalid subprotocol";
			} else if (protocolSet.size) protError = "Server sent no subprotocol";
			if (protError) {
				abortHandshake$1(websocket, socket, protError);
				return;
			}
			if (serverProt) websocket._protocol = serverProt;
			const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
			if (secWebSocketExtensions !== void 0) {
				if (!perMessageDeflate) {
					abortHandshake$1(websocket, socket, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
					return;
				}
				let extensions;
				try {
					extensions = parse$1(secWebSocketExtensions);
				} catch (err) {
					abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				const extensionNames = Object.keys(extensions);
				if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
					abortHandshake$1(websocket, socket, "Server indicated an extension that was not requested");
					return;
				}
				try {
					perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);
				} catch (err) {
					abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				websocket._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
			}
			websocket.setSocket(socket, head, {
				allowSynchronousEvents: opts.allowSynchronousEvents,
				generateMask: opts.generateMask,
				maxPayload: opts.maxPayload,
				skipUTF8Validation: opts.skipUTF8Validation
			});
		});
		if (opts.finishRequest) opts.finishRequest(req$1, websocket);
		else req$1.end();
	}
	/**
	* Emit the `'error'` and `'close'` events.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {Error} The error to emit
	* @private
	*/
	function emitErrorAndClose(websocket, err) {
		websocket._readyState = WebSocket$2.CLOSING;
		websocket._errorEmitted = true;
		websocket.emit("error", err);
		websocket.emitClose();
	}
	/**
	* Create a `net.Socket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {net.Socket} The newly created socket used to start the connection
	* @private
	*/
	function netConnect(options) {
		options.path = options.socketPath;
		return net.connect(options);
	}
	/**
	* Create a `tls.TLSSocket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {tls.TLSSocket} The newly created socket used to start the connection
	* @private
	*/
	function tlsConnect(options) {
		options.path = void 0;
		if (!options.servername && options.servername !== "") options.servername = net.isIP(options.host) ? "" : options.host;
		return tls.connect(options);
	}
	/**
	* Abort the handshake and emit an error.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	*     abort or the socket to destroy
	* @param {String} message The error message
	* @private
	*/
	function abortHandshake$1(websocket, stream$6, message) {
		websocket._readyState = WebSocket$2.CLOSING;
		const err = new Error(message);
		Error.captureStackTrace(err, abortHandshake$1);
		if (stream$6.setHeader) {
			stream$6[kAborted] = true;
			stream$6.abort();
			if (stream$6.socket && !stream$6.socket.destroyed) stream$6.socket.destroy();
			process.nextTick(emitErrorAndClose, websocket, err);
		} else {
			stream$6.destroy(err);
			stream$6.once("error", websocket.emit.bind(websocket, "error"));
			stream$6.once("close", websocket.emitClose.bind(websocket));
		}
	}
	/**
	* Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	* when the `readyState` attribute is `CLOSING` or `CLOSED`.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {*} [data] The data to send
	* @param {Function} [cb] Callback
	* @private
	*/
	function sendAfterClose(websocket, data, cb) {
		if (data) {
			const length = isBlob(data) ? data.size : toBuffer(data).length;
			if (websocket._socket) websocket._sender._bufferedBytes += length;
			else websocket._bufferedAmount += length;
		}
		if (cb) {
			const err = /* @__PURE__ */ new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
			process.nextTick(cb, err);
		}
	}
	/**
	* The listener of the `Receiver` `'conclude'` event.
	*
	* @param {Number} code The status code
	* @param {Buffer} reason The reason for closing
	* @private
	*/
	function receiverOnConclude(code$1, reason) {
		const websocket = this[kWebSocket$1];
		websocket._closeFrameReceived = true;
		websocket._closeMessage = reason;
		websocket._closeCode = code$1;
		if (websocket._socket[kWebSocket$1] === void 0) return;
		websocket._socket.removeListener("data", socketOnData);
		process.nextTick(resume, websocket._socket);
		if (code$1 === 1005) websocket.close();
		else websocket.close(code$1, reason);
	}
	/**
	* The listener of the `Receiver` `'drain'` event.
	*
	* @private
	*/
	function receiverOnDrain() {
		const websocket = this[kWebSocket$1];
		if (!websocket.isPaused) websocket._socket.resume();
	}
	/**
	* The listener of the `Receiver` `'error'` event.
	*
	* @param {(RangeError|Error)} err The emitted error
	* @private
	*/
	function receiverOnError(err) {
		const websocket = this[kWebSocket$1];
		if (websocket._socket[kWebSocket$1] !== void 0) {
			websocket._socket.removeListener("data", socketOnData);
			process.nextTick(resume, websocket._socket);
			websocket.close(err[kStatusCode]);
		}
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* The listener of the `Receiver` `'finish'` event.
	*
	* @private
	*/
	function receiverOnFinish() {
		this[kWebSocket$1].emitClose();
	}
	/**
	* The listener of the `Receiver` `'message'` event.
	*
	* @param {Buffer|ArrayBuffer|Buffer[])} data The message
	* @param {Boolean} isBinary Specifies whether the message is binary or not
	* @private
	*/
	function receiverOnMessage(data, isBinary) {
		this[kWebSocket$1].emit("message", data, isBinary);
	}
	/**
	* The listener of the `Receiver` `'ping'` event.
	*
	* @param {Buffer} data The data included in the ping frame
	* @private
	*/
	function receiverOnPing(data) {
		const websocket = this[kWebSocket$1];
		if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
		websocket.emit("ping", data);
	}
	/**
	* The listener of the `Receiver` `'pong'` event.
	*
	* @param {Buffer} data The data included in the pong frame
	* @private
	*/
	function receiverOnPong(data) {
		this[kWebSocket$1].emit("pong", data);
	}
	/**
	* Resume a readable stream
	*
	* @param {Readable} stream The readable stream
	* @private
	*/
	function resume(stream$6) {
		stream$6.resume();
	}
	/**
	* The `Sender` error event handler.
	*
	* @param {Error} The error
	* @private
	*/
	function senderOnError(err) {
		const websocket = this[kWebSocket$1];
		if (websocket.readyState === WebSocket$2.CLOSED) return;
		if (websocket.readyState === WebSocket$2.OPEN) {
			websocket._readyState = WebSocket$2.CLOSING;
			setCloseTimer(websocket);
		}
		this._socket.end();
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* Set a timer to destroy the underlying raw socket of a WebSocket.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @private
	*/
	function setCloseTimer(websocket) {
		websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
	}
	/**
	* The listener of the socket `'close'` event.
	*
	* @private
	*/
	function socketOnClose() {
		const websocket = this[kWebSocket$1];
		this.removeListener("close", socketOnClose);
		this.removeListener("data", socketOnData);
		this.removeListener("end", socketOnEnd);
		websocket._readyState = WebSocket$2.CLOSING;
		let chunk;
		if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) websocket._receiver.write(chunk);
		websocket._receiver.end();
		this[kWebSocket$1] = void 0;
		clearTimeout(websocket._closeTimer);
		if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) websocket.emitClose();
		else {
			websocket._receiver.on("error", receiverOnFinish);
			websocket._receiver.on("finish", receiverOnFinish);
		}
	}
	/**
	* The listener of the socket `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function socketOnData(chunk) {
		if (!this[kWebSocket$1]._receiver.write(chunk)) this.pause();
	}
	/**
	* The listener of the socket `'end'` event.
	*
	* @private
	*/
	function socketOnEnd() {
		const websocket = this[kWebSocket$1];
		websocket._readyState = WebSocket$2.CLOSING;
		websocket._receiver.end();
		this.end();
	}
	/**
	* The listener of the socket `'error'` event.
	*
	* @private
	*/
	function socketOnError$1() {
		const websocket = this[kWebSocket$1];
		this.removeListener("error", socketOnError$1);
		this.on("error", NOOP);
		if (websocket) {
			websocket._readyState = WebSocket$2.CLOSING;
			this.destroy();
		}
	}
}));

//#endregion
//#region node_modules/ws/lib/stream.js
var require_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	require_websocket();
	const { Duplex: Duplex$1 } = require("stream");
	/**
	* Emits the `'close'` event on a stream.
	*
	* @param {Duplex} stream The stream.
	* @private
	*/
	function emitClose$1(stream$6) {
		stream$6.emit("close");
	}
	/**
	* The listener of the `'end'` event.
	*
	* @private
	*/
	function duplexOnEnd() {
		if (!this.destroyed && this._writableState.finished) this.destroy();
	}
	/**
	* The listener of the `'error'` event.
	*
	* @param {Error} err The error
	* @private
	*/
	function duplexOnError(err) {
		this.removeListener("error", duplexOnError);
		this.destroy();
		if (this.listenerCount("error") === 0) this.emit("error", err);
	}
	/**
	* Wraps a `WebSocket` in a duplex stream.
	*
	* @param {WebSocket} ws The `WebSocket` to wrap
	* @param {Object} [options] The options for the `Duplex` constructor
	* @return {Duplex} The duplex stream
	* @public
	*/
	function createWebSocketStream$1(ws, options) {
		let terminateOnDestroy = true;
		const duplex = new Duplex$1({
			...options,
			autoDestroy: false,
			emitClose: false,
			objectMode: false,
			writableObjectMode: false
		});
		ws.on("message", function message(msg, isBinary) {
			const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
			if (!duplex.push(data)) ws.pause();
		});
		ws.once("error", function error$1(err) {
			if (duplex.destroyed) return;
			terminateOnDestroy = false;
			duplex.destroy(err);
		});
		ws.once("close", function close() {
			if (duplex.destroyed) return;
			duplex.push(null);
		});
		duplex._destroy = function(err, callback) {
			if (ws.readyState === ws.CLOSED) {
				callback(err);
				process.nextTick(emitClose$1, duplex);
				return;
			}
			let called = false;
			ws.once("error", function error$1(err$1) {
				called = true;
				callback(err$1);
			});
			ws.once("close", function close() {
				if (!called) callback(err);
				process.nextTick(emitClose$1, duplex);
			});
			if (terminateOnDestroy) ws.terminate();
		};
		duplex._final = function(callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._final(callback);
				});
				return;
			}
			if (ws._socket === null) return;
			if (ws._socket._writableState.finished) {
				callback();
				if (duplex._readableState.endEmitted) duplex.destroy();
			} else {
				ws._socket.once("finish", function finish() {
					callback();
				});
				ws.close();
			}
		};
		duplex._read = function() {
			if (ws.isPaused) ws.resume();
		};
		duplex._write = function(chunk, encoding, callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._write(chunk, encoding, callback);
				});
				return;
			}
			ws.send(chunk, callback);
		};
		duplex.on("end", duplexOnEnd);
		duplex.on("error", duplexOnError);
		return duplex;
	}
	module.exports = createWebSocketStream$1;
}));

//#endregion
//#region node_modules/ws/lib/subprotocol.js
var require_subprotocol = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { tokenChars } = require_validation();
	/**
	* Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	*
	* @param {String} header The field value of the header
	* @return {Set} The subprotocol names
	* @public
	*/
	function parse(header) {
		const protocols = /* @__PURE__ */ new Set();
		let start = -1;
		let end = -1;
		let i$2 = 0;
		for (; i$2 < header.length; i$2++) {
			const code$1 = header.charCodeAt(i$2);
			if (end === -1 && tokenChars[code$1] === 1) {
				if (start === -1) start = i$2;
			} else if (i$2 !== 0 && (code$1 === 32 || code$1 === 9)) {
				if (end === -1 && start !== -1) end = i$2;
			} else if (code$1 === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$2}`);
				if (end === -1) end = i$2;
				const protocol$1 = header.slice(start, end);
				if (protocols.has(protocol$1)) throw new SyntaxError(`The "${protocol$1}" subprotocol is duplicated`);
				protocols.add(protocol$1);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$2}`);
		}
		if (start === -1 || end !== -1) throw new SyntaxError("Unexpected end of input");
		const protocol = header.slice(start, i$2);
		if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
		protocols.add(protocol);
		return protocols;
	}
	module.exports = { parse };
}));

//#endregion
//#region node_modules/ws/lib/websocket-server.js
var require_websocket_server = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter = require("events");
	const http = require("http");
	const { Duplex } = require("stream");
	const { createHash } = require("crypto");
	const extension = require_extension();
	const PerMessageDeflate = require_permessage_deflate();
	const subprotocol = require_subprotocol();
	const WebSocket$1 = require_websocket();
	const { GUID, kWebSocket } = require_constants();
	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;
	/**
	* Class representing a WebSocket server.
	*
	* @extends EventEmitter
	*/
	var WebSocketServer$1 = class extends EventEmitter {
		/**
		* Create a `WebSocketServer` instance.
		*
		* @param {Object} options Configuration options
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Boolean} [options.autoPong=true] Specifies whether or not to
		*     automatically send a pong in response to a ping
		* @param {Number} [options.backlog=511] The maximum length of the queue of
		*     pending connections
		* @param {Boolean} [options.clientTracking=true] Specifies whether or not to
		*     track clients
		* @param {Function} [options.handleProtocols] A hook to handle protocols
		* @param {String} [options.host] The hostname where to bind the server
		* @param {Number} [options.maxPayload=104857600] The maximum allowed message
		*     size
		* @param {Boolean} [options.noServer=false] Enable no server mode
		* @param {String} [options.path] Accept only connections matching this path
		* @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
		*     permessage-deflate
		* @param {Number} [options.port] The port where to bind the server
		* @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
		*     server to use
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @param {Function} [options.verifyClient] A hook to reject connections
		* @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
		*     class to use. It must be the `WebSocket` class or class that extends it
		* @param {Function} [callback] A listener for the `listening` event
		*/
		constructor(options, callback) {
			super();
			options = {
				allowSynchronousEvents: true,
				autoPong: true,
				maxPayload: 100 * 1024 * 1024,
				skipUTF8Validation: false,
				perMessageDeflate: false,
				handleProtocols: null,
				clientTracking: true,
				verifyClient: null,
				noServer: false,
				backlog: null,
				server: null,
				host: null,
				path: null,
				port: null,
				WebSocket: WebSocket$1,
				...options
			};
			if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError("One and only one of the \"port\", \"server\", or \"noServer\" options must be specified");
			if (options.port != null) {
				this._server = http.createServer((req$1, res) => {
					const body = http.STATUS_CODES[426];
					res.writeHead(426, {
						"Content-Length": body.length,
						"Content-Type": "text/plain"
					});
					res.end(body);
				});
				this._server.listen(options.port, options.host, options.backlog, callback);
			} else if (options.server) this._server = options.server;
			if (this._server) {
				const emitConnection = this.emit.bind(this, "connection");
				this._removeListeners = addListeners(this._server, {
					listening: this.emit.bind(this, "listening"),
					error: this.emit.bind(this, "error"),
					upgrade: (req$1, socket, head) => {
						this.handleUpgrade(req$1, socket, head, emitConnection);
					}
				});
			}
			if (options.perMessageDeflate === true) options.perMessageDeflate = {};
			if (options.clientTracking) {
				this.clients = /* @__PURE__ */ new Set();
				this._shouldEmitClose = false;
			}
			this.options = options;
			this._state = RUNNING;
		}
		/**
		* Returns the bound address, the address family name, and port of the server
		* as reported by the operating system if listening on an IP socket.
		* If the server is listening on a pipe or UNIX domain socket, the name is
		* returned as a string.
		*
		* @return {(Object|String|null)} The address of the server
		* @public
		*/
		address() {
			if (this.options.noServer) throw new Error("The server is operating in \"noServer\" mode");
			if (!this._server) return null;
			return this._server.address();
		}
		/**
		* Stop the server from accepting new connections and emit the `'close'` event
		* when all existing connections are closed.
		*
		* @param {Function} [cb] A one-time listener for the `'close'` event
		* @public
		*/
		close(cb) {
			if (this._state === CLOSED) {
				if (cb) this.once("close", () => {
					cb(/* @__PURE__ */ new Error("The server is not running"));
				});
				process.nextTick(emitClose, this);
				return;
			}
			if (cb) this.once("close", cb);
			if (this._state === CLOSING) return;
			this._state = CLOSING;
			if (this.options.noServer || this.options.server) {
				if (this._server) {
					this._removeListeners();
					this._removeListeners = this._server = null;
				}
				if (this.clients) if (!this.clients.size) process.nextTick(emitClose, this);
				else this._shouldEmitClose = true;
				else process.nextTick(emitClose, this);
			} else {
				const server = this._server;
				this._removeListeners();
				this._removeListeners = this._server = null;
				server.close(() => {
					emitClose(this);
				});
			}
		}
		/**
		* See if a given request should be handled by this server instance.
		*
		* @param {http.IncomingMessage} req Request object to inspect
		* @return {Boolean} `true` if the request is valid, else `false`
		* @public
		*/
		shouldHandle(req$1) {
			if (this.options.path) {
				const index = req$1.url.indexOf("?");
				if ((index !== -1 ? req$1.url.slice(0, index) : req$1.url) !== this.options.path) return false;
			}
			return true;
		}
		/**
		* Handle a HTTP Upgrade request.
		*
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @public
		*/
		handleUpgrade(req$1, socket, head, cb) {
			socket.on("error", socketOnError);
			const key = req$1.headers["sec-websocket-key"];
			const upgrade$1 = req$1.headers.upgrade;
			const version = +req$1.headers["sec-websocket-version"];
			if (req$1.method !== "GET") {
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 405, "Invalid HTTP method");
				return;
			}
			if (upgrade$1 === void 0 || upgrade$1.toLowerCase() !== "websocket") {
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, "Invalid Upgrade header");
				return;
			}
			if (key === void 0 || !keyRegex.test(key)) {
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, "Missing or invalid Sec-WebSocket-Key header");
				return;
			}
			if (version !== 13 && version !== 8) {
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, "Missing or invalid Sec-WebSocket-Version header", { "Sec-WebSocket-Version": "13, 8" });
				return;
			}
			if (!this.shouldHandle(req$1)) {
				abortHandshake(socket, 400);
				return;
			}
			const secWebSocketProtocol = req$1.headers["sec-websocket-protocol"];
			let protocols = /* @__PURE__ */ new Set();
			if (secWebSocketProtocol !== void 0) try {
				protocols = subprotocol.parse(secWebSocketProtocol);
			} catch (err) {
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, "Invalid Sec-WebSocket-Protocol header");
				return;
			}
			const secWebSocketExtensions = req$1.headers["sec-websocket-extensions"];
			const extensions = {};
			if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
				const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
				try {
					const offers = extension.parse(secWebSocketExtensions);
					if (offers[PerMessageDeflate.extensionName]) {
						perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
						extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
					}
				} catch (err) {
					abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, "Invalid or unacceptable Sec-WebSocket-Extensions header");
					return;
				}
			}
			if (this.options.verifyClient) {
				const info$1 = {
					origin: req$1.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
					secure: !!(req$1.socket.authorized || req$1.socket.encrypted),
					req: req$1
				};
				if (this.options.verifyClient.length === 2) {
					this.options.verifyClient(info$1, (verified, code$1, message, headers) => {
						if (!verified) return abortHandshake(socket, code$1 || 401, message, headers);
						this.completeUpgrade(extensions, key, protocols, req$1, socket, head, cb);
					});
					return;
				}
				if (!this.options.verifyClient(info$1)) return abortHandshake(socket, 401);
			}
			this.completeUpgrade(extensions, key, protocols, req$1, socket, head, cb);
		}
		/**
		* Upgrade the connection to WebSocket.
		*
		* @param {Object} extensions The accepted extensions
		* @param {String} key The value of the `Sec-WebSocket-Key` header
		* @param {Set} protocols The subprotocols
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @throws {Error} If called more than once with the same socket
		* @private
		*/
		completeUpgrade(extensions, key, protocols, req$1, socket, head, cb) {
			if (!socket.readable || !socket.writable) return socket.destroy();
			if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
			if (this._state > RUNNING) return abortHandshake(socket, 503);
			const headers = [
				"HTTP/1.1 101 Switching Protocols",
				"Upgrade: websocket",
				"Connection: Upgrade",
				`Sec-WebSocket-Accept: ${createHash("sha1").update(key + GUID).digest("base64")}`
			];
			const ws = new this.options.WebSocket(null, void 0, this.options);
			if (protocols.size) {
				const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req$1) : protocols.values().next().value;
				if (protocol) {
					headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
					ws._protocol = protocol;
				}
			}
			if (extensions[PerMessageDeflate.extensionName]) {
				const params = extensions[PerMessageDeflate.extensionName].params;
				const value = extension.format({ [PerMessageDeflate.extensionName]: [params] });
				headers.push(`Sec-WebSocket-Extensions: ${value}`);
				ws._extensions = extensions;
			}
			this.emit("headers", headers, req$1);
			socket.write(headers.concat("\r\n").join("\r\n"));
			socket.removeListener("error", socketOnError);
			ws.setSocket(socket, head, {
				allowSynchronousEvents: this.options.allowSynchronousEvents,
				maxPayload: this.options.maxPayload,
				skipUTF8Validation: this.options.skipUTF8Validation
			});
			if (this.clients) {
				this.clients.add(ws);
				ws.on("close", () => {
					this.clients.delete(ws);
					if (this._shouldEmitClose && !this.clients.size) process.nextTick(emitClose, this);
				});
			}
			cb(ws, req$1);
		}
	};
	module.exports = WebSocketServer$1;
	/**
	* Add event listeners on an `EventEmitter` using a map of <event, listener>
	* pairs.
	*
	* @param {EventEmitter} server The event emitter
	* @param {Object.<String, Function>} map The listeners to add
	* @return {Function} A function that will remove the added listeners when
	*     called
	* @private
	*/
	function addListeners(server, map) {
		for (const event of Object.keys(map)) server.on(event, map[event]);
		return function removeListeners() {
			for (const event of Object.keys(map)) server.removeListener(event, map[event]);
		};
	}
	/**
	* Emit a `'close'` event on an `EventEmitter`.
	*
	* @param {EventEmitter} server The event emitter
	* @private
	*/
	function emitClose(server) {
		server._state = CLOSED;
		server.emit("close");
	}
	/**
	* Handle socket errors.
	*
	* @private
	*/
	function socketOnError() {
		this.destroy();
	}
	/**
	* Close the connection when preconditions are not fulfilled.
	*
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} [message] The HTTP response body
	* @param {Object} [headers] Additional HTTP response headers
	* @private
	*/
	function abortHandshake(socket, code$1, message, headers) {
		message = message || http.STATUS_CODES[code$1];
		headers = {
			Connection: "close",
			"Content-Type": "text/html",
			"Content-Length": Buffer.byteLength(message),
			...headers
		};
		socket.once("finish", socket.destroy);
		socket.end(`HTTP/1.1 ${code$1} ${http.STATUS_CODES[code$1]}\r\n` + Object.keys(headers).map((h$2) => `${h$2}: ${headers[h$2]}`).join("\r\n") + "\r\n\r\n" + message);
	}
	/**
	* Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	* one listener for it, otherwise call `abortHandshake()`.
	*
	* @param {WebSocketServer} server The WebSocket server
	* @param {http.IncomingMessage} req The request object
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} message The HTTP response body
	* @param {Object} [headers] The HTTP response headers
	* @private
	*/
	function abortHandshakeOrEmitwsClientError(server, req$1, socket, code$1, message, headers) {
		if (server.listenerCount("wsClientError")) {
			const err = new Error(message);
			Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
			server.emit("wsClientError", err, socket, req$1);
		} else abortHandshake(socket, code$1, message, headers);
	}
}));

//#endregion
//#region node_modules/ws/wrapper.mjs
var import_src = require_src();
var import_stream = /* @__PURE__ */ __toESM$1(require_stream(), 1);
var import_receiver = /* @__PURE__ */ __toESM$1(require_receiver(), 1);
var import_sender = /* @__PURE__ */ __toESM$1(require_sender(), 1);
var import_websocket = /* @__PURE__ */ __toESM$1(require_websocket(), 1);
var import_websocket_server = /* @__PURE__ */ __toESM$1(require_websocket_server(), 1);

//#endregion
//#region node_modules/@google/genai/dist/node/index.mjs
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
let _defaultBaseGeminiUrl = void 0;
let _defaultBaseVertexUrl = void 0;
/**
* Returns the default base URLs for the Gemini API and Vertex AI API.
*/
function getDefaultBaseUrls() {
	return {
		geminiUrl: _defaultBaseGeminiUrl,
		vertexUrl: _defaultBaseVertexUrl
	};
}
/**
* Returns the default base URL based on the following priority:
*   1. Base URLs set via HttpOptions.
*   2. Base URLs set via the latest call to setDefaultBaseUrls.
*   3. Base URLs set via environment variables.
*/
function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
	var _a$2, _b;
	if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {
		const defaultBaseUrls = getDefaultBaseUrls();
		if (vertexai) return (_a$2 = defaultBaseUrls.vertexUrl) !== null && _a$2 !== void 0 ? _a$2 : vertexBaseUrlFromEnv;
		else return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;
	}
	return httpOptions.baseUrl;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var BaseModule = class {};
function formatMap(templateString, valueMap) {
	return templateString.replace(/\{([^}]+)\}/g, (match, key) => {
		if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
			const value = valueMap[key];
			return value !== void 0 && value !== null ? String(value) : "";
		} else throw new Error(`Key '${key}' not found in valueMap.`);
	});
}
function setValueByPath(data, keys, value) {
	for (let i$2 = 0; i$2 < keys.length - 1; i$2++) {
		const key = keys[i$2];
		if (key.endsWith("[]")) {
			const keyName = key.slice(0, -2);
			if (!(keyName in data)) if (Array.isArray(value)) data[keyName] = Array.from({ length: value.length }, () => ({}));
			else throw new Error(`Value must be a list given an array path ${key}`);
			if (Array.isArray(data[keyName])) {
				const arrayData = data[keyName];
				if (Array.isArray(value)) for (let j = 0; j < arrayData.length; j++) {
					const entry = arrayData[j];
					setValueByPath(entry, keys.slice(i$2 + 1), value[j]);
				}
				else for (const d$1 of arrayData) setValueByPath(d$1, keys.slice(i$2 + 1), value);
			}
			return;
		} else if (key.endsWith("[0]")) {
			const keyName = key.slice(0, -3);
			if (!(keyName in data)) data[keyName] = [{}];
			const arrayData = data[keyName];
			setValueByPath(arrayData[0], keys.slice(i$2 + 1), value);
			return;
		}
		if (!data[key] || typeof data[key] !== "object") data[key] = {};
		data = data[key];
	}
	const keyToSet = keys[keys.length - 1];
	const existingData = data[keyToSet];
	if (existingData !== void 0) {
		if (!value || typeof value === "object" && Object.keys(value).length === 0) return;
		if (value === existingData) return;
		if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) Object.assign(existingData, value);
		else throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
	} else if (keyToSet === "_self" && typeof value === "object" && value !== null && !Array.isArray(value)) {
		const valueAsRecord = value;
		Object.assign(data, valueAsRecord);
	} else data[keyToSet] = value;
}
function getValueByPath(data, keys, defaultValue = void 0) {
	try {
		if (keys.length === 1 && keys[0] === "_self") return data;
		for (let i$2 = 0; i$2 < keys.length; i$2++) {
			if (typeof data !== "object" || data === null) return defaultValue;
			const key = keys[i$2];
			if (key.endsWith("[]")) {
				const keyName = key.slice(0, -2);
				if (keyName in data) {
					const arrayData = data[keyName];
					if (!Array.isArray(arrayData)) return defaultValue;
					return arrayData.map((d$1) => getValueByPath(d$1, keys.slice(i$2 + 1), defaultValue));
				} else return defaultValue;
			} else data = data[key];
		}
		return data;
	} catch (error$1) {
		if (error$1 instanceof TypeError) return defaultValue;
		throw error$1;
	}
}
/**
* Moves values from source paths to destination paths.
*
* Examples:
*   moveValueByPath(
*     {'requests': [{'content': v1}, {'content': v2}]},
*     {'requests[].*': 'requests[].request.*'}
*   )
*     -> {'requests': [{'request': {'content': v1}}, {'request': {'content': v2}}]}
*/
function moveValueByPath(data, paths) {
	for (const [sourcePath, destPath] of Object.entries(paths)) {
		const sourceKeys = sourcePath.split(".");
		const destKeys = destPath.split(".");
		const excludeKeys = /* @__PURE__ */ new Set();
		let wildcardIdx = -1;
		for (let i$2 = 0; i$2 < sourceKeys.length; i$2++) if (sourceKeys[i$2] === "*") {
			wildcardIdx = i$2;
			break;
		}
		if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) for (let i$2 = wildcardIdx; i$2 < destKeys.length; i$2++) {
			const key = destKeys[i$2];
			if (key !== "*" && !key.endsWith("[]") && !key.endsWith("[0]")) excludeKeys.add(key);
		}
		_moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);
	}
}
/**
* Recursively moves values from source path to destination path.
*/
function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {
	if (keyIdx >= sourceKeys.length) return;
	if (typeof data !== "object" || data === null) return;
	const key = sourceKeys[keyIdx];
	if (key.endsWith("[]")) {
		const keyName = key.slice(0, -2);
		const dataRecord = data;
		if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) for (const item of dataRecord[keyName]) _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);
	} else if (key === "*") {
		if (typeof data === "object" && data !== null && !Array.isArray(data)) {
			const dataRecord = data;
			const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith("_") && !excludeKeys.has(k));
			const valuesToMove = {};
			for (const k of keysToMove) valuesToMove[k] = dataRecord[k];
			for (const [k, v] of Object.entries(valuesToMove)) {
				const newDestKeys = [];
				for (const dk of destKeys.slice(keyIdx)) if (dk === "*") newDestKeys.push(k);
				else newDestKeys.push(dk);
				setValueByPath(dataRecord, newDestKeys, v);
			}
			for (const k of keysToMove) delete dataRecord[k];
		}
	} else {
		const dataRecord = data;
		if (key in dataRecord) _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);
	}
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function tBytes$1(fromBytes) {
	if (typeof fromBytes !== "string") throw new Error("fromImageBytes must be a string");
	return fromBytes;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function fetchPredictOperationParametersToVertex(fromObject) {
	const toObject = {};
	const fromOperationName = getValueByPath(fromObject, ["operationName"]);
	if (fromOperationName != null) setValueByPath(toObject, ["operationName"], fromOperationName);
	const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
	if (fromResourceName != null) setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
	return toObject;
}
function generateVideosOperationFromMldev$1(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	const fromResponse = getValueByPath(fromObject, ["response", "generateVideoResponse"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(fromResponse));
	return toObject;
}
function generateVideosOperationFromVertex$1(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	const fromResponse = getValueByPath(fromObject, ["response"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(fromResponse));
	return toObject;
}
function generateVideosResponseFromMldev$1(fromObject) {
	const toObject = {};
	const fromGeneratedVideos = getValueByPath(fromObject, ["generatedSamples"]);
	if (fromGeneratedVideos != null) {
		let transformedList = fromGeneratedVideos;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedVideoFromMldev$1(item);
		});
		setValueByPath(toObject, ["generatedVideos"], transformedList);
	}
	const fromRaiMediaFilteredCount = getValueByPath(fromObject, ["raiMediaFilteredCount"]);
	if (fromRaiMediaFilteredCount != null) setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
	const fromRaiMediaFilteredReasons = getValueByPath(fromObject, ["raiMediaFilteredReasons"]);
	if (fromRaiMediaFilteredReasons != null) setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
	return toObject;
}
function generateVideosResponseFromVertex$1(fromObject) {
	const toObject = {};
	const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
	if (fromGeneratedVideos != null) {
		let transformedList = fromGeneratedVideos;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedVideoFromVertex$1(item);
		});
		setValueByPath(toObject, ["generatedVideos"], transformedList);
	}
	const fromRaiMediaFilteredCount = getValueByPath(fromObject, ["raiMediaFilteredCount"]);
	if (fromRaiMediaFilteredCount != null) setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
	const fromRaiMediaFilteredReasons = getValueByPath(fromObject, ["raiMediaFilteredReasons"]);
	if (fromRaiMediaFilteredReasons != null) setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
	return toObject;
}
function generatedVideoFromMldev$1(fromObject) {
	const toObject = {};
	const fromVideo = getValueByPath(fromObject, ["video"]);
	if (fromVideo != null) setValueByPath(toObject, ["video"], videoFromMldev$1(fromVideo));
	return toObject;
}
function generatedVideoFromVertex$1(fromObject) {
	const toObject = {};
	const fromVideo = getValueByPath(fromObject, ["_self"]);
	if (fromVideo != null) setValueByPath(toObject, ["video"], videoFromVertex$1(fromVideo));
	return toObject;
}
function getOperationParametersToMldev(fromObject) {
	const toObject = {};
	const fromOperationName = getValueByPath(fromObject, ["operationName"]);
	if (fromOperationName != null) setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
	return toObject;
}
function getOperationParametersToVertex(fromObject) {
	const toObject = {};
	const fromOperationName = getValueByPath(fromObject, ["operationName"]);
	if (fromOperationName != null) setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
	return toObject;
}
function importFileOperationFromMldev$1(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	const fromResponse = getValueByPath(fromObject, ["response"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], importFileResponseFromMldev$1(fromResponse));
	return toObject;
}
function importFileResponseFromMldev$1(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromParent = getValueByPath(fromObject, ["parent"]);
	if (fromParent != null) setValueByPath(toObject, ["parent"], fromParent);
	const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
	if (fromDocumentName != null) setValueByPath(toObject, ["documentName"], fromDocumentName);
	return toObject;
}
function uploadToFileSearchStoreOperationFromMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	const fromResponse = getValueByPath(fromObject, ["response"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], uploadToFileSearchStoreResponseFromMldev(fromResponse));
	return toObject;
}
function uploadToFileSearchStoreResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromParent = getValueByPath(fromObject, ["parent"]);
	if (fromParent != null) setValueByPath(toObject, ["parent"], fromParent);
	const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
	if (fromDocumentName != null) setValueByPath(toObject, ["documentName"], fromDocumentName);
	return toObject;
}
function videoFromMldev$1(fromObject) {
	const toObject = {};
	const fromUri = getValueByPath(fromObject, ["uri"]);
	if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
	const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
	if (fromVideoBytes != null) setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
	const fromMimeType = getValueByPath(fromObject, ["encoding"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function videoFromVertex$1(fromObject) {
	const toObject = {};
	const fromUri = getValueByPath(fromObject, ["gcsUri"]);
	if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
	const fromVideoBytes = getValueByPath(fromObject, ["bytesBase64Encoded"]);
	if (fromVideoBytes != null) setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
/** Outcome of the code execution. */
var Outcome;
(function(Outcome$1) {
	/**
	* Unspecified status. This value should not be used.
	*/
	Outcome$1["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
	/**
	* Code execution completed successfully.
	*/
	Outcome$1["OUTCOME_OK"] = "OUTCOME_OK";
	/**
	* Code execution finished but with a failure. `stderr` should contain the reason.
	*/
	Outcome$1["OUTCOME_FAILED"] = "OUTCOME_FAILED";
	/**
	* Code execution ran for too long, and was cancelled. There may or may not be a partial output present.
	*/
	Outcome$1["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
})(Outcome || (Outcome = {}));
/** Programming language of the `code`. */
var Language;
(function(Language$1) {
	/**
	* Unspecified language. This value should not be used.
	*/
	Language$1["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
	/**
	* Python >= 3.10, with numpy and simpy available.
	*/
	Language$1["PYTHON"] = "PYTHON";
})(Language || (Language = {}));
/** Specifies how the response should be scheduled in the conversation. */
var FunctionResponseScheduling;
(function(FunctionResponseScheduling$1) {
	/**
	* This value is unused.
	*/
	FunctionResponseScheduling$1["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
	/**
	* Only add the result to the conversation context, do not interrupt or trigger generation.
	*/
	FunctionResponseScheduling$1["SILENT"] = "SILENT";
	/**
	* Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.
	*/
	FunctionResponseScheduling$1["WHEN_IDLE"] = "WHEN_IDLE";
	/**
	* Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.
	*/
	FunctionResponseScheduling$1["INTERRUPT"] = "INTERRUPT";
})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
/** The type of the data. */
var Type;
(function(Type$1) {
	/**
	* Not specified, should not be used.
	*/
	Type$1["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
	/**
	* OpenAPI string type
	*/
	Type$1["STRING"] = "STRING";
	/**
	* OpenAPI number type
	*/
	Type$1["NUMBER"] = "NUMBER";
	/**
	* OpenAPI integer type
	*/
	Type$1["INTEGER"] = "INTEGER";
	/**
	* OpenAPI boolean type
	*/
	Type$1["BOOLEAN"] = "BOOLEAN";
	/**
	* OpenAPI array type
	*/
	Type$1["ARRAY"] = "ARRAY";
	/**
	* OpenAPI object type
	*/
	Type$1["OBJECT"] = "OBJECT";
	/**
	* Null type
	*/
	Type$1["NULL"] = "NULL";
})(Type || (Type = {}));
/** The mode of the predictor to be used in dynamic retrieval. */
var Mode;
(function(Mode$1) {
	/**
	* Always trigger retrieval.
	*/
	Mode$1["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
	/**
	* Run retrieval only when system decides it is necessary.
	*/
	Mode$1["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(Mode || (Mode = {}));
/** The API spec that the external API implements. This enum is not supported in Gemini API. */
var ApiSpec;
(function(ApiSpec$1) {
	/**
	* Unspecified API spec. This value should not be used.
	*/
	ApiSpec$1["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
	/**
	* Simple search API spec.
	*/
	ApiSpec$1["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
	/**
	* Elastic search API spec.
	*/
	ApiSpec$1["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
})(ApiSpec || (ApiSpec = {}));
/** Type of auth scheme. This enum is not supported in Gemini API. */
var AuthType;
(function(AuthType$1) {
	AuthType$1["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
	/**
	* No Auth.
	*/
	AuthType$1["NO_AUTH"] = "NO_AUTH";
	/**
	* API Key Auth.
	*/
	AuthType$1["API_KEY_AUTH"] = "API_KEY_AUTH";
	/**
	* HTTP Basic Auth.
	*/
	AuthType$1["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
	/**
	* Google Service Account Auth.
	*/
	AuthType$1["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
	/**
	* OAuth auth.
	*/
	AuthType$1["OAUTH"] = "OAUTH";
	/**
	* OpenID Connect (OIDC) Auth.
	*/
	AuthType$1["OIDC_AUTH"] = "OIDC_AUTH";
})(AuthType || (AuthType = {}));
/** The location of the API key. This enum is not supported in Gemini API. */
var HttpElementLocation;
(function(HttpElementLocation$1) {
	HttpElementLocation$1["HTTP_IN_UNSPECIFIED"] = "HTTP_IN_UNSPECIFIED";
	/**
	* Element is in the HTTP request query.
	*/
	HttpElementLocation$1["HTTP_IN_QUERY"] = "HTTP_IN_QUERY";
	/**
	* Element is in the HTTP request header.
	*/
	HttpElementLocation$1["HTTP_IN_HEADER"] = "HTTP_IN_HEADER";
	/**
	* Element is in the HTTP request path.
	*/
	HttpElementLocation$1["HTTP_IN_PATH"] = "HTTP_IN_PATH";
	/**
	* Element is in the HTTP request body.
	*/
	HttpElementLocation$1["HTTP_IN_BODY"] = "HTTP_IN_BODY";
	/**
	* Element is in the HTTP request cookie.
	*/
	HttpElementLocation$1["HTTP_IN_COOKIE"] = "HTTP_IN_COOKIE";
})(HttpElementLocation || (HttpElementLocation = {}));
/** Sites with confidence level chosen & above this value will be blocked from the search results. This enum is not supported in Gemini API. */
var PhishBlockThreshold;
(function(PhishBlockThreshold$1) {
	/**
	* Defaults to unspecified.
	*/
	PhishBlockThreshold$1["PHISH_BLOCK_THRESHOLD_UNSPECIFIED"] = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED";
	/**
	* Blocks Low and above confidence URL that is risky.
	*/
	PhishBlockThreshold$1["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
	/**
	* Blocks Medium and above confidence URL that is risky.
	*/
	PhishBlockThreshold$1["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
	/**
	* Blocks High and above confidence URL that is risky.
	*/
	PhishBlockThreshold$1["BLOCK_HIGH_AND_ABOVE"] = "BLOCK_HIGH_AND_ABOVE";
	/**
	* Blocks Higher and above confidence URL that is risky.
	*/
	PhishBlockThreshold$1["BLOCK_HIGHER_AND_ABOVE"] = "BLOCK_HIGHER_AND_ABOVE";
	/**
	* Blocks Very high and above confidence URL that is risky.
	*/
	PhishBlockThreshold$1["BLOCK_VERY_HIGH_AND_ABOVE"] = "BLOCK_VERY_HIGH_AND_ABOVE";
	/**
	* Blocks Extremely high confidence URL that is risky.
	*/
	PhishBlockThreshold$1["BLOCK_ONLY_EXTREMELY_HIGH"] = "BLOCK_ONLY_EXTREMELY_HIGH";
})(PhishBlockThreshold || (PhishBlockThreshold = {}));
/** The level of thoughts tokens that the model should generate. */
var ThinkingLevel;
(function(ThinkingLevel$1) {
	/**
	* Default value.
	*/
	ThinkingLevel$1["THINKING_LEVEL_UNSPECIFIED"] = "THINKING_LEVEL_UNSPECIFIED";
	/**
	* Low thinking level.
	*/
	ThinkingLevel$1["LOW"] = "LOW";
	/**
	* High thinking level.
	*/
	ThinkingLevel$1["HIGH"] = "HIGH";
})(ThinkingLevel || (ThinkingLevel = {}));
/** Harm category. */
var HarmCategory;
(function(HarmCategory$1) {
	/**
	* The harm category is unspecified.
	*/
	HarmCategory$1["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
	/**
	* The harm category is harassment.
	*/
	HarmCategory$1["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
	/**
	* The harm category is hate speech.
	*/
	HarmCategory$1["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
	/**
	* The harm category is sexually explicit content.
	*/
	HarmCategory$1["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
	/**
	* The harm category is dangerous content.
	*/
	HarmCategory$1["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
	/**
	* Deprecated: Election filter is not longer supported. The harm category is civic integrity.
	*/
	HarmCategory$1["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
	/**
	* The harm category is image hate. This enum value is not supported in Gemini API.
	*/
	HarmCategory$1["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
	/**
	* The harm category is image dangerous content. This enum value is not supported in Gemini API.
	*/
	HarmCategory$1["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
	/**
	* The harm category is image harassment. This enum value is not supported in Gemini API.
	*/
	HarmCategory$1["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
	/**
	* The harm category is image sexually explicit content. This enum value is not supported in Gemini API.
	*/
	HarmCategory$1["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
	/**
	* The harm category is for jailbreak prompts. This enum value is not supported in Gemini API.
	*/
	HarmCategory$1["HARM_CATEGORY_JAILBREAK"] = "HARM_CATEGORY_JAILBREAK";
})(HarmCategory || (HarmCategory = {}));
/** Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. This enum is not supported in Gemini API. */
var HarmBlockMethod;
(function(HarmBlockMethod$1) {
	/**
	* The harm block method is unspecified.
	*/
	HarmBlockMethod$1["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
	/**
	* The harm block method uses both probability and severity scores.
	*/
	HarmBlockMethod$1["SEVERITY"] = "SEVERITY";
	/**
	* The harm block method uses the probability score.
	*/
	HarmBlockMethod$1["PROBABILITY"] = "PROBABILITY";
})(HarmBlockMethod || (HarmBlockMethod = {}));
/** The harm block threshold. */
var HarmBlockThreshold;
(function(HarmBlockThreshold$1) {
	/**
	* Unspecified harm block threshold.
	*/
	HarmBlockThreshold$1["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
	/**
	* Block low threshold and above (i.e. block more).
	*/
	HarmBlockThreshold$1["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
	/**
	* Block medium threshold and above.
	*/
	HarmBlockThreshold$1["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
	/**
	* Block only high threshold (i.e. block less).
	*/
	HarmBlockThreshold$1["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
	/**
	* Block none.
	*/
	HarmBlockThreshold$1["BLOCK_NONE"] = "BLOCK_NONE";
	/**
	* Turn off the safety filter.
	*/
	HarmBlockThreshold$1["OFF"] = "OFF";
})(HarmBlockThreshold || (HarmBlockThreshold = {}));
/** Output only. The reason why the model stopped generating tokens.

If empty, the model has not stopped generating the tokens. */
var FinishReason;
(function(FinishReason$1) {
	/**
	* The finish reason is unspecified.
	*/
	FinishReason$1["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
	/**
	* Token generation reached a natural stopping point or a configured stop sequence.
	*/
	FinishReason$1["STOP"] = "STOP";
	/**
	* Token generation reached the configured maximum output tokens.
	*/
	FinishReason$1["MAX_TOKENS"] = "MAX_TOKENS";
	/**
	* Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.
	*/
	FinishReason$1["SAFETY"] = "SAFETY";
	/**
	* The token generation stopped because of potential recitation.
	*/
	FinishReason$1["RECITATION"] = "RECITATION";
	/**
	* The token generation stopped because of using an unsupported language.
	*/
	FinishReason$1["LANGUAGE"] = "LANGUAGE";
	/**
	* All other reasons that stopped the token generation.
	*/
	FinishReason$1["OTHER"] = "OTHER";
	/**
	* Token generation stopped because the content contains forbidden terms.
	*/
	FinishReason$1["BLOCKLIST"] = "BLOCKLIST";
	/**
	* Token generation stopped for potentially containing prohibited content.
	*/
	FinishReason$1["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
	/**
	* Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
	*/
	FinishReason$1["SPII"] = "SPII";
	/**
	* The function call generated by the model is invalid.
	*/
	FinishReason$1["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
	/**
	* Token generation stopped because generated images have safety violations.
	*/
	FinishReason$1["IMAGE_SAFETY"] = "IMAGE_SAFETY";
	/**
	* The tool call generated by the model is invalid.
	*/
	FinishReason$1["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
	/**
	* Image generation stopped because the generated images have prohibited content.
	*/
	FinishReason$1["IMAGE_PROHIBITED_CONTENT"] = "IMAGE_PROHIBITED_CONTENT";
	/**
	* The model was expected to generate an image, but none was generated.
	*/
	FinishReason$1["NO_IMAGE"] = "NO_IMAGE";
})(FinishReason || (FinishReason = {}));
/** Output only. Harm probability levels in the content. */
var HarmProbability;
(function(HarmProbability$1) {
	/**
	* Harm probability unspecified.
	*/
	HarmProbability$1["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
	/**
	* Negligible level of harm.
	*/
	HarmProbability$1["NEGLIGIBLE"] = "NEGLIGIBLE";
	/**
	* Low level of harm.
	*/
	HarmProbability$1["LOW"] = "LOW";
	/**
	* Medium level of harm.
	*/
	HarmProbability$1["MEDIUM"] = "MEDIUM";
	/**
	* High level of harm.
	*/
	HarmProbability$1["HIGH"] = "HIGH";
})(HarmProbability || (HarmProbability = {}));
/** Output only. Harm severity levels in the content. This enum is not supported in Gemini API. */
var HarmSeverity;
(function(HarmSeverity$1) {
	/**
	* Harm severity unspecified.
	*/
	HarmSeverity$1["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
	/**
	* Negligible level of harm severity.
	*/
	HarmSeverity$1["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
	/**
	* Low level of harm severity.
	*/
	HarmSeverity$1["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
	/**
	* Medium level of harm severity.
	*/
	HarmSeverity$1["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
	/**
	* High level of harm severity.
	*/
	HarmSeverity$1["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
})(HarmSeverity || (HarmSeverity = {}));
/** Status of the url retrieval. */
var UrlRetrievalStatus;
(function(UrlRetrievalStatus$1) {
	/**
	* Default value. This value is unused.
	*/
	UrlRetrievalStatus$1["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
	/**
	* Url retrieval is successful.
	*/
	UrlRetrievalStatus$1["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
	/**
	* Url retrieval is failed due to error.
	*/
	UrlRetrievalStatus$1["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
	/**
	* Url retrieval is failed because the content is behind paywall. This enum value is not supported in Vertex AI.
	*/
	UrlRetrievalStatus$1["URL_RETRIEVAL_STATUS_PAYWALL"] = "URL_RETRIEVAL_STATUS_PAYWALL";
	/**
	* Url retrieval is failed because the content is unsafe. This enum value is not supported in Vertex AI.
	*/
	UrlRetrievalStatus$1["URL_RETRIEVAL_STATUS_UNSAFE"] = "URL_RETRIEVAL_STATUS_UNSAFE";
})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
/** Output only. The reason why the prompt was blocked. */
var BlockedReason;
(function(BlockedReason$1) {
	/**
	* The blocked reason is unspecified.
	*/
	BlockedReason$1["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
	/**
	* The prompt was blocked for safety reasons.
	*/
	BlockedReason$1["SAFETY"] = "SAFETY";
	/**
	* The prompt was blocked for other reasons. For example, it may be due to the prompt's language, or because it contains other harmful content.
	*/
	BlockedReason$1["OTHER"] = "OTHER";
	/**
	* The prompt was blocked because it contains a term from the terminology blocklist.
	*/
	BlockedReason$1["BLOCKLIST"] = "BLOCKLIST";
	/**
	* The prompt was blocked because it contains prohibited content.
	*/
	BlockedReason$1["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
	/**
	* The prompt was blocked because it contains content that is unsafe for image generation.
	*/
	BlockedReason$1["IMAGE_SAFETY"] = "IMAGE_SAFETY";
	/**
	* The prompt was blocked by Model Armor. This enum value is not supported in Gemini API.
	*/
	BlockedReason$1["MODEL_ARMOR"] = "MODEL_ARMOR";
	/**
	* The prompt was blocked as a jailbreak attempt. This enum value is not supported in Gemini API.
	*/
	BlockedReason$1["JAILBREAK"] = "JAILBREAK";
})(BlockedReason || (BlockedReason = {}));
/** Output only. The traffic type for this request. This enum is not supported in Gemini API. */
var TrafficType;
(function(TrafficType$1) {
	/**
	* Unspecified request traffic type.
	*/
	TrafficType$1["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
	/**
	* The request was processed using Pay-As-You-Go quota.
	*/
	TrafficType$1["ON_DEMAND"] = "ON_DEMAND";
	/**
	* Type for Provisioned Throughput traffic.
	*/
	TrafficType$1["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
})(TrafficType || (TrafficType = {}));
/** Server content modalities. */
var Modality;
(function(Modality$1) {
	/**
	* The modality is unspecified.
	*/
	Modality$1["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
	/**
	* Indicates the model should return text
	*/
	Modality$1["TEXT"] = "TEXT";
	/**
	* Indicates the model should return images.
	*/
	Modality$1["IMAGE"] = "IMAGE";
	/**
	* Indicates the model should return audio.
	*/
	Modality$1["AUDIO"] = "AUDIO";
})(Modality || (Modality = {}));
/** The media resolution to use. */
var MediaResolution;
(function(MediaResolution$1) {
	/**
	* Media resolution has not been set
	*/
	MediaResolution$1["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
	/**
	* Media resolution set to low (64 tokens).
	*/
	MediaResolution$1["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
	/**
	* Media resolution set to medium (256 tokens).
	*/
	MediaResolution$1["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
	/**
	* Media resolution set to high (zoomed reframing with 256 tokens).
	*/
	MediaResolution$1["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
})(MediaResolution || (MediaResolution = {}));
/** Tuning mode. This enum is not supported in Gemini API. */
var TuningMode;
(function(TuningMode$1) {
	/**
	* Tuning mode is unspecified.
	*/
	TuningMode$1["TUNING_MODE_UNSPECIFIED"] = "TUNING_MODE_UNSPECIFIED";
	/**
	* Full fine-tuning mode.
	*/
	TuningMode$1["TUNING_MODE_FULL"] = "TUNING_MODE_FULL";
	/**
	* PEFT adapter tuning mode.
	*/
	TuningMode$1["TUNING_MODE_PEFT_ADAPTER"] = "TUNING_MODE_PEFT_ADAPTER";
})(TuningMode || (TuningMode = {}));
/** Adapter size for tuning. This enum is not supported in Gemini API. */
var AdapterSize;
(function(AdapterSize$1) {
	/**
	* Adapter size is unspecified.
	*/
	AdapterSize$1["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
	/**
	* Adapter size 1.
	*/
	AdapterSize$1["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
	/**
	* Adapter size 2.
	*/
	AdapterSize$1["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
	/**
	* Adapter size 4.
	*/
	AdapterSize$1["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
	/**
	* Adapter size 8.
	*/
	AdapterSize$1["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
	/**
	* Adapter size 16.
	*/
	AdapterSize$1["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
	/**
	* Adapter size 32.
	*/
	AdapterSize$1["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
})(AdapterSize || (AdapterSize = {}));
/** Job state. */
var JobState;
(function(JobState$1) {
	/**
	* The job state is unspecified.
	*/
	JobState$1["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
	/**
	* The job has been just created or resumed and processing has not yet begun.
	*/
	JobState$1["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
	/**
	* The service is preparing to run the job.
	*/
	JobState$1["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
	/**
	* The job is in progress.
	*/
	JobState$1["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
	/**
	* The job completed successfully.
	*/
	JobState$1["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
	/**
	* The job failed.
	*/
	JobState$1["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
	/**
	* The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
	*/
	JobState$1["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
	/**
	* The job has been cancelled.
	*/
	JobState$1["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
	/**
	* The job has been stopped, and can be resumed.
	*/
	JobState$1["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
	/**
	* The job has expired.
	*/
	JobState$1["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
	/**
	* The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.
	*/
	JobState$1["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
	/**
	* The job is partially succeeded, some results may be missing due to errors.
	*/
	JobState$1["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
})(JobState || (JobState = {}));
/** The tuning task. Either I2V or T2V. This enum is not supported in Gemini API. */
var TuningTask;
(function(TuningTask$1) {
	/**
	* Default value. This value is unused.
	*/
	TuningTask$1["TUNING_TASK_UNSPECIFIED"] = "TUNING_TASK_UNSPECIFIED";
	/**
	* Tuning task for image to video.
	*/
	TuningTask$1["TUNING_TASK_I2V"] = "TUNING_TASK_I2V";
	/**
	* Tuning task for text to video.
	*/
	TuningTask$1["TUNING_TASK_T2V"] = "TUNING_TASK_T2V";
	/**
	* Tuning task for reference to video.
	*/
	TuningTask$1["TUNING_TASK_R2V"] = "TUNING_TASK_R2V";
})(TuningTask || (TuningTask = {}));
/** The tokenization quality used for given media. */
var PartMediaResolutionLevel;
(function(PartMediaResolutionLevel$1) {
	/**
	* Media resolution has not been set.
	*/
	PartMediaResolutionLevel$1["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
	/**
	* Media resolution set to low.
	*/
	PartMediaResolutionLevel$1["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
	/**
	* Media resolution set to medium.
	*/
	PartMediaResolutionLevel$1["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
	/**
	* Media resolution set to high.
	*/
	PartMediaResolutionLevel$1["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
})(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));
/** Options for feature selection preference. */
var FeatureSelectionPreference;
(function(FeatureSelectionPreference$1) {
	FeatureSelectionPreference$1["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
	FeatureSelectionPreference$1["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
	FeatureSelectionPreference$1["BALANCED"] = "BALANCED";
	FeatureSelectionPreference$1["PRIORITIZE_COST"] = "PRIORITIZE_COST";
})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
/** Defines the function behavior. Defaults to `BLOCKING`. */
var Behavior;
(function(Behavior$1) {
	/**
	* This value is unused.
	*/
	Behavior$1["UNSPECIFIED"] = "UNSPECIFIED";
	/**
	* If set, the system will wait to receive the function response before continuing the conversation.
	*/
	Behavior$1["BLOCKING"] = "BLOCKING";
	/**
	* If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.
	*/
	Behavior$1["NON_BLOCKING"] = "NON_BLOCKING";
})(Behavior || (Behavior = {}));
/** Config for the dynamic retrieval config mode. */
var DynamicRetrievalConfigMode;
(function(DynamicRetrievalConfigMode$1) {
	/**
	* Always trigger retrieval.
	*/
	DynamicRetrievalConfigMode$1["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
	/**
	* Run retrieval only when system decides it is necessary.
	*/
	DynamicRetrievalConfigMode$1["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
/** The environment being operated. */
var Environment;
(function(Environment$1) {
	/**
	* Defaults to browser.
	*/
	Environment$1["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
	/**
	* Operates in a web browser.
	*/
	Environment$1["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
})(Environment || (Environment = {}));
/** Config for the function calling config mode. */
var FunctionCallingConfigMode;
(function(FunctionCallingConfigMode$1) {
	/**
	* The function calling config mode is unspecified. Should not be used.
	*/
	FunctionCallingConfigMode$1["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
	/**
	* Default model behavior, model decides to predict either function calls or natural language response.
	*/
	FunctionCallingConfigMode$1["AUTO"] = "AUTO";
	/**
	* Model is constrained to always predicting function calls only. If "allowed_function_names" are set, the predicted function calls will be limited to any one of "allowed_function_names", else the predicted function calls will be any one of the provided "function_declarations".
	*/
	FunctionCallingConfigMode$1["ANY"] = "ANY";
	/**
	* Model will not predict any function calls. Model behavior is same as when not passing any function declarations.
	*/
	FunctionCallingConfigMode$1["NONE"] = "NONE";
	/**
	* Model decides to predict either a function call or a natural language response, but will validate function calls with constrained decoding. If "allowed_function_names" are set, the predicted function call will be limited to any one of "allowed_function_names", else the predicted function call will be any one of the provided "function_declarations".
	*/
	FunctionCallingConfigMode$1["VALIDATED"] = "VALIDATED";
})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
/** Enum that controls the safety filter level for objectionable content. */
var SafetyFilterLevel;
(function(SafetyFilterLevel$1) {
	SafetyFilterLevel$1["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
	SafetyFilterLevel$1["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
	SafetyFilterLevel$1["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
	SafetyFilterLevel$1["BLOCK_NONE"] = "BLOCK_NONE";
})(SafetyFilterLevel || (SafetyFilterLevel = {}));
/** Enum that controls the generation of people. */
var PersonGeneration;
(function(PersonGeneration$1) {
	/**
	* Block generation of images of people.
	*/
	PersonGeneration$1["DONT_ALLOW"] = "DONT_ALLOW";
	/**
	* Generate images of adults, but not children.
	*/
	PersonGeneration$1["ALLOW_ADULT"] = "ALLOW_ADULT";
	/**
	* Generate images that include adults and children.
	*/
	PersonGeneration$1["ALLOW_ALL"] = "ALLOW_ALL";
})(PersonGeneration || (PersonGeneration = {}));
/** Enum that specifies the language of the text in the prompt. */
var ImagePromptLanguage;
(function(ImagePromptLanguage$1) {
	/**
	* Auto-detect the language.
	*/
	ImagePromptLanguage$1["auto"] = "auto";
	/**
	* English
	*/
	ImagePromptLanguage$1["en"] = "en";
	/**
	* Japanese
	*/
	ImagePromptLanguage$1["ja"] = "ja";
	/**
	* Korean
	*/
	ImagePromptLanguage$1["ko"] = "ko";
	/**
	* Hindi
	*/
	ImagePromptLanguage$1["hi"] = "hi";
	/**
	* Chinese
	*/
	ImagePromptLanguage$1["zh"] = "zh";
	/**
	* Portuguese
	*/
	ImagePromptLanguage$1["pt"] = "pt";
	/**
	* Spanish
	*/
	ImagePromptLanguage$1["es"] = "es";
})(ImagePromptLanguage || (ImagePromptLanguage = {}));
/** Enum representing the mask mode of a mask reference image. */
var MaskReferenceMode;
(function(MaskReferenceMode$1) {
	MaskReferenceMode$1["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
	MaskReferenceMode$1["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
	MaskReferenceMode$1["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
	MaskReferenceMode$1["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
	MaskReferenceMode$1["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
})(MaskReferenceMode || (MaskReferenceMode = {}));
/** Enum representing the control type of a control reference image. */
var ControlReferenceType;
(function(ControlReferenceType$1) {
	ControlReferenceType$1["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
	ControlReferenceType$1["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
	ControlReferenceType$1["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
	ControlReferenceType$1["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
})(ControlReferenceType || (ControlReferenceType = {}));
/** Enum representing the subject type of a subject reference image. */
var SubjectReferenceType;
(function(SubjectReferenceType$1) {
	SubjectReferenceType$1["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
	SubjectReferenceType$1["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
	SubjectReferenceType$1["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
	SubjectReferenceType$1["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
})(SubjectReferenceType || (SubjectReferenceType = {}));
/** Enum representing the editing mode. */
var EditMode;
(function(EditMode$1) {
	EditMode$1["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
	EditMode$1["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
	EditMode$1["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
	EditMode$1["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
	EditMode$1["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
	EditMode$1["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
	EditMode$1["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
	EditMode$1["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
})(EditMode || (EditMode = {}));
/** Enum that represents the segmentation mode. */
var SegmentMode;
(function(SegmentMode$1) {
	SegmentMode$1["FOREGROUND"] = "FOREGROUND";
	SegmentMode$1["BACKGROUND"] = "BACKGROUND";
	SegmentMode$1["PROMPT"] = "PROMPT";
	SegmentMode$1["SEMANTIC"] = "SEMANTIC";
	SegmentMode$1["INTERACTIVE"] = "INTERACTIVE";
})(SegmentMode || (SegmentMode = {}));
/** Enum for the reference type of a video generation reference image. */
var VideoGenerationReferenceType;
(function(VideoGenerationReferenceType$1) {
	/**
	* A reference image that provides assets to the generated video,
	such as the scene, an object, a character, etc.
	*/
	VideoGenerationReferenceType$1["ASSET"] = "ASSET";
	/**
	* A reference image that provides aesthetics including colors,
	lighting, texture, etc., to be used as the style of the generated video,
	such as 'anime', 'photography', 'origami', etc.
	*/
	VideoGenerationReferenceType$1["STYLE"] = "STYLE";
})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));
/** Enum for the mask mode of a video generation mask. */
var VideoGenerationMaskMode;
(function(VideoGenerationMaskMode$1) {
	/**
	* The image mask contains a masked rectangular region which is
	applied on the first frame of the input video. The object described in
	the prompt is inserted into this region and will appear in subsequent
	frames.
	*/
	VideoGenerationMaskMode$1["INSERT"] = "INSERT";
	/**
	* The image mask is used to determine an object in the
	first video frame to track. This object is removed from the video.
	*/
	VideoGenerationMaskMode$1["REMOVE"] = "REMOVE";
	/**
	* The image mask is used to determine a region in the
	video. Objects in this region will be removed.
	*/
	VideoGenerationMaskMode$1["REMOVE_STATIC"] = "REMOVE_STATIC";
	/**
	* The image mask contains a masked rectangular region where
	the input video will go. The remaining area will be generated. Video
	masks are not supported.
	*/
	VideoGenerationMaskMode$1["OUTPAINT"] = "OUTPAINT";
})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));
/** Enum that controls the compression quality of the generated videos. */
var VideoCompressionQuality;
(function(VideoCompressionQuality$1) {
	/**
	* Optimized video compression quality. This will produce videos
	with a compressed, smaller file size.
	*/
	VideoCompressionQuality$1["OPTIMIZED"] = "OPTIMIZED";
	/**
	* Lossless video compression quality. This will produce videos
	with a larger file size.
	*/
	VideoCompressionQuality$1["LOSSLESS"] = "LOSSLESS";
})(VideoCompressionQuality || (VideoCompressionQuality = {}));
/** Enum representing the tuning method. */
var TuningMethod;
(function(TuningMethod$1) {
	/**
	* Supervised fine tuning.
	*/
	TuningMethod$1["SUPERVISED_FINE_TUNING"] = "SUPERVISED_FINE_TUNING";
	/**
	* Preference optimization tuning.
	*/
	TuningMethod$1["PREFERENCE_TUNING"] = "PREFERENCE_TUNING";
})(TuningMethod || (TuningMethod = {}));
/** State for the lifecycle of a Document. */
var DocumentState;
(function(DocumentState$1) {
	DocumentState$1["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
	DocumentState$1["STATE_PENDING"] = "STATE_PENDING";
	DocumentState$1["STATE_ACTIVE"] = "STATE_ACTIVE";
	DocumentState$1["STATE_FAILED"] = "STATE_FAILED";
})(DocumentState || (DocumentState = {}));
/** State for the lifecycle of a File. */
var FileState;
(function(FileState$1) {
	FileState$1["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
	FileState$1["PROCESSING"] = "PROCESSING";
	FileState$1["ACTIVE"] = "ACTIVE";
	FileState$1["FAILED"] = "FAILED";
})(FileState || (FileState = {}));
/** Source of the File. */
var FileSource;
(function(FileSource$1) {
	FileSource$1["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
	FileSource$1["UPLOADED"] = "UPLOADED";
	FileSource$1["GENERATED"] = "GENERATED";
})(FileSource || (FileSource = {}));
/** The reason why the turn is complete. */
var TurnCompleteReason;
(function(TurnCompleteReason$1) {
	/**
	* Default value. Reason is unspecified.
	*/
	TurnCompleteReason$1["TURN_COMPLETE_REASON_UNSPECIFIED"] = "TURN_COMPLETE_REASON_UNSPECIFIED";
	/**
	* The function call generated by the model is invalid.
	*/
	TurnCompleteReason$1["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
	/**
	* The response is rejected by the model.
	*/
	TurnCompleteReason$1["RESPONSE_REJECTED"] = "RESPONSE_REJECTED";
	/**
	* Needs more input from the user.
	*/
	TurnCompleteReason$1["NEED_MORE_INPUT"] = "NEED_MORE_INPUT";
})(TurnCompleteReason || (TurnCompleteReason = {}));
/** Server content modalities. */
var MediaModality;
(function(MediaModality$1) {
	/**
	* The modality is unspecified.
	*/
	MediaModality$1["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
	/**
	* Plain text.
	*/
	MediaModality$1["TEXT"] = "TEXT";
	/**
	* Images.
	*/
	MediaModality$1["IMAGE"] = "IMAGE";
	/**
	* Video.
	*/
	MediaModality$1["VIDEO"] = "VIDEO";
	/**
	* Audio.
	*/
	MediaModality$1["AUDIO"] = "AUDIO";
	/**
	* Document, e.g. PDF.
	*/
	MediaModality$1["DOCUMENT"] = "DOCUMENT";
})(MediaModality || (MediaModality = {}));
/** Start of speech sensitivity. */
var StartSensitivity;
(function(StartSensitivity$1) {
	/**
	* The default is START_SENSITIVITY_LOW.
	*/
	StartSensitivity$1["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
	/**
	* Automatic detection will detect the start of speech more often.
	*/
	StartSensitivity$1["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
	/**
	* Automatic detection will detect the start of speech less often.
	*/
	StartSensitivity$1["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
})(StartSensitivity || (StartSensitivity = {}));
/** End of speech sensitivity. */
var EndSensitivity;
(function(EndSensitivity$1) {
	/**
	* The default is END_SENSITIVITY_LOW.
	*/
	EndSensitivity$1["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
	/**
	* Automatic detection ends speech more often.
	*/
	EndSensitivity$1["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
	/**
	* Automatic detection ends speech less often.
	*/
	EndSensitivity$1["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
})(EndSensitivity || (EndSensitivity = {}));
/** The different ways of handling user activity. */
var ActivityHandling;
(function(ActivityHandling$1) {
	/**
	* If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.
	*/
	ActivityHandling$1["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
	/**
	* If true, start of activity will interrupt the model's response (also called "barge in"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.
	*/
	ActivityHandling$1["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
	/**
	* The model's response will not be interrupted.
	*/
	ActivityHandling$1["NO_INTERRUPTION"] = "NO_INTERRUPTION";
})(ActivityHandling || (ActivityHandling = {}));
/** Options about which input is included in the user's turn. */
var TurnCoverage;
(function(TurnCoverage$1) {
	/**
	* If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.
	*/
	TurnCoverage$1["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
	/**
	* The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.
	*/
	TurnCoverage$1["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
	/**
	* The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).
	*/
	TurnCoverage$1["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
})(TurnCoverage || (TurnCoverage = {}));
/** Scale of the generated music. */
var Scale;
(function(Scale$1) {
	/**
	* Default value. This value is unused.
	*/
	Scale$1["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
	/**
	* C major or A minor.
	*/
	Scale$1["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
	/**
	* Db major or Bb minor.
	*/
	Scale$1["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
	/**
	* D major or B minor.
	*/
	Scale$1["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
	/**
	* Eb major or C minor
	*/
	Scale$1["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
	/**
	* E major or Db minor.
	*/
	Scale$1["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
	/**
	* F major or D minor.
	*/
	Scale$1["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
	/**
	* Gb major or Eb minor.
	*/
	Scale$1["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
	/**
	* G major or E minor.
	*/
	Scale$1["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
	/**
	* Ab major or F minor.
	*/
	Scale$1["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
	/**
	* A major or Gb minor.
	*/
	Scale$1["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
	/**
	* Bb major or G minor.
	*/
	Scale$1["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
	/**
	* B major or Ab minor.
	*/
	Scale$1["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
})(Scale || (Scale = {}));
/** The mode of music generation. */
var MusicGenerationMode;
(function(MusicGenerationMode$1) {
	/**
	* Rely on the server default generation mode.
	*/
	MusicGenerationMode$1["MUSIC_GENERATION_MODE_UNSPECIFIED"] = "MUSIC_GENERATION_MODE_UNSPECIFIED";
	/**
	* Steer text prompts to regions of latent space with higher quality
	music.
	*/
	MusicGenerationMode$1["QUALITY"] = "QUALITY";
	/**
	* Steer text prompts to regions of latent space with a larger
	diversity of music.
	*/
	MusicGenerationMode$1["DIVERSITY"] = "DIVERSITY";
	/**
	* Steer text prompts to regions of latent space more likely to
	generate music with vocals.
	*/
	MusicGenerationMode$1["VOCALIZATION"] = "VOCALIZATION";
})(MusicGenerationMode || (MusicGenerationMode = {}));
/** The playback control signal to apply to the music generation. */
var LiveMusicPlaybackControl;
(function(LiveMusicPlaybackControl$1) {
	/**
	* This value is unused.
	*/
	LiveMusicPlaybackControl$1["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
	/**
	* Start generating the music.
	*/
	LiveMusicPlaybackControl$1["PLAY"] = "PLAY";
	/**
	* Hold the music generation. Use PLAY to resume from the current position.
	*/
	LiveMusicPlaybackControl$1["PAUSE"] = "PAUSE";
	/**
	* Stop the music generation and reset the context (prompts retained).
	Use PLAY to restart the music generation.
	*/
	LiveMusicPlaybackControl$1["STOP"] = "STOP";
	/**
	* Reset the context of the music generation without stopping it.
	Retains the current prompts and config.
	*/
	LiveMusicPlaybackControl$1["RESET_CONTEXT"] = "RESET_CONTEXT";
})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
/** A wrapper class for the http response. */
var HttpResponse = class {
	constructor(response) {
		const headers = {};
		for (const pair of response.headers.entries()) headers[pair[0]] = pair[1];
		this.headers = headers;
		this.responseInternal = response;
	}
	json() {
		return this.responseInternal.json();
	}
};
/** Response message for PredictionService.GenerateContent. */
var GenerateContentResponse = class {
	/**
	* Returns the concatenation of all text parts from the first candidate in the response.
	*
	* @remarks
	* If there are multiple candidates in the response, the text from the first
	* one will be returned.
	* If there are non-text parts in the response, the concatenation of all text
	* parts will be returned, and a warning will be logged.
	* If there are thought parts in the response, the concatenation of all text
	* parts excluding the thought parts will be returned.
	*
	* @example
	* ```ts
	* const response = await ai.models.generateContent({
	*   model: 'gemini-2.0-flash',
	*   contents:
	*     'Why is the sky blue?',
	* });
	*
	* console.debug(response.text);
	* ```
	*/
	get text() {
		var _a$2, _b, _c, _d, _e, _f, _g, _h;
		if (((_d = (_c = (_b = (_a$2 = this.candidates) === null || _a$2 === void 0 ? void 0 : _a$2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) return;
		if (this.candidates && this.candidates.length > 1) console.warn("there are multiple candidates in the response, returning text from the first one.");
		let text = "";
		let anyTextPartText = false;
		const nonTextParts = [];
		for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
			for (const [fieldName, fieldValue] of Object.entries(part)) if (fieldName !== "text" && fieldName !== "thought" && fieldName !== "thoughtSignature" && (fieldValue !== null || fieldValue !== void 0)) nonTextParts.push(fieldName);
			if (typeof part.text === "string") {
				if (typeof part.thought === "boolean" && part.thought) continue;
				anyTextPartText = true;
				text += part.text;
			}
		}
		if (nonTextParts.length > 0) console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
		return anyTextPartText ? text : void 0;
	}
	/**
	* Returns the concatenation of all inline data parts from the first candidate
	* in the response.
	*
	* @remarks
	* If there are multiple candidates in the response, the inline data from the
	* first one will be returned. If there are non-inline data parts in the
	* response, the concatenation of all inline data parts will be returned, and
	* a warning will be logged.
	*/
	get data() {
		var _a$2, _b, _c, _d, _e, _f, _g, _h;
		if (((_d = (_c = (_b = (_a$2 = this.candidates) === null || _a$2 === void 0 ? void 0 : _a$2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) return;
		if (this.candidates && this.candidates.length > 1) console.warn("there are multiple candidates in the response, returning data from the first one.");
		let data = "";
		const nonDataParts = [];
		for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
			for (const [fieldName, fieldValue] of Object.entries(part)) if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) nonDataParts.push(fieldName);
			if (part.inlineData && typeof part.inlineData.data === "string") data += atob(part.inlineData.data);
		}
		if (nonDataParts.length > 0) console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
		return data.length > 0 ? btoa(data) : void 0;
	}
	/**
	* Returns the function calls from the first candidate in the response.
	*
	* @remarks
	* If there are multiple candidates in the response, the function calls from
	* the first one will be returned.
	* If there are no function calls in the response, undefined will be returned.
	*
	* @example
	* ```ts
	* const controlLightFunctionDeclaration: FunctionDeclaration = {
	*   name: 'controlLight',
	*   parameters: {
	*   type: Type.OBJECT,
	*   description: 'Set the brightness and color temperature of a room light.',
	*   properties: {
	*     brightness: {
	*       type: Type.NUMBER,
	*       description:
	*         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
	*     },
	*     colorTemperature: {
	*       type: Type.STRING,
	*       description:
	*         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
	*     },
	*   },
	*   required: ['brightness', 'colorTemperature'],
	*  };
	*  const response = await ai.models.generateContent({
	*     model: 'gemini-2.0-flash',
	*     contents: 'Dim the lights so the room feels cozy and warm.',
	*     config: {
	*       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
	*       toolConfig: {
	*         functionCallingConfig: {
	*           mode: FunctionCallingConfigMode.ANY,
	*           allowedFunctionNames: ['controlLight'],
	*         },
	*       },
	*     },
	*   });
	*  console.debug(JSON.stringify(response.functionCalls));
	* ```
	*/
	get functionCalls() {
		var _a$2, _b, _c, _d, _e, _f, _g, _h;
		if (((_d = (_c = (_b = (_a$2 = this.candidates) === null || _a$2 === void 0 ? void 0 : _a$2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) return;
		if (this.candidates && this.candidates.length > 1) console.warn("there are multiple candidates in the response, returning function calls from the first one.");
		const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
		if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) return;
		return functionCalls;
	}
	/**
	* Returns the first executable code from the first candidate in the response.
	*
	* @remarks
	* If there are multiple candidates in the response, the executable code from
	* the first one will be returned.
	* If there are no executable code in the response, undefined will be
	* returned.
	*
	* @example
	* ```ts
	* const response = await ai.models.generateContent({
	*   model: 'gemini-2.0-flash',
	*   contents:
	*     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
	*   config: {
	*     tools: [{codeExecution: {}}],
	*   },
	* });
	*
	* console.debug(response.executableCode);
	* ```
	*/
	get executableCode() {
		var _a$2, _b, _c, _d, _e, _f, _g, _h, _j;
		if (((_d = (_c = (_b = (_a$2 = this.candidates) === null || _a$2 === void 0 ? void 0 : _a$2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) return;
		if (this.candidates && this.candidates.length > 1) console.warn("there are multiple candidates in the response, returning executable code from the first one.");
		const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode$1) => executableCode$1 !== void 0);
		if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) return;
		return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
	}
	/**
	* Returns the first code execution result from the first candidate in the response.
	*
	* @remarks
	* If there are multiple candidates in the response, the code execution result from
	* the first one will be returned.
	* If there are no code execution result in the response, undefined will be returned.
	*
	* @example
	* ```ts
	* const response = await ai.models.generateContent({
	*   model: 'gemini-2.0-flash',
	*   contents:
	*     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
	*   config: {
	*     tools: [{codeExecution: {}}],
	*   },
	* });
	*
	* console.debug(response.codeExecutionResult);
	* ```
	*/
	get codeExecutionResult() {
		var _a$2, _b, _c, _d, _e, _f, _g, _h, _j;
		if (((_d = (_c = (_b = (_a$2 = this.candidates) === null || _a$2 === void 0 ? void 0 : _a$2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) return;
		if (this.candidates && this.candidates.length > 1) console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
		const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult$1) => codeExecutionResult$1 !== void 0);
		if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) return;
		return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
	}
};
/** Response for the embed_content method. */
var EmbedContentResponse = class {};
/** The output images response. */
var GenerateImagesResponse = class {};
/** Response for the request to edit an image. */
var EditImageResponse = class {};
var UpscaleImageResponse = class {};
/** The output images response. */
var RecontextImageResponse = class {};
/** The output images response. */
var SegmentImageResponse = class {};
var ListModelsResponse = class {};
var DeleteModelResponse = class {};
/** Response for counting tokens. */
var CountTokensResponse = class {};
/** Response for computing tokens. */
var ComputeTokensResponse = class {};
/** A video generation operation. */
var GenerateVideosOperation = class GenerateVideosOperation {
	/**
	* Instantiates an Operation of the same type as the one being called with the fields set from the API response.
	* @internal
	*/
	_fromAPIResponse({ apiResponse, _isVertexAI }) {
		const operation = new GenerateVideosOperation();
		let response;
		const op = apiResponse;
		if (_isVertexAI) response = generateVideosOperationFromVertex$1(op);
		else response = generateVideosOperationFromMldev$1(op);
		Object.assign(operation, response);
		return operation;
	}
};
/** Response for the list tuning jobs method. */
var ListTuningJobsResponse = class {};
/** Empty response for caches.delete method. */
var DeleteCachedContentResponse = class {};
var ListCachedContentsResponse = class {};
/** Config for documents.list return value. */
var ListDocumentsResponse = class {};
/** Config for file_search_stores.list return value. */
var ListFileSearchStoresResponse = class {};
/** Response for the resumable upload method. */
var UploadToFileSearchStoreResumableResponse = class {};
/** Long-running operation for importing a file to a FileSearchStore. */
var ImportFileOperation = class ImportFileOperation {
	/**
	* Instantiates an Operation of the same type as the one being called with the fields set from the API response.
	* @internal
	*/
	_fromAPIResponse({ apiResponse, _isVertexAI }) {
		const operation = new ImportFileOperation();
		const response = importFileOperationFromMldev$1(apiResponse);
		Object.assign(operation, response);
		return operation;
	}
};
/** Response for the list files method. */
var ListFilesResponse = class {};
/** Response for the create file method. */
var CreateFileResponse = class {};
/** Response for the delete file method. */
var DeleteFileResponse = class {};
/** Config for batches.list return value. */
var ListBatchJobsResponse = class {};
/** Response message for API call. */
var LiveServerMessage = class {
	/**
	* Returns the concatenation of all text parts from the server content if present.
	*
	* @remarks
	* If there are non-text parts in the response, the concatenation of all text
	* parts will be returned, and a warning will be logged.
	*/
	get text() {
		var _a$2, _b, _c;
		let text = "";
		let anyTextPartFound = false;
		const nonTextParts = [];
		for (const part of (_c = (_b = (_a$2 = this.serverContent) === null || _a$2 === void 0 ? void 0 : _a$2.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
			for (const [fieldName, fieldValue] of Object.entries(part)) if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) nonTextParts.push(fieldName);
			if (typeof part.text === "string") {
				if (typeof part.thought === "boolean" && part.thought) continue;
				anyTextPartFound = true;
				text += part.text;
			}
		}
		if (nonTextParts.length > 0) console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
		return anyTextPartFound ? text : void 0;
	}
	/**
	* Returns the concatenation of all inline data parts from the server content if present.
	*
	* @remarks
	* If there are non-inline data parts in the
	* response, the concatenation of all inline data parts will be returned, and
	* a warning will be logged.
	*/
	get data() {
		var _a$2, _b, _c;
		let data = "";
		const nonDataParts = [];
		for (const part of (_c = (_b = (_a$2 = this.serverContent) === null || _a$2 === void 0 ? void 0 : _a$2.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
			for (const [fieldName, fieldValue] of Object.entries(part)) if (fieldName !== "inlineData" && fieldValue !== null) nonDataParts.push(fieldName);
			if (part.inlineData && typeof part.inlineData.data === "string") data += atob(part.inlineData.data);
		}
		if (nonDataParts.length > 0) console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
		return data.length > 0 ? btoa(data) : void 0;
	}
};
/** Response message for the LiveMusicClientMessage call. */
var LiveMusicServerMessage = class {
	/**
	* Returns the first audio chunk from the server content, if present.
	*
	* @remarks
	* If there are no audio chunks in the response, undefined will be returned.
	*/
	get audioChunk() {
		if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) return this.serverContent.audioChunks[0];
	}
};
/** Long-running operation for uploading a file to a FileSearchStore. */
var UploadToFileSearchStoreOperation = class UploadToFileSearchStoreOperation {
	/**
	* Instantiates an Operation of the same type as the one being called with the fields set from the API response.
	* @internal
	*/
	_fromAPIResponse({ apiResponse, _isVertexAI }) {
		const operation = new UploadToFileSearchStoreOperation();
		const response = uploadToFileSearchStoreOperationFromMldev(apiResponse);
		Object.assign(operation, response);
		return operation;
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function tModel(apiClient, model) {
	if (!model || typeof model !== "string") throw new Error("model is required and must be a string");
	if (model.includes("..") || model.includes("?") || model.includes("&")) throw new Error("invalid model parameter");
	if (apiClient.isVertexAI()) if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) return model;
	else if (model.indexOf("/") >= 0) {
		const parts = model.split("/", 2);
		return `publishers/${parts[0]}/models/${parts[1]}`;
	} else return `publishers/google/models/${model}`;
	else if (model.startsWith("models/") || model.startsWith("tunedModels/")) return model;
	else return `models/${model}`;
}
function tCachesModel(apiClient, model) {
	const transformedModel = tModel(apiClient, model);
	if (!transformedModel) return "";
	if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
	else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
	else return transformedModel;
}
function tBlobs(blobs) {
	if (Array.isArray(blobs)) return blobs.map((blob) => tBlob(blob));
	else return [tBlob(blobs)];
}
function tBlob(blob) {
	if (typeof blob === "object" && blob !== null) return blob;
	throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
}
function tImageBlob(blob) {
	const transformedBlob = tBlob(blob);
	if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) return transformedBlob;
	throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tAudioBlob(blob) {
	const transformedBlob = tBlob(blob);
	if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) return transformedBlob;
	throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tPart(origin) {
	if (origin === null || origin === void 0) throw new Error("PartUnion is required");
	if (typeof origin === "object") return origin;
	if (typeof origin === "string") return { text: origin };
	throw new Error(`Unsupported part type: ${typeof origin}`);
}
function tParts(origin) {
	if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) throw new Error("PartListUnion is required");
	if (Array.isArray(origin)) return origin.map((item) => tPart(item));
	return [tPart(origin)];
}
function _isContent(origin) {
	return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
}
function _isFunctionCallPart(origin) {
	return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
}
function _isFunctionResponsePart(origin) {
	return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
}
function tContent(origin) {
	if (origin === null || origin === void 0) throw new Error("ContentUnion is required");
	if (_isContent(origin)) return origin;
	return {
		role: "user",
		parts: tParts(origin)
	};
}
function tContentsForEmbed(apiClient, origin) {
	if (!origin) return [];
	if (apiClient.isVertexAI() && Array.isArray(origin)) return origin.flatMap((item) => {
		const content = tContent(item);
		if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) return [content.parts[0].text];
		return [];
	});
	else if (apiClient.isVertexAI()) {
		const content = tContent(origin);
		if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) return [content.parts[0].text];
		return [];
	}
	if (Array.isArray(origin)) return origin.map((item) => tContent(item));
	return [tContent(origin)];
}
function tContents(origin) {
	if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) throw new Error("contents are required");
	if (!Array.isArray(origin)) {
		if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
		return [tContent(origin)];
	}
	const result = [];
	const accumulatedParts = [];
	const isContentArray = _isContent(origin[0]);
	for (const item of origin) {
		const isContent = _isContent(item);
		if (isContent != isContentArray) throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
		if (isContent) result.push(item);
		else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
		else accumulatedParts.push(item);
	}
	if (!isContentArray) result.push({
		role: "user",
		parts: tParts(accumulatedParts)
	});
	return result;
}
function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
	if (typeList.includes("null")) resultingSchema["nullable"] = true;
	const listWithoutNull = typeList.filter((type) => type !== "null");
	if (listWithoutNull.length === 1) resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
	else {
		resultingSchema["anyOf"] = [];
		for (const i$2 of listWithoutNull) resultingSchema["anyOf"].push({ "type": Object.values(Type).includes(i$2.toUpperCase()) ? i$2.toUpperCase() : Type.TYPE_UNSPECIFIED });
	}
}
function processJsonSchema(_jsonSchema) {
	const genAISchema = {};
	const schemaFieldNames = ["items"];
	const listSchemaFieldNames = ["anyOf"];
	const dictSchemaFieldNames = ["properties"];
	if (_jsonSchema["type"] && _jsonSchema["anyOf"]) throw new Error("type and anyOf cannot be both populated.");
	const incomingAnyOf = _jsonSchema["anyOf"];
	if (incomingAnyOf != null && incomingAnyOf.length == 2) {
		if (incomingAnyOf[0]["type"] === "null") {
			genAISchema["nullable"] = true;
			_jsonSchema = incomingAnyOf[1];
		} else if (incomingAnyOf[1]["type"] === "null") {
			genAISchema["nullable"] = true;
			_jsonSchema = incomingAnyOf[0];
		}
	}
	if (_jsonSchema["type"] instanceof Array) flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
	for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
		if (fieldValue == null) continue;
		if (fieldName == "type") {
			if (fieldValue === "null") throw new Error("type: null can not be the only possible type for the field.");
			if (fieldValue instanceof Array) continue;
			genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
		} else if (schemaFieldNames.includes(fieldName)) genAISchema[fieldName] = processJsonSchema(fieldValue);
		else if (listSchemaFieldNames.includes(fieldName)) {
			const listSchemaFieldValue = [];
			for (const item of fieldValue) {
				if (item["type"] == "null") {
					genAISchema["nullable"] = true;
					continue;
				}
				listSchemaFieldValue.push(processJsonSchema(item));
			}
			genAISchema[fieldName] = listSchemaFieldValue;
		} else if (dictSchemaFieldNames.includes(fieldName)) {
			const dictSchemaFieldValue = {};
			for (const [key, value] of Object.entries(fieldValue)) dictSchemaFieldValue[key] = processJsonSchema(value);
			genAISchema[fieldName] = dictSchemaFieldValue;
		} else {
			if (fieldName === "additionalProperties") continue;
			genAISchema[fieldName] = fieldValue;
		}
	}
	return genAISchema;
}
function tSchema(schema) {
	return processJsonSchema(schema);
}
function tSpeechConfig(speechConfig) {
	if (typeof speechConfig === "object") return speechConfig;
	else if (typeof speechConfig === "string") return { voiceConfig: { prebuiltVoiceConfig: { voiceName: speechConfig } } };
	else throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
}
function tLiveSpeechConfig(speechConfig) {
	if ("multiSpeakerVoiceConfig" in speechConfig) throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
	return speechConfig;
}
function tTool(tool) {
	if (tool.functionDeclarations) for (const functionDeclaration of tool.functionDeclarations) {
		if (functionDeclaration.parameters) {
			if (!Object.keys(functionDeclaration.parameters).includes("$schema")) functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
			else if (!functionDeclaration.parametersJsonSchema) {
				functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
				delete functionDeclaration.parameters;
			}
		}
		if (functionDeclaration.response) {
			if (!Object.keys(functionDeclaration.response).includes("$schema")) functionDeclaration.response = processJsonSchema(functionDeclaration.response);
			else if (!functionDeclaration.responseJsonSchema) {
				functionDeclaration.responseJsonSchema = functionDeclaration.response;
				delete functionDeclaration.response;
			}
		}
	}
	return tool;
}
function tTools(tools) {
	if (tools === void 0 || tools === null) throw new Error("tools is required");
	if (!Array.isArray(tools)) throw new Error("tools is required and must be an array of Tools");
	const result = [];
	for (const tool of tools) result.push(tool);
	return result;
}
/**
* Prepends resource name with project, location, resource_prefix if needed.
*
* @param client The API client.
* @param resourceName The resource name.
* @param resourcePrefix The resource prefix.
* @param splitsAfterPrefix The number of splits after the prefix.
* @returns The completed resource name.
*
* Examples:
*
* ```
* resource_name = '123'
* resource_prefix = 'cachedContents'
* splits_after_prefix = 1
* client.vertexai = True
* client.project = 'bar'
* client.location = 'us-west1'
* _resource_name(client, resource_name, resource_prefix, splits_after_prefix)
* returns: 'projects/bar/locations/us-west1/cachedContents/123'
* ```
*
* ```
* resource_name = 'projects/foo/locations/us-central1/cachedContents/123'
* resource_prefix = 'cachedContents'
* splits_after_prefix = 1
* client.vertexai = True
* client.project = 'bar'
* client.location = 'us-west1'
* _resource_name(client, resource_name, resource_prefix, splits_after_prefix)
* returns: 'projects/foo/locations/us-central1/cachedContents/123'
* ```
*
* ```
* resource_name = '123'
* resource_prefix = 'cachedContents'
* splits_after_prefix = 1
* client.vertexai = False
* _resource_name(client, resource_name, resource_prefix, splits_after_prefix)
* returns 'cachedContents/123'
* ```
*
* ```
* resource_name = 'some/wrong/cachedContents/resource/name/123'
* resource_prefix = 'cachedContents'
* splits_after_prefix = 1
* client.vertexai = False
* # client.vertexai = True
* _resource_name(client, resource_name, resource_prefix, splits_after_prefix)
* -> 'some/wrong/resource/name/123'
* ```
*/
function resourceName(client, resourceName$1, resourcePrefix, splitsAfterPrefix = 1) {
	const shouldAppendPrefix = !resourceName$1.startsWith(`${resourcePrefix}/`) && resourceName$1.split("/").length === splitsAfterPrefix;
	if (client.isVertexAI()) if (resourceName$1.startsWith("projects/")) return resourceName$1;
	else if (resourceName$1.startsWith("locations/")) return `projects/${client.getProject()}/${resourceName$1}`;
	else if (resourceName$1.startsWith(`${resourcePrefix}/`)) return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName$1}`;
	else if (shouldAppendPrefix) return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName$1}`;
	else return resourceName$1;
	if (shouldAppendPrefix) return `${resourcePrefix}/${resourceName$1}`;
	return resourceName$1;
}
function tCachedContentName(apiClient, name) {
	if (typeof name !== "string") throw new Error("name must be a string");
	return resourceName(apiClient, name, "cachedContents");
}
function tTuningJobStatus(status) {
	switch (status) {
		case "STATE_UNSPECIFIED": return "JOB_STATE_UNSPECIFIED";
		case "CREATING": return "JOB_STATE_RUNNING";
		case "ACTIVE": return "JOB_STATE_SUCCEEDED";
		case "FAILED": return "JOB_STATE_FAILED";
		default: return status;
	}
}
function tBytes(fromImageBytes) {
	return tBytes$1(fromImageBytes);
}
function _isFile(origin) {
	return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
}
function isGeneratedVideo(origin) {
	return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
}
function isVideo(origin) {
	return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
}
function tFileName(fromName) {
	var _a$2;
	let name;
	if (_isFile(fromName)) name = fromName.name;
	if (isVideo(fromName)) {
		name = fromName.uri;
		if (name === void 0) return;
	}
	if (isGeneratedVideo(fromName)) {
		name = (_a$2 = fromName.video) === null || _a$2 === void 0 ? void 0 : _a$2.uri;
		if (name === void 0) return;
	}
	if (typeof fromName === "string") name = fromName;
	if (name === void 0) throw new Error("Could not extract file name from the provided input.");
	if (name.startsWith("https://")) {
		const match = name.split("files/")[1].match(/[a-z0-9]+/);
		if (match === null) throw new Error(`Could not extract file name from URI ${name}`);
		name = match[0];
	} else if (name.startsWith("files/")) name = name.split("files/")[1];
	return name;
}
function tModelsUrl(apiClient, baseModels) {
	let res;
	if (apiClient.isVertexAI()) res = baseModels ? "publishers/google/models" : "models";
	else res = baseModels ? "models" : "tunedModels";
	return res;
}
function tExtractModels(response) {
	for (const key of [
		"models",
		"tunedModels",
		"publisherModels"
	]) if (hasField(response, key)) return response[key];
	return [];
}
function hasField(data, fieldName) {
	return data !== null && typeof data === "object" && fieldName in data;
}
function mcpToGeminiTool(mcpTool, config = {}) {
	const mcpToolSchema = mcpTool;
	const functionDeclaration = {
		name: mcpToolSchema["name"],
		description: mcpToolSchema["description"],
		parametersJsonSchema: mcpToolSchema["inputSchema"]
	};
	if (mcpToolSchema["outputSchema"]) functionDeclaration["responseJsonSchema"] = mcpToolSchema["outputSchema"];
	if (config.behavior) functionDeclaration["behavior"] = config.behavior;
	return { functionDeclarations: [functionDeclaration] };
}
/**
* Converts a list of MCP tools to a single Gemini tool with a list of function
* declarations.
*/
function mcpToolsToGeminiTool(mcpTools, config = {}) {
	const functionDeclarations = [];
	const toolNames = /* @__PURE__ */ new Set();
	for (const mcpTool of mcpTools) {
		const mcpToolName = mcpTool.name;
		if (toolNames.has(mcpToolName)) throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
		toolNames.add(mcpToolName);
		const geminiTool = mcpToGeminiTool(mcpTool, config);
		if (geminiTool.functionDeclarations) functionDeclarations.push(...geminiTool.functionDeclarations);
	}
	return { functionDeclarations };
}
function tBatchJobSource(client, src) {
	let sourceObj;
	if (typeof src === "string") if (client.isVertexAI()) if (src.startsWith("gs://")) sourceObj = {
		format: "jsonl",
		gcsUri: [src]
	};
	else if (src.startsWith("bq://")) sourceObj = {
		format: "bigquery",
		bigqueryUri: src
	};
	else throw new Error(`Unsupported string source for Vertex AI: ${src}`);
	else if (src.startsWith("files/")) sourceObj = { fileName: src };
	else throw new Error(`Unsupported string source for Gemini API: ${src}`);
	else if (Array.isArray(src)) {
		if (client.isVertexAI()) throw new Error("InlinedRequest[] is not supported in Vertex AI.");
		sourceObj = { inlinedRequests: src };
	} else sourceObj = src;
	const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;
	const mldevSourcesCount = [sourceObj.inlinedRequests, sourceObj.fileName].filter(Boolean).length;
	if (client.isVertexAI()) {
		if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
	} else if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
	return sourceObj;
}
function tBatchJobDestination(dest) {
	if (typeof dest !== "string") return dest;
	const destString = dest;
	if (destString.startsWith("gs://")) return {
		format: "jsonl",
		gcsUri: destString
	};
	else if (destString.startsWith("bq://")) return {
		format: "bigquery",
		bigqueryUri: destString
	};
	else throw new Error(`Unsupported destination: ${destString}`);
}
function tRecvBatchJobDestination(dest) {
	if (typeof dest !== "object" || dest === null) return {};
	const obj = dest;
	const inlineResponsesVal = obj["inlinedResponses"];
	if (typeof inlineResponsesVal !== "object" || inlineResponsesVal === null) return dest;
	const responsesArray = inlineResponsesVal["inlinedResponses"];
	if (!Array.isArray(responsesArray) || responsesArray.length === 0) return dest;
	let hasEmbedding = false;
	for (const responseItem of responsesArray) {
		if (typeof responseItem !== "object" || responseItem === null) continue;
		const responseVal = responseItem["response"];
		if (typeof responseVal !== "object" || responseVal === null) continue;
		if (responseVal["embedding"] !== void 0) {
			hasEmbedding = true;
			break;
		}
	}
	if (hasEmbedding) {
		obj["inlinedEmbedContentResponses"] = obj["inlinedResponses"];
		delete obj["inlinedResponses"];
	}
	return dest;
}
function tBatchJobName(apiClient, name) {
	const nameString = name;
	if (!apiClient.isVertexAI()) if (/batches\/[^/]+$/.test(nameString)) return nameString.split("/").pop();
	else throw new Error(`Invalid batch job name: ${nameString}.`);
	if (/^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/.test(nameString)) return nameString.split("/").pop();
	else if (/^\d+$/.test(nameString)) return nameString;
	else throw new Error(`Invalid batch job name: ${nameString}.`);
}
function tJobState(state) {
	const stateString = state;
	if (stateString === "BATCH_STATE_UNSPECIFIED") return "JOB_STATE_UNSPECIFIED";
	else if (stateString === "BATCH_STATE_PENDING") return "JOB_STATE_PENDING";
	else if (stateString === "BATCH_STATE_RUNNING") return "JOB_STATE_RUNNING";
	else if (stateString === "BATCH_STATE_SUCCEEDED") return "JOB_STATE_SUCCEEDED";
	else if (stateString === "BATCH_STATE_FAILED") return "JOB_STATE_FAILED";
	else if (stateString === "BATCH_STATE_CANCELLED") return "JOB_STATE_CANCELLED";
	else if (stateString === "BATCH_STATE_EXPIRED") return "JOB_STATE_EXPIRED";
	else return stateString;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function batchJobDestinationFromMldev(fromObject) {
	const toObject = {};
	const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
	if (fromFileName != null) setValueByPath(toObject, ["fileName"], fromFileName);
	const fromInlinedResponses = getValueByPath(fromObject, ["inlinedResponses", "inlinedResponses"]);
	if (fromInlinedResponses != null) {
		let transformedList = fromInlinedResponses;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return inlinedResponseFromMldev(item);
		});
		setValueByPath(toObject, ["inlinedResponses"], transformedList);
	}
	const fromInlinedEmbedContentResponses = getValueByPath(fromObject, ["inlinedEmbedContentResponses", "inlinedResponses"]);
	if (fromInlinedEmbedContentResponses != null) {
		let transformedList = fromInlinedEmbedContentResponses;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["inlinedEmbedContentResponses"], transformedList);
	}
	return toObject;
}
function batchJobDestinationFromVertex(fromObject) {
	const toObject = {};
	const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
	if (fromFormat != null) setValueByPath(toObject, ["format"], fromFormat);
	const fromGcsUri = getValueByPath(fromObject, ["gcsDestination", "outputUriPrefix"]);
	if (fromGcsUri != null) setValueByPath(toObject, ["gcsUri"], fromGcsUri);
	const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryDestination", "outputUri"]);
	if (fromBigqueryUri != null) setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
	return toObject;
}
function batchJobDestinationToVertex(fromObject) {
	const toObject = {};
	const fromFormat = getValueByPath(fromObject, ["format"]);
	if (fromFormat != null) setValueByPath(toObject, ["predictionsFormat"], fromFormat);
	const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
	if (fromGcsUri != null) setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
	const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
	if (fromBigqueryUri != null) setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
	if (getValueByPath(fromObject, ["fileName"]) !== void 0) throw new Error("fileName parameter is not supported in Vertex AI.");
	if (getValueByPath(fromObject, ["inlinedResponses"]) !== void 0) throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
	if (getValueByPath(fromObject, ["inlinedEmbedContentResponses"]) !== void 0) throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
	return toObject;
}
function batchJobFromMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromDisplayName = getValueByPath(fromObject, ["metadata", "displayName"]);
	if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
	const fromState = getValueByPath(fromObject, ["metadata", "state"]);
	if (fromState != null) setValueByPath(toObject, ["state"], tJobState(fromState));
	const fromCreateTime = getValueByPath(fromObject, ["metadata", "createTime"]);
	if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
	const fromEndTime = getValueByPath(fromObject, ["metadata", "endTime"]);
	if (fromEndTime != null) setValueByPath(toObject, ["endTime"], fromEndTime);
	const fromUpdateTime = getValueByPath(fromObject, ["metadata", "updateTime"]);
	if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
	const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
	if (fromModel != null) setValueByPath(toObject, ["model"], fromModel);
	const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
	if (fromDest != null) setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));
	return toObject;
}
function batchJobFromVertex(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
	const fromState = getValueByPath(fromObject, ["state"]);
	if (fromState != null) setValueByPath(toObject, ["state"], tJobState(fromState));
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
	if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
	const fromStartTime = getValueByPath(fromObject, ["startTime"]);
	if (fromStartTime != null) setValueByPath(toObject, ["startTime"], fromStartTime);
	const fromEndTime = getValueByPath(fromObject, ["endTime"]);
	if (fromEndTime != null) setValueByPath(toObject, ["endTime"], fromEndTime);
	const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
	if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["model"], fromModel);
	const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
	if (fromSrc != null) setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
	const fromDest = getValueByPath(fromObject, ["outputConfig"]);
	if (fromDest != null) setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));
	const fromCompletionStats = getValueByPath(fromObject, ["completionStats"]);
	if (fromCompletionStats != null) setValueByPath(toObject, ["completionStats"], fromCompletionStats);
	return toObject;
}
function batchJobSourceFromVertex(fromObject) {
	const toObject = {};
	const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
	if (fromFormat != null) setValueByPath(toObject, ["format"], fromFormat);
	const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
	if (fromGcsUri != null) setValueByPath(toObject, ["gcsUri"], fromGcsUri);
	const fromBigqueryUri = getValueByPath(fromObject, ["bigquerySource", "inputUri"]);
	if (fromBigqueryUri != null) setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
	return toObject;
}
function batchJobSourceToMldev(apiClient, fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["format"]) !== void 0) throw new Error("format parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["bigqueryUri"]) !== void 0) throw new Error("bigqueryUri parameter is not supported in Gemini API.");
	const fromFileName = getValueByPath(fromObject, ["fileName"]);
	if (fromFileName != null) setValueByPath(toObject, ["fileName"], fromFileName);
	const fromInlinedRequests = getValueByPath(fromObject, ["inlinedRequests"]);
	if (fromInlinedRequests != null) {
		let transformedList = fromInlinedRequests;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return inlinedRequestToMldev(apiClient, item);
		});
		setValueByPath(toObject, ["requests", "requests"], transformedList);
	}
	return toObject;
}
function batchJobSourceToVertex(fromObject) {
	const toObject = {};
	const fromFormat = getValueByPath(fromObject, ["format"]);
	if (fromFormat != null) setValueByPath(toObject, ["instancesFormat"], fromFormat);
	const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
	if (fromGcsUri != null) setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
	const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
	if (fromBigqueryUri != null) setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
	if (getValueByPath(fromObject, ["fileName"]) !== void 0) throw new Error("fileName parameter is not supported in Vertex AI.");
	if (getValueByPath(fromObject, ["inlinedRequests"]) !== void 0) throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
	return toObject;
}
function blobToMldev$4(fromObject) {
	const toObject = {};
	const fromData = getValueByPath(fromObject, ["data"]);
	if (fromData != null) setValueByPath(toObject, ["data"], fromData);
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function cancelBatchJobParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
	return toObject;
}
function cancelBatchJobParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
	return toObject;
}
function candidateFromMldev$1(fromObject) {
	const toObject = {};
	const fromContent = getValueByPath(fromObject, ["content"]);
	if (fromContent != null) setValueByPath(toObject, ["content"], fromContent);
	const fromCitationMetadata = getValueByPath(fromObject, ["citationMetadata"]);
	if (fromCitationMetadata != null) setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
	const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
	if (fromTokenCount != null) setValueByPath(toObject, ["tokenCount"], fromTokenCount);
	const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
	if (fromFinishReason != null) setValueByPath(toObject, ["finishReason"], fromFinishReason);
	const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
	if (fromAvgLogprobs != null) setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
	const fromGroundingMetadata = getValueByPath(fromObject, ["groundingMetadata"]);
	if (fromGroundingMetadata != null) setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
	const fromIndex = getValueByPath(fromObject, ["index"]);
	if (fromIndex != null) setValueByPath(toObject, ["index"], fromIndex);
	const fromLogprobsResult = getValueByPath(fromObject, ["logprobsResult"]);
	if (fromLogprobsResult != null) setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
	const fromSafetyRatings = getValueByPath(fromObject, ["safetyRatings"]);
	if (fromSafetyRatings != null) {
		let transformedList = fromSafetyRatings;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["safetyRatings"], transformedList);
	}
	const fromUrlContextMetadata = getValueByPath(fromObject, ["urlContextMetadata"]);
	if (fromUrlContextMetadata != null) setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
	return toObject;
}
function citationMetadataFromMldev$1(fromObject) {
	const toObject = {};
	const fromCitations = getValueByPath(fromObject, ["citationSources"]);
	if (fromCitations != null) {
		let transformedList = fromCitations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["citations"], transformedList);
	}
	return toObject;
}
function contentToMldev$4(fromObject) {
	const toObject = {};
	const fromParts = getValueByPath(fromObject, ["parts"]);
	if (fromParts != null) {
		let transformedList = fromParts;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return partToMldev$4(item);
		});
		setValueByPath(toObject, ["parts"], transformedList);
	}
	const fromRole = getValueByPath(fromObject, ["role"]);
	if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
	return toObject;
}
function createBatchJobConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
	if (getValueByPath(fromObject, ["dest"]) !== void 0) throw new Error("dest parameter is not supported in Gemini API.");
	return toObject;
}
function createBatchJobConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["displayName"], fromDisplayName);
	const fromDest = getValueByPath(fromObject, ["dest"]);
	if (parentObject !== void 0 && fromDest != null) setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
	return toObject;
}
function createBatchJobParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromSrc = getValueByPath(fromObject, ["src"]);
	if (fromSrc != null) setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) createBatchJobConfigToMldev(fromConfig, toObject);
	return toObject;
}
function createBatchJobParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
	const fromSrc = getValueByPath(fromObject, ["src"]);
	if (fromSrc != null) setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) createBatchJobConfigToVertex(fromConfig, toObject);
	return toObject;
}
function createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
	return toObject;
}
function createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromSrc = getValueByPath(fromObject, ["src"]);
	if (fromSrc != null) setValueByPath(toObject, ["batch", "inputConfig"], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);
	return toObject;
}
function deleteBatchJobParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
	return toObject;
}
function deleteBatchJobParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
	return toObject;
}
function deleteResourceJobFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	return toObject;
}
function deleteResourceJobFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	return toObject;
}
function embedContentBatchToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (fromContents != null) {
		let transformedList = tContentsForEmbed(apiClient, fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, [
			"requests[]",
			"request",
			"content"
		], transformedList);
	}
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) {
		setValueByPath(toObject, ["_self"], embedContentConfigToMldev$1(fromConfig, toObject));
		moveValueByPath(toObject, { "requests[].*": "requests[].request.*" });
	}
	return toObject;
}
function embedContentConfigToMldev$1(fromObject, parentObject) {
	const toObject = {};
	const fromTaskType = getValueByPath(fromObject, ["taskType"]);
	if (parentObject !== void 0 && fromTaskType != null) setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
	const fromTitle = getValueByPath(fromObject, ["title"]);
	if (parentObject !== void 0 && fromTitle != null) setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
	const fromOutputDimensionality = getValueByPath(fromObject, ["outputDimensionality"]);
	if (parentObject !== void 0 && fromOutputDimensionality != null) setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
	if (getValueByPath(fromObject, ["mimeType"]) !== void 0) throw new Error("mimeType parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API.");
	return toObject;
}
function embeddingsBatchJobSourceToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromFileName = getValueByPath(fromObject, ["fileName"]);
	if (fromFileName != null) setValueByPath(toObject, ["file_name"], fromFileName);
	const fromInlinedRequests = getValueByPath(fromObject, ["inlinedRequests"]);
	if (fromInlinedRequests != null) setValueByPath(toObject, ["requests"], embedContentBatchToMldev(apiClient, fromInlinedRequests));
	return toObject;
}
function fileDataToMldev$4(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
	if (fromFileUri != null) setValueByPath(toObject, ["fileUri"], fromFileUri);
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function functionCallToMldev$4(fromObject) {
	const toObject = {};
	const fromId = getValueByPath(fromObject, ["id"]);
	if (fromId != null) setValueByPath(toObject, ["id"], fromId);
	const fromArgs = getValueByPath(fromObject, ["args"]);
	if (fromArgs != null) setValueByPath(toObject, ["args"], fromArgs);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
	return toObject;
}
function functionCallingConfigToMldev$2(fromObject) {
	const toObject = {};
	const fromMode = getValueByPath(fromObject, ["mode"]);
	if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
	const fromAllowedFunctionNames = getValueByPath(fromObject, ["allowedFunctionNames"]);
	if (fromAllowedFunctionNames != null) setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
	if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
	return toObject;
}
function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
	const toObject = {};
	const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
	if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
	const fromTemperature = getValueByPath(fromObject, ["temperature"]);
	if (fromTemperature != null) setValueByPath(toObject, ["temperature"], fromTemperature);
	const fromTopP = getValueByPath(fromObject, ["topP"]);
	if (fromTopP != null) setValueByPath(toObject, ["topP"], fromTopP);
	const fromTopK = getValueByPath(fromObject, ["topK"]);
	if (fromTopK != null) setValueByPath(toObject, ["topK"], fromTopK);
	const fromCandidateCount = getValueByPath(fromObject, ["candidateCount"]);
	if (fromCandidateCount != null) setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
	const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
	if (fromMaxOutputTokens != null) setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
	const fromStopSequences = getValueByPath(fromObject, ["stopSequences"]);
	if (fromStopSequences != null) setValueByPath(toObject, ["stopSequences"], fromStopSequences);
	const fromResponseLogprobs = getValueByPath(fromObject, ["responseLogprobs"]);
	if (fromResponseLogprobs != null) setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
	const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
	if (fromLogprobs != null) setValueByPath(toObject, ["logprobs"], fromLogprobs);
	const fromPresencePenalty = getValueByPath(fromObject, ["presencePenalty"]);
	if (fromPresencePenalty != null) setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
	const fromFrequencyPenalty = getValueByPath(fromObject, ["frequencyPenalty"]);
	if (fromFrequencyPenalty != null) setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (fromSeed != null) setValueByPath(toObject, ["seed"], fromSeed);
	const fromResponseMimeType = getValueByPath(fromObject, ["responseMimeType"]);
	if (fromResponseMimeType != null) setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
	const fromResponseSchema = getValueByPath(fromObject, ["responseSchema"]);
	if (fromResponseSchema != null) setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
	const fromResponseJsonSchema = getValueByPath(fromObject, ["responseJsonSchema"]);
	if (fromResponseJsonSchema != null) setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
	if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) throw new Error("routingConfig parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
	const fromSafetySettings = getValueByPath(fromObject, ["safetySettings"]);
	if (parentObject !== void 0 && fromSafetySettings != null) {
		let transformedList = fromSafetySettings;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return safetySettingToMldev$1(item);
		});
		setValueByPath(parentObject, ["safetySettings"], transformedList);
	}
	const fromTools = getValueByPath(fromObject, ["tools"]);
	if (parentObject !== void 0 && fromTools != null) {
		let transformedList = tTools(fromTools);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return toolToMldev$4(tTool(item));
		});
		setValueByPath(parentObject, ["tools"], transformedList);
	}
	const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
	if (parentObject !== void 0 && fromToolConfig != null) setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
	if (getValueByPath(fromObject, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API.");
	const fromCachedContent = getValueByPath(fromObject, ["cachedContent"]);
	if (parentObject !== void 0 && fromCachedContent != null) setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
	const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
	if (fromResponseModalities != null) setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
	if (fromSpeechConfig != null) setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
	if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) throw new Error("audioTimestamp parameter is not supported in Gemini API.");
	const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
	if (fromThinkingConfig != null) setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
	const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
	if (fromImageConfig != null) setValueByPath(toObject, ["imageConfig"], imageConfigToMldev$1(fromImageConfig));
	return toObject;
}
function generateContentResponseFromMldev$1(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromCandidates = getValueByPath(fromObject, ["candidates"]);
	if (fromCandidates != null) {
		let transformedList = fromCandidates;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return candidateFromMldev$1(item);
		});
		setValueByPath(toObject, ["candidates"], transformedList);
	}
	const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
	if (fromModelVersion != null) setValueByPath(toObject, ["modelVersion"], fromModelVersion);
	const fromPromptFeedback = getValueByPath(fromObject, ["promptFeedback"]);
	if (fromPromptFeedback != null) setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
	const fromResponseId = getValueByPath(fromObject, ["responseId"]);
	if (fromResponseId != null) setValueByPath(toObject, ["responseId"], fromResponseId);
	const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
	if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
	return toObject;
}
function getBatchJobParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
	return toObject;
}
function getBatchJobParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
	return toObject;
}
function googleMapsToMldev$4(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
	const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
	if (fromEnableWidget != null) setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
	return toObject;
}
function googleSearchToMldev$4(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API.");
	const fromTimeRangeFilter = getValueByPath(fromObject, ["timeRangeFilter"]);
	if (fromTimeRangeFilter != null) setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
	return toObject;
}
function imageConfigToMldev$1(fromObject) {
	const toObject = {};
	const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
	if (fromAspectRatio != null) setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
	const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
	if (fromImageSize != null) setValueByPath(toObject, ["imageSize"], fromImageSize);
	if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) throw new Error("outputMimeType parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
	return toObject;
}
function inlinedRequestToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (fromContents != null) {
		let transformedList = tContents(fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return contentToMldev$4(item);
		});
		setValueByPath(toObject, ["request", "contents"], transformedList);
	}
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ["request"], {})));
	return toObject;
}
function inlinedResponseFromMldev(fromObject) {
	const toObject = {};
	const fromResponse = getValueByPath(fromObject, ["response"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	return toObject;
}
function listBatchJobsConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	if (getValueByPath(fromObject, ["filter"]) !== void 0) throw new Error("filter parameter is not supported in Gemini API.");
	return toObject;
}
function listBatchJobsConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	const fromFilter = getValueByPath(fromObject, ["filter"]);
	if (parentObject !== void 0 && fromFilter != null) setValueByPath(parentObject, ["_query", "filter"], fromFilter);
	return toObject;
}
function listBatchJobsParametersToMldev(fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listBatchJobsConfigToMldev(fromConfig, toObject);
	return toObject;
}
function listBatchJobsParametersToVertex(fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listBatchJobsConfigToVertex(fromConfig, toObject);
	return toObject;
}
function listBatchJobsResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
	if (fromBatchJobs != null) {
		let transformedList = fromBatchJobs;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return batchJobFromMldev(item);
		});
		setValueByPath(toObject, ["batchJobs"], transformedList);
	}
	return toObject;
}
function listBatchJobsResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromBatchJobs = getValueByPath(fromObject, ["batchPredictionJobs"]);
	if (fromBatchJobs != null) {
		let transformedList = fromBatchJobs;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return batchJobFromVertex(item);
		});
		setValueByPath(toObject, ["batchJobs"], transformedList);
	}
	return toObject;
}
function partToMldev$4(fromObject) {
	const toObject = {};
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
	if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
	const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
	if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
	const fromFileData = getValueByPath(fromObject, ["fileData"]);
	if (fromFileData != null) setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
	const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
	if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], functionCallToMldev$4(fromFunctionCall));
	const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
	if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
	const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
	if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
	const fromText = getValueByPath(fromObject, ["text"]);
	if (fromText != null) setValueByPath(toObject, ["text"], fromText);
	const fromThought = getValueByPath(fromObject, ["thought"]);
	if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
	const fromThoughtSignature = getValueByPath(fromObject, ["thoughtSignature"]);
	if (fromThoughtSignature != null) setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
	const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
	if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
	return toObject;
}
function safetySettingToMldev$1(fromObject) {
	const toObject = {};
	const fromCategory = getValueByPath(fromObject, ["category"]);
	if (fromCategory != null) setValueByPath(toObject, ["category"], fromCategory);
	if (getValueByPath(fromObject, ["method"]) !== void 0) throw new Error("method parameter is not supported in Gemini API.");
	const fromThreshold = getValueByPath(fromObject, ["threshold"]);
	if (fromThreshold != null) setValueByPath(toObject, ["threshold"], fromThreshold);
	return toObject;
}
function toolConfigToMldev$2(fromObject) {
	const toObject = {};
	const fromFunctionCallingConfig = getValueByPath(fromObject, ["functionCallingConfig"]);
	if (fromFunctionCallingConfig != null) setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
	const fromRetrievalConfig = getValueByPath(fromObject, ["retrievalConfig"]);
	if (fromRetrievalConfig != null) setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
	return toObject;
}
function toolToMldev$4(fromObject) {
	const toObject = {};
	const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
	if (fromFunctionDeclarations != null) {
		let transformedList = fromFunctionDeclarations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["functionDeclarations"], transformedList);
	}
	if (getValueByPath(fromObject, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
	const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
	if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
	const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
	if (fromComputerUse != null) setValueByPath(toObject, ["computerUse"], fromComputerUse);
	const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
	if (fromFileSearch != null) setValueByPath(toObject, ["fileSearch"], fromFileSearch);
	const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
	if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
	if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
	const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
	if (fromGoogleMaps != null) setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$4(fromGoogleMaps));
	const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
	if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
	const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
	if (fromUrlContext != null) setValueByPath(toObject, ["urlContext"], fromUrlContext);
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var PagedItem;
(function(PagedItem$1) {
	PagedItem$1["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
	PagedItem$1["PAGED_ITEM_MODELS"] = "models";
	PagedItem$1["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
	PagedItem$1["PAGED_ITEM_FILES"] = "files";
	PagedItem$1["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
	PagedItem$1["PAGED_ITEM_FILE_SEARCH_STORES"] = "fileSearchStores";
	PagedItem$1["PAGED_ITEM_DOCUMENTS"] = "documents";
})(PagedItem || (PagedItem = {}));
/**
* Pager class for iterating through paginated results.
*/
var Pager = class {
	constructor(name, request$3, response, params) {
		this.pageInternal = [];
		this.paramsInternal = {};
		this.requestInternal = request$3;
		this.init(name, response, params);
	}
	init(name, response, params) {
		var _a$2, _b;
		this.nameInternal = name;
		this.pageInternal = response[this.nameInternal] || [];
		this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;
		this.idxInternal = 0;
		let requestParams = { config: {} };
		if (!params || Object.keys(params).length === 0) requestParams = { config: {} };
		else if (typeof params === "object") requestParams = Object.assign({}, params);
		else requestParams = params;
		if (requestParams["config"]) requestParams["config"]["pageToken"] = response["nextPageToken"];
		this.paramsInternal = requestParams;
		this.pageInternalSize = (_b = (_a$2 = requestParams["config"]) === null || _a$2 === void 0 ? void 0 : _a$2["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
	}
	initNextPage(response) {
		this.init(this.nameInternal, response, this.paramsInternal);
	}
	/**
	* Returns the current page, which is a list of items.
	*
	* @remarks
	* The first page is retrieved when the pager is created. The returned list of
	* items could be a subset of the entire list.
	*/
	get page() {
		return this.pageInternal;
	}
	/**
	* Returns the type of paged item (for example, ``batch_jobs``).
	*/
	get name() {
		return this.nameInternal;
	}
	/**
	* Returns the length of the page fetched each time by this pager.
	*
	* @remarks
	* The number of items in the page is less than or equal to the page length.
	*/
	get pageSize() {
		return this.pageInternalSize;
	}
	/**
	* Returns the headers of the API response.
	*/
	get sdkHttpResponse() {
		return this.sdkHttpResponseInternal;
	}
	/**
	* Returns the parameters when making the API request for the next page.
	*
	* @remarks
	* Parameters contain a set of optional configs that can be
	* used to customize the API request. For example, the `pageToken` parameter
	* contains the token to request the next page.
	*/
	get params() {
		return this.paramsInternal;
	}
	/**
	* Returns the total number of items in the current page.
	*/
	get pageLength() {
		return this.pageInternal.length;
	}
	/**
	* Returns the item at the given index.
	*/
	getItem(index) {
		return this.pageInternal[index];
	}
	/**
	* Returns an async iterator that support iterating through all items
	* retrieved from the API.
	*
	* @remarks
	* The iterator will automatically fetch the next page if there are more items
	* to fetch from the API.
	*
	* @example
	*
	* ```ts
	* const pager = await ai.files.list({config: {pageSize: 10}});
	* for await (const file of pager) {
	*   console.log(file.name);
	* }
	* ```
	*/
	[Symbol.asyncIterator]() {
		return {
			next: async () => {
				if (this.idxInternal >= this.pageLength) if (this.hasNextPage()) await this.nextPage();
				else return {
					value: void 0,
					done: true
				};
				const item = this.getItem(this.idxInternal);
				this.idxInternal += 1;
				return {
					value: item,
					done: false
				};
			},
			return: async () => {
				return {
					value: void 0,
					done: true
				};
			}
		};
	}
	/**
	* Fetches the next page of items. This makes a new API request.
	*
	* @throws {Error} If there are no more pages to fetch.
	*
	* @example
	*
	* ```ts
	* const pager = await ai.files.list({config: {pageSize: 10}});
	* let page = pager.page;
	* while (true) {
	*   for (const file of page) {
	*     console.log(file.name);
	*   }
	*   if (!pager.hasNextPage()) {
	*     break;
	*   }
	*   page = await pager.nextPage();
	* }
	* ```
	*/
	async nextPage() {
		if (!this.hasNextPage()) throw new Error("No more pages to fetch.");
		const response = await this.requestInternal(this.params);
		this.initNextPage(response);
		return this.page;
	}
	/**
	* Returns true if there are more pages to fetch from the API.
	*/
	hasNextPage() {
		var _a$2;
		if (((_a$2 = this.params["config"]) === null || _a$2 === void 0 ? void 0 : _a$2["pageToken"]) !== void 0) return true;
		return false;
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var Batches = class extends BaseModule {
	constructor(apiClient) {
		super();
		this.apiClient = apiClient;
		/**
		* Create batch job.
		*
		* @param params - The parameters for create batch job request.
		* @return The created batch job.
		*
		* @example
		* ```ts
		* const response = await ai.batches.create({
		*   model: 'gemini-2.0-flash',
		*   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},
		*   config: {
		*     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},
		*   }
		* });
		* console.log(response);
		* ```
		*/
		this.create = async (params) => {
			if (this.apiClient.isVertexAI()) params.config = this.formatDestination(params.src, params.config);
			return this.createInternal(params);
		};
		/**
		* **Experimental** Creates an embedding batch job.
		*
		* @param params - The parameters for create embedding batch job request.
		* @return The created batch job.
		*
		* @example
		* ```ts
		* const response = await ai.batches.createEmbeddings({
		*   model: 'text-embedding-004',
		*   src: {fileName: 'files/my_embedding_input'},
		* });
		* console.log(response);
		* ```
		*/
		this.createEmbeddings = async (params) => {
			console.warn("batches.createEmbeddings() is experimental and may change without notice.");
			if (this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support batches.createEmbeddings.");
			return this.createEmbeddingsInternal(params);
		};
		/**
		* Lists batch job configurations.
		*
		* @param params - The parameters for the list request.
		* @return The paginated results of the list of batch jobs.
		*
		* @example
		* ```ts
		* const batchJobs = await ai.batches.list({config: {'pageSize': 2}});
		* for await (const batchJob of batchJobs) {
		*   console.log(batchJob);
		* }
		* ```
		*/
		this.list = async (params = {}) => {
			return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x$1) => this.listInternal(x$1), await this.listInternal(params), params);
		};
	}
	createInlinedGenerateContentRequest(params) {
		const body = createBatchJobParametersToMldev(this.apiClient, params);
		const urlParams = body["_url"];
		const path$9 = formatMap("{model}:batchGenerateContent", urlParams);
		const requestsWrapper = body["batch"]["inputConfig"]["requests"];
		const requests = requestsWrapper["requests"];
		const newRequests = [];
		for (const request$3 of requests) {
			const requestDict = Object.assign({}, request$3);
			if (requestDict["systemInstruction"]) {
				const systemInstructionValue = requestDict["systemInstruction"];
				delete requestDict["systemInstruction"];
				const requestContent = requestDict["request"];
				requestContent["systemInstruction"] = systemInstructionValue;
				requestDict["request"] = requestContent;
			}
			newRequests.push(requestDict);
		}
		requestsWrapper["requests"] = newRequests;
		delete body["config"];
		delete body["_url"];
		delete body["_query"];
		return {
			path: path$9,
			body
		};
	}
	getGcsUri(src) {
		if (typeof src === "string") return src.startsWith("gs://") ? src : void 0;
		if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) return src.gcsUri[0];
	}
	getBigqueryUri(src) {
		if (typeof src === "string") return src.startsWith("bq://") ? src : void 0;
		if (!Array.isArray(src)) return src.bigqueryUri;
	}
	formatDestination(src, config) {
		const newConfig = config ? Object.assign({}, config) : {};
		const timestampStr = Date.now().toString();
		if (!newConfig.displayName) newConfig.displayName = `genaiBatchJob_${timestampStr}`;
		if (newConfig.dest === void 0) {
			const gcsUri = this.getGcsUri(src);
			const bigqueryUri = this.getBigqueryUri(src);
			if (gcsUri) if (gcsUri.endsWith(".jsonl")) newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;
			else newConfig.dest = `${gcsUri}_dest_${timestampStr}`;
			else if (bigqueryUri) newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;
			else throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
		}
		return newConfig;
	}
	/**
	* Internal method to create batch job.
	*
	* @param params - The parameters for create batch job request.
	* @return The created batch job.
	*
	*/
	async createInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = createBatchJobParametersToVertex(this.apiClient, params);
			path$9 = formatMap("batchPredictionJobs", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				return batchJobFromVertex(apiResponse);
			});
		} else {
			const body = createBatchJobParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{model}:batchGenerateContent", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				return batchJobFromMldev(apiResponse);
			});
		}
	}
	/**
	* Internal method to create batch job.
	*
	* @param params - The parameters for create batch job request.
	* @return The created batch job.
	*
	*/
	async createEmbeddingsInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{model}:asyncBatchEmbedContent", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				return batchJobFromMldev(apiResponse);
			});
		}
	}
	/**
	* Gets batch job configurations.
	*
	* @param params - The parameters for the get request.
	* @return The batch job.
	*
	* @example
	* ```ts
	* await ai.batches.get({name: '...'}); // The server-generated resource name.
	* ```
	*/
	async get(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = getBatchJobParametersToVertex(this.apiClient, params);
			path$9 = formatMap("batchPredictionJobs/{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				return batchJobFromVertex(apiResponse);
			});
		} else {
			const body = getBatchJobParametersToMldev(this.apiClient, params);
			path$9 = formatMap("batches/{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				return batchJobFromMldev(apiResponse);
			});
		}
	}
	/**
	* Cancels a batch job.
	*
	* @param params - The parameters for the cancel request.
	* @return The empty response returned by the API.
	*
	* @example
	* ```ts
	* await ai.batches.cancel({name: '...'}); // The server-generated resource name.
	* ```
	*/
	async cancel(params) {
		var _a$2, _b, _c, _d;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = cancelBatchJobParametersToVertex(this.apiClient, params);
			path$9 = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			await this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			});
		} else {
			const body = cancelBatchJobParametersToMldev(this.apiClient, params);
			path$9 = formatMap("batches/{name}:cancel", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			await this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			});
		}
	}
	async listInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = listBatchJobsParametersToVertex(params);
			path$9 = formatMap("batchPredictionJobs", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = listBatchJobsResponseFromVertex(apiResponse);
				const typedResp = new ListBatchJobsResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = listBatchJobsParametersToMldev(params);
			path$9 = formatMap("batches", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = listBatchJobsResponseFromMldev(apiResponse);
				const typedResp = new ListBatchJobsResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Deletes a batch job.
	*
	* @param params - The parameters for the delete request.
	* @return The empty response returned by the API.
	*
	* @example
	* ```ts
	* await ai.batches.delete({name: '...'}); // The server-generated resource name.
	* ```
	*/
	async delete(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = deleteBatchJobParametersToVertex(this.apiClient, params);
			path$9 = formatMap("batchPredictionJobs/{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "DELETE",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				return deleteResourceJobFromVertex(apiResponse);
			});
		} else {
			const body = deleteBatchJobParametersToMldev(this.apiClient, params);
			path$9 = formatMap("batches/{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "DELETE",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				return deleteResourceJobFromMldev(apiResponse);
			});
		}
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function blobToMldev$3(fromObject) {
	const toObject = {};
	const fromData = getValueByPath(fromObject, ["data"]);
	if (fromData != null) setValueByPath(toObject, ["data"], fromData);
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function contentToMldev$3(fromObject) {
	const toObject = {};
	const fromParts = getValueByPath(fromObject, ["parts"]);
	if (fromParts != null) {
		let transformedList = fromParts;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return partToMldev$3(item);
		});
		setValueByPath(toObject, ["parts"], transformedList);
	}
	const fromRole = getValueByPath(fromObject, ["role"]);
	if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
	return toObject;
}
function createCachedContentConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromTtl = getValueByPath(fromObject, ["ttl"]);
	if (parentObject !== void 0 && fromTtl != null) setValueByPath(parentObject, ["ttl"], fromTtl);
	const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
	if (parentObject !== void 0 && fromExpireTime != null) setValueByPath(parentObject, ["expireTime"], fromExpireTime);
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["displayName"], fromDisplayName);
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (parentObject !== void 0 && fromContents != null) {
		let transformedList = tContents(fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return contentToMldev$3(item);
		});
		setValueByPath(parentObject, ["contents"], transformedList);
	}
	const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
	if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
	const fromTools = getValueByPath(fromObject, ["tools"]);
	if (parentObject !== void 0 && fromTools != null) {
		let transformedList = fromTools;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return toolToMldev$3(item);
		});
		setValueByPath(parentObject, ["tools"], transformedList);
	}
	const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
	if (parentObject !== void 0 && fromToolConfig != null) setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
	if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) throw new Error("kmsKeyName parameter is not supported in Gemini API.");
	return toObject;
}
function createCachedContentConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromTtl = getValueByPath(fromObject, ["ttl"]);
	if (parentObject !== void 0 && fromTtl != null) setValueByPath(parentObject, ["ttl"], fromTtl);
	const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
	if (parentObject !== void 0 && fromExpireTime != null) setValueByPath(parentObject, ["expireTime"], fromExpireTime);
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["displayName"], fromDisplayName);
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (parentObject !== void 0 && fromContents != null) {
		let transformedList = tContents(fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(parentObject, ["contents"], transformedList);
	}
	const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
	if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
	const fromTools = getValueByPath(fromObject, ["tools"]);
	if (parentObject !== void 0 && fromTools != null) {
		let transformedList = fromTools;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return toolToVertex$2(item);
		});
		setValueByPath(parentObject, ["tools"], transformedList);
	}
	const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
	if (parentObject !== void 0 && fromToolConfig != null) setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
	const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
	if (parentObject !== void 0 && fromKmsKeyName != null) setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
	return toObject;
}
function createCachedContentParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) createCachedContentConfigToMldev(fromConfig, toObject);
	return toObject;
}
function createCachedContentParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) createCachedContentConfigToVertex(fromConfig, toObject);
	return toObject;
}
function deleteCachedContentParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
	return toObject;
}
function deleteCachedContentParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
	return toObject;
}
function deleteCachedContentResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	return toObject;
}
function deleteCachedContentResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	return toObject;
}
function fileDataToMldev$3(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
	if (fromFileUri != null) setValueByPath(toObject, ["fileUri"], fromFileUri);
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function functionCallToMldev$3(fromObject) {
	const toObject = {};
	const fromId = getValueByPath(fromObject, ["id"]);
	if (fromId != null) setValueByPath(toObject, ["id"], fromId);
	const fromArgs = getValueByPath(fromObject, ["args"]);
	if (fromArgs != null) setValueByPath(toObject, ["args"], fromArgs);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
	return toObject;
}
function functionCallingConfigToMldev$1(fromObject) {
	const toObject = {};
	const fromMode = getValueByPath(fromObject, ["mode"]);
	if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
	const fromAllowedFunctionNames = getValueByPath(fromObject, ["allowedFunctionNames"]);
	if (fromAllowedFunctionNames != null) setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
	if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
	return toObject;
}
function functionDeclarationToVertex$2(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI.");
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromParameters = getValueByPath(fromObject, ["parameters"]);
	if (fromParameters != null) setValueByPath(toObject, ["parameters"], fromParameters);
	const fromParametersJsonSchema = getValueByPath(fromObject, ["parametersJsonSchema"]);
	if (fromParametersJsonSchema != null) setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
	const fromResponse = getValueByPath(fromObject, ["response"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], fromResponse);
	const fromResponseJsonSchema = getValueByPath(fromObject, ["responseJsonSchema"]);
	if (fromResponseJsonSchema != null) setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
	return toObject;
}
function getCachedContentParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
	return toObject;
}
function getCachedContentParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
	return toObject;
}
function googleMapsToMldev$3(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
	const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
	if (fromEnableWidget != null) setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
	return toObject;
}
function googleSearchToMldev$3(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API.");
	const fromTimeRangeFilter = getValueByPath(fromObject, ["timeRangeFilter"]);
	if (fromTimeRangeFilter != null) setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
	return toObject;
}
function listCachedContentsConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	return toObject;
}
function listCachedContentsConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	return toObject;
}
function listCachedContentsParametersToMldev(fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listCachedContentsConfigToMldev(fromConfig, toObject);
	return toObject;
}
function listCachedContentsParametersToVertex(fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listCachedContentsConfigToVertex(fromConfig, toObject);
	return toObject;
}
function listCachedContentsResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromCachedContents = getValueByPath(fromObject, ["cachedContents"]);
	if (fromCachedContents != null) {
		let transformedList = fromCachedContents;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["cachedContents"], transformedList);
	}
	return toObject;
}
function listCachedContentsResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromCachedContents = getValueByPath(fromObject, ["cachedContents"]);
	if (fromCachedContents != null) {
		let transformedList = fromCachedContents;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["cachedContents"], transformedList);
	}
	return toObject;
}
function partToMldev$3(fromObject) {
	const toObject = {};
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
	if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
	const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
	if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
	const fromFileData = getValueByPath(fromObject, ["fileData"]);
	if (fromFileData != null) setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
	const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
	if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], functionCallToMldev$3(fromFunctionCall));
	const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
	if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
	const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
	if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
	const fromText = getValueByPath(fromObject, ["text"]);
	if (fromText != null) setValueByPath(toObject, ["text"], fromText);
	const fromThought = getValueByPath(fromObject, ["thought"]);
	if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
	const fromThoughtSignature = getValueByPath(fromObject, ["thoughtSignature"]);
	if (fromThoughtSignature != null) setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
	const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
	if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
	return toObject;
}
function toolConfigToMldev$1(fromObject) {
	const toObject = {};
	const fromFunctionCallingConfig = getValueByPath(fromObject, ["functionCallingConfig"]);
	if (fromFunctionCallingConfig != null) setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
	const fromRetrievalConfig = getValueByPath(fromObject, ["retrievalConfig"]);
	if (fromRetrievalConfig != null) setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
	return toObject;
}
function toolToMldev$3(fromObject) {
	const toObject = {};
	const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
	if (fromFunctionDeclarations != null) {
		let transformedList = fromFunctionDeclarations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["functionDeclarations"], transformedList);
	}
	if (getValueByPath(fromObject, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
	const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
	if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
	const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
	if (fromComputerUse != null) setValueByPath(toObject, ["computerUse"], fromComputerUse);
	const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
	if (fromFileSearch != null) setValueByPath(toObject, ["fileSearch"], fromFileSearch);
	const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
	if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
	if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
	const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
	if (fromGoogleMaps != null) setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$3(fromGoogleMaps));
	const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
	if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
	const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
	if (fromUrlContext != null) setValueByPath(toObject, ["urlContext"], fromUrlContext);
	return toObject;
}
function toolToVertex$2(fromObject) {
	const toObject = {};
	const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
	if (fromFunctionDeclarations != null) {
		let transformedList = fromFunctionDeclarations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return functionDeclarationToVertex$2(item);
		});
		setValueByPath(toObject, ["functionDeclarations"], transformedList);
	}
	const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
	if (fromRetrieval != null) setValueByPath(toObject, ["retrieval"], fromRetrieval);
	const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
	if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
	const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
	if (fromComputerUse != null) setValueByPath(toObject, ["computerUse"], fromComputerUse);
	if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) throw new Error("fileSearch parameter is not supported in Vertex AI.");
	const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
	if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
	const fromEnterpriseWebSearch = getValueByPath(fromObject, ["enterpriseWebSearch"]);
	if (fromEnterpriseWebSearch != null) setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
	const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
	if (fromGoogleMaps != null) setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
	const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
	if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
	const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
	if (fromUrlContext != null) setValueByPath(toObject, ["urlContext"], fromUrlContext);
	return toObject;
}
function updateCachedContentConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromTtl = getValueByPath(fromObject, ["ttl"]);
	if (parentObject !== void 0 && fromTtl != null) setValueByPath(parentObject, ["ttl"], fromTtl);
	const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
	if (parentObject !== void 0 && fromExpireTime != null) setValueByPath(parentObject, ["expireTime"], fromExpireTime);
	return toObject;
}
function updateCachedContentConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromTtl = getValueByPath(fromObject, ["ttl"]);
	if (parentObject !== void 0 && fromTtl != null) setValueByPath(parentObject, ["ttl"], fromTtl);
	const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
	if (parentObject !== void 0 && fromExpireTime != null) setValueByPath(parentObject, ["expireTime"], fromExpireTime);
	return toObject;
}
function updateCachedContentParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) updateCachedContentConfigToMldev(fromConfig, toObject);
	return toObject;
}
function updateCachedContentParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) updateCachedContentConfigToVertex(fromConfig, toObject);
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var Caches = class extends BaseModule {
	constructor(apiClient) {
		super();
		this.apiClient = apiClient;
		/**
		* Lists cached content configurations.
		*
		* @param params - The parameters for the list request.
		* @return The paginated results of the list of cached contents.
		*
		* @example
		* ```ts
		* const cachedContents = await ai.caches.list({config: {'pageSize': 2}});
		* for await (const cachedContent of cachedContents) {
		*   console.log(cachedContent);
		* }
		* ```
		*/
		this.list = async (params = {}) => {
			return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x$1) => this.listInternal(x$1), await this.listInternal(params), params);
		};
	}
	/**
	* Creates a cached contents resource.
	*
	* @remarks
	* Context caching is only supported for specific models. See [Gemini
	* Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
	* and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
	* for more information.
	*
	* @param params - The parameters for the create request.
	* @return The created cached content.
	*
	* @example
	* ```ts
	* const contents = ...; // Initialize the content to cache.
	* const response = await ai.caches.create({
	*   model: 'gemini-2.0-flash-001',
	*   config: {
	*    'contents': contents,
	*    'displayName': 'test cache',
	*    'systemInstruction': 'What is the sum of the two pdfs?',
	*    'ttl': '86400s',
	*  }
	* });
	* ```
	*/
	async create(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = createCachedContentParametersToVertex(this.apiClient, params);
			path$9 = formatMap("cachedContents", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		} else {
			const body = createCachedContentParametersToMldev(this.apiClient, params);
			path$9 = formatMap("cachedContents", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		}
	}
	/**
	* Gets cached content configurations.
	*
	* @param params - The parameters for the get request.
	* @return The cached content.
	*
	* @example
	* ```ts
	* await ai.caches.get({name: '...'}); // The server-generated resource name.
	* ```
	*/
	async get(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = getCachedContentParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		} else {
			const body = getCachedContentParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		}
	}
	/**
	* Deletes cached content.
	*
	* @param params - The parameters for the delete request.
	* @return The empty response returned by the API.
	*
	* @example
	* ```ts
	* await ai.caches.delete({name: '...'}); // The server-generated resource name.
	* ```
	*/
	async delete(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = deleteCachedContentParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "DELETE",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = deleteCachedContentResponseFromVertex(apiResponse);
				const typedResp = new DeleteCachedContentResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = deleteCachedContentParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "DELETE",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = deleteCachedContentResponseFromMldev(apiResponse);
				const typedResp = new DeleteCachedContentResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Updates cached content configurations.
	*
	* @param params - The parameters for the update request.
	* @return The updated cached content.
	*
	* @example
	* ```ts
	* const response = await ai.caches.update({
	*   name: '...',  // The server-generated resource name.
	*   config: {'ttl': '7600s'}
	* });
	* ```
	*/
	async update(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = updateCachedContentParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "PATCH",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		} else {
			const body = updateCachedContentParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "PATCH",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		}
	}
	async listInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = listCachedContentsParametersToVertex(params);
			path$9 = formatMap("cachedContents", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = listCachedContentsResponseFromVertex(apiResponse);
				const typedResp = new ListCachedContentsResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = listCachedContentsParametersToMldev(params);
			path$9 = formatMap("cachedContents", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = listCachedContentsResponseFromMldev(apiResponse);
				const typedResp = new ListCachedContentsResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
};
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __values(o) {
	var s$2 = typeof Symbol === "function" && Symbol.iterator, m$2 = s$2 && o[s$2], i$2 = 0;
	if (m$2) return m$2.call(o);
	if (o && typeof o.length === "number") return { next: function() {
		if (o && i$2 >= o.length) o = void 0;
		return {
			value: o && o[i$2++],
			done: !o
		};
	} };
	throw new TypeError(s$2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
	return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var g = generator.apply(thisArg, _arguments || []), i$2, q = [];
	return i$2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i$2[Symbol.asyncIterator] = function() {
		return this;
	}, i$2;
	function awaitReturn(f$2) {
		return function(v) {
			return Promise.resolve(v).then(f$2, reject);
		};
	}
	function verb(n, f$2) {
		if (g[n]) {
			i$2[n] = function(v) {
				return new Promise(function(a, b) {
					q.push([
						n,
						v,
						a,
						b
					]) > 1 || resume$3(n, v);
				});
			};
			if (f$2) i$2[n] = f$2(i$2[n]);
		}
	}
	function resume$3(n, v) {
		try {
			step(g[n](v));
		} catch (e$1) {
			settle(q[0][3], e$1);
		}
	}
	function step(r$1) {
		r$1.value instanceof __await ? Promise.resolve(r$1.value.v).then(fulfill, reject) : settle(q[0][2], r$1);
	}
	function fulfill(value) {
		resume$3("next", value);
	}
	function reject(value) {
		resume$3("throw", value);
	}
	function settle(f$2, v) {
		if (f$2(v), q.shift(), q.length) resume$3(q[0][0], q[0][1]);
	}
}
function __asyncValues(o) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m$2 = o[Symbol.asyncIterator], i$2;
	return m$2 ? m$2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i$2 = {}, verb("next"), verb("throw"), verb("return"), i$2[Symbol.asyncIterator] = function() {
		return this;
	}, i$2);
	function verb(n) {
		i$2[n] = o[n] && function(v) {
			return new Promise(function(resolve, reject) {
				v = o[n](v), settle(resolve, reject, v.done, v.value);
			});
		};
	}
	function settle(resolve, reject, d$1, v) {
		Promise.resolve(v).then(function(v$1) {
			resolve({
				value: v$1,
				done: d$1
			});
		}, reject);
	}
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
/**
* Returns true if the response is valid, false otherwise.
*/
function isValidResponse(response) {
	var _a$2;
	if (response.candidates == void 0 || response.candidates.length === 0) return false;
	const content = (_a$2 = response.candidates[0]) === null || _a$2 === void 0 ? void 0 : _a$2.content;
	if (content === void 0) return false;
	return isValidContent(content);
}
function isValidContent(content) {
	if (content.parts === void 0 || content.parts.length === 0) return false;
	for (const part of content.parts) if (part === void 0 || Object.keys(part).length === 0) return false;
	return true;
}
/**
* Validates the history contains the correct roles.
*
* @throws Error if the history does not start with a user turn.
* @throws Error if the history contains an invalid role.
*/
function validateHistory(history) {
	if (history.length === 0) return;
	for (const content of history) if (content.role !== "user" && content.role !== "model") throw new Error(`Role must be user or model, but got ${content.role}.`);
}
/**
* Extracts the curated (valid) history from a comprehensive history.
*
* @remarks
* The model may sometimes generate invalid or empty contents(e.g., due to safty
* filters or recitation). Extracting valid turns from the history
* ensures that subsequent requests could be accpeted by the model.
*/
function extractCuratedHistory(comprehensiveHistory) {
	if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) return [];
	const curatedHistory = [];
	const length = comprehensiveHistory.length;
	let i$2 = 0;
	while (i$2 < length) if (comprehensiveHistory[i$2].role === "user") {
		curatedHistory.push(comprehensiveHistory[i$2]);
		i$2++;
	} else {
		const modelOutput = [];
		let isValid = true;
		while (i$2 < length && comprehensiveHistory[i$2].role === "model") {
			modelOutput.push(comprehensiveHistory[i$2]);
			if (isValid && !isValidContent(comprehensiveHistory[i$2])) isValid = false;
			i$2++;
		}
		if (isValid) curatedHistory.push(...modelOutput);
		else curatedHistory.pop();
	}
	return curatedHistory;
}
/**
* A utility class to create a chat session.
*/
var Chats = class {
	constructor(modelsModule, apiClient) {
		this.modelsModule = modelsModule;
		this.apiClient = apiClient;
	}
	/**
	* Creates a new chat session.
	*
	* @remarks
	* The config in the params will be used for all requests within the chat
	* session unless overridden by a per-request `config` in
	* @see {@link types.SendMessageParameters#config}.
	*
	* @param params - Parameters for creating a chat session.
	* @returns A new chat session.
	*
	* @example
	* ```ts
	* const chat = ai.chats.create({
	*   model: 'gemini-2.0-flash'
	*   config: {
	*     temperature: 0.5,
	*     maxOutputTokens: 1024,
	*   }
	* });
	* ```
	*/
	create(params) {
		return new Chat(this.apiClient, this.modelsModule, params.model, params.config, structuredClone(params.history));
	}
};
/**
* Chat session that enables sending messages to the model with previous
* conversation context.
*
* @remarks
* The session maintains all the turns between user and model.
*/
var Chat = class {
	constructor(apiClient, modelsModule, model, config = {}, history = []) {
		this.apiClient = apiClient;
		this.modelsModule = modelsModule;
		this.model = model;
		this.config = config;
		this.history = history;
		this.sendPromise = Promise.resolve();
		validateHistory(history);
	}
	/**
	* Sends a message to the model and returns the response.
	*
	* @remarks
	* This method will wait for the previous message to be processed before
	* sending the next message.
	*
	* @see {@link Chat#sendMessageStream} for streaming method.
	* @param params - parameters for sending messages within a chat session.
	* @returns The model's response.
	*
	* @example
	* ```ts
	* const chat = ai.chats.create({model: 'gemini-2.0-flash'});
	* const response = await chat.sendMessage({
	*   message: 'Why is the sky blue?'
	* });
	* console.log(response.text);
	* ```
	*/
	async sendMessage(params) {
		var _a$2;
		await this.sendPromise;
		const inputContent = tContent(params.message);
		const responsePromise = this.modelsModule.generateContent({
			model: this.model,
			contents: this.getHistory(true).concat(inputContent),
			config: (_a$2 = params.config) !== null && _a$2 !== void 0 ? _a$2 : this.config
		});
		this.sendPromise = (async () => {
			var _a$3, _b, _c;
			const response = await responsePromise;
			const outputContent = (_b = (_a$3 = response.candidates) === null || _a$3 === void 0 ? void 0 : _a$3[0]) === null || _b === void 0 ? void 0 : _b.content;
			const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
			const index = this.getHistory(true).length;
			let automaticFunctionCallingHistory = [];
			if (fullAutomaticFunctionCallingHistory != null) automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
			const modelOutput = outputContent ? [outputContent] : [];
			this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
		})();
		await this.sendPromise.catch(() => {
			this.sendPromise = Promise.resolve();
		});
		return responsePromise;
	}
	/**
	* Sends a message to the model and returns the response in chunks.
	*
	* @remarks
	* This method will wait for the previous message to be processed before
	* sending the next message.
	*
	* @see {@link Chat#sendMessage} for non-streaming method.
	* @param params - parameters for sending the message.
	* @return The model's response.
	*
	* @example
	* ```ts
	* const chat = ai.chats.create({model: 'gemini-2.0-flash'});
	* const response = await chat.sendMessageStream({
	*   message: 'Why is the sky blue?'
	* });
	* for await (const chunk of response) {
	*   console.log(chunk.text);
	* }
	* ```
	*/
	async sendMessageStream(params) {
		var _a$2;
		await this.sendPromise;
		const inputContent = tContent(params.message);
		const streamResponse = this.modelsModule.generateContentStream({
			model: this.model,
			contents: this.getHistory(true).concat(inputContent),
			config: (_a$2 = params.config) !== null && _a$2 !== void 0 ? _a$2 : this.config
		});
		this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
		const response = await streamResponse;
		return this.processStreamResponse(response, inputContent);
	}
	/**
	* Returns the chat history.
	*
	* @remarks
	* The history is a list of contents alternating between user and model.
	*
	* There are two types of history:
	* - The `curated history` contains only the valid turns between user and
	* model, which will be included in the subsequent requests sent to the model.
	* - The `comprehensive history` contains all turns, including invalid or
	*   empty model outputs, providing a complete record of the history.
	*
	* The history is updated after receiving the response from the model,
	* for streaming response, it means receiving the last chunk of the response.
	*
	* The `comprehensive history` is returned by default. To get the `curated
	* history`, set the `curated` parameter to `true`.
	*
	* @param curated - whether to return the curated history or the comprehensive
	*     history.
	* @return History contents alternating between user and model for the entire
	*     chat session.
	*/
	getHistory(curated = false) {
		const history = curated ? extractCuratedHistory(this.history) : this.history;
		return structuredClone(history);
	}
	processStreamResponse(streamResponse, inputContent) {
		var _a$2, _b;
		return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
			var _c, e_1, _d, _e;
			const outputContent = [];
			try {
				for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {
					_e = streamResponse_1_1.value;
					_f = false;
					const chunk = _e;
					if (isValidResponse(chunk)) {
						const content = (_b = (_a$2 = chunk.candidates) === null || _a$2 === void 0 ? void 0 : _a$2[0]) === null || _b === void 0 ? void 0 : _b.content;
						if (content !== void 0) outputContent.push(content);
					}
					yield yield __await(chunk);
				}
			} catch (e_1_1) {
				e_1 = { error: e_1_1 };
			} finally {
				try {
					if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));
				} finally {
					if (e_1) throw e_1.error;
				}
			}
			this.recordHistory(inputContent, outputContent);
		});
	}
	recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
		let outputContents = [];
		if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) outputContents = modelOutput;
		else outputContents.push({
			role: "model",
			parts: []
		});
		if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
		else this.history.push(userInput);
		this.history.push(...outputContents);
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
/**
* API errors raised by the GenAI API.
*/
var ApiError = class ApiError extends Error {
	constructor(options) {
		super(options.message);
		this.name = "ApiError";
		this.status = options.status;
		Object.setPrototypeOf(this, ApiError.prototype);
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function createFileParametersToMldev(fromObject) {
	const toObject = {};
	const fromFile$1 = getValueByPath(fromObject, ["file"]);
	if (fromFile$1 != null) setValueByPath(toObject, ["file"], fromFile$1);
	return toObject;
}
function createFileResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	return toObject;
}
function deleteFileParametersToMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
	return toObject;
}
function deleteFileResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	return toObject;
}
function getFileParametersToMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
	return toObject;
}
function listFilesConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	return toObject;
}
function listFilesParametersToMldev(fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listFilesConfigToMldev(fromConfig, toObject);
	return toObject;
}
function listFilesResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromFiles = getValueByPath(fromObject, ["files"]);
	if (fromFiles != null) {
		let transformedList = fromFiles;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["files"], transformedList);
	}
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var Files = class extends BaseModule {
	constructor(apiClient) {
		super();
		this.apiClient = apiClient;
		/**
		* Lists all current project files from the service.
		*
		* @param params - The parameters for the list request
		* @return The paginated results of the list of files
		*
		* @example
		* The following code prints the names of all files from the service, the
		* size of each page is 10.
		*
		* ```ts
		* const listResponse = await ai.files.list({config: {'pageSize': 10}});
		* for await (const file of listResponse) {
		*   console.log(file.name);
		* }
		* ```
		*/
		this.list = async (params = {}) => {
			return new Pager(PagedItem.PAGED_ITEM_FILES, (x$1) => this.listInternal(x$1), await this.listInternal(params), params);
		};
	}
	/**
	* Uploads a file asynchronously to the Gemini API.
	* This method is not available in Vertex AI.
	* Supported upload sources:
	* - Node.js: File path (string) or Blob object.
	* - Browser: Blob object (e.g., File).
	*
	* @remarks
	* The `mimeType` can be specified in the `config` parameter. If omitted:
	*  - For file path (string) inputs, the `mimeType` will be inferred from the
	*     file extension.
	*  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
	*     property.
	* Somex eamples for file extension to mimeType mapping:
	* .txt -> text/plain
	* .json -> application/json
	* .jpg  -> image/jpeg
	* .png -> image/png
	* .mp3 -> audio/mpeg
	* .mp4 -> video/mp4
	*
	* This section can contain multiple paragraphs and code examples.
	*
	* @param params - Optional parameters specified in the
	*        `types.UploadFileParameters` interface.
	*         @see {@link types.UploadFileParameters#config} for the optional
	*         config in the parameters.
	* @return A promise that resolves to a `types.File` object.
	* @throws An error if called on a Vertex AI client.
	* @throws An error if the `mimeType` is not provided and can not be inferred,
	* the `mimeType` can be provided in the `params.config` parameter.
	* @throws An error occurs if a suitable upload location cannot be established.
	*
	* @example
	* The following code uploads a file to Gemini API.
	*
	* ```ts
	* const file = await ai.files.upload({file: 'file.txt', config: {
	*   mimeType: 'text/plain',
	* }});
	* console.log(file.name);
	* ```
	*/
	async upload(params) {
		if (this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
		return this.apiClient.uploadFile(params.file, params.config).then((resp) => {
			return resp;
		});
	}
	/**
	* Downloads a remotely stored file asynchronously to a location specified in
	* the `params` object. This method only works on Node environment, to
	* download files in the browser, use a browser compliant method like an <a>
	* tag.
	*
	* @param params - The parameters for the download request.
	*
	* @example
	* The following code downloads an example file named "files/mehozpxf877d" as
	* "file.txt".
	*
	* ```ts
	* await ai.files.download({file: file.name, downloadPath: 'file.txt'});
	* ```
	*/
	async download(params) {
		await this.apiClient.downloadFile(params);
	}
	async listInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = listFilesParametersToMldev(params);
			path$9 = formatMap("files", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = listFilesResponseFromMldev(apiResponse);
				const typedResp = new ListFilesResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	async createInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = createFileParametersToMldev(params);
			path$9 = formatMap("upload/v1beta/files", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				const resp = createFileResponseFromMldev(apiResponse);
				const typedResp = new CreateFileResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Retrieves the file information from the service.
	*
	* @param params - The parameters for the get request
	* @return The Promise that resolves to the types.File object requested.
	*
	* @example
	* ```ts
	* const config: GetFileParameters = {
	*   name: fileName,
	* };
	* file = await ai.files.get(config);
	* console.log(file.name);
	* ```
	*/
	async get(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = getFileParametersToMldev(params);
			path$9 = formatMap("files/{file}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		}
	}
	/**
	* Deletes a remotely stored file.
	*
	* @param params - The parameters for the delete request.
	* @return The DeleteFileResponse, the response for the delete method.
	*
	* @example
	* The following code deletes an example file named "files/mehozpxf877d".
	*
	* ```ts
	* await ai.files.delete({name: file.name});
	* ```
	*/
	async delete(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = deleteFileParametersToMldev(params);
			path$9 = formatMap("files/{file}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "DELETE",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = deleteFileResponseFromMldev(apiResponse);
				const typedResp = new DeleteFileResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function blobToMldev$2(fromObject) {
	const toObject = {};
	const fromData = getValueByPath(fromObject, ["data"]);
	if (fromData != null) setValueByPath(toObject, ["data"], fromData);
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function contentToMldev$2(fromObject) {
	const toObject = {};
	const fromParts = getValueByPath(fromObject, ["parts"]);
	if (fromParts != null) {
		let transformedList = fromParts;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return partToMldev$2(item);
		});
		setValueByPath(toObject, ["parts"], transformedList);
	}
	const fromRole = getValueByPath(fromObject, ["role"]);
	if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
	return toObject;
}
function fileDataToMldev$2(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
	if (fromFileUri != null) setValueByPath(toObject, ["fileUri"], fromFileUri);
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function functionCallToMldev$2(fromObject) {
	const toObject = {};
	const fromId = getValueByPath(fromObject, ["id"]);
	if (fromId != null) setValueByPath(toObject, ["id"], fromId);
	const fromArgs = getValueByPath(fromObject, ["args"]);
	if (fromArgs != null) setValueByPath(toObject, ["args"], fromArgs);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
	return toObject;
}
function functionDeclarationToVertex$1(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI.");
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromParameters = getValueByPath(fromObject, ["parameters"]);
	if (fromParameters != null) setValueByPath(toObject, ["parameters"], fromParameters);
	const fromParametersJsonSchema = getValueByPath(fromObject, ["parametersJsonSchema"]);
	if (fromParametersJsonSchema != null) setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
	const fromResponse = getValueByPath(fromObject, ["response"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], fromResponse);
	const fromResponseJsonSchema = getValueByPath(fromObject, ["responseJsonSchema"]);
	if (fromResponseJsonSchema != null) setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
	return toObject;
}
function generationConfigToVertex$1(fromObject) {
	const toObject = {};
	const fromModelSelectionConfig = getValueByPath(fromObject, ["modelSelectionConfig"]);
	if (fromModelSelectionConfig != null) setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
	const fromResponseJsonSchema = getValueByPath(fromObject, ["responseJsonSchema"]);
	if (fromResponseJsonSchema != null) setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
	const fromAudioTimestamp = getValueByPath(fromObject, ["audioTimestamp"]);
	if (fromAudioTimestamp != null) setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
	const fromCandidateCount = getValueByPath(fromObject, ["candidateCount"]);
	if (fromCandidateCount != null) setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
	const fromEnableAffectiveDialog = getValueByPath(fromObject, ["enableAffectiveDialog"]);
	if (fromEnableAffectiveDialog != null) setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
	const fromFrequencyPenalty = getValueByPath(fromObject, ["frequencyPenalty"]);
	if (fromFrequencyPenalty != null) setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
	const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
	if (fromLogprobs != null) setValueByPath(toObject, ["logprobs"], fromLogprobs);
	const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
	if (fromMaxOutputTokens != null) setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromPresencePenalty = getValueByPath(fromObject, ["presencePenalty"]);
	if (fromPresencePenalty != null) setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
	const fromResponseLogprobs = getValueByPath(fromObject, ["responseLogprobs"]);
	if (fromResponseLogprobs != null) setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
	const fromResponseMimeType = getValueByPath(fromObject, ["responseMimeType"]);
	if (fromResponseMimeType != null) setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
	const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
	if (fromResponseModalities != null) setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
	const fromResponseSchema = getValueByPath(fromObject, ["responseSchema"]);
	if (fromResponseSchema != null) setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
	const fromRoutingConfig = getValueByPath(fromObject, ["routingConfig"]);
	if (fromRoutingConfig != null) setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (fromSeed != null) setValueByPath(toObject, ["seed"], fromSeed);
	const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
	if (fromSpeechConfig != null) setValueByPath(toObject, ["speechConfig"], speechConfigToVertex$1(fromSpeechConfig));
	const fromStopSequences = getValueByPath(fromObject, ["stopSequences"]);
	if (fromStopSequences != null) setValueByPath(toObject, ["stopSequences"], fromStopSequences);
	const fromTemperature = getValueByPath(fromObject, ["temperature"]);
	if (fromTemperature != null) setValueByPath(toObject, ["temperature"], fromTemperature);
	const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
	if (fromThinkingConfig != null) setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
	const fromTopK = getValueByPath(fromObject, ["topK"]);
	if (fromTopK != null) setValueByPath(toObject, ["topK"], fromTopK);
	const fromTopP = getValueByPath(fromObject, ["topP"]);
	if (fromTopP != null) setValueByPath(toObject, ["topP"], fromTopP);
	if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
	return toObject;
}
function googleMapsToMldev$2(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
	const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
	if (fromEnableWidget != null) setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
	return toObject;
}
function googleSearchToMldev$2(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API.");
	const fromTimeRangeFilter = getValueByPath(fromObject, ["timeRangeFilter"]);
	if (fromTimeRangeFilter != null) setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
	return toObject;
}
function liveConnectConfigToMldev$1(fromObject, parentObject) {
	const toObject = {};
	const fromGenerationConfig = getValueByPath(fromObject, ["generationConfig"]);
	if (parentObject !== void 0 && fromGenerationConfig != null) setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
	const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
	if (parentObject !== void 0 && fromResponseModalities != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"responseModalities"
	], fromResponseModalities);
	const fromTemperature = getValueByPath(fromObject, ["temperature"]);
	if (parentObject !== void 0 && fromTemperature != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"temperature"
	], fromTemperature);
	const fromTopP = getValueByPath(fromObject, ["topP"]);
	if (parentObject !== void 0 && fromTopP != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"topP"
	], fromTopP);
	const fromTopK = getValueByPath(fromObject, ["topK"]);
	if (parentObject !== void 0 && fromTopK != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"topK"
	], fromTopK);
	const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
	if (parentObject !== void 0 && fromMaxOutputTokens != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"maxOutputTokens"
	], fromMaxOutputTokens);
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (parentObject !== void 0 && fromMediaResolution != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"mediaResolution"
	], fromMediaResolution);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"seed"
	], fromSeed);
	const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
	if (parentObject !== void 0 && fromSpeechConfig != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"speechConfig"
	], tLiveSpeechConfig(fromSpeechConfig));
	const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
	if (parentObject !== void 0 && fromThinkingConfig != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"thinkingConfig"
	], fromThinkingConfig);
	const fromEnableAffectiveDialog = getValueByPath(fromObject, ["enableAffectiveDialog"]);
	if (parentObject !== void 0 && fromEnableAffectiveDialog != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"enableAffectiveDialog"
	], fromEnableAffectiveDialog);
	const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
	if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
	const fromTools = getValueByPath(fromObject, ["tools"]);
	if (parentObject !== void 0 && fromTools != null) {
		let transformedList = tTools(fromTools);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return toolToMldev$2(tTool(item));
		});
		setValueByPath(parentObject, ["setup", "tools"], transformedList);
	}
	const fromSessionResumption = getValueByPath(fromObject, ["sessionResumption"]);
	if (parentObject !== void 0 && fromSessionResumption != null) setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
	const fromInputAudioTranscription = getValueByPath(fromObject, ["inputAudioTranscription"]);
	if (parentObject !== void 0 && fromInputAudioTranscription != null) setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
	const fromOutputAudioTranscription = getValueByPath(fromObject, ["outputAudioTranscription"]);
	if (parentObject !== void 0 && fromOutputAudioTranscription != null) setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
	const fromRealtimeInputConfig = getValueByPath(fromObject, ["realtimeInputConfig"]);
	if (parentObject !== void 0 && fromRealtimeInputConfig != null) setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
	const fromContextWindowCompression = getValueByPath(fromObject, ["contextWindowCompression"]);
	if (parentObject !== void 0 && fromContextWindowCompression != null) setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
	const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
	if (parentObject !== void 0 && fromProactivity != null) setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
	return toObject;
}
function liveConnectConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromGenerationConfig = getValueByPath(fromObject, ["generationConfig"]);
	if (parentObject !== void 0 && fromGenerationConfig != null) setValueByPath(parentObject, ["setup", "generationConfig"], generationConfigToVertex$1(fromGenerationConfig));
	const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
	if (parentObject !== void 0 && fromResponseModalities != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"responseModalities"
	], fromResponseModalities);
	const fromTemperature = getValueByPath(fromObject, ["temperature"]);
	if (parentObject !== void 0 && fromTemperature != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"temperature"
	], fromTemperature);
	const fromTopP = getValueByPath(fromObject, ["topP"]);
	if (parentObject !== void 0 && fromTopP != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"topP"
	], fromTopP);
	const fromTopK = getValueByPath(fromObject, ["topK"]);
	if (parentObject !== void 0 && fromTopK != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"topK"
	], fromTopK);
	const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
	if (parentObject !== void 0 && fromMaxOutputTokens != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"maxOutputTokens"
	], fromMaxOutputTokens);
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (parentObject !== void 0 && fromMediaResolution != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"mediaResolution"
	], fromMediaResolution);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"seed"
	], fromSeed);
	const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
	if (parentObject !== void 0 && fromSpeechConfig != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"speechConfig"
	], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));
	const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
	if (parentObject !== void 0 && fromThinkingConfig != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"thinkingConfig"
	], fromThinkingConfig);
	const fromEnableAffectiveDialog = getValueByPath(fromObject, ["enableAffectiveDialog"]);
	if (parentObject !== void 0 && fromEnableAffectiveDialog != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"enableAffectiveDialog"
	], fromEnableAffectiveDialog);
	const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
	if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["setup", "systemInstruction"], tContent(fromSystemInstruction));
	const fromTools = getValueByPath(fromObject, ["tools"]);
	if (parentObject !== void 0 && fromTools != null) {
		let transformedList = tTools(fromTools);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return toolToVertex$1(tTool(item));
		});
		setValueByPath(parentObject, ["setup", "tools"], transformedList);
	}
	const fromSessionResumption = getValueByPath(fromObject, ["sessionResumption"]);
	if (parentObject !== void 0 && fromSessionResumption != null) setValueByPath(parentObject, ["setup", "sessionResumption"], fromSessionResumption);
	const fromInputAudioTranscription = getValueByPath(fromObject, ["inputAudioTranscription"]);
	if (parentObject !== void 0 && fromInputAudioTranscription != null) setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
	const fromOutputAudioTranscription = getValueByPath(fromObject, ["outputAudioTranscription"]);
	if (parentObject !== void 0 && fromOutputAudioTranscription != null) setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
	const fromRealtimeInputConfig = getValueByPath(fromObject, ["realtimeInputConfig"]);
	if (parentObject !== void 0 && fromRealtimeInputConfig != null) setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
	const fromContextWindowCompression = getValueByPath(fromObject, ["contextWindowCompression"]);
	if (parentObject !== void 0 && fromContextWindowCompression != null) setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
	const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
	if (parentObject !== void 0 && fromProactivity != null) setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
	return toObject;
}
function liveConnectParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
	return toObject;
}
function liveConnectParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
	return toObject;
}
function liveMusicSetConfigParametersToMldev(fromObject) {
	const toObject = {};
	const fromMusicGenerationConfig = getValueByPath(fromObject, ["musicGenerationConfig"]);
	if (fromMusicGenerationConfig != null) setValueByPath(toObject, ["musicGenerationConfig"], fromMusicGenerationConfig);
	return toObject;
}
function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
	const toObject = {};
	const fromWeightedPrompts = getValueByPath(fromObject, ["weightedPrompts"]);
	if (fromWeightedPrompts != null) {
		let transformedList = fromWeightedPrompts;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["weightedPrompts"], transformedList);
	}
	return toObject;
}
function liveSendRealtimeInputParametersToMldev(fromObject) {
	const toObject = {};
	const fromMedia = getValueByPath(fromObject, ["media"]);
	if (fromMedia != null) {
		let transformedList = tBlobs(fromMedia);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return blobToMldev$2(item);
		});
		setValueByPath(toObject, ["mediaChunks"], transformedList);
	}
	const fromAudio = getValueByPath(fromObject, ["audio"]);
	if (fromAudio != null) setValueByPath(toObject, ["audio"], blobToMldev$2(tAudioBlob(fromAudio)));
	const fromAudioStreamEnd = getValueByPath(fromObject, ["audioStreamEnd"]);
	if (fromAudioStreamEnd != null) setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
	const fromVideo = getValueByPath(fromObject, ["video"]);
	if (fromVideo != null) setValueByPath(toObject, ["video"], blobToMldev$2(tImageBlob(fromVideo)));
	const fromText = getValueByPath(fromObject, ["text"]);
	if (fromText != null) setValueByPath(toObject, ["text"], fromText);
	const fromActivityStart = getValueByPath(fromObject, ["activityStart"]);
	if (fromActivityStart != null) setValueByPath(toObject, ["activityStart"], fromActivityStart);
	const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
	if (fromActivityEnd != null) setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
	return toObject;
}
function liveSendRealtimeInputParametersToVertex(fromObject) {
	const toObject = {};
	const fromMedia = getValueByPath(fromObject, ["media"]);
	if (fromMedia != null) {
		let transformedList = tBlobs(fromMedia);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["mediaChunks"], transformedList);
	}
	const fromAudio = getValueByPath(fromObject, ["audio"]);
	if (fromAudio != null) setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
	const fromAudioStreamEnd = getValueByPath(fromObject, ["audioStreamEnd"]);
	if (fromAudioStreamEnd != null) setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
	const fromVideo = getValueByPath(fromObject, ["video"]);
	if (fromVideo != null) setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
	const fromText = getValueByPath(fromObject, ["text"]);
	if (fromText != null) setValueByPath(toObject, ["text"], fromText);
	const fromActivityStart = getValueByPath(fromObject, ["activityStart"]);
	if (fromActivityStart != null) setValueByPath(toObject, ["activityStart"], fromActivityStart);
	const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
	if (fromActivityEnd != null) setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
	return toObject;
}
function liveServerMessageFromVertex(fromObject) {
	const toObject = {};
	const fromSetupComplete = getValueByPath(fromObject, ["setupComplete"]);
	if (fromSetupComplete != null) setValueByPath(toObject, ["setupComplete"], fromSetupComplete);
	const fromServerContent = getValueByPath(fromObject, ["serverContent"]);
	if (fromServerContent != null) setValueByPath(toObject, ["serverContent"], fromServerContent);
	const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
	if (fromToolCall != null) setValueByPath(toObject, ["toolCall"], fromToolCall);
	const fromToolCallCancellation = getValueByPath(fromObject, ["toolCallCancellation"]);
	if (fromToolCallCancellation != null) setValueByPath(toObject, ["toolCallCancellation"], fromToolCallCancellation);
	const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
	if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
	const fromGoAway = getValueByPath(fromObject, ["goAway"]);
	if (fromGoAway != null) setValueByPath(toObject, ["goAway"], fromGoAway);
	const fromSessionResumptionUpdate = getValueByPath(fromObject, ["sessionResumptionUpdate"]);
	if (fromSessionResumptionUpdate != null) setValueByPath(toObject, ["sessionResumptionUpdate"], fromSessionResumptionUpdate);
	return toObject;
}
function partToMldev$2(fromObject) {
	const toObject = {};
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
	if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
	const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
	if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
	const fromFileData = getValueByPath(fromObject, ["fileData"]);
	if (fromFileData != null) setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
	const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
	if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], functionCallToMldev$2(fromFunctionCall));
	const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
	if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
	const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
	if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
	const fromText = getValueByPath(fromObject, ["text"]);
	if (fromText != null) setValueByPath(toObject, ["text"], fromText);
	const fromThought = getValueByPath(fromObject, ["thought"]);
	if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
	const fromThoughtSignature = getValueByPath(fromObject, ["thoughtSignature"]);
	if (fromThoughtSignature != null) setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
	const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
	if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
	return toObject;
}
function sessionResumptionConfigToMldev$1(fromObject) {
	const toObject = {};
	const fromHandle = getValueByPath(fromObject, ["handle"]);
	if (fromHandle != null) setValueByPath(toObject, ["handle"], fromHandle);
	if (getValueByPath(fromObject, ["transparent"]) !== void 0) throw new Error("transparent parameter is not supported in Gemini API.");
	return toObject;
}
function speechConfigToVertex$1(fromObject) {
	const toObject = {};
	const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
	if (fromLanguageCode != null) setValueByPath(toObject, ["languageCode"], fromLanguageCode);
	const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
	if (fromVoiceConfig != null) setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
	if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
	return toObject;
}
function toolToMldev$2(fromObject) {
	const toObject = {};
	const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
	if (fromFunctionDeclarations != null) {
		let transformedList = fromFunctionDeclarations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["functionDeclarations"], transformedList);
	}
	if (getValueByPath(fromObject, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
	const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
	if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
	const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
	if (fromComputerUse != null) setValueByPath(toObject, ["computerUse"], fromComputerUse);
	const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
	if (fromFileSearch != null) setValueByPath(toObject, ["fileSearch"], fromFileSearch);
	const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
	if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
	if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
	const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
	if (fromGoogleMaps != null) setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$2(fromGoogleMaps));
	const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
	if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
	const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
	if (fromUrlContext != null) setValueByPath(toObject, ["urlContext"], fromUrlContext);
	return toObject;
}
function toolToVertex$1(fromObject) {
	const toObject = {};
	const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
	if (fromFunctionDeclarations != null) {
		let transformedList = fromFunctionDeclarations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return functionDeclarationToVertex$1(item);
		});
		setValueByPath(toObject, ["functionDeclarations"], transformedList);
	}
	const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
	if (fromRetrieval != null) setValueByPath(toObject, ["retrieval"], fromRetrieval);
	const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
	if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
	const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
	if (fromComputerUse != null) setValueByPath(toObject, ["computerUse"], fromComputerUse);
	if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) throw new Error("fileSearch parameter is not supported in Vertex AI.");
	const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
	if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
	const fromEnterpriseWebSearch = getValueByPath(fromObject, ["enterpriseWebSearch"]);
	if (fromEnterpriseWebSearch != null) setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
	const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
	if (fromGoogleMaps != null) setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
	const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
	if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
	const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
	if (fromUrlContext != null) setValueByPath(toObject, ["urlContext"], fromUrlContext);
	return toObject;
}
function usageMetadataFromVertex(fromObject) {
	const toObject = {};
	const fromPromptTokenCount = getValueByPath(fromObject, ["promptTokenCount"]);
	if (fromPromptTokenCount != null) setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
	const fromCachedContentTokenCount = getValueByPath(fromObject, ["cachedContentTokenCount"]);
	if (fromCachedContentTokenCount != null) setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
	const fromResponseTokenCount = getValueByPath(fromObject, ["candidatesTokenCount"]);
	if (fromResponseTokenCount != null) setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
	const fromToolUsePromptTokenCount = getValueByPath(fromObject, ["toolUsePromptTokenCount"]);
	if (fromToolUsePromptTokenCount != null) setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
	const fromThoughtsTokenCount = getValueByPath(fromObject, ["thoughtsTokenCount"]);
	if (fromThoughtsTokenCount != null) setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
	const fromTotalTokenCount = getValueByPath(fromObject, ["totalTokenCount"]);
	if (fromTotalTokenCount != null) setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
	const fromPromptTokensDetails = getValueByPath(fromObject, ["promptTokensDetails"]);
	if (fromPromptTokensDetails != null) {
		let transformedList = fromPromptTokensDetails;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["promptTokensDetails"], transformedList);
	}
	const fromCacheTokensDetails = getValueByPath(fromObject, ["cacheTokensDetails"]);
	if (fromCacheTokensDetails != null) {
		let transformedList = fromCacheTokensDetails;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
	}
	const fromResponseTokensDetails = getValueByPath(fromObject, ["candidatesTokensDetails"]);
	if (fromResponseTokensDetails != null) {
		let transformedList = fromResponseTokensDetails;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["responseTokensDetails"], transformedList);
	}
	const fromToolUsePromptTokensDetails = getValueByPath(fromObject, ["toolUsePromptTokensDetails"]);
	if (fromToolUsePromptTokensDetails != null) {
		let transformedList = fromToolUsePromptTokensDetails;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
	}
	const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
	if (fromTrafficType != null) setValueByPath(toObject, ["trafficType"], fromTrafficType);
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function blobToMldev$1(fromObject) {
	const toObject = {};
	const fromData = getValueByPath(fromObject, ["data"]);
	if (fromData != null) setValueByPath(toObject, ["data"], fromData);
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function candidateFromMldev(fromObject) {
	const toObject = {};
	const fromContent = getValueByPath(fromObject, ["content"]);
	if (fromContent != null) setValueByPath(toObject, ["content"], fromContent);
	const fromCitationMetadata = getValueByPath(fromObject, ["citationMetadata"]);
	if (fromCitationMetadata != null) setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
	const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
	if (fromTokenCount != null) setValueByPath(toObject, ["tokenCount"], fromTokenCount);
	const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
	if (fromFinishReason != null) setValueByPath(toObject, ["finishReason"], fromFinishReason);
	const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
	if (fromAvgLogprobs != null) setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
	const fromGroundingMetadata = getValueByPath(fromObject, ["groundingMetadata"]);
	if (fromGroundingMetadata != null) setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
	const fromIndex = getValueByPath(fromObject, ["index"]);
	if (fromIndex != null) setValueByPath(toObject, ["index"], fromIndex);
	const fromLogprobsResult = getValueByPath(fromObject, ["logprobsResult"]);
	if (fromLogprobsResult != null) setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
	const fromSafetyRatings = getValueByPath(fromObject, ["safetyRatings"]);
	if (fromSafetyRatings != null) {
		let transformedList = fromSafetyRatings;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["safetyRatings"], transformedList);
	}
	const fromUrlContextMetadata = getValueByPath(fromObject, ["urlContextMetadata"]);
	if (fromUrlContextMetadata != null) setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
	return toObject;
}
function citationMetadataFromMldev(fromObject) {
	const toObject = {};
	const fromCitations = getValueByPath(fromObject, ["citationSources"]);
	if (fromCitations != null) {
		let transformedList = fromCitations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["citations"], transformedList);
	}
	return toObject;
}
function computeTokensParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (fromContents != null) {
		let transformedList = tContents(fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["contents"], transformedList);
	}
	return toObject;
}
function computeTokensResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
	if (fromTokensInfo != null) {
		let transformedList = fromTokensInfo;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["tokensInfo"], transformedList);
	}
	return toObject;
}
function contentEmbeddingFromVertex(fromObject) {
	const toObject = {};
	const fromValues = getValueByPath(fromObject, ["values"]);
	if (fromValues != null) setValueByPath(toObject, ["values"], fromValues);
	const fromStatistics = getValueByPath(fromObject, ["statistics"]);
	if (fromStatistics != null) setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
	return toObject;
}
function contentEmbeddingStatisticsFromVertex(fromObject) {
	const toObject = {};
	const fromTruncated = getValueByPath(fromObject, ["truncated"]);
	if (fromTruncated != null) setValueByPath(toObject, ["truncated"], fromTruncated);
	const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
	if (fromTokenCount != null) setValueByPath(toObject, ["tokenCount"], fromTokenCount);
	return toObject;
}
function contentToMldev$1(fromObject) {
	const toObject = {};
	const fromParts = getValueByPath(fromObject, ["parts"]);
	if (fromParts != null) {
		let transformedList = fromParts;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return partToMldev$1(item);
		});
		setValueByPath(toObject, ["parts"], transformedList);
	}
	const fromRole = getValueByPath(fromObject, ["role"]);
	if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
	return toObject;
}
function controlReferenceConfigToVertex(fromObject) {
	const toObject = {};
	const fromControlType = getValueByPath(fromObject, ["controlType"]);
	if (fromControlType != null) setValueByPath(toObject, ["controlType"], fromControlType);
	const fromEnableControlImageComputation = getValueByPath(fromObject, ["enableControlImageComputation"]);
	if (fromEnableControlImageComputation != null) setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
	return toObject;
}
function countTokensConfigToMldev(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) throw new Error("systemInstruction parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["tools"]) !== void 0) throw new Error("tools parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) throw new Error("generationConfig parameter is not supported in Gemini API.");
	return toObject;
}
function countTokensConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
	if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
	const fromTools = getValueByPath(fromObject, ["tools"]);
	if (parentObject !== void 0 && fromTools != null) {
		let transformedList = fromTools;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return toolToVertex(item);
		});
		setValueByPath(parentObject, ["tools"], transformedList);
	}
	const fromGenerationConfig = getValueByPath(fromObject, ["generationConfig"]);
	if (parentObject !== void 0 && fromGenerationConfig != null) setValueByPath(parentObject, ["generationConfig"], generationConfigToVertex(fromGenerationConfig));
	return toObject;
}
function countTokensParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (fromContents != null) {
		let transformedList = tContents(fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return contentToMldev$1(item);
		});
		setValueByPath(toObject, ["contents"], transformedList);
	}
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) countTokensConfigToMldev(fromConfig);
	return toObject;
}
function countTokensParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (fromContents != null) {
		let transformedList = tContents(fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["contents"], transformedList);
	}
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) countTokensConfigToVertex(fromConfig, toObject);
	return toObject;
}
function countTokensResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
	if (fromTotalTokens != null) setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
	const fromCachedContentTokenCount = getValueByPath(fromObject, ["cachedContentTokenCount"]);
	if (fromCachedContentTokenCount != null) setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
	return toObject;
}
function countTokensResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
	if (fromTotalTokens != null) setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
	return toObject;
}
function deleteModelParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
	return toObject;
}
function deleteModelParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
	return toObject;
}
function deleteModelResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	return toObject;
}
function deleteModelResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	return toObject;
}
function editImageConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
	if (parentObject !== void 0 && fromOutputGcsUri != null) setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
	const fromNegativePrompt = getValueByPath(fromObject, ["negativePrompt"]);
	if (parentObject !== void 0 && fromNegativePrompt != null) setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
	const fromNumberOfImages = getValueByPath(fromObject, ["numberOfImages"]);
	if (parentObject !== void 0 && fromNumberOfImages != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
	const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
	if (parentObject !== void 0 && fromAspectRatio != null) setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
	const fromGuidanceScale = getValueByPath(fromObject, ["guidanceScale"]);
	if (parentObject !== void 0 && fromGuidanceScale != null) setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
	const fromSafetyFilterLevel = getValueByPath(fromObject, ["safetyFilterLevel"]);
	if (parentObject !== void 0 && fromSafetyFilterLevel != null) setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
	const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
	if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
	const fromIncludeSafetyAttributes = getValueByPath(fromObject, ["includeSafetyAttributes"]);
	if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
	const fromIncludeRaiReason = getValueByPath(fromObject, ["includeRaiReason"]);
	if (parentObject !== void 0 && fromIncludeRaiReason != null) setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
	const fromLanguage = getValueByPath(fromObject, ["language"]);
	if (parentObject !== void 0 && fromLanguage != null) setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
	const fromOutputMimeType = getValueByPath(fromObject, ["outputMimeType"]);
	if (parentObject !== void 0 && fromOutputMimeType != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"mimeType"
	], fromOutputMimeType);
	const fromOutputCompressionQuality = getValueByPath(fromObject, ["outputCompressionQuality"]);
	if (parentObject !== void 0 && fromOutputCompressionQuality != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"compressionQuality"
	], fromOutputCompressionQuality);
	const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
	if (parentObject !== void 0 && fromAddWatermark != null) setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (parentObject !== void 0 && fromLabels != null) setValueByPath(parentObject, ["labels"], fromLabels);
	const fromEditMode = getValueByPath(fromObject, ["editMode"]);
	if (parentObject !== void 0 && fromEditMode != null) setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
	const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
	if (parentObject !== void 0 && fromBaseSteps != null) setValueByPath(parentObject, [
		"parameters",
		"editConfig",
		"baseSteps"
	], fromBaseSteps);
	return toObject;
}
function editImageParametersInternalToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromPrompt = getValueByPath(fromObject, ["prompt"]);
	if (fromPrompt != null) setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
	const fromReferenceImages = getValueByPath(fromObject, ["referenceImages"]);
	if (fromReferenceImages != null) {
		let transformedList = fromReferenceImages;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return referenceImageAPIInternalToVertex(item);
		});
		setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
	}
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) editImageConfigToVertex(fromConfig, toObject);
	return toObject;
}
function editImageResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromGeneratedImages = getValueByPath(fromObject, ["predictions"]);
	if (fromGeneratedImages != null) {
		let transformedList = fromGeneratedImages;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedImageFromVertex(item);
		});
		setValueByPath(toObject, ["generatedImages"], transformedList);
	}
	return toObject;
}
function embedContentConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromTaskType = getValueByPath(fromObject, ["taskType"]);
	if (parentObject !== void 0 && fromTaskType != null) setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
	const fromTitle = getValueByPath(fromObject, ["title"]);
	if (parentObject !== void 0 && fromTitle != null) setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
	const fromOutputDimensionality = getValueByPath(fromObject, ["outputDimensionality"]);
	if (parentObject !== void 0 && fromOutputDimensionality != null) setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
	if (getValueByPath(fromObject, ["mimeType"]) !== void 0) throw new Error("mimeType parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API.");
	return toObject;
}
function embedContentConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromTaskType = getValueByPath(fromObject, ["taskType"]);
	if (parentObject !== void 0 && fromTaskType != null) setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
	const fromTitle = getValueByPath(fromObject, ["title"]);
	if (parentObject !== void 0 && fromTitle != null) setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
	const fromOutputDimensionality = getValueByPath(fromObject, ["outputDimensionality"]);
	if (parentObject !== void 0 && fromOutputDimensionality != null) setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (parentObject !== void 0 && fromMimeType != null) setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
	const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
	if (parentObject !== void 0 && fromAutoTruncate != null) setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
	return toObject;
}
function embedContentParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (fromContents != null) {
		let transformedList = tContentsForEmbed(apiClient, fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["requests[]", "content"], transformedList);
	}
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) embedContentConfigToMldev(fromConfig, toObject);
	const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
	if (fromModelForEmbedContent !== void 0) setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
	return toObject;
}
function embedContentParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (fromContents != null) {
		let transformedList = tContentsForEmbed(apiClient, fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["instances[]", "content"], transformedList);
	}
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) embedContentConfigToVertex(fromConfig, toObject);
	return toObject;
}
function embedContentResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
	if (fromEmbeddings != null) {
		let transformedList = fromEmbeddings;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["embeddings"], transformedList);
	}
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	return toObject;
}
function embedContentResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromEmbeddings = getValueByPath(fromObject, ["predictions[]", "embeddings"]);
	if (fromEmbeddings != null) {
		let transformedList = fromEmbeddings;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return contentEmbeddingFromVertex(item);
		});
		setValueByPath(toObject, ["embeddings"], transformedList);
	}
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	return toObject;
}
function endpointFromVertex(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["endpoint"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromDeployedModelId = getValueByPath(fromObject, ["deployedModelId"]);
	if (fromDeployedModelId != null) setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
	return toObject;
}
function fileDataToMldev$1(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
	if (fromFileUri != null) setValueByPath(toObject, ["fileUri"], fromFileUri);
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function functionCallToMldev$1(fromObject) {
	const toObject = {};
	const fromId = getValueByPath(fromObject, ["id"]);
	if (fromId != null) setValueByPath(toObject, ["id"], fromId);
	const fromArgs = getValueByPath(fromObject, ["args"]);
	if (fromArgs != null) setValueByPath(toObject, ["args"], fromArgs);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
	return toObject;
}
function functionCallingConfigToMldev(fromObject) {
	const toObject = {};
	const fromMode = getValueByPath(fromObject, ["mode"]);
	if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
	const fromAllowedFunctionNames = getValueByPath(fromObject, ["allowedFunctionNames"]);
	if (fromAllowedFunctionNames != null) setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
	if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
	return toObject;
}
function functionDeclarationToVertex(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI.");
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromParameters = getValueByPath(fromObject, ["parameters"]);
	if (fromParameters != null) setValueByPath(toObject, ["parameters"], fromParameters);
	const fromParametersJsonSchema = getValueByPath(fromObject, ["parametersJsonSchema"]);
	if (fromParametersJsonSchema != null) setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
	const fromResponse = getValueByPath(fromObject, ["response"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], fromResponse);
	const fromResponseJsonSchema = getValueByPath(fromObject, ["responseJsonSchema"]);
	if (fromResponseJsonSchema != null) setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
	return toObject;
}
function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
	const toObject = {};
	const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
	if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
	const fromTemperature = getValueByPath(fromObject, ["temperature"]);
	if (fromTemperature != null) setValueByPath(toObject, ["temperature"], fromTemperature);
	const fromTopP = getValueByPath(fromObject, ["topP"]);
	if (fromTopP != null) setValueByPath(toObject, ["topP"], fromTopP);
	const fromTopK = getValueByPath(fromObject, ["topK"]);
	if (fromTopK != null) setValueByPath(toObject, ["topK"], fromTopK);
	const fromCandidateCount = getValueByPath(fromObject, ["candidateCount"]);
	if (fromCandidateCount != null) setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
	const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
	if (fromMaxOutputTokens != null) setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
	const fromStopSequences = getValueByPath(fromObject, ["stopSequences"]);
	if (fromStopSequences != null) setValueByPath(toObject, ["stopSequences"], fromStopSequences);
	const fromResponseLogprobs = getValueByPath(fromObject, ["responseLogprobs"]);
	if (fromResponseLogprobs != null) setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
	const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
	if (fromLogprobs != null) setValueByPath(toObject, ["logprobs"], fromLogprobs);
	const fromPresencePenalty = getValueByPath(fromObject, ["presencePenalty"]);
	if (fromPresencePenalty != null) setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
	const fromFrequencyPenalty = getValueByPath(fromObject, ["frequencyPenalty"]);
	if (fromFrequencyPenalty != null) setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (fromSeed != null) setValueByPath(toObject, ["seed"], fromSeed);
	const fromResponseMimeType = getValueByPath(fromObject, ["responseMimeType"]);
	if (fromResponseMimeType != null) setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
	const fromResponseSchema = getValueByPath(fromObject, ["responseSchema"]);
	if (fromResponseSchema != null) setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
	const fromResponseJsonSchema = getValueByPath(fromObject, ["responseJsonSchema"]);
	if (fromResponseJsonSchema != null) setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
	if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) throw new Error("routingConfig parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
	const fromSafetySettings = getValueByPath(fromObject, ["safetySettings"]);
	if (parentObject !== void 0 && fromSafetySettings != null) {
		let transformedList = fromSafetySettings;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return safetySettingToMldev(item);
		});
		setValueByPath(parentObject, ["safetySettings"], transformedList);
	}
	const fromTools = getValueByPath(fromObject, ["tools"]);
	if (parentObject !== void 0 && fromTools != null) {
		let transformedList = tTools(fromTools);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return toolToMldev$1(tTool(item));
		});
		setValueByPath(parentObject, ["tools"], transformedList);
	}
	const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
	if (parentObject !== void 0 && fromToolConfig != null) setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
	if (getValueByPath(fromObject, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API.");
	const fromCachedContent = getValueByPath(fromObject, ["cachedContent"]);
	if (parentObject !== void 0 && fromCachedContent != null) setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
	const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
	if (fromResponseModalities != null) setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
	if (fromSpeechConfig != null) setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
	if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) throw new Error("audioTimestamp parameter is not supported in Gemini API.");
	const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
	if (fromThinkingConfig != null) setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
	const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
	if (fromImageConfig != null) setValueByPath(toObject, ["imageConfig"], imageConfigToMldev(fromImageConfig));
	return toObject;
}
function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
	const toObject = {};
	const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
	if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
	const fromTemperature = getValueByPath(fromObject, ["temperature"]);
	if (fromTemperature != null) setValueByPath(toObject, ["temperature"], fromTemperature);
	const fromTopP = getValueByPath(fromObject, ["topP"]);
	if (fromTopP != null) setValueByPath(toObject, ["topP"], fromTopP);
	const fromTopK = getValueByPath(fromObject, ["topK"]);
	if (fromTopK != null) setValueByPath(toObject, ["topK"], fromTopK);
	const fromCandidateCount = getValueByPath(fromObject, ["candidateCount"]);
	if (fromCandidateCount != null) setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
	const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
	if (fromMaxOutputTokens != null) setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
	const fromStopSequences = getValueByPath(fromObject, ["stopSequences"]);
	if (fromStopSequences != null) setValueByPath(toObject, ["stopSequences"], fromStopSequences);
	const fromResponseLogprobs = getValueByPath(fromObject, ["responseLogprobs"]);
	if (fromResponseLogprobs != null) setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
	const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
	if (fromLogprobs != null) setValueByPath(toObject, ["logprobs"], fromLogprobs);
	const fromPresencePenalty = getValueByPath(fromObject, ["presencePenalty"]);
	if (fromPresencePenalty != null) setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
	const fromFrequencyPenalty = getValueByPath(fromObject, ["frequencyPenalty"]);
	if (fromFrequencyPenalty != null) setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (fromSeed != null) setValueByPath(toObject, ["seed"], fromSeed);
	const fromResponseMimeType = getValueByPath(fromObject, ["responseMimeType"]);
	if (fromResponseMimeType != null) setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
	const fromResponseSchema = getValueByPath(fromObject, ["responseSchema"]);
	if (fromResponseSchema != null) setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
	const fromResponseJsonSchema = getValueByPath(fromObject, ["responseJsonSchema"]);
	if (fromResponseJsonSchema != null) setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
	const fromRoutingConfig = getValueByPath(fromObject, ["routingConfig"]);
	if (fromRoutingConfig != null) setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
	const fromModelSelectionConfig = getValueByPath(fromObject, ["modelSelectionConfig"]);
	if (fromModelSelectionConfig != null) setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
	const fromSafetySettings = getValueByPath(fromObject, ["safetySettings"]);
	if (parentObject !== void 0 && fromSafetySettings != null) {
		let transformedList = fromSafetySettings;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(parentObject, ["safetySettings"], transformedList);
	}
	const fromTools = getValueByPath(fromObject, ["tools"]);
	if (parentObject !== void 0 && fromTools != null) {
		let transformedList = tTools(fromTools);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return toolToVertex(tTool(item));
		});
		setValueByPath(parentObject, ["tools"], transformedList);
	}
	const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
	if (parentObject !== void 0 && fromToolConfig != null) setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (parentObject !== void 0 && fromLabels != null) setValueByPath(parentObject, ["labels"], fromLabels);
	const fromCachedContent = getValueByPath(fromObject, ["cachedContent"]);
	if (parentObject !== void 0 && fromCachedContent != null) setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
	const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
	if (fromResponseModalities != null) setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
	if (fromSpeechConfig != null) setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));
	const fromAudioTimestamp = getValueByPath(fromObject, ["audioTimestamp"]);
	if (fromAudioTimestamp != null) setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
	const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
	if (fromThinkingConfig != null) setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
	const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
	if (fromImageConfig != null) setValueByPath(toObject, ["imageConfig"], imageConfigToVertex(fromImageConfig));
	return toObject;
}
function generateContentParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (fromContents != null) {
		let transformedList = tContents(fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return contentToMldev$1(item);
		});
		setValueByPath(toObject, ["contents"], transformedList);
	}
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
	return toObject;
}
function generateContentParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromContents = getValueByPath(fromObject, ["contents"]);
	if (fromContents != null) {
		let transformedList = tContents(fromContents);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["contents"], transformedList);
	}
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
	return toObject;
}
function generateContentResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromCandidates = getValueByPath(fromObject, ["candidates"]);
	if (fromCandidates != null) {
		let transformedList = fromCandidates;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return candidateFromMldev(item);
		});
		setValueByPath(toObject, ["candidates"], transformedList);
	}
	const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
	if (fromModelVersion != null) setValueByPath(toObject, ["modelVersion"], fromModelVersion);
	const fromPromptFeedback = getValueByPath(fromObject, ["promptFeedback"]);
	if (fromPromptFeedback != null) setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
	const fromResponseId = getValueByPath(fromObject, ["responseId"]);
	if (fromResponseId != null) setValueByPath(toObject, ["responseId"], fromResponseId);
	const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
	if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
	return toObject;
}
function generateContentResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromCandidates = getValueByPath(fromObject, ["candidates"]);
	if (fromCandidates != null) {
		let transformedList = fromCandidates;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["candidates"], transformedList);
	}
	const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
	if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
	const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
	if (fromModelVersion != null) setValueByPath(toObject, ["modelVersion"], fromModelVersion);
	const fromPromptFeedback = getValueByPath(fromObject, ["promptFeedback"]);
	if (fromPromptFeedback != null) setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
	const fromResponseId = getValueByPath(fromObject, ["responseId"]);
	if (fromResponseId != null) setValueByPath(toObject, ["responseId"], fromResponseId);
	const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
	if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
	return toObject;
}
function generateImagesConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) throw new Error("negativePrompt parameter is not supported in Gemini API.");
	const fromNumberOfImages = getValueByPath(fromObject, ["numberOfImages"]);
	if (parentObject !== void 0 && fromNumberOfImages != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
	const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
	if (parentObject !== void 0 && fromAspectRatio != null) setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
	const fromGuidanceScale = getValueByPath(fromObject, ["guidanceScale"]);
	if (parentObject !== void 0 && fromGuidanceScale != null) setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
	if (getValueByPath(fromObject, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API.");
	const fromSafetyFilterLevel = getValueByPath(fromObject, ["safetyFilterLevel"]);
	if (parentObject !== void 0 && fromSafetyFilterLevel != null) setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
	const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
	if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
	const fromIncludeSafetyAttributes = getValueByPath(fromObject, ["includeSafetyAttributes"]);
	if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
	const fromIncludeRaiReason = getValueByPath(fromObject, ["includeRaiReason"]);
	if (parentObject !== void 0 && fromIncludeRaiReason != null) setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
	const fromLanguage = getValueByPath(fromObject, ["language"]);
	if (parentObject !== void 0 && fromLanguage != null) setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
	const fromOutputMimeType = getValueByPath(fromObject, ["outputMimeType"]);
	if (parentObject !== void 0 && fromOutputMimeType != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"mimeType"
	], fromOutputMimeType);
	const fromOutputCompressionQuality = getValueByPath(fromObject, ["outputCompressionQuality"]);
	if (parentObject !== void 0 && fromOutputCompressionQuality != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"compressionQuality"
	], fromOutputCompressionQuality);
	if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) throw new Error("addWatermark parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API.");
	const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
	if (parentObject !== void 0 && fromImageSize != null) setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
	if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) throw new Error("enhancePrompt parameter is not supported in Gemini API.");
	return toObject;
}
function generateImagesConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
	if (parentObject !== void 0 && fromOutputGcsUri != null) setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
	const fromNegativePrompt = getValueByPath(fromObject, ["negativePrompt"]);
	if (parentObject !== void 0 && fromNegativePrompt != null) setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
	const fromNumberOfImages = getValueByPath(fromObject, ["numberOfImages"]);
	if (parentObject !== void 0 && fromNumberOfImages != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
	const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
	if (parentObject !== void 0 && fromAspectRatio != null) setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
	const fromGuidanceScale = getValueByPath(fromObject, ["guidanceScale"]);
	if (parentObject !== void 0 && fromGuidanceScale != null) setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
	const fromSafetyFilterLevel = getValueByPath(fromObject, ["safetyFilterLevel"]);
	if (parentObject !== void 0 && fromSafetyFilterLevel != null) setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
	const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
	if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
	const fromIncludeSafetyAttributes = getValueByPath(fromObject, ["includeSafetyAttributes"]);
	if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
	const fromIncludeRaiReason = getValueByPath(fromObject, ["includeRaiReason"]);
	if (parentObject !== void 0 && fromIncludeRaiReason != null) setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
	const fromLanguage = getValueByPath(fromObject, ["language"]);
	if (parentObject !== void 0 && fromLanguage != null) setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
	const fromOutputMimeType = getValueByPath(fromObject, ["outputMimeType"]);
	if (parentObject !== void 0 && fromOutputMimeType != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"mimeType"
	], fromOutputMimeType);
	const fromOutputCompressionQuality = getValueByPath(fromObject, ["outputCompressionQuality"]);
	if (parentObject !== void 0 && fromOutputCompressionQuality != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"compressionQuality"
	], fromOutputCompressionQuality);
	const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
	if (parentObject !== void 0 && fromAddWatermark != null) setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (parentObject !== void 0 && fromLabels != null) setValueByPath(parentObject, ["labels"], fromLabels);
	const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
	if (parentObject !== void 0 && fromImageSize != null) setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
	const fromEnhancePrompt = getValueByPath(fromObject, ["enhancePrompt"]);
	if (parentObject !== void 0 && fromEnhancePrompt != null) setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
	return toObject;
}
function generateImagesParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromPrompt = getValueByPath(fromObject, ["prompt"]);
	if (fromPrompt != null) setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) generateImagesConfigToMldev(fromConfig, toObject);
	return toObject;
}
function generateImagesParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromPrompt = getValueByPath(fromObject, ["prompt"]);
	if (fromPrompt != null) setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) generateImagesConfigToVertex(fromConfig, toObject);
	return toObject;
}
function generateImagesResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromGeneratedImages = getValueByPath(fromObject, ["predictions"]);
	if (fromGeneratedImages != null) {
		let transformedList = fromGeneratedImages;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedImageFromMldev(item);
		});
		setValueByPath(toObject, ["generatedImages"], transformedList);
	}
	const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, ["positivePromptSafetyAttributes"]);
	if (fromPositivePromptSafetyAttributes != null) setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
	return toObject;
}
function generateImagesResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromGeneratedImages = getValueByPath(fromObject, ["predictions"]);
	if (fromGeneratedImages != null) {
		let transformedList = fromGeneratedImages;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedImageFromVertex(item);
		});
		setValueByPath(toObject, ["generatedImages"], transformedList);
	}
	const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, ["positivePromptSafetyAttributes"]);
	if (fromPositivePromptSafetyAttributes != null) setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
	return toObject;
}
function generateVideosConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromNumberOfVideos = getValueByPath(fromObject, ["numberOfVideos"]);
	if (parentObject !== void 0 && fromNumberOfVideos != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
	if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["fps"]) !== void 0) throw new Error("fps parameter is not supported in Gemini API.");
	const fromDurationSeconds = getValueByPath(fromObject, ["durationSeconds"]);
	if (parentObject !== void 0 && fromDurationSeconds != null) setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
	if (getValueByPath(fromObject, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API.");
	const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
	if (parentObject !== void 0 && fromAspectRatio != null) setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
	const fromResolution = getValueByPath(fromObject, ["resolution"]);
	if (parentObject !== void 0 && fromResolution != null) setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
	const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
	if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
	if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) throw new Error("pubsubTopic parameter is not supported in Gemini API.");
	const fromNegativePrompt = getValueByPath(fromObject, ["negativePrompt"]);
	if (parentObject !== void 0 && fromNegativePrompt != null) setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
	const fromEnhancePrompt = getValueByPath(fromObject, ["enhancePrompt"]);
	if (parentObject !== void 0 && fromEnhancePrompt != null) setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
	if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) throw new Error("generateAudio parameter is not supported in Gemini API.");
	const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
	if (parentObject !== void 0 && fromLastFrame != null) setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToMldev(fromLastFrame));
	const fromReferenceImages = getValueByPath(fromObject, ["referenceImages"]);
	if (parentObject !== void 0 && fromReferenceImages != null) {
		let transformedList = fromReferenceImages;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return videoGenerationReferenceImageToMldev(item);
		});
		setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
	}
	if (getValueByPath(fromObject, ["mask"]) !== void 0) throw new Error("mask parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["compressionQuality"]) !== void 0) throw new Error("compressionQuality parameter is not supported in Gemini API.");
	return toObject;
}
function generateVideosConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromNumberOfVideos = getValueByPath(fromObject, ["numberOfVideos"]);
	if (parentObject !== void 0 && fromNumberOfVideos != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
	const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
	if (parentObject !== void 0 && fromOutputGcsUri != null) setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
	const fromFps = getValueByPath(fromObject, ["fps"]);
	if (parentObject !== void 0 && fromFps != null) setValueByPath(parentObject, ["parameters", "fps"], fromFps);
	const fromDurationSeconds = getValueByPath(fromObject, ["durationSeconds"]);
	if (parentObject !== void 0 && fromDurationSeconds != null) setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
	const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
	if (parentObject !== void 0 && fromAspectRatio != null) setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
	const fromResolution = getValueByPath(fromObject, ["resolution"]);
	if (parentObject !== void 0 && fromResolution != null) setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
	const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
	if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
	const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
	if (parentObject !== void 0 && fromPubsubTopic != null) setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
	const fromNegativePrompt = getValueByPath(fromObject, ["negativePrompt"]);
	if (parentObject !== void 0 && fromNegativePrompt != null) setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
	const fromEnhancePrompt = getValueByPath(fromObject, ["enhancePrompt"]);
	if (parentObject !== void 0 && fromEnhancePrompt != null) setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
	const fromGenerateAudio = getValueByPath(fromObject, ["generateAudio"]);
	if (parentObject !== void 0 && fromGenerateAudio != null) setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
	const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
	if (parentObject !== void 0 && fromLastFrame != null) setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
	const fromReferenceImages = getValueByPath(fromObject, ["referenceImages"]);
	if (parentObject !== void 0 && fromReferenceImages != null) {
		let transformedList = fromReferenceImages;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return videoGenerationReferenceImageToVertex(item);
		});
		setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
	}
	const fromMask = getValueByPath(fromObject, ["mask"]);
	if (parentObject !== void 0 && fromMask != null) setValueByPath(parentObject, ["instances[0]", "mask"], videoGenerationMaskToVertex(fromMask));
	const fromCompressionQuality = getValueByPath(fromObject, ["compressionQuality"]);
	if (parentObject !== void 0 && fromCompressionQuality != null) setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
	return toObject;
}
function generateVideosOperationFromMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	const fromResponse = getValueByPath(fromObject, ["response", "generateVideoResponse"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
	return toObject;
}
function generateVideosOperationFromVertex(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	const fromResponse = getValueByPath(fromObject, ["response"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
	return toObject;
}
function generateVideosParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromPrompt = getValueByPath(fromObject, ["prompt"]);
	if (fromPrompt != null) setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (fromImage != null) setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
	const fromVideo = getValueByPath(fromObject, ["video"]);
	if (fromVideo != null) setValueByPath(toObject, ["instances[0]", "video"], videoToMldev(fromVideo));
	const fromSource = getValueByPath(fromObject, ["source"]);
	if (fromSource != null) generateVideosSourceToMldev(fromSource, toObject);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) generateVideosConfigToMldev(fromConfig, toObject);
	return toObject;
}
function generateVideosParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromPrompt = getValueByPath(fromObject, ["prompt"]);
	if (fromPrompt != null) setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (fromImage != null) setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
	const fromVideo = getValueByPath(fromObject, ["video"]);
	if (fromVideo != null) setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
	const fromSource = getValueByPath(fromObject, ["source"]);
	if (fromSource != null) generateVideosSourceToVertex(fromSource, toObject);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) generateVideosConfigToVertex(fromConfig, toObject);
	return toObject;
}
function generateVideosResponseFromMldev(fromObject) {
	const toObject = {};
	const fromGeneratedVideos = getValueByPath(fromObject, ["generatedSamples"]);
	if (fromGeneratedVideos != null) {
		let transformedList = fromGeneratedVideos;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedVideoFromMldev(item);
		});
		setValueByPath(toObject, ["generatedVideos"], transformedList);
	}
	const fromRaiMediaFilteredCount = getValueByPath(fromObject, ["raiMediaFilteredCount"]);
	if (fromRaiMediaFilteredCount != null) setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
	const fromRaiMediaFilteredReasons = getValueByPath(fromObject, ["raiMediaFilteredReasons"]);
	if (fromRaiMediaFilteredReasons != null) setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
	return toObject;
}
function generateVideosResponseFromVertex(fromObject) {
	const toObject = {};
	const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
	if (fromGeneratedVideos != null) {
		let transformedList = fromGeneratedVideos;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedVideoFromVertex(item);
		});
		setValueByPath(toObject, ["generatedVideos"], transformedList);
	}
	const fromRaiMediaFilteredCount = getValueByPath(fromObject, ["raiMediaFilteredCount"]);
	if (fromRaiMediaFilteredCount != null) setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
	const fromRaiMediaFilteredReasons = getValueByPath(fromObject, ["raiMediaFilteredReasons"]);
	if (fromRaiMediaFilteredReasons != null) setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
	return toObject;
}
function generateVideosSourceToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromPrompt = getValueByPath(fromObject, ["prompt"]);
	if (parentObject !== void 0 && fromPrompt != null) setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (parentObject !== void 0 && fromImage != null) setValueByPath(parentObject, ["instances[0]", "image"], imageToMldev(fromImage));
	const fromVideo = getValueByPath(fromObject, ["video"]);
	if (parentObject !== void 0 && fromVideo != null) setValueByPath(parentObject, ["instances[0]", "video"], videoToMldev(fromVideo));
	return toObject;
}
function generateVideosSourceToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromPrompt = getValueByPath(fromObject, ["prompt"]);
	if (parentObject !== void 0 && fromPrompt != null) setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (parentObject !== void 0 && fromImage != null) setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
	const fromVideo = getValueByPath(fromObject, ["video"]);
	if (parentObject !== void 0 && fromVideo != null) setValueByPath(parentObject, ["instances[0]", "video"], videoToVertex(fromVideo));
	return toObject;
}
function generatedImageFromMldev(fromObject) {
	const toObject = {};
	const fromImage = getValueByPath(fromObject, ["_self"]);
	if (fromImage != null) setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
	const fromRaiFilteredReason = getValueByPath(fromObject, ["raiFilteredReason"]);
	if (fromRaiFilteredReason != null) setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
	const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
	if (fromSafetyAttributes != null) setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
	return toObject;
}
function generatedImageFromVertex(fromObject) {
	const toObject = {};
	const fromImage = getValueByPath(fromObject, ["_self"]);
	if (fromImage != null) setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
	const fromRaiFilteredReason = getValueByPath(fromObject, ["raiFilteredReason"]);
	if (fromRaiFilteredReason != null) setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
	const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
	if (fromSafetyAttributes != null) setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
	const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
	if (fromEnhancedPrompt != null) setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
	return toObject;
}
function generatedImageMaskFromVertex(fromObject) {
	const toObject = {};
	const fromMask = getValueByPath(fromObject, ["_self"]);
	if (fromMask != null) setValueByPath(toObject, ["mask"], imageFromVertex(fromMask));
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (fromLabels != null) {
		let transformedList = fromLabels;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["labels"], transformedList);
	}
	return toObject;
}
function generatedVideoFromMldev(fromObject) {
	const toObject = {};
	const fromVideo = getValueByPath(fromObject, ["video"]);
	if (fromVideo != null) setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
	return toObject;
}
function generatedVideoFromVertex(fromObject) {
	const toObject = {};
	const fromVideo = getValueByPath(fromObject, ["_self"]);
	if (fromVideo != null) setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
	return toObject;
}
function generationConfigToVertex(fromObject) {
	const toObject = {};
	const fromModelSelectionConfig = getValueByPath(fromObject, ["modelSelectionConfig"]);
	if (fromModelSelectionConfig != null) setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
	const fromResponseJsonSchema = getValueByPath(fromObject, ["responseJsonSchema"]);
	if (fromResponseJsonSchema != null) setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
	const fromAudioTimestamp = getValueByPath(fromObject, ["audioTimestamp"]);
	if (fromAudioTimestamp != null) setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
	const fromCandidateCount = getValueByPath(fromObject, ["candidateCount"]);
	if (fromCandidateCount != null) setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
	const fromEnableAffectiveDialog = getValueByPath(fromObject, ["enableAffectiveDialog"]);
	if (fromEnableAffectiveDialog != null) setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
	const fromFrequencyPenalty = getValueByPath(fromObject, ["frequencyPenalty"]);
	if (fromFrequencyPenalty != null) setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
	const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
	if (fromLogprobs != null) setValueByPath(toObject, ["logprobs"], fromLogprobs);
	const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
	if (fromMaxOutputTokens != null) setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromPresencePenalty = getValueByPath(fromObject, ["presencePenalty"]);
	if (fromPresencePenalty != null) setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
	const fromResponseLogprobs = getValueByPath(fromObject, ["responseLogprobs"]);
	if (fromResponseLogprobs != null) setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
	const fromResponseMimeType = getValueByPath(fromObject, ["responseMimeType"]);
	if (fromResponseMimeType != null) setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
	const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
	if (fromResponseModalities != null) setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
	const fromResponseSchema = getValueByPath(fromObject, ["responseSchema"]);
	if (fromResponseSchema != null) setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
	const fromRoutingConfig = getValueByPath(fromObject, ["routingConfig"]);
	if (fromRoutingConfig != null) setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (fromSeed != null) setValueByPath(toObject, ["seed"], fromSeed);
	const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
	if (fromSpeechConfig != null) setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(fromSpeechConfig));
	const fromStopSequences = getValueByPath(fromObject, ["stopSequences"]);
	if (fromStopSequences != null) setValueByPath(toObject, ["stopSequences"], fromStopSequences);
	const fromTemperature = getValueByPath(fromObject, ["temperature"]);
	if (fromTemperature != null) setValueByPath(toObject, ["temperature"], fromTemperature);
	const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
	if (fromThinkingConfig != null) setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
	const fromTopK = getValueByPath(fromObject, ["topK"]);
	if (fromTopK != null) setValueByPath(toObject, ["topK"], fromTopK);
	const fromTopP = getValueByPath(fromObject, ["topP"]);
	if (fromTopP != null) setValueByPath(toObject, ["topP"], fromTopP);
	if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
	return toObject;
}
function getModelParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
	return toObject;
}
function getModelParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
	return toObject;
}
function googleMapsToMldev$1(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
	const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
	if (fromEnableWidget != null) setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
	return toObject;
}
function googleSearchToMldev$1(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API.");
	const fromTimeRangeFilter = getValueByPath(fromObject, ["timeRangeFilter"]);
	if (fromTimeRangeFilter != null) setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
	return toObject;
}
function imageConfigToMldev(fromObject) {
	const toObject = {};
	const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
	if (fromAspectRatio != null) setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
	const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
	if (fromImageSize != null) setValueByPath(toObject, ["imageSize"], fromImageSize);
	if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) throw new Error("outputMimeType parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
	return toObject;
}
function imageConfigToVertex(fromObject) {
	const toObject = {};
	const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
	if (fromAspectRatio != null) setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
	const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
	if (fromImageSize != null) setValueByPath(toObject, ["imageSize"], fromImageSize);
	const fromOutputMimeType = getValueByPath(fromObject, ["outputMimeType"]);
	if (fromOutputMimeType != null) setValueByPath(toObject, ["imageOutputOptions", "mimeType"], fromOutputMimeType);
	const fromOutputCompressionQuality = getValueByPath(fromObject, ["outputCompressionQuality"]);
	if (fromOutputCompressionQuality != null) setValueByPath(toObject, ["imageOutputOptions", "compressionQuality"], fromOutputCompressionQuality);
	return toObject;
}
function imageFromMldev(fromObject) {
	const toObject = {};
	const fromImageBytes = getValueByPath(fromObject, ["bytesBase64Encoded"]);
	if (fromImageBytes != null) setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function imageFromVertex(fromObject) {
	const toObject = {};
	const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
	if (fromGcsUri != null) setValueByPath(toObject, ["gcsUri"], fromGcsUri);
	const fromImageBytes = getValueByPath(fromObject, ["bytesBase64Encoded"]);
	if (fromImageBytes != null) setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function imageToMldev(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API.");
	const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
	if (fromImageBytes != null) setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function imageToVertex(fromObject) {
	const toObject = {};
	const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
	if (fromGcsUri != null) setValueByPath(toObject, ["gcsUri"], fromGcsUri);
	const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
	if (fromImageBytes != null) setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function listModelsConfigToMldev(apiClient, fromObject, parentObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	const fromFilter = getValueByPath(fromObject, ["filter"]);
	if (parentObject !== void 0 && fromFilter != null) setValueByPath(parentObject, ["_query", "filter"], fromFilter);
	const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
	if (parentObject !== void 0 && fromQueryBase != null) setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
	return toObject;
}
function listModelsConfigToVertex(apiClient, fromObject, parentObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	const fromFilter = getValueByPath(fromObject, ["filter"]);
	if (parentObject !== void 0 && fromFilter != null) setValueByPath(parentObject, ["_query", "filter"], fromFilter);
	const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
	if (parentObject !== void 0 && fromQueryBase != null) setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
	return toObject;
}
function listModelsParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listModelsConfigToMldev(apiClient, fromConfig, toObject);
	return toObject;
}
function listModelsParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listModelsConfigToVertex(apiClient, fromConfig, toObject);
	return toObject;
}
function listModelsResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromModels = getValueByPath(fromObject, ["_self"]);
	if (fromModels != null) {
		let transformedList = tExtractModels(fromModels);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return modelFromMldev(item);
		});
		setValueByPath(toObject, ["models"], transformedList);
	}
	return toObject;
}
function listModelsResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromModels = getValueByPath(fromObject, ["_self"]);
	if (fromModels != null) {
		let transformedList = tExtractModels(fromModels);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return modelFromVertex(item);
		});
		setValueByPath(toObject, ["models"], transformedList);
	}
	return toObject;
}
function maskReferenceConfigToVertex(fromObject) {
	const toObject = {};
	const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
	if (fromMaskMode != null) setValueByPath(toObject, ["maskMode"], fromMaskMode);
	const fromSegmentationClasses = getValueByPath(fromObject, ["segmentationClasses"]);
	if (fromSegmentationClasses != null) setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
	const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
	if (fromMaskDilation != null) setValueByPath(toObject, ["dilation"], fromMaskDilation);
	return toObject;
}
function modelFromMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
	const fromVersion = getValueByPath(fromObject, ["version"]);
	if (fromVersion != null) setValueByPath(toObject, ["version"], fromVersion);
	const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
	if (fromTunedModelInfo != null) setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
	const fromInputTokenLimit = getValueByPath(fromObject, ["inputTokenLimit"]);
	if (fromInputTokenLimit != null) setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
	const fromOutputTokenLimit = getValueByPath(fromObject, ["outputTokenLimit"]);
	if (fromOutputTokenLimit != null) setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
	const fromSupportedActions = getValueByPath(fromObject, ["supportedGenerationMethods"]);
	if (fromSupportedActions != null) setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
	const fromTemperature = getValueByPath(fromObject, ["temperature"]);
	if (fromTemperature != null) setValueByPath(toObject, ["temperature"], fromTemperature);
	const fromMaxTemperature = getValueByPath(fromObject, ["maxTemperature"]);
	if (fromMaxTemperature != null) setValueByPath(toObject, ["maxTemperature"], fromMaxTemperature);
	const fromTopP = getValueByPath(fromObject, ["topP"]);
	if (fromTopP != null) setValueByPath(toObject, ["topP"], fromTopP);
	const fromTopK = getValueByPath(fromObject, ["topK"]);
	if (fromTopK != null) setValueByPath(toObject, ["topK"], fromTopK);
	const fromThinking = getValueByPath(fromObject, ["thinking"]);
	if (fromThinking != null) setValueByPath(toObject, ["thinking"], fromThinking);
	return toObject;
}
function modelFromVertex(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
	const fromVersion = getValueByPath(fromObject, ["versionId"]);
	if (fromVersion != null) setValueByPath(toObject, ["version"], fromVersion);
	const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
	if (fromEndpoints != null) {
		let transformedList = fromEndpoints;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return endpointFromVertex(item);
		});
		setValueByPath(toObject, ["endpoints"], transformedList);
	}
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (fromLabels != null) setValueByPath(toObject, ["labels"], fromLabels);
	const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
	if (fromTunedModelInfo != null) setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
	const fromDefaultCheckpointId = getValueByPath(fromObject, ["defaultCheckpointId"]);
	if (fromDefaultCheckpointId != null) setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
	const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
	if (fromCheckpoints != null) {
		let transformedList = fromCheckpoints;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["checkpoints"], transformedList);
	}
	return toObject;
}
function partToMldev$1(fromObject) {
	const toObject = {};
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
	if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
	const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
	if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
	const fromFileData = getValueByPath(fromObject, ["fileData"]);
	if (fromFileData != null) setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
	const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
	if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], functionCallToMldev$1(fromFunctionCall));
	const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
	if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
	const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
	if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
	const fromText = getValueByPath(fromObject, ["text"]);
	if (fromText != null) setValueByPath(toObject, ["text"], fromText);
	const fromThought = getValueByPath(fromObject, ["thought"]);
	if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
	const fromThoughtSignature = getValueByPath(fromObject, ["thoughtSignature"]);
	if (fromThoughtSignature != null) setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
	const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
	if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
	return toObject;
}
function productImageToVertex(fromObject) {
	const toObject = {};
	const fromProductImage = getValueByPath(fromObject, ["productImage"]);
	if (fromProductImage != null) setValueByPath(toObject, ["image"], imageToVertex(fromProductImage));
	return toObject;
}
function recontextImageConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromNumberOfImages = getValueByPath(fromObject, ["numberOfImages"]);
	if (parentObject !== void 0 && fromNumberOfImages != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
	const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
	if (parentObject !== void 0 && fromBaseSteps != null) setValueByPath(parentObject, ["parameters", "baseSteps"], fromBaseSteps);
	const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
	if (parentObject !== void 0 && fromOutputGcsUri != null) setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
	const fromSafetyFilterLevel = getValueByPath(fromObject, ["safetyFilterLevel"]);
	if (parentObject !== void 0 && fromSafetyFilterLevel != null) setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
	const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
	if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
	const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
	if (parentObject !== void 0 && fromAddWatermark != null) setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
	const fromOutputMimeType = getValueByPath(fromObject, ["outputMimeType"]);
	if (parentObject !== void 0 && fromOutputMimeType != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"mimeType"
	], fromOutputMimeType);
	const fromOutputCompressionQuality = getValueByPath(fromObject, ["outputCompressionQuality"]);
	if (parentObject !== void 0 && fromOutputCompressionQuality != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"compressionQuality"
	], fromOutputCompressionQuality);
	const fromEnhancePrompt = getValueByPath(fromObject, ["enhancePrompt"]);
	if (parentObject !== void 0 && fromEnhancePrompt != null) setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (parentObject !== void 0 && fromLabels != null) setValueByPath(parentObject, ["labels"], fromLabels);
	return toObject;
}
function recontextImageParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromSource = getValueByPath(fromObject, ["source"]);
	if (fromSource != null) recontextImageSourceToVertex(fromSource, toObject);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) recontextImageConfigToVertex(fromConfig, toObject);
	return toObject;
}
function recontextImageResponseFromVertex(fromObject) {
	const toObject = {};
	const fromGeneratedImages = getValueByPath(fromObject, ["predictions"]);
	if (fromGeneratedImages != null) {
		let transformedList = fromGeneratedImages;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedImageFromVertex(item);
		});
		setValueByPath(toObject, ["generatedImages"], transformedList);
	}
	return toObject;
}
function recontextImageSourceToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromPrompt = getValueByPath(fromObject, ["prompt"]);
	if (parentObject !== void 0 && fromPrompt != null) setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
	const fromPersonImage = getValueByPath(fromObject, ["personImage"]);
	if (parentObject !== void 0 && fromPersonImage != null) setValueByPath(parentObject, [
		"instances[0]",
		"personImage",
		"image"
	], imageToVertex(fromPersonImage));
	const fromProductImages = getValueByPath(fromObject, ["productImages"]);
	if (parentObject !== void 0 && fromProductImages != null) {
		let transformedList = fromProductImages;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return productImageToVertex(item);
		});
		setValueByPath(parentObject, ["instances[0]", "productImages"], transformedList);
	}
	return toObject;
}
function referenceImageAPIInternalToVertex(fromObject) {
	const toObject = {};
	const fromReferenceImage = getValueByPath(fromObject, ["referenceImage"]);
	if (fromReferenceImage != null) setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
	const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
	if (fromReferenceId != null) setValueByPath(toObject, ["referenceId"], fromReferenceId);
	const fromReferenceType = getValueByPath(fromObject, ["referenceType"]);
	if (fromReferenceType != null) setValueByPath(toObject, ["referenceType"], fromReferenceType);
	const fromMaskImageConfig = getValueByPath(fromObject, ["maskImageConfig"]);
	if (fromMaskImageConfig != null) setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
	const fromControlImageConfig = getValueByPath(fromObject, ["controlImageConfig"]);
	if (fromControlImageConfig != null) setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
	const fromStyleImageConfig = getValueByPath(fromObject, ["styleImageConfig"]);
	if (fromStyleImageConfig != null) setValueByPath(toObject, ["styleImageConfig"], fromStyleImageConfig);
	const fromSubjectImageConfig = getValueByPath(fromObject, ["subjectImageConfig"]);
	if (fromSubjectImageConfig != null) setValueByPath(toObject, ["subjectImageConfig"], fromSubjectImageConfig);
	return toObject;
}
function safetyAttributesFromMldev(fromObject) {
	const toObject = {};
	const fromCategories = getValueByPath(fromObject, ["safetyAttributes", "categories"]);
	if (fromCategories != null) setValueByPath(toObject, ["categories"], fromCategories);
	const fromScores = getValueByPath(fromObject, ["safetyAttributes", "scores"]);
	if (fromScores != null) setValueByPath(toObject, ["scores"], fromScores);
	const fromContentType = getValueByPath(fromObject, ["contentType"]);
	if (fromContentType != null) setValueByPath(toObject, ["contentType"], fromContentType);
	return toObject;
}
function safetyAttributesFromVertex(fromObject) {
	const toObject = {};
	const fromCategories = getValueByPath(fromObject, ["safetyAttributes", "categories"]);
	if (fromCategories != null) setValueByPath(toObject, ["categories"], fromCategories);
	const fromScores = getValueByPath(fromObject, ["safetyAttributes", "scores"]);
	if (fromScores != null) setValueByPath(toObject, ["scores"], fromScores);
	const fromContentType = getValueByPath(fromObject, ["contentType"]);
	if (fromContentType != null) setValueByPath(toObject, ["contentType"], fromContentType);
	return toObject;
}
function safetySettingToMldev(fromObject) {
	const toObject = {};
	const fromCategory = getValueByPath(fromObject, ["category"]);
	if (fromCategory != null) setValueByPath(toObject, ["category"], fromCategory);
	if (getValueByPath(fromObject, ["method"]) !== void 0) throw new Error("method parameter is not supported in Gemini API.");
	const fromThreshold = getValueByPath(fromObject, ["threshold"]);
	if (fromThreshold != null) setValueByPath(toObject, ["threshold"], fromThreshold);
	return toObject;
}
function scribbleImageToVertex(fromObject) {
	const toObject = {};
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (fromImage != null) setValueByPath(toObject, ["image"], imageToVertex(fromImage));
	return toObject;
}
function segmentImageConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromMode = getValueByPath(fromObject, ["mode"]);
	if (parentObject !== void 0 && fromMode != null) setValueByPath(parentObject, ["parameters", "mode"], fromMode);
	const fromMaxPredictions = getValueByPath(fromObject, ["maxPredictions"]);
	if (parentObject !== void 0 && fromMaxPredictions != null) setValueByPath(parentObject, ["parameters", "maxPredictions"], fromMaxPredictions);
	const fromConfidenceThreshold = getValueByPath(fromObject, ["confidenceThreshold"]);
	if (parentObject !== void 0 && fromConfidenceThreshold != null) setValueByPath(parentObject, ["parameters", "confidenceThreshold"], fromConfidenceThreshold);
	const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
	if (parentObject !== void 0 && fromMaskDilation != null) setValueByPath(parentObject, ["parameters", "maskDilation"], fromMaskDilation);
	const fromBinaryColorThreshold = getValueByPath(fromObject, ["binaryColorThreshold"]);
	if (parentObject !== void 0 && fromBinaryColorThreshold != null) setValueByPath(parentObject, ["parameters", "binaryColorThreshold"], fromBinaryColorThreshold);
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (parentObject !== void 0 && fromLabels != null) setValueByPath(parentObject, ["labels"], fromLabels);
	return toObject;
}
function segmentImageParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromSource = getValueByPath(fromObject, ["source"]);
	if (fromSource != null) segmentImageSourceToVertex(fromSource, toObject);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) segmentImageConfigToVertex(fromConfig, toObject);
	return toObject;
}
function segmentImageResponseFromVertex(fromObject) {
	const toObject = {};
	const fromGeneratedMasks = getValueByPath(fromObject, ["predictions"]);
	if (fromGeneratedMasks != null) {
		let transformedList = fromGeneratedMasks;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedImageMaskFromVertex(item);
		});
		setValueByPath(toObject, ["generatedMasks"], transformedList);
	}
	return toObject;
}
function segmentImageSourceToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromPrompt = getValueByPath(fromObject, ["prompt"]);
	if (parentObject !== void 0 && fromPrompt != null) setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (parentObject !== void 0 && fromImage != null) setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
	const fromScribbleImage = getValueByPath(fromObject, ["scribbleImage"]);
	if (parentObject !== void 0 && fromScribbleImage != null) setValueByPath(parentObject, ["instances[0]", "scribble"], scribbleImageToVertex(fromScribbleImage));
	return toObject;
}
function speechConfigToVertex(fromObject) {
	const toObject = {};
	const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
	if (fromLanguageCode != null) setValueByPath(toObject, ["languageCode"], fromLanguageCode);
	const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
	if (fromVoiceConfig != null) setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
	if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
	return toObject;
}
function toolConfigToMldev(fromObject) {
	const toObject = {};
	const fromFunctionCallingConfig = getValueByPath(fromObject, ["functionCallingConfig"]);
	if (fromFunctionCallingConfig != null) setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
	const fromRetrievalConfig = getValueByPath(fromObject, ["retrievalConfig"]);
	if (fromRetrievalConfig != null) setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
	return toObject;
}
function toolToMldev$1(fromObject) {
	const toObject = {};
	const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
	if (fromFunctionDeclarations != null) {
		let transformedList = fromFunctionDeclarations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["functionDeclarations"], transformedList);
	}
	if (getValueByPath(fromObject, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
	const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
	if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
	const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
	if (fromComputerUse != null) setValueByPath(toObject, ["computerUse"], fromComputerUse);
	const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
	if (fromFileSearch != null) setValueByPath(toObject, ["fileSearch"], fromFileSearch);
	const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
	if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
	if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
	const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
	if (fromGoogleMaps != null) setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$1(fromGoogleMaps));
	const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
	if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
	const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
	if (fromUrlContext != null) setValueByPath(toObject, ["urlContext"], fromUrlContext);
	return toObject;
}
function toolToVertex(fromObject) {
	const toObject = {};
	const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
	if (fromFunctionDeclarations != null) {
		let transformedList = fromFunctionDeclarations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return functionDeclarationToVertex(item);
		});
		setValueByPath(toObject, ["functionDeclarations"], transformedList);
	}
	const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
	if (fromRetrieval != null) setValueByPath(toObject, ["retrieval"], fromRetrieval);
	const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
	if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
	const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
	if (fromComputerUse != null) setValueByPath(toObject, ["computerUse"], fromComputerUse);
	if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) throw new Error("fileSearch parameter is not supported in Vertex AI.");
	const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
	if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
	const fromEnterpriseWebSearch = getValueByPath(fromObject, ["enterpriseWebSearch"]);
	if (fromEnterpriseWebSearch != null) setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
	const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
	if (fromGoogleMaps != null) setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
	const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
	if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
	const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
	if (fromUrlContext != null) setValueByPath(toObject, ["urlContext"], fromUrlContext);
	return toObject;
}
function tunedModelInfoFromMldev(fromObject) {
	const toObject = {};
	const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
	if (fromBaseModel != null) setValueByPath(toObject, ["baseModel"], fromBaseModel);
	const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
	if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
	const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
	if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
	return toObject;
}
function tunedModelInfoFromVertex(fromObject) {
	const toObject = {};
	const fromBaseModel = getValueByPath(fromObject, ["labels", "google-vertex-llm-tuning-base-model-id"]);
	if (fromBaseModel != null) setValueByPath(toObject, ["baseModel"], fromBaseModel);
	const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
	if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
	const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
	if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
	return toObject;
}
function updateModelConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["displayName"], fromDisplayName);
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (parentObject !== void 0 && fromDescription != null) setValueByPath(parentObject, ["description"], fromDescription);
	const fromDefaultCheckpointId = getValueByPath(fromObject, ["defaultCheckpointId"]);
	if (parentObject !== void 0 && fromDefaultCheckpointId != null) setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
	return toObject;
}
function updateModelConfigToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["displayName"], fromDisplayName);
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (parentObject !== void 0 && fromDescription != null) setValueByPath(parentObject, ["description"], fromDescription);
	const fromDefaultCheckpointId = getValueByPath(fromObject, ["defaultCheckpointId"]);
	if (parentObject !== void 0 && fromDefaultCheckpointId != null) setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
	return toObject;
}
function updateModelParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) updateModelConfigToMldev(fromConfig, toObject);
	return toObject;
}
function updateModelParametersToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) updateModelConfigToVertex(fromConfig, toObject);
	return toObject;
}
function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {
	const toObject = {};
	const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
	if (parentObject !== void 0 && fromOutputGcsUri != null) setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
	const fromSafetyFilterLevel = getValueByPath(fromObject, ["safetyFilterLevel"]);
	if (parentObject !== void 0 && fromSafetyFilterLevel != null) setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
	const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
	if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
	const fromIncludeRaiReason = getValueByPath(fromObject, ["includeRaiReason"]);
	if (parentObject !== void 0 && fromIncludeRaiReason != null) setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
	const fromOutputMimeType = getValueByPath(fromObject, ["outputMimeType"]);
	if (parentObject !== void 0 && fromOutputMimeType != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"mimeType"
	], fromOutputMimeType);
	const fromOutputCompressionQuality = getValueByPath(fromObject, ["outputCompressionQuality"]);
	if (parentObject !== void 0 && fromOutputCompressionQuality != null) setValueByPath(parentObject, [
		"parameters",
		"outputOptions",
		"compressionQuality"
	], fromOutputCompressionQuality);
	const fromEnhanceInputImage = getValueByPath(fromObject, ["enhanceInputImage"]);
	if (parentObject !== void 0 && fromEnhanceInputImage != null) setValueByPath(parentObject, [
		"parameters",
		"upscaleConfig",
		"enhanceInputImage"
	], fromEnhanceInputImage);
	const fromImagePreservationFactor = getValueByPath(fromObject, ["imagePreservationFactor"]);
	if (parentObject !== void 0 && fromImagePreservationFactor != null) setValueByPath(parentObject, [
		"parameters",
		"upscaleConfig",
		"imagePreservationFactor"
	], fromImagePreservationFactor);
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (parentObject !== void 0 && fromLabels != null) setValueByPath(parentObject, ["labels"], fromLabels);
	const fromNumberOfImages = getValueByPath(fromObject, ["numberOfImages"]);
	if (parentObject !== void 0 && fromNumberOfImages != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
	const fromMode = getValueByPath(fromObject, ["mode"]);
	if (parentObject !== void 0 && fromMode != null) setValueByPath(parentObject, ["parameters", "mode"], fromMode);
	return toObject;
}
function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (fromImage != null) setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
	const fromUpscaleFactor = getValueByPath(fromObject, ["upscaleFactor"]);
	if (fromUpscaleFactor != null) setValueByPath(toObject, [
		"parameters",
		"upscaleConfig",
		"upscaleFactor"
	], fromUpscaleFactor);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);
	return toObject;
}
function upscaleImageResponseFromVertex(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromGeneratedImages = getValueByPath(fromObject, ["predictions"]);
	if (fromGeneratedImages != null) {
		let transformedList = fromGeneratedImages;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return generatedImageFromVertex(item);
		});
		setValueByPath(toObject, ["generatedImages"], transformedList);
	}
	return toObject;
}
function videoFromMldev(fromObject) {
	const toObject = {};
	const fromUri = getValueByPath(fromObject, ["uri"]);
	if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
	const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
	if (fromVideoBytes != null) setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
	const fromMimeType = getValueByPath(fromObject, ["encoding"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function videoFromVertex(fromObject) {
	const toObject = {};
	const fromUri = getValueByPath(fromObject, ["gcsUri"]);
	if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
	const fromVideoBytes = getValueByPath(fromObject, ["bytesBase64Encoded"]);
	if (fromVideoBytes != null) setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function videoGenerationMaskToVertex(fromObject) {
	const toObject = {};
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (fromImage != null) setValueByPath(toObject, ["_self"], imageToVertex(fromImage));
	const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
	if (fromMaskMode != null) setValueByPath(toObject, ["maskMode"], fromMaskMode);
	return toObject;
}
function videoGenerationReferenceImageToMldev(fromObject) {
	const toObject = {};
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (fromImage != null) setValueByPath(toObject, ["image"], imageToMldev(fromImage));
	const fromReferenceType = getValueByPath(fromObject, ["referenceType"]);
	if (fromReferenceType != null) setValueByPath(toObject, ["referenceType"], fromReferenceType);
	return toObject;
}
function videoGenerationReferenceImageToVertex(fromObject) {
	const toObject = {};
	const fromImage = getValueByPath(fromObject, ["image"]);
	if (fromImage != null) setValueByPath(toObject, ["image"], imageToVertex(fromImage));
	const fromReferenceType = getValueByPath(fromObject, ["referenceType"]);
	if (fromReferenceType != null) setValueByPath(toObject, ["referenceType"], fromReferenceType);
	return toObject;
}
function videoToMldev(fromObject) {
	const toObject = {};
	const fromUri = getValueByPath(fromObject, ["uri"]);
	if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
	const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
	if (fromVideoBytes != null) setValueByPath(toObject, ["encodedVideo"], tBytes(fromVideoBytes));
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["encoding"], fromMimeType);
	return toObject;
}
function videoToVertex(fromObject) {
	const toObject = {};
	const fromUri = getValueByPath(fromObject, ["uri"]);
	if (fromUri != null) setValueByPath(toObject, ["gcsUri"], fromUri);
	const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
	if (fromVideoBytes != null) setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
const CONTENT_TYPE_HEADER = "Content-Type";
const SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
const USER_AGENT_HEADER = "User-Agent";
const GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
const LIBRARY_LABEL = `google-genai-sdk/1.30.0`;
const VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
const GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
const responseLineRE = /^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
/**
* The ApiClient class is used to send requests to the Gemini API or Vertex AI
* endpoints.
*/
var ApiClient = class {
	constructor(opts) {
		var _a$2, _b;
		this.clientOptions = Object.assign(Object.assign({}, opts), {
			project: opts.project,
			location: opts.location,
			apiKey: opts.apiKey,
			vertexai: opts.vertexai
		});
		const initHttpOptions = {};
		if (this.clientOptions.vertexai) {
			initHttpOptions.apiVersion = (_a$2 = this.clientOptions.apiVersion) !== null && _a$2 !== void 0 ? _a$2 : VERTEX_AI_API_DEFAULT_VERSION;
			initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();
			this.normalizeAuthParameters();
		} else {
			initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;
			initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
		}
		initHttpOptions.headers = this.getDefaultHeaders();
		this.clientOptions.httpOptions = initHttpOptions;
		if (opts.httpOptions) this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
	}
	/**
	* Determines the base URL for Vertex AI based on project and location.
	* Uses the global endpoint if location is 'global' or if project/location
	* are not specified (implying API key usage).
	* @private
	*/
	baseUrlFromProjectLocation() {
		if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global") return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
		return `https://aiplatform.googleapis.com/`;
	}
	/**
	* Normalizes authentication parameters for Vertex AI.
	* If project and location are provided, API key is cleared.
	* If project and location are not provided (implying API key usage),
	* project and location are cleared.
	* @private
	*/
	normalizeAuthParameters() {
		if (this.clientOptions.project && this.clientOptions.location) {
			this.clientOptions.apiKey = void 0;
			return;
		}
		this.clientOptions.project = void 0;
		this.clientOptions.location = void 0;
	}
	isVertexAI() {
		var _a$2;
		return (_a$2 = this.clientOptions.vertexai) !== null && _a$2 !== void 0 ? _a$2 : false;
	}
	getProject() {
		return this.clientOptions.project;
	}
	getLocation() {
		return this.clientOptions.location;
	}
	getApiVersion() {
		if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) return this.clientOptions.httpOptions.apiVersion;
		throw new Error("API version is not set.");
	}
	getBaseUrl() {
		if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) return this.clientOptions.httpOptions.baseUrl;
		throw new Error("Base URL is not set.");
	}
	getRequestUrl() {
		return this.getRequestUrlInternal(this.clientOptions.httpOptions);
	}
	getHeaders() {
		if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) return this.clientOptions.httpOptions.headers;
		else throw new Error("Headers are not set.");
	}
	getRequestUrlInternal(httpOptions) {
		if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) throw new Error("HTTP options are not correctly set.");
		const urlElement = [httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl];
		if (httpOptions.apiVersion && httpOptions.apiVersion !== "") urlElement.push(httpOptions.apiVersion);
		return urlElement.join("/");
	}
	getBaseResourcePath() {
		return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
	}
	getApiKey() {
		return this.clientOptions.apiKey;
	}
	getWebsocketBaseUrl() {
		const baseUrl$1 = this.getBaseUrl();
		const urlParts = new URL(baseUrl$1);
		urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
		return urlParts.toString();
	}
	setBaseUrl(url) {
		if (this.clientOptions.httpOptions) this.clientOptions.httpOptions.baseUrl = url;
		else throw new Error("HTTP options are not correctly set.");
	}
	constructUrl(path$9, httpOptions, prependProjectLocation) {
		const urlElement = [this.getRequestUrlInternal(httpOptions)];
		if (prependProjectLocation) urlElement.push(this.getBaseResourcePath());
		if (path$9 !== "") urlElement.push(path$9);
		return new URL(`${urlElement.join("/")}`);
	}
	shouldPrependVertexProjectPath(request$3) {
		if (this.clientOptions.apiKey) return false;
		if (!this.clientOptions.vertexai) return false;
		if (request$3.path.startsWith("projects/")) return false;
		if (request$3.httpMethod === "GET" && request$3.path.startsWith("publishers/google/models")) return false;
		return true;
	}
	async request(request$3) {
		let patchedHttpOptions = this.clientOptions.httpOptions;
		if (request$3.httpOptions) patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request$3.httpOptions);
		const prependProjectLocation = this.shouldPrependVertexProjectPath(request$3);
		const url = this.constructUrl(request$3.path, patchedHttpOptions, prependProjectLocation);
		if (request$3.queryParams) for (const [key, value] of Object.entries(request$3.queryParams)) url.searchParams.append(key, String(value));
		let requestInit = {};
		if (request$3.httpMethod === "GET") {
			if (request$3.body && request$3.body !== "{}") throw new Error("Request body should be empty for GET request, but got non empty request body");
		} else requestInit.body = request$3.body;
		requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request$3.abortSignal);
		return this.unaryApiCall(url, requestInit, request$3.httpMethod);
	}
	patchHttpOptions(baseHttpOptions, requestHttpOptions) {
		const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
		for (const [key, value] of Object.entries(requestHttpOptions)) if (typeof value === "object") patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
		else if (value !== void 0) patchedHttpOptions[key] = value;
		return patchedHttpOptions;
	}
	async requestStream(request$3) {
		let patchedHttpOptions = this.clientOptions.httpOptions;
		if (request$3.httpOptions) patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request$3.httpOptions);
		const prependProjectLocation = this.shouldPrependVertexProjectPath(request$3);
		const url = this.constructUrl(request$3.path, patchedHttpOptions, prependProjectLocation);
		if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") url.searchParams.set("alt", "sse");
		let requestInit = {};
		requestInit.body = request$3.body;
		requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request$3.abortSignal);
		return this.streamApiCall(url, requestInit, request$3.httpMethod);
	}
	async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {
		if (httpOptions && httpOptions.timeout || abortSignal) {
			const abortController = new AbortController();
			const signal = abortController.signal;
			if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
				const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
				if (timeoutHandle && typeof timeoutHandle.unref === "function") timeoutHandle.unref();
			}
			if (abortSignal) abortSignal.addEventListener("abort", () => {
				abortController.abort();
			});
			requestInit.signal = signal;
		}
		if (httpOptions && httpOptions.extraBody !== null) includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
		requestInit.headers = await this.getHeadersInternal(httpOptions, url);
		return requestInit;
	}
	async unaryApiCall(url, requestInit, httpMethod) {
		return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
			await throwErrorIfNotOK(response);
			return new HttpResponse(response);
		}).catch((e$1) => {
			if (e$1 instanceof Error) throw e$1;
			else throw new Error(JSON.stringify(e$1));
		});
	}
	async streamApiCall(url, requestInit, httpMethod) {
		return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
			await throwErrorIfNotOK(response);
			return this.processStreamResponse(response);
		}).catch((e$1) => {
			if (e$1 instanceof Error) throw e$1;
			else throw new Error(JSON.stringify(e$1));
		});
	}
	processStreamResponse(response) {
		var _a$2;
		return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
			const reader = (_a$2 = response === null || response === void 0 ? void 0 : response.body) === null || _a$2 === void 0 ? void 0 : _a$2.getReader();
			const decoder = new TextDecoder("utf-8");
			if (!reader) throw new Error("Response body is empty");
			try {
				let buffer$1 = "";
				while (true) {
					const { done, value } = yield __await(reader.read());
					if (done) {
						if (buffer$1.trim().length > 0) throw new Error("Incomplete JSON segment at the end");
						break;
					}
					const chunkString = decoder.decode(value, { stream: true });
					try {
						const chunkJson = JSON.parse(chunkString);
						if ("error" in chunkJson) {
							const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
							const status = errorJson["status"];
							const code$1 = errorJson["code"];
							const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
							if (code$1 >= 400 && code$1 < 600) throw new ApiError({
								message: errorMessage,
								status: code$1
							});
						}
					} catch (e$1) {
						if (e$1.name === "ApiError") throw e$1;
					}
					buffer$1 += chunkString;
					let match = buffer$1.match(responseLineRE);
					while (match) {
						const processedChunkString = match[1];
						try {
							yield yield __await(new HttpResponse(new Response(processedChunkString, {
								headers: response === null || response === void 0 ? void 0 : response.headers,
								status: response === null || response === void 0 ? void 0 : response.status,
								statusText: response === null || response === void 0 ? void 0 : response.statusText
							})));
							buffer$1 = buffer$1.slice(match[0].length);
							match = buffer$1.match(responseLineRE);
						} catch (e$1) {
							throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e$1}`);
						}
					}
				}
			} finally {
				reader.releaseLock();
			}
		});
	}
	async apiCall(url, requestInit) {
		return fetch(url, requestInit).catch((e$1) => {
			throw new Error(`exception ${e$1} sending request`);
		});
	}
	getDefaultHeaders() {
		const headers = {};
		const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
		headers[USER_AGENT_HEADER] = versionHeaderValue;
		headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
		headers[CONTENT_TYPE_HEADER] = "application/json";
		return headers;
	}
	async getHeadersInternal(httpOptions, url) {
		const headers = new Headers();
		if (httpOptions && httpOptions.headers) {
			for (const [key, value] of Object.entries(httpOptions.headers)) headers.append(key, value);
			if (httpOptions.timeout && httpOptions.timeout > 0) headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
		}
		await this.clientOptions.auth.addAuthHeaders(headers, url);
		return headers;
	}
	getFileName(file) {
		var _a$2;
		let fileName = "";
		if (typeof file === "string") {
			fileName = file.replace(/[/\\]+$/, "");
			fileName = (_a$2 = fileName.split(/[/\\]/).pop()) !== null && _a$2 !== void 0 ? _a$2 : "";
		}
		return fileName;
	}
	/**
	* Uploads a file asynchronously using Gemini API only, this is not supported
	* in Vertex AI.
	*
	* @param file The string path to the file to be uploaded or a Blob object.
	* @param config Optional parameters specified in the `UploadFileConfig`
	*     interface. @see {@link types.UploadFileConfig}
	* @return A promise that resolves to a `File` object.
	* @throws An error if called on a Vertex AI client.
	* @throws An error if the `mimeType` is not provided and can not be inferred,
	*/
	async uploadFile(file, config) {
		var _a$2;
		const fileToUpload = {};
		if (config != null) {
			fileToUpload.mimeType = config.mimeType;
			fileToUpload.name = config.name;
			fileToUpload.displayName = config.displayName;
		}
		if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) fileToUpload.name = `files/${fileToUpload.name}`;
		const uploader = this.clientOptions.uploader;
		const fileStat = await uploader.stat(file);
		fileToUpload.sizeBytes = String(fileStat.size);
		const mimeType = (_a$2 = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a$2 !== void 0 ? _a$2 : fileStat.type;
		if (mimeType === void 0 || mimeType === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
		fileToUpload.mimeType = mimeType;
		const body = { file: fileToUpload };
		const fileName = this.getFileName(file);
		const path$9 = formatMap("upload/v1beta/files", body["_url"]);
		const uploadUrl = await this.fetchUploadUrl(path$9, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
		return uploader.upload(file, uploadUrl, this);
	}
	/**
	* Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported
	* in Vertex AI.
	*
	* @param fileSearchStoreName The name of the file search store to upload the file to.
	* @param file The string path to the file to be uploaded or a Blob object.
	* @param config Optional parameters specified in the `UploadFileConfig`
	*     interface. @see {@link UploadFileConfig}
	* @return A promise that resolves to a `File` object.
	* @throws An error if called on a Vertex AI client.
	* @throws An error if the `mimeType` is not provided and can not be inferred,
	*/
	async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {
		var _a$2;
		const uploader = this.clientOptions.uploader;
		const fileStat = await uploader.stat(file);
		const sizeBytes = String(fileStat.size);
		const mimeType = (_a$2 = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a$2 !== void 0 ? _a$2 : fileStat.type;
		if (mimeType === void 0 || mimeType === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
		const path$9 = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;
		const fileName = this.getFileName(file);
		const body = {};
		if (config === null || config === void 0 ? void 0 : config.customMetadata) body["customMetadata"] = config.customMetadata;
		if (config === null || config === void 0 ? void 0 : config.chunkingConfig) body["chunkingConfig"] = config.chunkingConfig;
		const uploadUrl = await this.fetchUploadUrl(path$9, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
		return uploader.uploadToFileSearchStore(file, uploadUrl, this);
	}
	/**
	* Downloads a file asynchronously to the specified path.
	*
	* @params params - The parameters for the download request, see {@link
	* types.DownloadFileParameters}
	*/
	async downloadFile(params) {
		await this.clientOptions.downloader.download(params, this);
	}
	async fetchUploadUrl(path$9, sizeBytes, mimeType, fileName, body, configHttpOptions) {
		var _a$2;
		let httpOptions = {};
		if (configHttpOptions) httpOptions = configHttpOptions;
		else httpOptions = {
			apiVersion: "",
			headers: Object.assign({
				"Content-Type": "application/json",
				"X-Goog-Upload-Protocol": "resumable",
				"X-Goog-Upload-Command": "start",
				"X-Goog-Upload-Header-Content-Length": `${sizeBytes}`,
				"X-Goog-Upload-Header-Content-Type": `${mimeType}`
			}, fileName ? { "X-Goog-Upload-File-Name": fileName } : {})
		};
		const httpResponse = await this.request({
			path: path$9,
			body: JSON.stringify(body),
			httpMethod: "POST",
			httpOptions
		});
		if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
		const uploadUrl = (_a$2 = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a$2 === void 0 ? void 0 : _a$2["x-goog-upload-url"];
		if (uploadUrl === void 0) throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
		return uploadUrl;
	}
};
async function throwErrorIfNotOK(response) {
	var _a$2;
	if (response === void 0) throw new Error("response is undefined");
	if (!response.ok) {
		const status = response.status;
		let errorBody;
		if ((_a$2 = response.headers.get("content-type")) === null || _a$2 === void 0 ? void 0 : _a$2.includes("application/json")) errorBody = await response.json();
		else errorBody = { error: {
			message: await response.text(),
			code: response.status,
			status: response.statusText
		} };
		const errorMessage = JSON.stringify(errorBody);
		if (status >= 400 && status < 600) throw new ApiError({
			message: errorMessage,
			status
		});
		throw new Error(errorMessage);
	}
}
/**
* Recursively updates the `requestInit.body` with values from an `extraBody` object.
*
* If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.
* The `extraBody` is then deeply merged into this parsed object.
* If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,
* as merging structured data into an opaque Blob is not supported.
*
* The function does not enforce that updated values from `extraBody` have the
* same type as existing values in `requestInit.body`. Type mismatches during
* the merge will result in a warning, but the value from `extraBody` will overwrite
* the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.
*
* @param requestInit The RequestInit object whose body will be updated.
* @param extraBody The object containing updates to be merged into `requestInit.body`.
*/
function includeExtraBodyToRequestInit(requestInit, extraBody) {
	if (!extraBody || Object.keys(extraBody).length === 0) return;
	if (requestInit.body instanceof Blob) {
		console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
		return;
	}
	let currentBodyObject = {};
	if (typeof requestInit.body === "string" && requestInit.body.length > 0) try {
		const parsedBody = JSON.parse(requestInit.body);
		if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) currentBodyObject = parsedBody;
		else {
			console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
			return;
		}
	} catch (e$1) {
		console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
		return;
	}
	function deepMerge(target, source) {
		const output = Object.assign({}, target);
		for (const key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
			const sourceValue = source[key];
			const targetValue = output[key];
			if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) output[key] = deepMerge(targetValue, sourceValue);
			else {
				if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
				output[key] = sourceValue;
			}
		}
		return output;
	}
	const mergedBody = deepMerge(currentBodyObject, extraBody);
	requestInit.body = JSON.stringify(mergedBody);
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
const MCP_LABEL = "mcp_used/unknown";
let hasMcpToolUsageFromMcpToTool = false;
function hasMcpToolUsage(tools) {
	for (const tool of tools) {
		if (isMcpCallableTool(tool)) return true;
		if (typeof tool === "object" && "inputSchema" in tool) return true;
	}
	return hasMcpToolUsageFromMcpToTool;
}
function setMcpUsageHeader(headers) {
	var _a$2;
	headers[GOOGLE_API_CLIENT_HEADER] = (((_a$2 = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a$2 !== void 0 ? _a$2 : "") + ` ${MCP_LABEL}`).trimStart();
}
function isMcpCallableTool(object) {
	return object !== null && typeof object === "object" && object instanceof McpCallableTool;
}
function listAllTools(mcpClient, maxTools = 100) {
	return __asyncGenerator(this, arguments, function* listAllTools_1() {
		let cursor = void 0;
		let numTools = 0;
		while (numTools < maxTools) {
			const t$1 = yield __await(mcpClient.listTools({ cursor }));
			for (const tool of t$1.tools) {
				yield yield __await(tool);
				numTools++;
			}
			if (!t$1.nextCursor) break;
			cursor = t$1.nextCursor;
		}
	});
}
/**
* McpCallableTool can be used for model inference and invoking MCP clients with
* given function call arguments.
*
* @experimental Built-in MCP support is an experimental feature, may change in future
* versions.
*/
var McpCallableTool = class McpCallableTool {
	constructor(mcpClients = [], config) {
		this.mcpTools = [];
		this.functionNameToMcpClient = {};
		this.mcpClients = mcpClients;
		this.config = config;
	}
	/**
	* Creates a McpCallableTool.
	*/
	static create(mcpClients, config) {
		return new McpCallableTool(mcpClients, config);
	}
	/**
	* Validates the function names are not duplicate and initialize the function
	* name to MCP client mapping.
	*
	* @throws {Error} if the MCP tools from the MCP clients have duplicate tool
	*     names.
	*/
	async initialize() {
		var _a$2, e_1, _b, _c;
		if (this.mcpTools.length > 0) return;
		const functionMap = {};
		const mcpTools = [];
		for (const mcpClient of this.mcpClients) try {
			for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a$2 = _f.done, !_a$2; _d = true) {
				_c = _f.value;
				_d = false;
				const mcpTool = _c;
				mcpTools.push(mcpTool);
				const mcpToolName = mcpTool.name;
				if (functionMap[mcpToolName]) throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
				functionMap[mcpToolName] = mcpClient;
			}
		} catch (e_1_1) {
			e_1 = { error: e_1_1 };
		} finally {
			try {
				if (!_d && !_a$2 && (_b = _e.return)) await _b.call(_e);
			} finally {
				if (e_1) throw e_1.error;
			}
		}
		this.mcpTools = mcpTools;
		this.functionNameToMcpClient = functionMap;
	}
	async tool() {
		await this.initialize();
		return mcpToolsToGeminiTool(this.mcpTools, this.config);
	}
	async callTool(functionCalls) {
		await this.initialize();
		const functionCallResponseParts = [];
		for (const functionCall of functionCalls) if (functionCall.name in this.functionNameToMcpClient) {
			const mcpClient = this.functionNameToMcpClient[functionCall.name];
			let requestOptions = void 0;
			if (this.config.timeout) requestOptions = { timeout: this.config.timeout };
			const callToolResponse = await mcpClient.callTool({
				name: functionCall.name,
				arguments: functionCall.args
			}, void 0, requestOptions);
			functionCallResponseParts.push({ functionResponse: {
				name: functionCall.name,
				response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
			} });
		}
		return functionCallResponseParts;
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
/**
* Handles incoming messages from the WebSocket.
*
* @remarks
* This function is responsible for parsing incoming messages, transforming them
* into LiveMusicServerMessage, and then calling the onmessage callback.
* Note that the first message which is received from the server is a
* setupComplete message.
*
* @param apiClient The ApiClient instance.
* @param onmessage The user-provided onmessage callback (if any).
* @param event The MessageEvent from the WebSocket.
*/
async function handleWebSocketMessage$1(apiClient, onmessage, event) {
	const serverMessage = new LiveMusicServerMessage();
	let data;
	if (event.data instanceof Blob) data = JSON.parse(await event.data.text());
	else data = JSON.parse(event.data);
	Object.assign(serverMessage, data);
	onmessage(serverMessage);
}
/**
LiveMusic class encapsulates the configuration for live music
generation via Lyria Live models.

@experimental
*/
var LiveMusic = class {
	constructor(apiClient, auth$2, webSocketFactory) {
		this.apiClient = apiClient;
		this.auth = auth$2;
		this.webSocketFactory = webSocketFactory;
	}
	/**
	Establishes a connection to the specified model and returns a
	LiveMusicSession object representing that connection.
	
	@experimental
	
	@remarks
	
	@param params - The parameters for establishing a connection to the model.
	@return A live session.
	
	@example
	```ts
	let model = 'models/lyria-realtime-exp';
	const session = await ai.live.music.connect({
	model: model,
	callbacks: {
	onmessage: (e: MessageEvent) => {
	console.log('Received message from the server: %s\n', debug(e.data));
	},
	onerror: (e: ErrorEvent) => {
	console.log('Error occurred: %s\n', debug(e.error));
	},
	onclose: (e: CloseEvent) => {
	console.log('Connection closed.');
	},
	},
	});
	```
	*/
	async connect(params) {
		var _a$2, _b;
		if (this.apiClient.isVertexAI()) throw new Error("Live music is not supported for Vertex AI.");
		console.warn("Live music generation is experimental and may change in future versions.");
		const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
		const apiVersion = this.apiClient.getApiVersion();
		const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
		const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${this.apiClient.getApiKey()}`;
		let onopenResolve = () => {};
		const onopenPromise = new Promise((resolve) => {
			onopenResolve = resolve;
		});
		const callbacks = params.callbacks;
		const onopenAwaitedCallback = function() {
			onopenResolve({});
		};
		const apiClient = this.apiClient;
		const websocketCallbacks = {
			onopen: onopenAwaitedCallback,
			onmessage: (event) => {
				handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
			},
			onerror: (_a$2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a$2 !== void 0 ? _a$2 : function(e$1) {},
			onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e$1) {}
		};
		const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
		conn.connect();
		await onopenPromise;
		const clientMessage = { setup: { model: tModel(this.apiClient, params.model) } };
		conn.send(JSON.stringify(clientMessage));
		return new LiveMusicSession(conn, this.apiClient);
	}
};
/**
Represents a connection to the API.

@experimental
*/
var LiveMusicSession = class {
	constructor(conn, apiClient) {
		this.conn = conn;
		this.apiClient = apiClient;
	}
	/**
	Sets inputs to steer music generation. Updates the session's current
	weighted prompts.
	
	@param params - Contains one property, `weightedPrompts`.
	
	- `weightedPrompts` to send to the model; weights are normalized to
	sum to 1.0.
	
	@experimental
	*/
	async setWeightedPrompts(params) {
		if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) throw new Error("Weighted prompts must be set and contain at least one entry.");
		const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);
		this.conn.send(JSON.stringify({ clientContent }));
	}
	/**
	Sets a configuration to the model. Updates the session's current
	music generation config.
	
	@param params - Contains one property, `musicGenerationConfig`.
	
	- `musicGenerationConfig` to set in the model. Passing an empty or
	undefined config to the model will reset the config to defaults.
	
	@experimental
	*/
	async setMusicGenerationConfig(params) {
		if (!params.musicGenerationConfig) params.musicGenerationConfig = {};
		const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
		this.conn.send(JSON.stringify(setConfigParameters));
	}
	sendPlaybackControl(playbackControl) {
		const clientMessage = { playbackControl };
		this.conn.send(JSON.stringify(clientMessage));
	}
	/**
	* Start the music stream.
	*
	* @experimental
	*/
	play() {
		this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
	}
	/**
	* Temporarily halt the music stream. Use `play` to resume from the current
	* position.
	*
	* @experimental
	*/
	pause() {
		this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
	}
	/**
	* Stop the music stream and reset the state. Retains the current prompts
	* and config.
	*
	* @experimental
	*/
	stop() {
		this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
	}
	/**
	* Resets the context of the music generation without stopping it.
	* Retains the current prompts and config.
	*
	* @experimental
	*/
	resetContext() {
		this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
	}
	/**
	Terminates the WebSocket connection.
	
	@experimental
	*/
	close() {
		this.conn.close();
	}
};
function headersToMap$1(headers) {
	const headerMap = {};
	headers.forEach((value, key) => {
		headerMap[key] = value;
	});
	return headerMap;
}
function mapToHeaders$1(map) {
	const headers = new Headers();
	for (const [key, value] of Object.entries(map)) headers.append(key, value);
	return headers;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
const FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
/**
* Handles incoming messages from the WebSocket.
*
* @remarks
* This function is responsible for parsing incoming messages, transforming them
* into LiveServerMessages, and then calling the onmessage callback. Note that
* the first message which is received from the server is a setupComplete
* message.
*
* @param apiClient The ApiClient instance.
* @param onmessage The user-provided onmessage callback (if any).
* @param event The MessageEvent from the WebSocket.
*/
async function handleWebSocketMessage(apiClient, onmessage, event) {
	const serverMessage = new LiveServerMessage();
	let jsonData;
	if (event.data instanceof Blob) jsonData = await event.data.text();
	else if (event.data instanceof ArrayBuffer) jsonData = new TextDecoder().decode(event.data);
	else jsonData = event.data;
	const data = JSON.parse(jsonData);
	if (apiClient.isVertexAI()) {
		const resp = liveServerMessageFromVertex(data);
		Object.assign(serverMessage, resp);
	} else {
		const resp = data;
		Object.assign(serverMessage, resp);
	}
	onmessage(serverMessage);
}
/**
Live class encapsulates the configuration for live interaction with the
Generative Language API. It embeds ApiClient for general API settings.

@experimental
*/
var Live = class {
	constructor(apiClient, auth$2, webSocketFactory) {
		this.apiClient = apiClient;
		this.auth = auth$2;
		this.webSocketFactory = webSocketFactory;
		this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
	}
	/**
	Establishes a connection to the specified model with the given
	configuration and returns a Session object representing that connection.
	
	@experimental Built-in MCP support is an experimental feature, may change in
	future versions.
	
	@remarks
	
	@param params - The parameters for establishing a connection to the model.
	@return A live session.
	
	@example
	```ts
	let model: string;
	if (GOOGLE_GENAI_USE_VERTEXAI) {
	model = 'gemini-2.0-flash-live-preview-04-09';
	} else {
	model = 'gemini-live-2.5-flash-preview';
	}
	const session = await ai.live.connect({
	model: model,
	config: {
	responseModalities: [Modality.AUDIO],
	},
	callbacks: {
	onopen: () => {
	console.log('Connected to the socket.');
	},
	onmessage: (e: MessageEvent) => {
	console.log('Received message from the server: %s\n', debug(e.data));
	},
	onerror: (e: ErrorEvent) => {
	console.log('Error occurred: %s\n', debug(e.error));
	},
	onclose: (e: CloseEvent) => {
	console.log('Connection closed.');
	},
	},
	});
	```
	*/
	async connect(params) {
		var _a$2, _b, _c, _d, _e, _f;
		if (params.config && params.config.httpOptions) throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
		const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
		const apiVersion = this.apiClient.getApiVersion();
		let url;
		const clientHeaders = this.apiClient.getHeaders();
		if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) setMcpUsageHeader(clientHeaders);
		const headers = mapToHeaders(clientHeaders);
		if (this.apiClient.isVertexAI()) {
			url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
			await this.auth.addAuthHeaders(headers, url);
		} else {
			const apiKey = this.apiClient.getApiKey();
			let method = "BidiGenerateContent";
			let keyName = "key";
			if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith("auth_tokens/")) {
				console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
				if (apiVersion !== "v1alpha") console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
				method = "BidiGenerateContentConstrained";
				keyName = "access_token";
			}
			url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;
		}
		let onopenResolve = () => {};
		const onopenPromise = new Promise((resolve) => {
			onopenResolve = resolve;
		});
		const callbacks = params.callbacks;
		const onopenAwaitedCallback = function() {
			var _a$3;
			(_a$3 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a$3 === void 0 || _a$3.call(callbacks);
			onopenResolve({});
		};
		const apiClient = this.apiClient;
		const websocketCallbacks = {
			onopen: onopenAwaitedCallback,
			onmessage: (event) => {
				handleWebSocketMessage(apiClient, callbacks.onmessage, event);
			},
			onerror: (_a$2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a$2 !== void 0 ? _a$2 : function(e$1) {},
			onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e$1) {}
		};
		const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
		conn.connect();
		await onopenPromise;
		let transformedModel = tModel(this.apiClient, params.model);
		if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) transformedModel = `projects/${this.apiClient.getProject()}/locations/${this.apiClient.getLocation()}/` + transformedModel;
		let clientMessage = {};
		if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) if (params.config === void 0) params.config = { responseModalities: [Modality.AUDIO] };
		else params.config.responseModalities = [Modality.AUDIO];
		if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
		const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];
		const convertedTools = [];
		for (const tool of inputTools) if (this.isCallableTool(tool)) {
			const callableTool = tool;
			convertedTools.push(await callableTool.tool());
		} else convertedTools.push(tool);
		if (convertedTools.length > 0) params.config.tools = convertedTools;
		const liveConnectParameters = {
			model: transformedModel,
			config: params.config,
			callbacks: params.callbacks
		};
		if (this.apiClient.isVertexAI()) clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
		else clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
		delete clientMessage["config"];
		conn.send(JSON.stringify(clientMessage));
		return new Session(conn, this.apiClient);
	}
	isCallableTool(tool) {
		return "callTool" in tool && typeof tool.callTool === "function";
	}
};
const defaultLiveSendClientContentParamerters = { turnComplete: true };
/**
Represents a connection to the API.

@experimental
*/
var Session = class {
	constructor(conn, apiClient) {
		this.conn = conn;
		this.apiClient = apiClient;
	}
	tLiveClientContent(apiClient, params) {
		if (params.turns !== null && params.turns !== void 0) {
			let contents = [];
			try {
				contents = tContents(params.turns);
				if (!apiClient.isVertexAI()) contents = contents.map((item) => contentToMldev$1(item));
			} catch (_a$2) {
				throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
			}
			return { clientContent: {
				turns: contents,
				turnComplete: params.turnComplete
			} };
		}
		return { clientContent: { turnComplete: params.turnComplete } };
	}
	tLiveClienttToolResponse(apiClient, params) {
		let functionResponses = [];
		if (params.functionResponses == null) throw new Error("functionResponses is required.");
		if (!Array.isArray(params.functionResponses)) functionResponses = [params.functionResponses];
		else functionResponses = params.functionResponses;
		if (functionResponses.length === 0) throw new Error("functionResponses is required.");
		for (const functionResponse of functionResponses) {
			if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
			if (!apiClient.isVertexAI() && !("id" in functionResponse)) throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
		}
		return { toolResponse: { functionResponses } };
	}
	/**
	Send a message over the established connection.
	
	@param params - Contains two **optional** properties, `turns` and
	`turnComplete`.
	
	- `turns` will be converted to a `Content[]`
	- `turnComplete: true` [default] indicates that you are done sending
	content and expect a response. If `turnComplete: false`, the server
	will wait for additional messages before starting generation.
	
	@experimental
	
	@remarks
	There are two ways to send messages to the live API:
	`sendClientContent` and `sendRealtimeInput`.
	
	`sendClientContent` messages are added to the model context **in order**.
	Having a conversation using `sendClientContent` messages is roughly
	equivalent to using the `Chat.sendMessageStream`, except that the state of
	the `chat` history is stored on the API server instead of locally.
	
	Because of `sendClientContent`'s order guarantee, the model cannot respons
	as quickly to `sendClientContent` messages as to `sendRealtimeInput`
	messages. This makes the biggest difference when sending objects that have
	significant preprocessing time (typically images).
	
	The `sendClientContent` message sends a `Content[]`
	which has more options than the `Blob` sent by `sendRealtimeInput`.
	
	So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
	
	- Sending anything that can't be represented as a `Blob` (text,
	`sendClientContent({turns="Hello?"}`)).
	- Managing turns when not using audio input and voice activity detection.
	(`sendClientContent({turnComplete:true})` or the short form
	`sendClientContent()`)
	- Prefilling a conversation context
	```
	sendClientContent({
	turns: [
	Content({role:user, parts:...}),
	Content({role:user, parts:...}),
	...
	]
	})
	```
	@experimental
	*/
	sendClientContent(params) {
		params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
		const clientMessage = this.tLiveClientContent(this.apiClient, params);
		this.conn.send(JSON.stringify(clientMessage));
	}
	/**
	Send a realtime message over the established connection.
	
	@param params - Contains one property, `media`.
	
	- `media` will be converted to a `Blob`
	
	@experimental
	
	@remarks
	Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
	
	With `sendRealtimeInput` the api will respond to audio automatically
	based on voice activity detection (VAD).
	
	`sendRealtimeInput` is optimized for responsivness at the expense of
	deterministic ordering guarantees. Audio and video tokens are to the
	context when they become available.
	
	Note: The Call signature expects a `Blob` object, but only a subset
	of audio and image mimetypes are allowed.
	*/
	sendRealtimeInput(params) {
		let clientMessage = {};
		if (this.apiClient.isVertexAI()) clientMessage = { "realtimeInput": liveSendRealtimeInputParametersToVertex(params) };
		else clientMessage = { "realtimeInput": liveSendRealtimeInputParametersToMldev(params) };
		this.conn.send(JSON.stringify(clientMessage));
	}
	/**
	Send a function response message over the established connection.
	
	@param params - Contains property `functionResponses`.
	
	- `functionResponses` will be converted to a `functionResponses[]`
	
	@remarks
	Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
	
	Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
	
	@experimental
	*/
	sendToolResponse(params) {
		if (params.functionResponses == null) throw new Error("Tool response parameters are required.");
		const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
		this.conn.send(JSON.stringify(clientMessage));
	}
	/**
	Terminates the WebSocket connection.
	
	@experimental
	
	@example
	```ts
	let model: string;
	if (GOOGLE_GENAI_USE_VERTEXAI) {
	model = 'gemini-2.0-flash-live-preview-04-09';
	} else {
	model = 'gemini-live-2.5-flash-preview';
	}
	const session = await ai.live.connect({
	model: model,
	config: {
	responseModalities: [Modality.AUDIO],
	}
	});
	
	session.close();
	```
	*/
	close() {
		this.conn.close();
	}
};
function headersToMap(headers) {
	const headerMap = {};
	headers.forEach((value, key) => {
		headerMap[key] = value;
	});
	return headerMap;
}
function mapToHeaders(map) {
	const headers = new Headers();
	for (const [key, value] of Object.entries(map)) headers.append(key, value);
	return headers;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
const DEFAULT_MAX_REMOTE_CALLS = 10;
/** Returns whether automatic function calling is disabled. */
function shouldDisableAfc(config) {
	var _a$2, _b, _c;
	if ((_a$2 = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a$2 === void 0 ? void 0 : _a$2.disable) return true;
	let callableToolsPresent = false;
	for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) if (isCallableTool(tool)) {
		callableToolsPresent = true;
		break;
	}
	if (!callableToolsPresent) return true;
	const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
	if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
		console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
		return true;
	}
	return false;
}
function isCallableTool(tool) {
	return "callTool" in tool && typeof tool.callTool === "function";
}
function hasCallableTools(params) {
	var _a$2, _b, _c;
	return (_c = (_b = (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
}
/**
* Returns the indexes of the tools that are not compatible with AFC.
*/
function findAfcIncompatibleToolIndexes(params) {
	var _a$2;
	const afcIncompatibleToolIndexes = [];
	if (!((_a$2 = params === null || params === void 0 ? void 0 : params.config) === null || _a$2 === void 0 ? void 0 : _a$2.tools)) return afcIncompatibleToolIndexes;
	params.config.tools.forEach((tool, index) => {
		if (isCallableTool(tool)) return;
		const geminiTool = tool;
		if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) afcIncompatibleToolIndexes.push(index);
	});
	return afcIncompatibleToolIndexes;
}
/**
* Returns whether to append automatic function calling history to the
* response.
*/
function shouldAppendAfcHistory(config) {
	var _a$2;
	return !((_a$2 = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a$2 === void 0 ? void 0 : _a$2.ignoreCallHistory);
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var Models = class extends BaseModule {
	constructor(apiClient) {
		super();
		this.apiClient = apiClient;
		/**
		* Makes an API request to generate content with a given model.
		*
		* For the `model` parameter, supported formats for Vertex AI API include:
		* - The Gemini model ID, for example: 'gemini-2.0-flash'
		* - The full resource name starts with 'projects/', for example:
		*  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'
		* - The partial resource name with 'publishers/', for example:
		*  'publishers/google/models/gemini-2.0-flash' or
		*  'publishers/meta/models/llama-3.1-405b-instruct-maas'
		* - `/` separated publisher and model name, for example:
		* 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'
		*
		* For the `model` parameter, supported formats for Gemini API include:
		* - The Gemini model ID, for example: 'gemini-2.0-flash'
		* - The model name starts with 'models/', for example:
		*  'models/gemini-2.0-flash'
		* - For tuned models, the model name starts with 'tunedModels/',
		* for example:
		* 'tunedModels/1234567890123456789'
		*
		* Some models support multimodal input and output.
		*
		* @param params - The parameters for generating content.
		* @return The response from generating content.
		*
		* @example
		* ```ts
		* const response = await ai.models.generateContent({
		*   model: 'gemini-2.0-flash',
		*   contents: 'why is the sky blue?',
		*   config: {
		*     candidateCount: 2,
		*   }
		* });
		* console.log(response);
		* ```
		*/
		this.generateContent = async (params) => {
			var _a$2, _b, _c, _d, _e;
			const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
			this.maybeMoveToResponseJsonSchem(params);
			if (!hasCallableTools(params) || shouldDisableAfc(params.config)) return await this.generateContentInternal(transformedParams);
			const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
			if (incompatibleToolIndexes.length > 0) {
				const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
				throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);
			}
			let response;
			let functionResponseContent;
			const automaticFunctionCallingHistory = tContents(transformedParams.contents);
			const maxRemoteCalls = (_c = (_b = (_a$2 = transformedParams.config) === null || _a$2 === void 0 ? void 0 : _a$2.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
			let remoteCalls = 0;
			while (remoteCalls < maxRemoteCalls) {
				response = await this.generateContentInternal(transformedParams);
				if (!response.functionCalls || response.functionCalls.length === 0) break;
				const responseContent = response.candidates[0].content;
				const functionResponseParts = [];
				for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) if (isCallableTool(tool)) {
					const parts = await tool.callTool(response.functionCalls);
					functionResponseParts.push(...parts);
				}
				remoteCalls++;
				functionResponseContent = {
					role: "user",
					parts: functionResponseParts
				};
				transformedParams.contents = tContents(transformedParams.contents);
				transformedParams.contents.push(responseContent);
				transformedParams.contents.push(functionResponseContent);
				if (shouldAppendAfcHistory(transformedParams.config)) {
					automaticFunctionCallingHistory.push(responseContent);
					automaticFunctionCallingHistory.push(functionResponseContent);
				}
			}
			if (shouldAppendAfcHistory(transformedParams.config)) response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
			return response;
		};
		/**
		* Makes an API request to generate content with a given model and yields the
		* response in chunks.
		*
		* For the `model` parameter, supported formats for Vertex AI API include:
		* - The Gemini model ID, for example: 'gemini-2.0-flash'
		* - The full resource name starts with 'projects/', for example:
		*  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'
		* - The partial resource name with 'publishers/', for example:
		*  'publishers/google/models/gemini-2.0-flash' or
		*  'publishers/meta/models/llama-3.1-405b-instruct-maas'
		* - `/` separated publisher and model name, for example:
		* 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'
		*
		* For the `model` parameter, supported formats for Gemini API include:
		* - The Gemini model ID, for example: 'gemini-2.0-flash'
		* - The model name starts with 'models/', for example:
		*  'models/gemini-2.0-flash'
		* - For tuned models, the model name starts with 'tunedModels/',
		* for example:
		*  'tunedModels/1234567890123456789'
		*
		* Some models support multimodal input and output.
		*
		* @param params - The parameters for generating content with streaming response.
		* @return The response from generating content.
		*
		* @example
		* ```ts
		* const response = await ai.models.generateContentStream({
		*   model: 'gemini-2.0-flash',
		*   contents: 'why is the sky blue?',
		*   config: {
		*     maxOutputTokens: 200,
		*   }
		* });
		* for await (const chunk of response) {
		*   console.log(chunk);
		* }
		* ```
		*/
		this.generateContentStream = async (params) => {
			var _a$2, _b, _c, _d, _e;
			this.maybeMoveToResponseJsonSchem(params);
			if (shouldDisableAfc(params.config)) {
				const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
				return await this.generateContentStreamInternal(transformedParams);
			}
			const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
			if (incompatibleToolIndexes.length > 0) {
				const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
				throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`);
			}
			const streamFunctionCall = (_c = (_b = (_a$2 = params === null || params === void 0 ? void 0 : params.config) === null || _a$2 === void 0 ? void 0 : _a$2.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;
			const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;
			if (streamFunctionCall && !disableAfc) throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature.");
			return await this.processAfcStream(params);
		};
		/**
		* Generates an image based on a text description and configuration.
		*
		* @param params - The parameters for generating images.
		* @return The response from the API.
		*
		* @example
		* ```ts
		* const response = await client.models.generateImages({
		*  model: 'imagen-3.0-generate-002',
		*  prompt: 'Robot holding a red skateboard',
		*  config: {
		*    numberOfImages: 1,
		*    includeRaiReason: true,
		*  },
		* });
		* console.log(response?.generatedImages?.[0]?.image?.imageBytes);
		* ```
		*/
		this.generateImages = async (params) => {
			return await this.generateImagesInternal(params).then((apiResponse) => {
				var _a$2;
				let positivePromptSafetyAttributes;
				const generatedImages = [];
				if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) for (const generatedImage of apiResponse.generatedImages) if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a$2 = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a$2 === void 0 ? void 0 : _a$2.contentType) === "Positive Prompt") positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
				else generatedImages.push(generatedImage);
				let response;
				if (positivePromptSafetyAttributes) response = {
					generatedImages,
					positivePromptSafetyAttributes,
					sdkHttpResponse: apiResponse.sdkHttpResponse
				};
				else response = {
					generatedImages,
					sdkHttpResponse: apiResponse.sdkHttpResponse
				};
				return response;
			});
		};
		this.list = async (params) => {
			var _a$2;
			const actualParams = { config: Object.assign(Object.assign({}, { queryBase: true }), params === null || params === void 0 ? void 0 : params.config) };
			if (this.apiClient.isVertexAI()) {
				if (!actualParams.config.queryBase) if ((_a$2 = actualParams.config) === null || _a$2 === void 0 ? void 0 : _a$2.filter) throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
				else actualParams.config.filter = "labels.tune-type:*";
			}
			return new Pager(PagedItem.PAGED_ITEM_MODELS, (x$1) => this.listInternal(x$1), await this.listInternal(actualParams), actualParams);
		};
		/**
		* Edits an image based on a prompt, list of reference images, and configuration.
		*
		* @param params - The parameters for editing an image.
		* @return The response from the API.
		*
		* @example
		* ```ts
		* const response = await client.models.editImage({
		*  model: 'imagen-3.0-capability-001',
		*  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',
		*  referenceImages: [subjectReferenceImage]
		*  config: {
		*    numberOfImages: 1,
		*    includeRaiReason: true,
		*  },
		* });
		* console.log(response?.generatedImages?.[0]?.image?.imageBytes);
		* ```
		*/
		this.editImage = async (params) => {
			const paramsInternal = {
				model: params.model,
				prompt: params.prompt,
				referenceImages: [],
				config: params.config
			};
			if (params.referenceImages) {
				if (params.referenceImages) paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
			}
			return await this.editImageInternal(paramsInternal);
		};
		/**
		* Upscales an image based on an image, upscale factor, and configuration.
		* Only supported in Vertex AI currently.
		*
		* @param params - The parameters for upscaling an image.
		* @return The response from the API.
		*
		* @example
		* ```ts
		* const response = await client.models.upscaleImage({
		*  model: 'imagen-3.0-generate-002',
		*  image: image,
		*  upscaleFactor: 'x2',
		*  config: {
		*    includeRaiReason: true,
		*  },
		* });
		* console.log(response?.generatedImages?.[0]?.image?.imageBytes);
		* ```
		*/
		this.upscaleImage = async (params) => {
			let apiConfig = {
				numberOfImages: 1,
				mode: "upscale"
			};
			if (params.config) apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
			const apiParams = {
				model: params.model,
				image: params.image,
				upscaleFactor: params.upscaleFactor,
				config: apiConfig
			};
			return await this.upscaleImageInternal(apiParams);
		};
		/**
		*  Generates videos based on a text description and configuration.
		*
		* @param params - The parameters for generating videos.
		* @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.
		*
		* @example
		* ```ts
		* const operation = await ai.models.generateVideos({
		*  model: 'veo-2.0-generate-001',
		*  source: {
		*    prompt: 'A neon hologram of a cat driving at top speed',
		*  },
		*  config: {
		*    numberOfVideos: 1
		* });
		*
		* while (!operation.done) {
		*   await new Promise(resolve => setTimeout(resolve, 10000));
		*   operation = await ai.operations.getVideosOperation({operation: operation});
		* }
		*
		* console.log(operation.response?.generatedVideos?.[0]?.video?.uri);
		* ```
		*/
		this.generateVideos = async (params) => {
			var _a$2, _b, _c, _d, _e, _f;
			if ((params.prompt || params.image || params.video) && params.source) throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
			if (!this.apiClient.isVertexAI()) {
				if (((_a$2 = params.video) === null || _a$2 === void 0 ? void 0 : _a$2.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) params.video = {
					uri: params.video.uri,
					mimeType: params.video.mimeType
				};
				else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) params.source.video = {
					uri: params.source.video.uri,
					mimeType: params.source.video.mimeType
				};
			}
			return await this.generateVideosInternal(params);
		};
	}
	/**
	* This logic is needed for GenerateContentConfig only.
	* Previously we made GenerateContentConfig.responseSchema field to accept
	* unknown. Since v1.9.0, we switch to use backend JSON schema support.
	* To maintain backward compatibility, we move the data that was treated as
	* JSON schema from the responseSchema field to the responseJsonSchema field.
	*/
	maybeMoveToResponseJsonSchem(params) {
		if (params.config && params.config.responseSchema) {
			if (!params.config.responseJsonSchema) {
				if (Object.keys(params.config.responseSchema).includes("$schema")) {
					params.config.responseJsonSchema = params.config.responseSchema;
					delete params.config.responseSchema;
				}
			}
		}
	}
	/**
	* Transforms the CallableTools in the parameters to be simply Tools, it
	* copies the params into a new object and replaces the tools, it does not
	* modify the original params. Also sets the MCP usage header if there are
	* MCP tools in the parameters.
	*/
	async processParamsMaybeAddMcpUsage(params) {
		var _a$2, _b, _c;
		const tools = (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.tools;
		if (!tools) return params;
		const transformedTools = await Promise.all(tools.map(async (tool) => {
			if (isCallableTool(tool)) return await tool.tool();
			return tool;
		}));
		const newParams = {
			model: params.model,
			contents: params.contents,
			config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
		};
		newParams.config.tools = transformedTools;
		if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
			const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
			let newHeaders = Object.assign({}, headers);
			if (Object.keys(newHeaders).length === 0) newHeaders = this.apiClient.getDefaultHeaders();
			setMcpUsageHeader(newHeaders);
			newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
		}
		return newParams;
	}
	async initAfcToolsMap(params) {
		var _a$2, _b, _c;
		const afcTools = /* @__PURE__ */ new Map();
		for (const tool of (_b = (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.tools) !== null && _b !== void 0 ? _b : []) if (isCallableTool(tool)) {
			const callableTool = tool;
			const toolDeclaration = await callableTool.tool();
			for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
				if (!declaration.name) throw new Error("Function declaration name is required.");
				if (afcTools.has(declaration.name)) throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
				afcTools.set(declaration.name, callableTool);
			}
		}
		return afcTools;
	}
	async processAfcStream(params) {
		var _a$2, _b, _c;
		const maxRemoteCalls = (_c = (_b = (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
		let wereFunctionsCalled = false;
		let remoteCallCount = 0;
		const afcToolsMap = await this.initAfcToolsMap(params);
		return (function(models, afcTools, params$1) {
			var _a$3, _b$1;
			return __asyncGenerator(this, arguments, function* () {
				var _c$1, e_1, _d, _e;
				while (remoteCallCount < maxRemoteCalls) {
					if (wereFunctionsCalled) {
						remoteCallCount++;
						wereFunctionsCalled = false;
					}
					const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params$1));
					const response = yield __await(models.generateContentStreamInternal(transformedParams));
					const functionResponses = [];
					const responseContents = [];
					try {
						for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c$1 = response_1_1.done, !_c$1; _f = true) {
							_e = response_1_1.value;
							_f = false;
							const chunk = _e;
							yield yield __await(chunk);
							if (chunk.candidates && ((_a$3 = chunk.candidates[0]) === null || _a$3 === void 0 ? void 0 : _a$3.content)) {
								responseContents.push(chunk.candidates[0].content);
								for (const part of (_b$1 = chunk.candidates[0].content.parts) !== null && _b$1 !== void 0 ? _b$1 : []) if (remoteCallCount < maxRemoteCalls && part.functionCall) {
									if (!part.functionCall.name) throw new Error("Function call name was not returned by the model.");
									if (!afcTools.has(part.functionCall.name)) throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
									else {
										const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
										functionResponses.push(...responseParts);
									}
								}
							}
						}
					} catch (e_1_1) {
						e_1 = { error: e_1_1 };
					} finally {
						try {
							if (!_f && !_c$1 && (_d = response_1.return)) yield __await(_d.call(response_1));
						} finally {
							if (e_1) throw e_1.error;
						}
					}
					if (functionResponses.length > 0) {
						wereFunctionsCalled = true;
						const typedResponseChunk = new GenerateContentResponse();
						typedResponseChunk.candidates = [{ content: {
							role: "user",
							parts: functionResponses
						} }];
						yield yield __await(typedResponseChunk);
						const newContents = [];
						newContents.push(...responseContents);
						newContents.push({
							role: "user",
							parts: functionResponses
						});
						params$1.contents = tContents(params$1.contents).concat(newContents);
					} else break;
				}
			});
		})(this, afcToolsMap, params);
	}
	async generateContentInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = generateContentParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:generateContent", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = generateContentResponseFromVertex(apiResponse);
				const typedResp = new GenerateContentResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = generateContentParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{model}:generateContent", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = generateContentResponseFromMldev(apiResponse);
				const typedResp = new GenerateContentResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	async generateContentStreamInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = generateContentParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.requestStream({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			});
			return response.then(function(apiResponse) {
				return __asyncGenerator(this, arguments, function* () {
					var _a$3, e_2, _b$1, _c$1;
					try {
						for (var _d$1 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a$3 = apiResponse_1_1.done, !_a$3; _d$1 = true) {
							_c$1 = apiResponse_1_1.value;
							_d$1 = false;
							const chunk = _c$1;
							const resp = generateContentResponseFromVertex(yield __await(chunk.json()));
							resp["sdkHttpResponse"] = { headers: chunk.headers };
							const typedResp = new GenerateContentResponse();
							Object.assign(typedResp, resp);
							yield yield __await(typedResp);
						}
					} catch (e_2_1) {
						e_2 = { error: e_2_1 };
					} finally {
						try {
							if (!_d$1 && !_a$3 && (_b$1 = apiResponse_1.return)) yield __await(_b$1.call(apiResponse_1));
						} finally {
							if (e_2) throw e_2.error;
						}
					}
				});
			});
		} else {
			const body = generateContentParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.requestStream({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			});
			return response.then(function(apiResponse) {
				return __asyncGenerator(this, arguments, function* () {
					var _a$3, e_3, _b$1, _c$1;
					try {
						for (var _d$1 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a$3 = apiResponse_2_1.done, !_a$3; _d$1 = true) {
							_c$1 = apiResponse_2_1.value;
							_d$1 = false;
							const chunk = _c$1;
							const resp = generateContentResponseFromMldev(yield __await(chunk.json()));
							resp["sdkHttpResponse"] = { headers: chunk.headers };
							const typedResp = new GenerateContentResponse();
							Object.assign(typedResp, resp);
							yield yield __await(typedResp);
						}
					} catch (e_3_1) {
						e_3 = { error: e_3_1 };
					} finally {
						try {
							if (!_d$1 && !_a$3 && (_b$1 = apiResponse_2.return)) yield __await(_b$1.call(apiResponse_2));
						} finally {
							if (e_3) throw e_3.error;
						}
					}
				});
			});
		}
	}
	/**
	* Calculates embeddings for the given contents. Only text is supported.
	*
	* @param params - The parameters for embedding contents.
	* @return The response from the API.
	*
	* @example
	* ```ts
	* const response = await ai.models.embedContent({
	*  model: 'text-embedding-004',
	*  contents: [
	*    'What is your name?',
	*    'What is your favorite color?',
	*  ],
	*  config: {
	*    outputDimensionality: 64,
	*  },
	* });
	* console.log(response);
	* ```
	*/
	async embedContent(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = embedContentParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:predict", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = embedContentResponseFromVertex(apiResponse);
				const typedResp = new EmbedContentResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = embedContentParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{model}:batchEmbedContents", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = embedContentResponseFromMldev(apiResponse);
				const typedResp = new EmbedContentResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Private method for generating images.
	*/
	async generateImagesInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = generateImagesParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:predict", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = generateImagesResponseFromVertex(apiResponse);
				const typedResp = new GenerateImagesResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = generateImagesParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{model}:predict", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = generateImagesResponseFromMldev(apiResponse);
				const typedResp = new GenerateImagesResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Private method for editing an image.
	*/
	async editImageInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = editImageParametersInternalToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:predict", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = editImageResponseFromVertex(apiResponse);
				const typedResp = new EditImageResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else throw new Error("This method is only supported by the Vertex AI.");
	}
	/**
	* Private method for upscaling an image.
	*/
	async upscaleImageInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:predict", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = upscaleImageResponseFromVertex(apiResponse);
				const typedResp = new UpscaleImageResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else throw new Error("This method is only supported by the Vertex AI.");
	}
	/**
	* Recontextualizes an image.
	*
	* There are two types of recontextualization currently supported:
	* 1) Imagen Product Recontext - Generate images of products in new scenes
	*    and contexts.
	* 2) Virtual Try-On: Generate images of persons modeling fashion products.
	*
	* @param params - The parameters for recontextualizing an image.
	* @return The response from the API.
	*
	* @example
	* ```ts
	* const response1 = await ai.models.recontextImage({
	*  model: 'imagen-product-recontext-preview-06-30',
	*  source: {
	*    prompt: 'In a modern kitchen setting.',
	*    productImages: [productImage],
	*  },
	*  config: {
	*    numberOfImages: 1,
	*  },
	* });
	* console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
	*
	* const response2 = await ai.models.recontextImage({
	*  model: 'virtual-try-on-preview-08-04',
	*  source: {
	*    personImage: personImage,
	*    productImages: [productImage],
	*  },
	*  config: {
	*    numberOfImages: 1,
	*  },
	* });
	* console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
	* ```
	*/
	async recontextImage(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = recontextImageParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:predict", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				const resp = recontextImageResponseFromVertex(apiResponse);
				const typedResp = new RecontextImageResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else throw new Error("This method is only supported by the Vertex AI.");
	}
	/**
	* Segments an image, creating a mask of a specified area.
	*
	* @param params - The parameters for segmenting an image.
	* @return The response from the API.
	*
	* @example
	* ```ts
	* const response = await ai.models.segmentImage({
	*  model: 'image-segmentation-001',
	*  source: {
	*    image: image,
	*  },
	*  config: {
	*    mode: 'foreground',
	*  },
	* });
	* console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);
	* ```
	*/
	async segmentImage(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = segmentImageParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:predict", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				const resp = segmentImageResponseFromVertex(apiResponse);
				const typedResp = new SegmentImageResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else throw new Error("This method is only supported by the Vertex AI.");
	}
	/**
	* Fetches information about a model by name.
	*
	* @example
	* ```ts
	* const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
	* ```
	*/
	async get(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = getModelParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				return modelFromVertex(apiResponse);
			});
		} else {
			const body = getModelParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				return modelFromMldev(apiResponse);
			});
		}
	}
	async listInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = listModelsParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{models_url}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = listModelsResponseFromVertex(apiResponse);
				const typedResp = new ListModelsResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = listModelsParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{models_url}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = listModelsResponseFromMldev(apiResponse);
				const typedResp = new ListModelsResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Updates a tuned model by its name.
	*
	* @param params - The parameters for updating the model.
	* @return The response from the API.
	*
	* @example
	* ```ts
	* const response = await ai.models.update({
	*   model: 'tuned-model-name',
	*   config: {
	*     displayName: 'New display name',
	*     description: 'New description',
	*   },
	* });
	* ```
	*/
	async update(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = updateModelParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "PATCH",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				return modelFromVertex(apiResponse);
			});
		} else {
			const body = updateModelParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "PATCH",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				return modelFromMldev(apiResponse);
			});
		}
	}
	/**
	* Deletes a tuned model by its name.
	*
	* @param params - The parameters for deleting the model.
	* @return The response from the API.
	*
	* @example
	* ```ts
	* const response = await ai.models.delete({model: 'tuned-model-name'});
	* ```
	*/
	async delete(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = deleteModelParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "DELETE",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = deleteModelResponseFromVertex(apiResponse);
				const typedResp = new DeleteModelResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = deleteModelParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "DELETE",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = deleteModelResponseFromMldev(apiResponse);
				const typedResp = new DeleteModelResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Counts the number of tokens in the given contents. Multimodal input is
	* supported for Gemini models.
	*
	* @param params - The parameters for counting tokens.
	* @return The response from the API.
	*
	* @example
	* ```ts
	* const response = await ai.models.countTokens({
	*  model: 'gemini-2.0-flash',
	*  contents: 'The quick brown fox jumps over the lazy dog.'
	* });
	* console.log(response);
	* ```
	*/
	async countTokens(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = countTokensParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:countTokens", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = countTokensResponseFromVertex(apiResponse);
				const typedResp = new CountTokensResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = countTokensParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{model}:countTokens", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = countTokensResponseFromMldev(apiResponse);
				const typedResp = new CountTokensResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Given a list of contents, returns a corresponding TokensInfo containing
	* the list of tokens and list of token ids.
	*
	* This method is not supported by the Gemini Developer API.
	*
	* @param params - The parameters for computing tokens.
	* @return The response from the API.
	*
	* @example
	* ```ts
	* const response = await ai.models.computeTokens({
	*  model: 'gemini-2.0-flash',
	*  contents: 'What is your name?'
	* });
	* console.log(response);
	* ```
	*/
	async computeTokens(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = computeTokensParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:computeTokens", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = computeTokensResponseFromVertex(apiResponse);
				const typedResp = new ComputeTokensResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else throw new Error("This method is only supported by the Vertex AI.");
	}
	/**
	* Private method for generating videos.
	*/
	async generateVideosInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = generateVideosParametersToVertex(this.apiClient, params);
			path$9 = formatMap("{model}:predictLongRunning", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				const resp = generateVideosOperationFromVertex(apiResponse);
				const typedResp = new GenerateVideosOperation();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = generateVideosParametersToMldev(this.apiClient, params);
			path$9 = formatMap("{model}:predictLongRunning", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				const resp = generateVideosOperationFromMldev(apiResponse);
				const typedResp = new GenerateVideosOperation();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var Operations = class extends BaseModule {
	constructor(apiClient) {
		super();
		this.apiClient = apiClient;
	}
	/**
	* Gets the status of a long-running operation.
	*
	* @param parameters The parameters for the get operation request.
	* @return The updated Operation object, with the latest status or result.
	*/
	async getVideosOperation(parameters) {
		const operation = parameters.operation;
		const config = parameters.config;
		if (operation.name === void 0 || operation.name === "") throw new Error("Operation name is required.");
		if (this.apiClient.isVertexAI()) {
			const resourceName$1 = operation.name.split("/operations/")[0];
			let httpOptions = void 0;
			if (config && "httpOptions" in config) httpOptions = config.httpOptions;
			const rawOperation = await this.fetchPredictVideosOperationInternal({
				operationName: operation.name,
				resourceName: resourceName$1,
				config: { httpOptions }
			});
			return operation._fromAPIResponse({
				apiResponse: rawOperation,
				_isVertexAI: true
			});
		} else {
			const rawOperation = await this.getVideosOperationInternal({
				operationName: operation.name,
				config
			});
			return operation._fromAPIResponse({
				apiResponse: rawOperation,
				_isVertexAI: false
			});
		}
	}
	/**
	* Gets the status of a long-running operation.
	*
	* @param parameters The parameters for the get operation request.
	* @return The updated Operation object, with the latest status or result.
	*/
	async get(parameters) {
		const operation = parameters.operation;
		const config = parameters.config;
		if (operation.name === void 0 || operation.name === "") throw new Error("Operation name is required.");
		if (this.apiClient.isVertexAI()) {
			const resourceName$1 = operation.name.split("/operations/")[0];
			let httpOptions = void 0;
			if (config && "httpOptions" in config) httpOptions = config.httpOptions;
			const rawOperation = await this.fetchPredictVideosOperationInternal({
				operationName: operation.name,
				resourceName: resourceName$1,
				config: { httpOptions }
			});
			return operation._fromAPIResponse({
				apiResponse: rawOperation,
				_isVertexAI: true
			});
		} else {
			const rawOperation = await this.getVideosOperationInternal({
				operationName: operation.name,
				config
			});
			return operation._fromAPIResponse({
				apiResponse: rawOperation,
				_isVertexAI: false
			});
		}
	}
	async getVideosOperationInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = getOperationParametersToVertex(params);
			path$9 = formatMap("{operationName}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response;
		} else {
			const body = getOperationParametersToMldev(params);
			path$9 = formatMap("{operationName}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response;
		}
	}
	async fetchPredictVideosOperationInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = fetchPredictOperationParametersToVertex(params);
			path$9 = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response;
		} else throw new Error("This method is only supported by the Vertex AI.");
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function blobToMldev(fromObject) {
	const toObject = {};
	const fromData = getValueByPath(fromObject, ["data"]);
	if (fromData != null) setValueByPath(toObject, ["data"], fromData);
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function contentToMldev(fromObject) {
	const toObject = {};
	const fromParts = getValueByPath(fromObject, ["parts"]);
	if (fromParts != null) {
		let transformedList = fromParts;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return partToMldev(item);
		});
		setValueByPath(toObject, ["parts"], transformedList);
	}
	const fromRole = getValueByPath(fromObject, ["role"]);
	if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
	return toObject;
}
function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
	const toObject = {};
	const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
	if (parentObject !== void 0 && fromExpireTime != null) setValueByPath(parentObject, ["expireTime"], fromExpireTime);
	const fromNewSessionExpireTime = getValueByPath(fromObject, ["newSessionExpireTime"]);
	if (parentObject !== void 0 && fromNewSessionExpireTime != null) setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
	const fromUses = getValueByPath(fromObject, ["uses"]);
	if (parentObject !== void 0 && fromUses != null) setValueByPath(parentObject, ["uses"], fromUses);
	const fromLiveConnectConstraints = getValueByPath(fromObject, ["liveConnectConstraints"]);
	if (parentObject !== void 0 && fromLiveConnectConstraints != null) setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
	const fromLockAdditionalFields = getValueByPath(fromObject, ["lockAdditionalFields"]);
	if (parentObject !== void 0 && fromLockAdditionalFields != null) setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
	return toObject;
}
function createAuthTokenParametersToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
	return toObject;
}
function fileDataToMldev(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API.");
	const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
	if (fromFileUri != null) setValueByPath(toObject, ["fileUri"], fromFileUri);
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
	return toObject;
}
function functionCallToMldev(fromObject) {
	const toObject = {};
	const fromId = getValueByPath(fromObject, ["id"]);
	if (fromId != null) setValueByPath(toObject, ["id"], fromId);
	const fromArgs = getValueByPath(fromObject, ["args"]);
	if (fromArgs != null) setValueByPath(toObject, ["args"], fromArgs);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API.");
	return toObject;
}
function googleMapsToMldev(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API.");
	const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
	if (fromEnableWidget != null) setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
	return toObject;
}
function googleSearchToMldev(fromObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API.");
	const fromTimeRangeFilter = getValueByPath(fromObject, ["timeRangeFilter"]);
	if (fromTimeRangeFilter != null) setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
	return toObject;
}
function liveConnectConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromGenerationConfig = getValueByPath(fromObject, ["generationConfig"]);
	if (parentObject !== void 0 && fromGenerationConfig != null) setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
	const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
	if (parentObject !== void 0 && fromResponseModalities != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"responseModalities"
	], fromResponseModalities);
	const fromTemperature = getValueByPath(fromObject, ["temperature"]);
	if (parentObject !== void 0 && fromTemperature != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"temperature"
	], fromTemperature);
	const fromTopP = getValueByPath(fromObject, ["topP"]);
	if (parentObject !== void 0 && fromTopP != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"topP"
	], fromTopP);
	const fromTopK = getValueByPath(fromObject, ["topK"]);
	if (parentObject !== void 0 && fromTopK != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"topK"
	], fromTopK);
	const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
	if (parentObject !== void 0 && fromMaxOutputTokens != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"maxOutputTokens"
	], fromMaxOutputTokens);
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (parentObject !== void 0 && fromMediaResolution != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"mediaResolution"
	], fromMediaResolution);
	const fromSeed = getValueByPath(fromObject, ["seed"]);
	if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"seed"
	], fromSeed);
	const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
	if (parentObject !== void 0 && fromSpeechConfig != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"speechConfig"
	], tLiveSpeechConfig(fromSpeechConfig));
	const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
	if (parentObject !== void 0 && fromThinkingConfig != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"thinkingConfig"
	], fromThinkingConfig);
	const fromEnableAffectiveDialog = getValueByPath(fromObject, ["enableAffectiveDialog"]);
	if (parentObject !== void 0 && fromEnableAffectiveDialog != null) setValueByPath(parentObject, [
		"setup",
		"generationConfig",
		"enableAffectiveDialog"
	], fromEnableAffectiveDialog);
	const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
	if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
	const fromTools = getValueByPath(fromObject, ["tools"]);
	if (parentObject !== void 0 && fromTools != null) {
		let transformedList = tTools(fromTools);
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return toolToMldev(tTool(item));
		});
		setValueByPath(parentObject, ["setup", "tools"], transformedList);
	}
	const fromSessionResumption = getValueByPath(fromObject, ["sessionResumption"]);
	if (parentObject !== void 0 && fromSessionResumption != null) setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
	const fromInputAudioTranscription = getValueByPath(fromObject, ["inputAudioTranscription"]);
	if (parentObject !== void 0 && fromInputAudioTranscription != null) setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
	const fromOutputAudioTranscription = getValueByPath(fromObject, ["outputAudioTranscription"]);
	if (parentObject !== void 0 && fromOutputAudioTranscription != null) setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
	const fromRealtimeInputConfig = getValueByPath(fromObject, ["realtimeInputConfig"]);
	if (parentObject !== void 0 && fromRealtimeInputConfig != null) setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
	const fromContextWindowCompression = getValueByPath(fromObject, ["contextWindowCompression"]);
	if (parentObject !== void 0 && fromContextWindowCompression != null) setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
	const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
	if (parentObject !== void 0 && fromProactivity != null) setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
	return toObject;
}
function liveConnectConstraintsToMldev(apiClient, fromObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["model"]);
	if (fromModel != null) setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
	return toObject;
}
function partToMldev(fromObject) {
	const toObject = {};
	const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
	if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
	const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
	if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
	const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
	if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
	const fromFileData = getValueByPath(fromObject, ["fileData"]);
	if (fromFileData != null) setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
	const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
	if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], functionCallToMldev(fromFunctionCall));
	const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
	if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
	const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
	if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
	const fromText = getValueByPath(fromObject, ["text"]);
	if (fromText != null) setValueByPath(toObject, ["text"], fromText);
	const fromThought = getValueByPath(fromObject, ["thought"]);
	if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
	const fromThoughtSignature = getValueByPath(fromObject, ["thoughtSignature"]);
	if (fromThoughtSignature != null) setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
	const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
	if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
	return toObject;
}
function sessionResumptionConfigToMldev(fromObject) {
	const toObject = {};
	const fromHandle = getValueByPath(fromObject, ["handle"]);
	if (fromHandle != null) setValueByPath(toObject, ["handle"], fromHandle);
	if (getValueByPath(fromObject, ["transparent"]) !== void 0) throw new Error("transparent parameter is not supported in Gemini API.");
	return toObject;
}
function toolToMldev(fromObject) {
	const toObject = {};
	const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
	if (fromFunctionDeclarations != null) {
		let transformedList = fromFunctionDeclarations;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["functionDeclarations"], transformedList);
	}
	if (getValueByPath(fromObject, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
	const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
	if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
	const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
	if (fromComputerUse != null) setValueByPath(toObject, ["computerUse"], fromComputerUse);
	const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
	if (fromFileSearch != null) setValueByPath(toObject, ["fileSearch"], fromFileSearch);
	const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
	if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
	if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
	const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
	if (fromGoogleMaps != null) setValueByPath(toObject, ["googleMaps"], googleMapsToMldev(fromGoogleMaps));
	const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
	if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
	const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
	if (fromUrlContext != null) setValueByPath(toObject, ["urlContext"], fromUrlContext);
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
/**
* Returns a comma-separated list of field masks from a given object.
*
* @param setup The object to extract field masks from.
* @return A comma-separated list of field masks.
*/
function getFieldMasks(setup$1) {
	const fields = [];
	for (const key in setup$1) if (Object.prototype.hasOwnProperty.call(setup$1, key)) {
		const value = setup$1[key];
		if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
			const field = Object.keys(value).map((kk) => `${key}.${kk}`);
			fields.push(...field);
		} else fields.push(key);
	}
	return fields.join(",");
}
/**
* Converts bidiGenerateContentSetup.
* @param requestDict - The request dictionary.
* @param config - The configuration object.
* @return - The modified request dictionary.
*/
function convertBidiSetupToTokenSetup(requestDict, config) {
	let setupForMaskGeneration = null;
	const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
	if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
		const innerSetup = bidiGenerateContentSetupValue.setup;
		if (typeof innerSetup === "object" && innerSetup !== null) {
			requestDict["bidiGenerateContentSetup"] = innerSetup;
			setupForMaskGeneration = innerSetup;
		} else delete requestDict["bidiGenerateContentSetup"];
	} else if (bidiGenerateContentSetupValue !== void 0) delete requestDict["bidiGenerateContentSetup"];
	const preExistingFieldMask = requestDict["fieldMask"];
	if (setupForMaskGeneration) {
		const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
		if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) if (generatedMaskFromBidi) requestDict["fieldMask"] = generatedMaskFromBidi;
		else delete requestDict["fieldMask"];
		else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
			const generationConfigFields = [
				"temperature",
				"topK",
				"topP",
				"maxOutputTokens",
				"responseModalities",
				"seed",
				"speechConfig"
			];
			let mappedFieldsFromPreExisting = [];
			if (preExistingFieldMask.length > 0) mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
				if (generationConfigFields.includes(field)) return `generationConfig.${field}`;
				return field;
			});
			const finalMaskParts = [];
			if (generatedMaskFromBidi) finalMaskParts.push(generatedMaskFromBidi);
			if (mappedFieldsFromPreExisting.length > 0) finalMaskParts.push(...mappedFieldsFromPreExisting);
			if (finalMaskParts.length > 0) requestDict["fieldMask"] = finalMaskParts.join(",");
			else delete requestDict["fieldMask"];
		} else delete requestDict["fieldMask"];
	} else if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) requestDict["fieldMask"] = preExistingFieldMask.join(",");
	else delete requestDict["fieldMask"];
	return requestDict;
}
var Tokens = class extends BaseModule {
	constructor(apiClient) {
		super();
		this.apiClient = apiClient;
	}
	/**
	* Creates an ephemeral auth token resource.
	*
	* @experimental
	*
	* @remarks
	* Ephemeral auth tokens is only supported in the Gemini Developer API.
	* It can be used for the session connection to the Live constrained API.
	* Support in v1alpha only.
	*
	* @param params - The parameters for the create request.
	* @return The created auth token.
	*
	* @example
	* ```ts
	* const ai = new GoogleGenAI({
	*     apiKey: token.name,
	*     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
	* });
	*
	* // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
	* // when using the token in Live API sessions. Each session connection can
	* // use a different configuration.
	* const config: CreateAuthTokenConfig = {
	*     uses: 3,
	*     expireTime: '2025-05-01T00:00:00Z',
	* }
	* const token = await ai.tokens.create(config);
	*
	* // Case 2: If LiveEphemeralParameters is set, lock all fields in
	* // LiveConnectConfig when using the token in Live API sessions. For
	* // example, changing `outputAudioTranscription` in the Live API
	* // connection will be ignored by the API.
	* const config: CreateAuthTokenConfig =
	*     uses: 3,
	*     expireTime: '2025-05-01T00:00:00Z',
	*     LiveEphemeralParameters: {
	*        model: 'gemini-2.0-flash-001',
	*        config: {
	*           'responseModalities': ['AUDIO'],
	*           'systemInstruction': 'Always answer in English.',
	*        }
	*     }
	* }
	* const token = await ai.tokens.create(config);
	*
	* // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
	* // set, lock LiveConnectConfig with set and additional fields (e.g.
	* // responseModalities, systemInstruction, temperature in this example) when
	* // using the token in Live API sessions.
	* const config: CreateAuthTokenConfig =
	*     uses: 3,
	*     expireTime: '2025-05-01T00:00:00Z',
	*     LiveEphemeralParameters: {
	*        model: 'gemini-2.0-flash-001',
	*        config: {
	*           'responseModalities': ['AUDIO'],
	*           'systemInstruction': 'Always answer in English.',
	*        }
	*     },
	*     lockAdditionalFields: ['temperature'],
	* }
	* const token = await ai.tokens.create(config);
	*
	* // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
	* // empty array, lock LiveConnectConfig with set fields (e.g.
	* // responseModalities, systemInstruction in this example) when using the
	* // token in Live API sessions.
	* const config: CreateAuthTokenConfig =
	*     uses: 3,
	*     expireTime: '2025-05-01T00:00:00Z',
	*     LiveEphemeralParameters: {
	*        model: 'gemini-2.0-flash-001',
	*        config: {
	*           'responseModalities': ['AUDIO'],
	*           'systemInstruction': 'Always answer in English.',
	*        }
	*     },
	*     lockAdditionalFields: [],
	* }
	* const token = await ai.tokens.create(config);
	* ```
	*/
	async create(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
		else {
			const body = createAuthTokenParametersToMldev(this.apiClient, params);
			path$9 = formatMap("auth_tokens", body["_url"]);
			queryParams = body["_query"];
			delete body["config"];
			delete body["_url"];
			delete body["_query"];
			const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(transformedBody),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		}
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function createFileSearchStoreConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["displayName"], fromDisplayName);
	return toObject;
}
function createFileSearchStoreParametersToMldev(fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) createFileSearchStoreConfigToMldev(fromConfig, toObject);
	return toObject;
}
function deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromForce = getValueByPath(fromObject, ["force"]);
	if (parentObject !== void 0 && fromForce != null) setValueByPath(parentObject, ["_query", "force"], fromForce);
	return toObject;
}
function deleteFileSearchStoreParametersToMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], fromName);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) deleteFileSearchStoreConfigToMldev(fromConfig, toObject);
	return toObject;
}
function getFileSearchStoreParametersToMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], fromName);
	return toObject;
}
function importFileConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromCustomMetadata = getValueByPath(fromObject, ["customMetadata"]);
	if (parentObject !== void 0 && fromCustomMetadata != null) {
		let transformedList = fromCustomMetadata;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(parentObject, ["customMetadata"], transformedList);
	}
	const fromChunkingConfig = getValueByPath(fromObject, ["chunkingConfig"]);
	if (parentObject !== void 0 && fromChunkingConfig != null) setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
	return toObject;
}
function importFileOperationFromMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	const fromResponse = getValueByPath(fromObject, ["response"]);
	if (fromResponse != null) setValueByPath(toObject, ["response"], importFileResponseFromMldev(fromResponse));
	return toObject;
}
function importFileParametersToMldev(fromObject) {
	const toObject = {};
	const fromFileSearchStoreName = getValueByPath(fromObject, ["fileSearchStoreName"]);
	if (fromFileSearchStoreName != null) setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
	const fromFileName = getValueByPath(fromObject, ["fileName"]);
	if (fromFileName != null) setValueByPath(toObject, ["fileName"], fromFileName);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) importFileConfigToMldev(fromConfig, toObject);
	return toObject;
}
function importFileResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromParent = getValueByPath(fromObject, ["parent"]);
	if (fromParent != null) setValueByPath(toObject, ["parent"], fromParent);
	const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
	if (fromDocumentName != null) setValueByPath(toObject, ["documentName"], fromDocumentName);
	return toObject;
}
function listFileSearchStoresConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	return toObject;
}
function listFileSearchStoresParametersToMldev(fromObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listFileSearchStoresConfigToMldev(fromConfig, toObject);
	return toObject;
}
function listFileSearchStoresResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromFileSearchStores = getValueByPath(fromObject, ["fileSearchStores"]);
	if (fromFileSearchStores != null) {
		let transformedList = fromFileSearchStores;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["fileSearchStores"], transformedList);
	}
	return toObject;
}
function uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
	if (parentObject !== void 0 && fromMimeType != null) setValueByPath(parentObject, ["mimeType"], fromMimeType);
	const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
	if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["displayName"], fromDisplayName);
	const fromCustomMetadata = getValueByPath(fromObject, ["customMetadata"]);
	if (parentObject !== void 0 && fromCustomMetadata != null) {
		let transformedList = fromCustomMetadata;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(parentObject, ["customMetadata"], transformedList);
	}
	const fromChunkingConfig = getValueByPath(fromObject, ["chunkingConfig"]);
	if (parentObject !== void 0 && fromChunkingConfig != null) setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
	return toObject;
}
function uploadToFileSearchStoreParametersToMldev(fromObject) {
	const toObject = {};
	const fromFileSearchStoreName = getValueByPath(fromObject, ["fileSearchStoreName"]);
	if (fromFileSearchStoreName != null) setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);
	return toObject;
}
function uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function deleteDocumentConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromForce = getValueByPath(fromObject, ["force"]);
	if (parentObject !== void 0 && fromForce != null) setValueByPath(parentObject, ["_query", "force"], fromForce);
	return toObject;
}
function deleteDocumentParametersToMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], fromName);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) deleteDocumentConfigToMldev(fromConfig, toObject);
	return toObject;
}
function getDocumentParametersToMldev(fromObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], fromName);
	return toObject;
}
function listDocumentsConfigToMldev(fromObject, parentObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	return toObject;
}
function listDocumentsParametersToMldev(fromObject) {
	const toObject = {};
	const fromParent = getValueByPath(fromObject, ["parent"]);
	if (fromParent != null) setValueByPath(toObject, ["_url", "parent"], fromParent);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listDocumentsConfigToMldev(fromConfig, toObject);
	return toObject;
}
function listDocumentsResponseFromMldev(fromObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromDocuments = getValueByPath(fromObject, ["documents"]);
	if (fromDocuments != null) {
		let transformedList = fromDocuments;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["documents"], transformedList);
	}
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var Documents = class extends BaseModule {
	constructor(apiClient) {
		super();
		this.apiClient = apiClient;
		/**
		* Lists documents.
		*
		* @param params - The parameters for the list request.
		* @return - A pager of documents.
		*
		* @example
		* ```ts
		* const documents = await ai.documents.list({config: {'pageSize': 2}});
		* for await (const document of documents) {
		*   console.log(document);
		* }
		* ```
		*/
		this.list = async (params) => {
			return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x$1) => this.listInternal({
				parent: params.parent,
				config: x$1.config
			}), await this.listInternal(params), params);
		};
	}
	/**
	* Gets a Document.
	*
	* @param params - The parameters for getting a document.
	* @return Document.
	*/
	async get(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = getDocumentParametersToMldev(params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		}
	}
	/**
	* Deletes a Document.
	*
	* @param params - The parameters for deleting a document.
	*/
	async delete(params) {
		var _a$2, _b;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = deleteDocumentParametersToMldev(params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			await this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "DELETE",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			});
		}
	}
	/**
	* Lists all Documents in a FileSearchStore.
	*
	* @param params - The parameters for listing documents.
	* @return ListDocumentsResponse.
	*/
	async listInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = listDocumentsParametersToMldev(params);
			path$9 = formatMap("{parent}/documents", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				const resp = listDocumentsResponseFromMldev(apiResponse);
				const typedResp = new ListDocumentsResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var FileSearchStores = class extends BaseModule {
	constructor(apiClient, documents = new Documents(apiClient)) {
		super();
		this.apiClient = apiClient;
		this.documents = documents;
		/**
		* Lists file search stores.
		*
		* @param params - The parameters for the list request.
		* @return - A pager of file search stores.
		*
		* @example
		* ```ts
		* const fileSearchStores = await ai.fileSearchStores.list({config: {'pageSize': 2}});
		* for await (const fileSearchStore of fileSearchStores) {
		*   console.log(fileSearchStore);
		* }
		* ```
		*/
		this.list = async (params = {}) => {
			return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x$1) => this.listInternal(x$1), await this.listInternal(params), params);
		};
	}
	/**
	* Uploads a file asynchronously to a given File Search Store.
	* This method is not available in Vertex AI.
	* Supported upload sources:
	* - Node.js: File path (string) or Blob object.
	* - Browser: Blob object (e.g., File).
	*
	* @remarks
	* The `mimeType` can be specified in the `config` parameter. If omitted:
	*  - For file path (string) inputs, the `mimeType` will be inferred from the
	*     file extension.
	*  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
	*     property.
	*
	* This section can contain multiple paragraphs and code examples.
	*
	* @param params - Optional parameters specified in the
	*        `types.UploadToFileSearchStoreParameters` interface.
	*         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional
	*         config in the parameters.
	* @return A promise that resolves to a long running operation.
	* @throws An error if called on a Vertex AI client.
	* @throws An error if the `mimeType` is not provided and can not be inferred,
	* the `mimeType` can be provided in the `params.config` parameter.
	* @throws An error occurs if a suitable upload location cannot be established.
	*
	* @example
	* The following code uploads a file to a given file search store.
	*
	* ```ts
	* const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {
	*   mimeType: 'text/plain',
	* }});
	* console.log(operation.name);
	* ```
	*/
	async uploadToFileSearchStore(params) {
		if (this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support uploading files to a file search store.");
		return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);
	}
	/**
	* Creates a File Search Store.
	*
	* @param params - The parameters for creating a File Search Store.
	* @return FileSearchStore.
	*/
	async create(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = createFileSearchStoreParametersToMldev(params);
			path$9 = formatMap("fileSearchStores", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		}
	}
	/**
	* Gets a File Search Store.
	*
	* @param params - The parameters for getting a File Search Store.
	* @return FileSearchStore.
	*/
	async get(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = getFileSearchStoreParametersToMldev(params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((resp) => {
				return resp;
			});
		}
	}
	/**
	* Deletes a File Search Store.
	*
	* @param params - The parameters for deleting a File Search Store.
	*/
	async delete(params) {
		var _a$2, _b;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = deleteFileSearchStoreParametersToMldev(params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			await this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "DELETE",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			});
		}
	}
	/**
	* Lists all FileSearchStore owned by the user.
	*
	* @param params - The parameters for listing file search stores.
	* @return ListFileSearchStoresResponse.
	*/
	async listInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = listFileSearchStoresParametersToMldev(params);
			path$9 = formatMap("fileSearchStores", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				const resp = listFileSearchStoresResponseFromMldev(apiResponse);
				const typedResp = new ListFileSearchStoresResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	async uploadToFileSearchStoreInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = uploadToFileSearchStoreParametersToMldev(params);
			path$9 = formatMap("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);
				const typedResp = new UploadToFileSearchStoreResumableResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Imports a File from File Service to a FileSearchStore.
	*
	* This is a long-running operation, see aip.dev/151
	*
	* @param params - The parameters for importing a file to a file search store.
	* @return ImportFileOperation.
	*/
	async importFile(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = importFileParametersToMldev(params);
			path$9 = formatMap("{file_search_store_name}:importFile", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json();
			});
			return response.then((apiResponse) => {
				const resp = importFileOperationFromMldev(apiResponse);
				const typedResp = new ImportFileOperation();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
const GOOGLE_API_KEY_HEADER = "x-goog-api-key";
const REQUIRED_VERTEX_AI_SCOPE = "https://www.googleapis.com/auth/cloud-platform";
var NodeAuth = class {
	constructor(opts) {
		if (opts.apiKey !== void 0) {
			this.apiKey = opts.apiKey;
			return;
		}
		this.googleAuth = new import_src.GoogleAuth(buildGoogleAuthOptions(opts.googleAuthOptions));
	}
	async addAuthHeaders(headers, url) {
		if (this.apiKey !== void 0) {
			if (this.apiKey.startsWith("auth_tokens/")) throw new Error("Ephemeral tokens are only supported by the live API.");
			this.addKeyHeader(headers);
			return;
		}
		return this.addGoogleAuthHeaders(headers, url);
	}
	addKeyHeader(headers) {
		if (headers.get(GOOGLE_API_KEY_HEADER) !== null) return;
		if (this.apiKey === void 0) throw new Error("Trying to set API key header but apiKey is not set");
		headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
	}
	async addGoogleAuthHeaders(headers, url) {
		if (this.googleAuth === void 0) throw new Error("Trying to set google-auth headers but googleAuth is unset");
		const authHeaders = await this.googleAuth.getRequestHeaders(url);
		for (const [key, value] of authHeaders) {
			if (headers.get(key) !== null) continue;
			headers.append(key, value);
		}
	}
};
function buildGoogleAuthOptions(googleAuthOptions) {
	let authOptions;
	if (!googleAuthOptions) {
		authOptions = { scopes: [REQUIRED_VERTEX_AI_SCOPE] };
		return authOptions;
	} else {
		authOptions = googleAuthOptions;
		if (!authOptions.scopes) {
			authOptions.scopes = [REQUIRED_VERTEX_AI_SCOPE];
			return authOptions;
		} else if (typeof authOptions.scopes === "string" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);
		return authOptions;
	}
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var NodeDownloader = class {
	async download(params, apiClient) {
		if (params.downloadPath) {
			const response = await downloadFile(params, apiClient);
			if (response instanceof HttpResponse) {
				const writer = (0, fs.createWriteStream)(params.downloadPath);
				node_stream.Readable.fromWeb(response.responseInternal.body).pipe(writer);
				await (0, node_stream_promises.finished)(writer);
			} else try {
				await (0, fs_promises.writeFile)(params.downloadPath, response, { encoding: "base64" });
			} catch (error$1) {
				throw new Error(`Failed to write file to ${params.downloadPath}: ${error$1}`);
			}
		}
	}
};
async function downloadFile(params, apiClient) {
	var _a$2, _b, _c;
	const name = tFileName(params.file);
	if (name !== void 0) return await apiClient.request({
		path: `files/${name}:download`,
		httpMethod: "GET",
		queryParams: { "alt": "media" },
		httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
		abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
	});
	else if (isGeneratedVideo(params.file)) {
		const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;
		if (typeof videoBytes === "string") return videoBytes;
		else throw new Error("Failed to download generated video, Uri or videoBytes not found.");
	} else if (isVideo(params.file)) {
		const videoBytes = params.file.videoBytes;
		if (typeof videoBytes === "string") return videoBytes;
		else throw new Error("Failed to download video, Uri or videoBytes not found.");
	} else throw new Error("Unsupported file type");
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var NodeWebSocketFactory = class {
	create(url, headers, callbacks) {
		return new NodeWebSocket(url, headers, callbacks);
	}
};
var NodeWebSocket = class {
	constructor(url, headers, callbacks) {
		this.url = url;
		this.headers = headers;
		this.callbacks = callbacks;
	}
	connect() {
		this.ws = new import_websocket.default(this.url, { headers: this.headers });
		this.ws.onopen = this.callbacks.onopen;
		this.ws.onerror = this.callbacks.onerror;
		this.ws.onclose = this.callbacks.onclose;
		this.ws.onmessage = this.callbacks.onmessage;
	}
	send(message) {
		if (this.ws === void 0) throw new Error("WebSocket is not connected");
		this.ws.send(message);
	}
	close() {
		if (this.ws === void 0) throw new Error("WebSocket is not connected");
		this.ws.close();
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
function cancelTuningJobParametersToMldev(fromObject, _rootObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], fromName);
	return toObject;
}
function cancelTuningJobParametersToVertex(fromObject, _rootObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], fromName);
	return toObject;
}
function createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) throw new Error("validationDataset parameter is not supported in Gemini API.");
	const fromTunedModelDisplayName = getValueByPath(fromObject, ["tunedModelDisplayName"]);
	if (parentObject !== void 0 && fromTunedModelDisplayName != null) setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
	if (getValueByPath(fromObject, ["description"]) !== void 0) throw new Error("description parameter is not supported in Gemini API.");
	const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
	if (parentObject !== void 0 && fromEpochCount != null) setValueByPath(parentObject, [
		"tuningTask",
		"hyperparameters",
		"epochCount"
	], fromEpochCount);
	const fromLearningRateMultiplier = getValueByPath(fromObject, ["learningRateMultiplier"]);
	if (fromLearningRateMultiplier != null) setValueByPath(toObject, [
		"tuningTask",
		"hyperparameters",
		"learningRateMultiplier"
	], fromLearningRateMultiplier);
	if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["preTunedModelCheckpointId"]) !== void 0) throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) throw new Error("adapterSize parameter is not supported in Gemini API.");
	const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
	if (parentObject !== void 0 && fromBatchSize != null) setValueByPath(parentObject, [
		"tuningTask",
		"hyperparameters",
		"batchSize"
	], fromBatchSize);
	const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
	if (parentObject !== void 0 && fromLearningRate != null) setValueByPath(parentObject, [
		"tuningTask",
		"hyperparameters",
		"learningRate"
	], fromLearningRate);
	if (getValueByPath(fromObject, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["beta"]) !== void 0) throw new Error("beta parameter is not supported in Gemini API.");
	return toObject;
}
function createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {
	const toObject = {};
	let discriminatorValidationDataset = getValueByPath(rootObject, ["config", "method"]);
	if (discriminatorValidationDataset === void 0) discriminatorValidationDataset = "SUPERVISED_FINE_TUNING";
	if (discriminatorValidationDataset === "SUPERVISED_FINE_TUNING") {
		const fromValidationDataset = getValueByPath(fromObject, ["validationDataset"]);
		if (parentObject !== void 0 && fromValidationDataset != null) setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
	} else if (discriminatorValidationDataset === "PREFERENCE_TUNING") {
		const fromValidationDataset = getValueByPath(fromObject, ["validationDataset"]);
		if (parentObject !== void 0 && fromValidationDataset != null) setValueByPath(parentObject, ["preferenceOptimizationSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
	}
	const fromTunedModelDisplayName = getValueByPath(fromObject, ["tunedModelDisplayName"]);
	if (parentObject !== void 0 && fromTunedModelDisplayName != null) setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (parentObject !== void 0 && fromDescription != null) setValueByPath(parentObject, ["description"], fromDescription);
	let discriminatorEpochCount = getValueByPath(rootObject, ["config", "method"]);
	if (discriminatorEpochCount === void 0) discriminatorEpochCount = "SUPERVISED_FINE_TUNING";
	if (discriminatorEpochCount === "SUPERVISED_FINE_TUNING") {
		const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
		if (parentObject !== void 0 && fromEpochCount != null) setValueByPath(parentObject, [
			"supervisedTuningSpec",
			"hyperParameters",
			"epochCount"
		], fromEpochCount);
	} else if (discriminatorEpochCount === "PREFERENCE_TUNING") {
		const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
		if (parentObject !== void 0 && fromEpochCount != null) setValueByPath(parentObject, [
			"preferenceOptimizationSpec",
			"hyperParameters",
			"epochCount"
		], fromEpochCount);
	}
	let discriminatorLearningRateMultiplier = getValueByPath(rootObject, ["config", "method"]);
	if (discriminatorLearningRateMultiplier === void 0) discriminatorLearningRateMultiplier = "SUPERVISED_FINE_TUNING";
	if (discriminatorLearningRateMultiplier === "SUPERVISED_FINE_TUNING") {
		const fromLearningRateMultiplier = getValueByPath(fromObject, ["learningRateMultiplier"]);
		if (parentObject !== void 0 && fromLearningRateMultiplier != null) setValueByPath(parentObject, [
			"supervisedTuningSpec",
			"hyperParameters",
			"learningRateMultiplier"
		], fromLearningRateMultiplier);
	} else if (discriminatorLearningRateMultiplier === "PREFERENCE_TUNING") {
		const fromLearningRateMultiplier = getValueByPath(fromObject, ["learningRateMultiplier"]);
		if (parentObject !== void 0 && fromLearningRateMultiplier != null) setValueByPath(parentObject, [
			"preferenceOptimizationSpec",
			"hyperParameters",
			"learningRateMultiplier"
		], fromLearningRateMultiplier);
	}
	let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ["config", "method"]);
	if (discriminatorExportLastCheckpointOnly === void 0) discriminatorExportLastCheckpointOnly = "SUPERVISED_FINE_TUNING";
	if (discriminatorExportLastCheckpointOnly === "SUPERVISED_FINE_TUNING") {
		const fromExportLastCheckpointOnly = getValueByPath(fromObject, ["exportLastCheckpointOnly"]);
		if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
	} else if (discriminatorExportLastCheckpointOnly === "PREFERENCE_TUNING") {
		const fromExportLastCheckpointOnly = getValueByPath(fromObject, ["exportLastCheckpointOnly"]);
		if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) setValueByPath(parentObject, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
	}
	let discriminatorAdapterSize = getValueByPath(rootObject, ["config", "method"]);
	if (discriminatorAdapterSize === void 0) discriminatorAdapterSize = "SUPERVISED_FINE_TUNING";
	if (discriminatorAdapterSize === "SUPERVISED_FINE_TUNING") {
		const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
		if (parentObject !== void 0 && fromAdapterSize != null) setValueByPath(parentObject, [
			"supervisedTuningSpec",
			"hyperParameters",
			"adapterSize"
		], fromAdapterSize);
	} else if (discriminatorAdapterSize === "PREFERENCE_TUNING") {
		const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
		if (parentObject !== void 0 && fromAdapterSize != null) setValueByPath(parentObject, [
			"preferenceOptimizationSpec",
			"hyperParameters",
			"adapterSize"
		], fromAdapterSize);
	}
	if (getValueByPath(fromObject, ["batchSize"]) !== void 0) throw new Error("batchSize parameter is not supported in Vertex AI.");
	if (getValueByPath(fromObject, ["learningRate"]) !== void 0) throw new Error("learningRate parameter is not supported in Vertex AI.");
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (parentObject !== void 0 && fromLabels != null) setValueByPath(parentObject, ["labels"], fromLabels);
	const fromBeta = getValueByPath(fromObject, ["beta"]);
	if (parentObject !== void 0 && fromBeta != null) setValueByPath(parentObject, [
		"preferenceOptimizationSpec",
		"hyperParameters",
		"beta"
	], fromBeta);
	return toObject;
}
function createTuningJobParametersPrivateToMldev(fromObject, rootObject) {
	const toObject = {};
	const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
	if (fromBaseModel != null) setValueByPath(toObject, ["baseModel"], fromBaseModel);
	const fromPreTunedModel = getValueByPath(fromObject, ["preTunedModel"]);
	if (fromPreTunedModel != null) setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
	const fromTrainingDataset = getValueByPath(fromObject, ["trainingDataset"]);
	if (fromTrainingDataset != null) tuningDatasetToMldev(fromTrainingDataset);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) createTuningJobConfigToMldev(fromConfig, toObject);
	return toObject;
}
function createTuningJobParametersPrivateToVertex(fromObject, rootObject) {
	const toObject = {};
	const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
	if (fromBaseModel != null) setValueByPath(toObject, ["baseModel"], fromBaseModel);
	const fromPreTunedModel = getValueByPath(fromObject, ["preTunedModel"]);
	if (fromPreTunedModel != null) setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
	const fromTrainingDataset = getValueByPath(fromObject, ["trainingDataset"]);
	if (fromTrainingDataset != null) tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) createTuningJobConfigToVertex(fromConfig, toObject, rootObject);
	return toObject;
}
function getTuningJobParametersToMldev(fromObject, _rootObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], fromName);
	return toObject;
}
function getTuningJobParametersToVertex(fromObject, _rootObject) {
	const toObject = {};
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["_url", "name"], fromName);
	return toObject;
}
function listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	const fromFilter = getValueByPath(fromObject, ["filter"]);
	if (parentObject !== void 0 && fromFilter != null) setValueByPath(parentObject, ["_query", "filter"], fromFilter);
	return toObject;
}
function listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {
	const toObject = {};
	const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
	if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
	const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
	if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
	const fromFilter = getValueByPath(fromObject, ["filter"]);
	if (parentObject !== void 0 && fromFilter != null) setValueByPath(parentObject, ["_query", "filter"], fromFilter);
	return toObject;
}
function listTuningJobsParametersToMldev(fromObject, rootObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listTuningJobsConfigToMldev(fromConfig, toObject);
	return toObject;
}
function listTuningJobsParametersToVertex(fromObject, rootObject) {
	const toObject = {};
	const fromConfig = getValueByPath(fromObject, ["config"]);
	if (fromConfig != null) listTuningJobsConfigToVertex(fromConfig, toObject);
	return toObject;
}
function listTuningJobsResponseFromMldev(fromObject, rootObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
	if (fromTuningJobs != null) {
		let transformedList = fromTuningJobs;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return tuningJobFromMldev(item);
		});
		setValueByPath(toObject, ["tuningJobs"], transformedList);
	}
	return toObject;
}
function listTuningJobsResponseFromVertex(fromObject, rootObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
	if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
	const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
	if (fromTuningJobs != null) {
		let transformedList = fromTuningJobs;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return tuningJobFromVertex(item);
		});
		setValueByPath(toObject, ["tuningJobs"], transformedList);
	}
	return toObject;
}
function tunedModelFromMldev(fromObject, _rootObject) {
	const toObject = {};
	const fromModel = getValueByPath(fromObject, ["name"]);
	if (fromModel != null) setValueByPath(toObject, ["model"], fromModel);
	const fromEndpoint = getValueByPath(fromObject, ["name"]);
	if (fromEndpoint != null) setValueByPath(toObject, ["endpoint"], fromEndpoint);
	return toObject;
}
function tuningDatasetToMldev(fromObject, _rootObject) {
	const toObject = {};
	if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API.");
	if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== void 0) throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
	const fromExamples = getValueByPath(fromObject, ["examples"]);
	if (fromExamples != null) {
		let transformedList = fromExamples;
		if (Array.isArray(transformedList)) transformedList = transformedList.map((item) => {
			return item;
		});
		setValueByPath(toObject, ["examples", "examples"], transformedList);
	}
	return toObject;
}
function tuningDatasetToVertex(fromObject, parentObject, rootObject) {
	const toObject = {};
	let discriminatorGcsUri = getValueByPath(rootObject, ["config", "method"]);
	if (discriminatorGcsUri === void 0) discriminatorGcsUri = "SUPERVISED_FINE_TUNING";
	if (discriminatorGcsUri === "SUPERVISED_FINE_TUNING") {
		const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
		if (parentObject !== void 0 && fromGcsUri != null) setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
	} else if (discriminatorGcsUri === "PREFERENCE_TUNING") {
		const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
		if (parentObject !== void 0 && fromGcsUri != null) setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromGcsUri);
	}
	let discriminatorVertexDatasetResource = getValueByPath(rootObject, ["config", "method"]);
	if (discriminatorVertexDatasetResource === void 0) discriminatorVertexDatasetResource = "SUPERVISED_FINE_TUNING";
	if (discriminatorVertexDatasetResource === "SUPERVISED_FINE_TUNING") {
		const fromVertexDatasetResource = getValueByPath(fromObject, ["vertexDatasetResource"]);
		if (parentObject !== void 0 && fromVertexDatasetResource != null) setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
	} else if (discriminatorVertexDatasetResource === "PREFERENCE_TUNING") {
		const fromVertexDatasetResource = getValueByPath(fromObject, ["vertexDatasetResource"]);
		if (parentObject !== void 0 && fromVertexDatasetResource != null) setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromVertexDatasetResource);
	}
	if (getValueByPath(fromObject, ["examples"]) !== void 0) throw new Error("examples parameter is not supported in Vertex AI.");
	return toObject;
}
function tuningJobFromMldev(fromObject, rootObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromState = getValueByPath(fromObject, ["state"]);
	if (fromState != null) setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
	const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
	if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
	const fromStartTime = getValueByPath(fromObject, ["tuningTask", "startTime"]);
	if (fromStartTime != null) setValueByPath(toObject, ["startTime"], fromStartTime);
	const fromEndTime = getValueByPath(fromObject, ["tuningTask", "completeTime"]);
	if (fromEndTime != null) setValueByPath(toObject, ["endTime"], fromEndTime);
	const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
	if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
	const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
	if (fromBaseModel != null) setValueByPath(toObject, ["baseModel"], fromBaseModel);
	const fromTunedModel = getValueByPath(fromObject, ["_self"]);
	if (fromTunedModel != null) setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
	return toObject;
}
function tuningJobFromVertex(fromObject, _rootObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromState = getValueByPath(fromObject, ["state"]);
	if (fromState != null) setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
	const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
	if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
	const fromStartTime = getValueByPath(fromObject, ["startTime"]);
	if (fromStartTime != null) setValueByPath(toObject, ["startTime"], fromStartTime);
	const fromEndTime = getValueByPath(fromObject, ["endTime"]);
	if (fromEndTime != null) setValueByPath(toObject, ["endTime"], fromEndTime);
	const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
	if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	const fromDescription = getValueByPath(fromObject, ["description"]);
	if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
	const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
	if (fromBaseModel != null) setValueByPath(toObject, ["baseModel"], fromBaseModel);
	const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
	if (fromTunedModel != null) setValueByPath(toObject, ["tunedModel"], fromTunedModel);
	const fromPreTunedModel = getValueByPath(fromObject, ["preTunedModel"]);
	if (fromPreTunedModel != null) setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
	const fromSupervisedTuningSpec = getValueByPath(fromObject, ["supervisedTuningSpec"]);
	if (fromSupervisedTuningSpec != null) setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
	const fromPreferenceOptimizationSpec = getValueByPath(fromObject, ["preferenceOptimizationSpec"]);
	if (fromPreferenceOptimizationSpec != null) setValueByPath(toObject, ["preferenceOptimizationSpec"], fromPreferenceOptimizationSpec);
	const fromTuningDataStats = getValueByPath(fromObject, ["tuningDataStats"]);
	if (fromTuningDataStats != null) setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
	const fromEncryptionSpec = getValueByPath(fromObject, ["encryptionSpec"]);
	if (fromEncryptionSpec != null) setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
	const fromPartnerModelTuningSpec = getValueByPath(fromObject, ["partnerModelTuningSpec"]);
	if (fromPartnerModelTuningSpec != null) setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
	const fromCustomBaseModel = getValueByPath(fromObject, ["customBaseModel"]);
	if (fromCustomBaseModel != null) setValueByPath(toObject, ["customBaseModel"], fromCustomBaseModel);
	const fromExperiment = getValueByPath(fromObject, ["experiment"]);
	if (fromExperiment != null) setValueByPath(toObject, ["experiment"], fromExperiment);
	const fromLabels = getValueByPath(fromObject, ["labels"]);
	if (fromLabels != null) setValueByPath(toObject, ["labels"], fromLabels);
	const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
	if (fromOutputUri != null) setValueByPath(toObject, ["outputUri"], fromOutputUri);
	const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
	if (fromPipelineJob != null) setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
	const fromServiceAccount = getValueByPath(fromObject, ["serviceAccount"]);
	if (fromServiceAccount != null) setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
	const fromTunedModelDisplayName = getValueByPath(fromObject, ["tunedModelDisplayName"]);
	if (fromTunedModelDisplayName != null) setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
	const fromVeoTuningSpec = getValueByPath(fromObject, ["veoTuningSpec"]);
	if (fromVeoTuningSpec != null) setValueByPath(toObject, ["veoTuningSpec"], fromVeoTuningSpec);
	return toObject;
}
function tuningOperationFromMldev(fromObject, _rootObject) {
	const toObject = {};
	const fromSdkHttpResponse = getValueByPath(fromObject, ["sdkHttpResponse"]);
	if (fromSdkHttpResponse != null) setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
	const fromName = getValueByPath(fromObject, ["name"]);
	if (fromName != null) setValueByPath(toObject, ["name"], fromName);
	const fromMetadata = getValueByPath(fromObject, ["metadata"]);
	if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
	const fromDone = getValueByPath(fromObject, ["done"]);
	if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
	const fromError = getValueByPath(fromObject, ["error"]);
	if (fromError != null) setValueByPath(toObject, ["error"], fromError);
	return toObject;
}
function tuningValidationDatasetToVertex(fromObject, _rootObject) {
	const toObject = {};
	const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
	if (fromGcsUri != null) setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
	const fromVertexDatasetResource = getValueByPath(fromObject, ["vertexDatasetResource"]);
	if (fromVertexDatasetResource != null) setValueByPath(toObject, ["validationDatasetUri"], fromVertexDatasetResource);
	return toObject;
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var Tunings = class extends BaseModule {
	constructor(apiClient) {
		super();
		this.apiClient = apiClient;
		/**
		* Gets a TuningJob.
		*
		* @param name - The resource name of the tuning job.
		* @return - A TuningJob object.
		*
		* @experimental - The SDK's tuning implementation is experimental, and may
		* change in future versions.
		*/
		this.get = async (params) => {
			return await this.getInternal(params);
		};
		/**
		* Lists tuning jobs.
		*
		* @param config - The configuration for the list request.
		* @return - A list of tuning jobs.
		*
		* @experimental - The SDK's tuning implementation is experimental, and may
		* change in future versions.
		*/
		this.list = async (params = {}) => {
			return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x$1) => this.listInternal(x$1), await this.listInternal(params), params);
		};
		/**
		* Creates a supervised fine-tuning job.
		*
		* @param params - The parameters for the tuning job.
		* @return - A TuningJob operation.
		*
		* @experimental - The SDK's tuning implementation is experimental, and may
		* change in future versions.
		*/
		this.tune = async (params) => {
			var _a$2;
			if (this.apiClient.isVertexAI()) if (params.baseModel.startsWith("projects/")) {
				const preTunedModel = { tunedModelName: params.baseModel };
				if ((_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.preTunedModelCheckpointId) preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;
				const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel });
				paramsPrivate.baseModel = void 0;
				return await this.tuneInternal(paramsPrivate);
			} else {
				const paramsPrivate = Object.assign({}, params);
				return await this.tuneInternal(paramsPrivate);
			}
			else {
				const paramsPrivate = Object.assign({}, params);
				const operation = await this.tuneMldevInternal(paramsPrivate);
				let tunedModelName = "";
				if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) tunedModelName = operation["metadata"]["tunedModel"];
				else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) tunedModelName = operation["name"].split("/operations/")[0];
				return {
					name: tunedModelName,
					state: JobState.JOB_STATE_QUEUED
				};
			}
		};
	}
	async getInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = getTuningJobParametersToVertex(params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				return tuningJobFromVertex(apiResponse);
			});
		} else {
			const body = getTuningJobParametersToMldev(params);
			path$9 = formatMap("{name}", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				return tuningJobFromMldev(apiResponse);
			});
		}
	}
	async listInternal(params) {
		var _a$2, _b, _c, _d;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = listTuningJobsParametersToVertex(params);
			path$9 = formatMap("tuningJobs", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = listTuningJobsResponseFromVertex(apiResponse);
				const typedResp = new ListTuningJobsResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		} else {
			const body = listTuningJobsParametersToMldev(params);
			path$9 = formatMap("tunedModels", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "GET",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				const resp = listTuningJobsResponseFromMldev(apiResponse);
				const typedResp = new ListTuningJobsResponse();
				Object.assign(typedResp, resp);
				return typedResp;
			});
		}
	}
	/**
	* Cancels a tuning job.
	*
	* @param params - The parameters for the cancel request.
	* @return The empty response returned by the API.
	*
	* @example
	* ```ts
	* await ai.tunings.cancel({name: '...'}); // The server-generated resource name.
	* ```
	*/
	async cancel(params) {
		var _a$2, _b, _c, _d;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = cancelTuningJobParametersToVertex(params);
			path$9 = formatMap("{name}:cancel", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			await this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			});
		} else {
			const body = cancelTuningJobParametersToMldev(params);
			path$9 = formatMap("{name}:cancel", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			await this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
				abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
			});
		}
	}
	async tuneInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) {
			const body = createTuningJobParametersPrivateToVertex(params, params);
			path$9 = formatMap("tuningJobs", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				return tuningJobFromVertex(apiResponse);
			});
		} else throw new Error("This method is only supported by the Vertex AI.");
	}
	async tuneMldevInternal(params) {
		var _a$2, _b;
		let response;
		let path$9 = "";
		let queryParams = {};
		if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
		else {
			const body = createTuningJobParametersPrivateToMldev(params);
			path$9 = formatMap("tunedModels", body["_url"]);
			queryParams = body["_query"];
			delete body["_url"];
			delete body["_query"];
			response = this.apiClient.request({
				path: path$9,
				queryParams,
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions: (_a$2 = params.config) === null || _a$2 === void 0 ? void 0 : _a$2.httpOptions,
				abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
			}).then((httpResponse) => {
				return httpResponse.json().then((jsonResponse) => {
					const response$1 = jsonResponse;
					response$1.sdkHttpResponse = { headers: httpResponse.headers };
					return response$1;
				});
			});
			return response.then((apiResponse) => {
				return tuningOperationFromMldev(apiResponse);
			});
		}
	}
};
const MAX_CHUNK_SIZE = 1024 * 1024 * 8;
const MAX_RETRY_COUNT = 3;
const INITIAL_RETRY_DELAY_MS = 1e3;
const DELAY_MULTIPLIER = 2;
const X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
async function uploadBlob(file, uploadUrl, apiClient) {
	var _a$2;
	const response = await uploadBlobInternal(file, uploadUrl, apiClient);
	const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
	if (((_a$2 = response === null || response === void 0 ? void 0 : response.headers) === null || _a$2 === void 0 ? void 0 : _a$2[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized.");
	return responseJson["file"];
}
async function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {
	var _a$2;
	const response = await uploadBlobInternal(file, uploadUrl, apiClient);
	const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
	if (((_a$2 = response === null || response === void 0 ? void 0 : response.headers) === null || _a$2 === void 0 ? void 0 : _a$2[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized.");
	const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);
	const typedResp = new UploadToFileSearchStoreOperation();
	Object.assign(typedResp, resp);
	return typedResp;
}
async function uploadBlobInternal(file, uploadUrl, apiClient) {
	var _a$2, _b;
	let fileSize = 0;
	let offset = 0;
	let response = new HttpResponse(new Response());
	let uploadCommand = "upload";
	fileSize = file.size;
	while (offset < fileSize) {
		const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
		const chunk = file.slice(offset, offset + chunkSize);
		if (offset + chunkSize >= fileSize) uploadCommand += ", finalize";
		let retryCount = 0;
		let currentDelayMs = INITIAL_RETRY_DELAY_MS;
		while (retryCount < MAX_RETRY_COUNT) {
			response = await apiClient.request({
				path: "",
				body: chunk,
				httpMethod: "POST",
				httpOptions: {
					apiVersion: "",
					baseUrl: uploadUrl,
					headers: {
						"X-Goog-Upload-Command": uploadCommand,
						"X-Goog-Upload-Offset": String(offset),
						"Content-Length": String(chunkSize)
					}
				}
			});
			if ((_a$2 = response === null || response === void 0 ? void 0 : response.headers) === null || _a$2 === void 0 ? void 0 : _a$2[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) break;
			retryCount++;
			await sleep(currentDelayMs);
			currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
		}
		offset += chunkSize;
		if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") break;
		if (fileSize <= offset) throw new Error("All content has been uploaded, but the upload status is not finalized.");
	}
	return response;
}
async function getBlobStat(file) {
	return {
		size: file.size,
		type: file.type
	};
}
function sleep(ms) {
	return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
}
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
var NodeUploader = class {
	async stat(file) {
		const fileStat = {
			size: 0,
			type: void 0
		};
		if (typeof file === "string") {
			fileStat.size = (await fs_promises.stat(file)).size;
			fileStat.type = this.inferMimeType(file);
			return fileStat;
		} else return await getBlobStat(file);
	}
	async upload(file, uploadUrl, apiClient) {
		if (typeof file === "string") return await this.uploadFileFromPath(file, uploadUrl, apiClient);
		else return uploadBlob(file, uploadUrl, apiClient);
	}
	async uploadToFileSearchStore(file, uploadUrl, apiClient) {
		if (typeof file === "string") return await this.uploadFileToFileSearchStoreFromPath(file, uploadUrl, apiClient);
		else return uploadBlobToFileSearchStore(file, uploadUrl, apiClient);
	}
	/**
	* Infers the MIME type of a file based on its extension.
	*
	* @param filePath The path to the file.
	* @returns The MIME type of the file, or undefined if it cannot be inferred.
	*/
	inferMimeType(filePath) {
		const fileExtension = filePath.slice(filePath.lastIndexOf(".") + 1);
		return {
			"aac": "audio/aac",
			"abw": "application/x-abiword",
			"arc": "application/x-freearc",
			"avi": "video/x-msvideo",
			"azw": "application/vnd.amazon.ebook",
			"bin": "application/octet-stream",
			"bmp": "image/bmp",
			"bz": "application/x-bzip",
			"bz2": "application/x-bzip2",
			"csh": "application/x-csh",
			"css": "text/css",
			"csv": "text/csv",
			"doc": "application/msword",
			"docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
			"eot": "application/vnd.ms-fontobject",
			"epub": "application/epub+zip",
			"gz": "application/gzip",
			"gif": "image/gif",
			"htm": "text/html",
			"html": "text/html",
			"ico": "image/vnd.microsoft.icon",
			"ics": "text/calendar",
			"jar": "application/java-archive",
			"jpeg": "image/jpeg",
			"jpg": "image/jpeg",
			"js": "text/javascript",
			"json": "application/json",
			"jsonld": "application/ld+json",
			"kml": "application/vnd.google-earth.kml+xml",
			"kmz": "application/vnd.google-earth.kmz+xml",
			"mjs": "text/javascript",
			"mp3": "audio/mpeg",
			"mp4": "video/mp4",
			"mpeg": "video/mpeg",
			"mpkg": "application/vnd.apple.installer+xml",
			"odt": "application/vnd.oasis.opendocument.text",
			"oga": "audio/ogg",
			"ogv": "video/ogg",
			"ogx": "application/ogg",
			"opus": "audio/opus",
			"otf": "font/otf",
			"png": "image/png",
			"pdf": "application/pdf",
			"php": "application/x-httpd-php",
			"ppt": "application/vnd.ms-powerpoint",
			"pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
			"rar": "application/vnd.rar",
			"rtf": "application/rtf",
			"sh": "application/x-sh",
			"svg": "image/svg+xml",
			"swf": "application/x-shockwave-flash",
			"tar": "application/x-tar",
			"tif": "image/tiff",
			"tiff": "image/tiff",
			"ts": "video/mp2t",
			"ttf": "font/ttf",
			"txt": "text/plain",
			"vsd": "application/vnd.visio",
			"wav": "audio/wav",
			"weba": "audio/webm",
			"webm": "video/webm",
			"webp": "image/webp",
			"woff": "font/woff",
			"woff2": "font/woff2",
			"xhtml": "application/xhtml+xml",
			"xls": "application/vnd.ms-excel",
			"xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
			"xml": "application/xml",
			"xul": "application/vnd.mozilla.xul+xml",
			"zip": "application/zip",
			"3gp": "video/3gpp",
			"3g2": "video/3gpp2",
			"7z": "application/x-7z-compressed"
		}[fileExtension.toLowerCase()];
	}
	async uploadFileFromPath(file, uploadUrl, apiClient) {
		var _a$2;
		const response = await this.uploadFileFromPathInternal(file, uploadUrl, apiClient);
		const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
		if (((_a$2 = response === null || response === void 0 ? void 0 : response.headers) === null || _a$2 === void 0 ? void 0 : _a$2[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized.");
		return responseJson["file"];
	}
	async uploadFileToFileSearchStoreFromPath(file, uploadUrl, apiClient) {
		var _a$2;
		const response = await this.uploadFileFromPathInternal(file, uploadUrl, apiClient);
		const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
		if (((_a$2 = response === null || response === void 0 ? void 0 : response.headers) === null || _a$2 === void 0 ? void 0 : _a$2[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized.");
		const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);
		const typedResp = new UploadToFileSearchStoreOperation();
		Object.assign(typedResp, resp);
		return typedResp;
	}
	async uploadFileFromPathInternal(file, uploadUrl, apiClient) {
		var _a$2, _b;
		let fileSize = 0;
		let offset = 0;
		let response = new HttpResponse(new Response());
		let uploadCommand = "upload";
		let fileHandle;
		const fileName = path.basename(file);
		try {
			fileHandle = await fs_promises.open(file, "r");
			if (!fileHandle) throw new Error(`Failed to open file`);
			fileSize = (await fileHandle.stat()).size;
			while (offset < fileSize) {
				const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
				if (offset + chunkSize >= fileSize) uploadCommand += ", finalize";
				const buffer$1 = new Uint8Array(chunkSize);
				const { bytesRead } = await fileHandle.read(buffer$1, 0, chunkSize, offset);
				if (bytesRead !== chunkSize) throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);
				const chunk = new Blob([buffer$1]);
				let retryCount = 0;
				let currentDelayMs = INITIAL_RETRY_DELAY_MS;
				while (retryCount < MAX_RETRY_COUNT) {
					response = await apiClient.request({
						path: "",
						body: chunk,
						httpMethod: "POST",
						httpOptions: {
							apiVersion: "",
							baseUrl: uploadUrl,
							headers: {
								"X-Goog-Upload-Command": uploadCommand,
								"X-Goog-Upload-Offset": String(offset),
								"Content-Length": String(bytesRead),
								"X-Goog-Upload-File-Name": fileName
							}
						}
					});
					if ((_a$2 = response === null || response === void 0 ? void 0 : response.headers) === null || _a$2 === void 0 ? void 0 : _a$2[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) break;
					retryCount++;
					await sleep(currentDelayMs);
					currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
				}
				offset += bytesRead;
				if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") break;
				if (fileSize <= offset) throw new Error("All content has been uploaded, but the upload status is not finalized.");
			}
			return response;
		} finally {
			if (fileHandle) await fileHandle.close();
		}
	}
};
/**
* @license
* Copyright 2025 Google LLC
* SPDX-License-Identifier: Apache-2.0
*/
const LANGUAGE_LABEL_PREFIX = "gl-node/";
/**
* The Google GenAI SDK.
*
* @remarks
* Provides access to the GenAI features through either the {@link
* https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or
* the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI
* API}.
*
* The {@link GoogleGenAIOptions.vertexai} value determines which of the API
* services to use.
*
* When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be
* set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link
* GoogleGenAIOptions.location} must be set, or a {@link
* GoogleGenAIOptions.apiKey} must be set when using Express Mode.
*
* Explicitly passed in values in {@link GoogleGenAIOptions} will always take
* precedence over environment variables. If both project/location and api_key
* exist in the environment variables, the project/location will be used.
*
* @example
* Initializing the SDK for using the Gemini API:
* ```ts
* import {GoogleGenAI} from '@google/genai';
* const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});
* ```
*
* @example
* Initializing the SDK for using the Vertex AI API:
* ```ts
* import {GoogleGenAI} from '@google/genai';
* const ai = new GoogleGenAI({
*   vertexai: true,
*   project: 'PROJECT_ID',
*   location: 'PROJECT_LOCATION'
* });
* ```
*
*/
var GoogleGenAI = class {
	constructor(options) {
		var _a$2, _b, _c, _d, _e, _f;
		if ((options.project || options.location) && options.apiKey) throw new Error("Project/location and API key are mutually exclusive in the client initializer.");
		this.vertexai = (_b = (_a$2 = options.vertexai) !== null && _a$2 !== void 0 ? _a$2 : getBooleanEnv("GOOGLE_GENAI_USE_VERTEXAI")) !== null && _b !== void 0 ? _b : false;
		const envApiKey = getApiKeyFromEnv();
		const envProject = getEnv("GOOGLE_CLOUD_PROJECT");
		const envLocation = getEnv("GOOGLE_CLOUD_LOCATION");
		this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;
		this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;
		this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;
		if (options.vertexai) {
			if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {
				console.debug("The user provided Google Cloud credentials will take precedence over the API key from the environment variable.");
				this.apiKey = void 0;
			}
			if ((envProject || envLocation) && options.apiKey) {
				console.debug("The user provided Vertex AI API key will take precedence over the project/location from the environment variables.");
				this.project = void 0;
				this.location = void 0;
			} else if ((options.project || options.location) && envApiKey) {
				console.debug("The user provided project/location will take precedence over the API key from the environment variables.");
				this.apiKey = void 0;
			} else if ((envProject || envLocation) && envApiKey) {
				console.debug("The project/location from the environment variables will take precedence over the API key from the environment variables.");
				this.apiKey = void 0;
			}
			if (!this.location && !this.apiKey) this.location = "global";
		}
		const baseUrl$1 = getBaseUrl(options.httpOptions, options.vertexai, getEnv("GOOGLE_VERTEX_BASE_URL"), getEnv("GOOGLE_GEMINI_BASE_URL"));
		if (baseUrl$1) if (options.httpOptions) options.httpOptions.baseUrl = baseUrl$1;
		else options.httpOptions = { baseUrl: baseUrl$1 };
		this.apiVersion = options.apiVersion;
		const auth$2 = new NodeAuth({
			apiKey: this.apiKey,
			googleAuthOptions: options.googleAuthOptions
		});
		this.apiClient = new ApiClient({
			auth: auth$2,
			project: this.project,
			location: this.location,
			apiVersion: this.apiVersion,
			apiKey: this.apiKey,
			vertexai: this.vertexai,
			httpOptions: options.httpOptions,
			userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,
			uploader: new NodeUploader(),
			downloader: new NodeDownloader()
		});
		this.models = new Models(this.apiClient);
		this.live = new Live(this.apiClient, auth$2, new NodeWebSocketFactory());
		this.batches = new Batches(this.apiClient);
		this.chats = new Chats(this.models, this.apiClient);
		this.caches = new Caches(this.apiClient);
		this.files = new Files(this.apiClient);
		this.operations = new Operations(this.apiClient);
		this.authTokens = new Tokens(this.apiClient);
		this.tunings = new Tunings(this.apiClient);
		this.fileSearchStores = new FileSearchStores(this.apiClient);
	}
};
function getEnv(env) {
	var _a$2, _b, _c;
	return (_c = (_b = (_a$2 = process === null || process === void 0 ? void 0 : process.env) === null || _a$2 === void 0 ? void 0 : _a$2[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : void 0;
}
function getBooleanEnv(env) {
	return stringToBoolean(getEnv(env));
}
function stringToBoolean(str) {
	if (str === void 0) return false;
	return str.toLowerCase() === "true";
}
function getApiKeyFromEnv() {
	const envGoogleApiKey = getEnv("GOOGLE_API_KEY");
	const envGeminiApiKey = getEnv("GEMINI_API_KEY");
	if (envGoogleApiKey && envGeminiApiKey) console.warn("Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.");
	return envGoogleApiKey || envGeminiApiKey || void 0;
}

//#endregion
//#region src/generate-changelog.js
var import_core$1 = /* @__PURE__ */ __toESM$1(require_core(), 1);
/**
* Format commits data for AI processing
* @param {Array} weeks - Weeks with commits grouped
* @returns {string} - Formatted text for AI
*/
function formatCommitsForAI(weeks) {
	return weeks.map((week) => {
		const commitsText = week.commits.filter((commit) => {
			return !commit.message.toLowerCase().startsWith("merge");
		}).map((commit) => {
			const filesText = commit.files.filter((file) => {
				return !file.filename.includes("package-lock.json") && !file.filename.includes("yarn.lock") && !file.filename.includes("pnpm-lock.yaml");
			}).map((file) => {
				let fileInfo = `  - ${file.filename} (${file.status}): +${file.additions} -${file.deletions}`;
				if (file.patch) {
					const patchLines = file.patch.split("\n").slice(0, 20).join("\n");
					fileInfo += `\n${patchLines}`;
				}
				return fileInfo;
			}).join("\n");
			return `
**Commit:** ${commit.message}
**Author:** ${commit.author}
**Date:** ${commit.date}
**Files changed:**
${filesText}
`;
		}).join("\n---\n");
		return {
			weekStart: week.weekStart,
			weekEnd: week.weekEnd,
			commitsText
		};
	}).filter((week) => week.commitsText.length > 0);
}
/**
* Generate and merge changelog using Gemini AI (single prompt approach)
* @param {Array} weeks - Weeks with commits grouped
* @param {string} oldChangelog - Existing changelog content
* @param {string} apiKey - Google API key
* @returns {Promise<string>} - Complete merged changelog
*/
async function generateAndMergeChangelog(weeks, oldChangelog, apiKey) {
	try {
		const genAI = new GoogleGenAI({ apiKey });
		const formattedWeeks = formatCommitsForAI(weeks);
		if (formattedWeeks.length === 0) {
			import_core$1.warning("No meaningful commits found to generate changelog");
			return oldChangelog || "# Changelog\n\nNo changes to report.";
		}
		const weeksData = formattedWeeks.map((week) => `
### Week: ${week.weekStart} to ${week.weekEnd}

${week.commitsText}
    `).join("\n\n");
		const prompt = `You are a technical documentation expert. Your task is to analyze commits and create/update a changelog.

EXISTING CHANGELOG:
${oldChangelog || "# Changelog\n\nAll notable changes to this project will be documented in this file."}

NEW COMMITS TO ANALYZE:
${weeksData}

TASK:
1. Analyze the new commits and group changes by category: Features, Bug Fixes, Performance, Documentation, Refactoring, Other
2. For each category, create concise bullet points in markdown format
3. Create a new section for each week with date headers like: ## [${formattedWeeks[0]?.weekStart || "YYYY-MM-DD"}]
4. Merge the new sections into the existing changelog at the top (newest first)
5. Avoid duplicates - check if similar changes already exist
6. Ignore merge commits and trivial configuration changes
7. Use professional, clear language that describes WHAT changed and WHY it matters
8. Each bullet point should be actionable and user-focused

OUTPUT FORMAT RULES:
- Start with "# Changelog" header if not present
- New week sections go at the TOP (after the header)
- Keep chronological order (newest first)
- Only include categories that have actual changes
- Each bullet should start with a verb (Added, Fixed, Improved, Updated, etc.)
- Be concise but descriptive

Return ONLY the complete merged changelog as raw text. No explanations, no additional text.`;
		import_core$1.info("Sending request to Gemini AI...");
		const result = await genAI.models.generateContent({
			model: "gemini-2.0-flash",
			contents: prompt
		});
		import_core$1.info("Successfully generated and merged changelog");
		return result.text;
	} catch (error$1) {
		import_core$1.error(`Error generating changelog with AI: ${error$1.message}`);
		throw error$1;
	}
}

//#endregion
//#region src/index.js
var import_core = /* @__PURE__ */ __toESM$1(require_core(), 1);
async function run() {
	try {
		import_core.info("Starting AI-powered changelog generation...");
		const githubToken = process.env.GITHUB_TOKEN;
		const googleApiKey = process.env.GOOGLE_API_KEY;
		const commitsCount = parseInt(process.env.COMMITS_COUNT || "10", 10);
		const changelogPath = process.env.CHANGELOG_PATH || "CHANGELOG.md";
		if (!githubToken) throw new Error("GITHUB_TOKEN is required");
		if (!googleApiKey) throw new Error("GOOGLE_API_KEY is required");
		import_core.info(`Configuration: analyzing last ${commitsCount} commits`);
		const { owner, repo } = getRepoInfo();
		import_core.info("Step 1/3: Fetching commits from GitHub...");
		const weeks = await getCommitsGroupedByWeek({
			token: githubToken,
			owner,
			repo,
			commitsCount
		});
		if (!weeks || weeks.length === 0) {
			import_core.warning("No commits found to process");
			return;
		}
		import_core.info("Step 2/3: Reading existing changelog...");
		const oldChangelog = readChangelog(changelogPath);
		import_core.info("Step 3/3: Generating and merging changelog with AI...");
		const finalChangelog = await generateAndMergeChangelog(weeks, oldChangelog, googleApiKey);
		if (!finalChangelog) {
			import_core.warning("AI generated empty changelog");
			return;
		}
		import_core.info("Changelog generation completed successfully!");
		import_core.setOutput("changelog-content", finalChangelog);
		import_core.setOutput("changelog-updated", "true");
	} catch (error$1) {
		import_core.error(`Error: ${error$1.message}`);
		import_core.setFailed(error$1.message);
	}
}
run();

//#endregion